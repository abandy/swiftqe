/**
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// Generated from MySqlParser.g4 by ANTLR 4.13.1
import Antlr4

open class MySqlParser: Parser {

	internal static var _decisionToDFA: [DFA] = {
          var decisionToDFA = [DFA]()
          let length = MySqlParser._ATN.getNumberOfDecisions()
          for i in 0..<length {
            decisionToDFA.append(DFA(MySqlParser._ATN.getDecisionState(i)!, i))
           }
           return decisionToDFA
     }()

	internal static let _sharedContextCache = PredictionContextCache()

	public
	enum Tokens: Int {
		case EOF = -1, SPACE = 1, SPEC_MYSQL_COMMENT = 2, COMMENT_INPUT = 3, LINE_COMMENT = 4, 
                 ADD = 5, ALL = 6, ALTER = 7, ALWAYS = 8, ANALYZE = 9, AND = 10, 
                 ARRAY = 11, AS = 12, ASC = 13, ATTRIBUTE = 14, BEFORE = 15, 
                 BETWEEN = 16, BOTH = 17, BUCKETS = 18, BY = 19, CALL = 20, 
                 CASCADE = 21, CASE = 22, CAST = 23, CHANGE = 24, CHARACTER = 25, 
                 CHECK = 26, COLLATE = 27, COLUMN = 28, CONDITION = 29, 
                 CONSTRAINT = 30, CONTINUE = 31, CONVERT = 32, CREATE = 33, 
                 CROSS = 34, CURRENT = 35, CURRENT_ROLE = 36, CURRENT_USER = 37, 
                 CURSOR = 38, DATABASE = 39, DATABASES = 40, DECLARE = 41, 
                 DEFAULT = 42, DELAYED = 43, DELETE = 44, DESC = 45, DESCRIBE = 46, 
                 DETERMINISTIC = 47, DIAGNOSTICS = 48, DISTINCT = 49, DISTINCTROW = 50, 
                 DROP = 51, EACH = 52, ELSE = 53, ELSEIF = 54, EMPTY = 55, 
                 ENCLOSED = 56, ENFORCED = 57, ESCAPED = 58, EXCEPT = 59, 
                 EXISTS = 60, EXIT = 61, EXPLAIN = 62, FALSE = 63, FETCH = 64, 
                 FOR = 65, FORCE = 66, FOREIGN = 67, FROM = 68, FULLTEXT = 69, 
                 GENERATED = 70, GET = 71, GRANT = 72, GROUP = 73, HAVING = 74, 
                 HIGH_PRIORITY = 75, HISTOGRAM = 76, IF = 77, IGNORE = 78, 
                 IGNORED = 79, IN = 80, INDEX = 81, INFILE = 82, INNER = 83, 
                 INOUT = 84, INSERT = 85, INTERVAL = 86, INTO = 87, IS = 88, 
                 ITERATE = 89, JOIN = 90, KEY = 91, KEYS = 92, KILL = 93, 
                 LATERAL = 94, LEADING = 95, LEAVE = 96, LEFT = 97, LIKE = 98, 
                 LIMIT = 99, LINEAR = 100, LINES = 101, LOAD = 102, LOCK = 103, 
                 LOCKED = 104, LOOP = 105, LOW_PRIORITY = 106, MASTER_BIND = 107, 
                 MASTER_SSL_VERIFY_SERVER_CERT = 108, MATCH = 109, MAXVALUE = 110, 
                 MINVALUE = 111, MODIFIES = 112, NATURAL = 113, NOT = 114, 
                 NO_WRITE_TO_BINLOG = 115, NULL_LITERAL = 116, NUMBER = 117, 
                 ON = 118, OPTIMIZE = 119, OPTION = 120, OPTIONAL = 121, 
                 OPTIONALLY = 122, OR = 123, ORDER = 124, OUT = 125, OUTER = 126, 
                 OUTFILE = 127, OVER = 128, PARTITION = 129, PRIMARY = 130, 
                 PROCEDURE = 131, PURGE = 132, RANGE = 133, READ = 134, 
                 READS = 135, REFERENCES = 136, REGEXP = 137, RELEASE = 138, 
                 RENAME = 139, REPEAT = 140, REPLACE = 141, REQUIRE = 142, 
                 RESIGNAL = 143, RESTRICT = 144, RETAIN = 145, RETURN = 146, 
                 REVOKE = 147, RIGHT = 148, RLIKE = 149, SCHEMA = 150, SCHEMAS = 151, 
                 SELECT = 152, SET = 153, SEPARATOR = 154, SHOW = 155, SIGNAL = 156, 
                 SKIP_ = 157, SKIP_QUERY_REWRITE = 158, SPATIAL = 159, SQL = 160, 
                 SQLEXCEPTION = 161, SQLSTATE = 162, SQLWARNING = 163, SQL_BIG_RESULT = 164, 
                 SQL_CALC_FOUND_ROWS = 165, SQL_SMALL_RESULT = 166, SSL = 167, 
                 STACKED = 168, STARTING = 169, STATEMENT = 170, STRAIGHT_JOIN = 171, 
                 TABLE = 172, TERMINATED = 173, THEN = 174, TO = 175, TRAILING = 176, 
                 TRIGGER = 177, TRUE = 178, UNDO = 179, UNION = 180, UNIQUE = 181, 
                 UNLOCK = 182, UNSIGNED = 183, UPDATE = 184, USAGE = 185, 
                 USE = 186, USING = 187, VALUES = 188, WHEN = 189, WHERE = 190, 
                 WHILE = 191, WITH = 192, WRITE = 193, XOR = 194, ZEROFILL = 195, 
                 TINYINT = 196, SMALLINT = 197, MEDIUMINT = 198, MIDDLEINT = 199, 
                 INT = 200, INT1 = 201, INT2 = 202, INT3 = 203, INT4 = 204, 
                 INT8 = 205, INTEGER = 206, BIGINT = 207, REAL = 208, DOUBLE = 209, 
                 PRECISION = 210, FLOAT = 211, FLOAT4 = 212, FLOAT8 = 213, 
                 DECIMAL = 214, DEC = 215, NUMERIC = 216, DATE = 217, TIME = 218, 
                 TIMESTAMP = 219, DATETIME = 220, YEAR = 221, CHAR = 222, 
                 VARCHAR = 223, NVARCHAR = 224, NATIONAL = 225, BINARY = 226, 
                 VARBINARY = 227, TINYBLOB = 228, BLOB = 229, MEDIUMBLOB = 230, 
                 LONG = 231, LONGBLOB = 232, TINYTEXT = 233, TEXT = 234, 
                 MEDIUMTEXT = 235, LONGTEXT = 236, ENUM = 237, VARYING = 238, 
                 SERIAL = 239, YEAR_MONTH = 240, DAY_HOUR = 241, DAY_MINUTE = 242, 
                 DAY_SECOND = 243, HOUR_MINUTE = 244, HOUR_SECOND = 245, 
                 MINUTE_SECOND = 246, SECOND_MICROSECOND = 247, MINUTE_MICROSECOND = 248, 
                 HOUR_MICROSECOND = 249, DAY_MICROSECOND = 250, JSON_ARRAY = 251, 
                 JSON_ARRAYAGG = 252, JSON_ARRAY_APPEND = 253, JSON_ARRAY_INSERT = 254, 
                 JSON_CONTAINS = 255, JSON_CONTAINS_PATH = 256, JSON_DEPTH = 257, 
                 JSON_EXTRACT = 258, JSON_INSERT = 259, JSON_KEYS = 260, 
                 JSON_LENGTH = 261, JSON_MERGE = 262, JSON_MERGE_PATCH = 263, 
                 JSON_MERGE_PRESERVE = 264, JSON_OBJECT = 265, JSON_OBJECTAGG = 266, 
                 JSON_OVERLAPS = 267, JSON_PRETTY = 268, JSON_QUOTE = 269, 
                 JSON_REMOVE = 270, JSON_REPLACE = 271, JSON_SCHEMA_VALID = 272, 
                 JSON_SCHEMA_VALIDATION_REPORT = 273, JSON_SEARCH = 274, 
                 JSON_SET = 275, JSON_STORAGE_FREE = 276, JSON_STORAGE_SIZE = 277, 
                 JSON_TABLE = 278, JSON_TYPE = 279, JSON_UNQUOTE = 280, 
                 JSON_VALID = 281, JSON_VALUE = 282, NESTED = 283, ORDINALITY = 284, 
                 PATH = 285, AVG = 286, BIT_AND = 287, BIT_OR = 288, BIT_XOR = 289, 
                 COUNT = 290, CUME_DIST = 291, DENSE_RANK = 292, FIRST_VALUE = 293, 
                 GROUP_CONCAT = 294, LAG = 295, LAST_VALUE = 296, LEAD = 297, 
                 MAX = 298, MIN = 299, NTILE = 300, NTH_VALUE = 301, PERCENT_RANK = 302, 
                 RANK = 303, ROW_NUMBER = 304, STD = 305, STDDEV = 306, 
                 STDDEV_POP = 307, STDDEV_SAMP = 308, SUM = 309, VAR_POP = 310, 
                 VAR_SAMP = 311, VARIANCE = 312, CURRENT_DATE = 313, CURRENT_TIME = 314, 
                 CURRENT_TIMESTAMP = 315, LOCALTIME = 316, CURDATE = 317, 
                 CURTIME = 318, DATE_ADD = 319, DATE_SUB = 320, EXTRACT = 321, 
                 LOCALTIMESTAMP = 322, NOW = 323, POSITION = 324, SUBSTR = 325, 
                 SUBSTRING = 326, SYSDATE = 327, TRIM = 328, UTC_DATE = 329, 
                 UTC_TIME = 330, UTC_TIMESTAMP = 331, ACCOUNT = 332, ACTION = 333, 
                 AFTER = 334, AGGREGATE = 335, ALGORITHM = 336, ANY = 337, 
                 AT = 338, AUTHORS = 339, AUTOCOMMIT = 340, AUTOEXTEND_SIZE = 341, 
                 AUTO_INCREMENT = 342, AVG_ROW_LENGTH = 343, BEGIN = 344, 
                 BINLOG = 345, BIT = 346, BLOCK = 347, BOOL = 348, BOOLEAN = 349, 
                 BTREE = 350, CACHE = 351, CASCADED = 352, CHAIN = 353, 
                 CHANGED = 354, CHANNEL = 355, CHECKSUM = 356, PAGE_CHECKSUM = 357, 
                 CIPHER = 358, CLASS_ORIGIN = 359, CLIENT = 360, CLOSE = 361, 
                 CLUSTERING = 362, COALESCE = 363, CODE = 364, COLUMNS = 365, 
                 COLUMN_FORMAT = 366, COLUMN_NAME = 367, COMMENT = 368, 
                 COMMIT = 369, COMPACT = 370, COMPLETION = 371, COMPRESSED = 372, 
                 COMPRESSION = 373, CONCURRENT = 374, CONNECT = 375, CONNECTION = 376, 
                 CONSISTENT = 377, CONSTRAINT_CATALOG = 378, CONSTRAINT_SCHEMA = 379, 
                 CONSTRAINT_NAME = 380, CONTAINS = 381, CONTEXT = 382, CONTRIBUTORS = 383, 
                 COPY = 384, CPU = 385, CYCLE = 386, CURSOR_NAME = 387, 
                 DATA = 388, DATAFILE = 389, DEALLOCATE = 390, DEFAULT_AUTH = 391, 
                 DEFINER = 392, DELAY_KEY_WRITE = 393, DES_KEY_FILE = 394, 
                 DIRECTORY = 395, DISABLE = 396, DISCARD = 397, DISK = 398, 
                 DO = 399, DUMPFILE = 400, DUPLICATE = 401, DYNAMIC = 402, 
                 ENABLE = 403, ENCRYPTED = 404, ENCRYPTION = 405, ENCRYPTION_KEY_ID = 406, 
                 END = 407, ENDS = 408, ENGINE = 409, ENGINES = 410, ERROR = 411, 
                 ERRORS = 412, ESCAPE = 413, EVEN = 414, EVENT = 415, EVENTS = 416, 
                 EVERY = 417, EXCHANGE = 418, EXCLUSIVE = 419, EXPIRE = 420, 
                 EXPORT = 421, EXTENDED = 422, EXTENT_SIZE = 423, FAILED_LOGIN_ATTEMPTS = 424, 
                 FAST = 425, FAULTS = 426, FIELDS = 427, FILE_BLOCK_SIZE = 428, 
                 FILTER = 429, FIRST = 430, FIXED = 431, FLUSH = 432, FOLLOWING = 433, 
                 FOLLOWS = 434, FOUND = 435, FULL = 436, FUNCTION = 437, 
                 GENERAL = 438, GLOBAL = 439, GRANTS = 440, GROUP_REPLICATION = 441, 
                 HANDLER = 442, HASH = 443, HELP = 444, HISTORY = 445, HOST = 446, 
                 HOSTS = 447, IDENTIFIED = 448, IGNORE_SERVER_IDS = 449, 
                 IMPORT = 450, INCREMENT = 451, INDEXES = 452, INITIAL_SIZE = 453, 
                 INPLACE = 454, INSERT_METHOD = 455, INSTALL = 456, INSTANCE = 457, 
                 INSTANT = 458, INVISIBLE = 459, INVOKER = 460, IO = 461, 
                 IO_THREAD = 462, IPC = 463, ISOLATION = 464, ISSUER = 465, 
                 JSON = 466, KEY_BLOCK_SIZE = 467, LANGUAGE = 468, LAST = 469, 
                 LEAVES = 470, LESS = 471, LEVEL = 472, LIST = 473, LOCAL = 474, 
                 LOGFILE = 475, LOGS = 476, MASTER = 477, MASTER_AUTO_POSITION = 478, 
                 MASTER_CONNECT_RETRY = 479, MASTER_DELAY = 480, MASTER_HEARTBEAT_PERIOD = 481, 
                 MASTER_HOST = 482, MASTER_LOG_FILE = 483, MASTER_LOG_POS = 484, 
                 MASTER_PASSWORD = 485, MASTER_PORT = 486, MASTER_RETRY_COUNT = 487, 
                 MASTER_SSL = 488, MASTER_SSL_CA = 489, MASTER_SSL_CAPATH = 490, 
                 MASTER_SSL_CERT = 491, MASTER_SSL_CIPHER = 492, MASTER_SSL_CRL = 493, 
                 MASTER_SSL_CRLPATH = 494, MASTER_SSL_KEY = 495, MASTER_TLS_VERSION = 496, 
                 MASTER_USER = 497, MAX_CONNECTIONS_PER_HOUR = 498, MAX_QUERIES_PER_HOUR = 499, 
                 MAX_ROWS = 500, MAX_SIZE = 501, MAX_UPDATES_PER_HOUR = 502, 
                 MAX_USER_CONNECTIONS = 503, MEDIUM = 504, MEMBER = 505, 
                 MERGE = 506, MESSAGE_TEXT = 507, MID = 508, MIGRATE = 509, 
                 MIN_ROWS = 510, MODE = 511, MODIFY = 512, MUTEX = 513, 
                 MYSQL = 514, MYSQL_ERRNO = 515, NAME = 516, NAMES = 517, 
                 NCHAR = 518, NEVER = 519, NEXT = 520, NO = 521, NOCACHE = 522, 
                 NOCOPY = 523, NOCYCLE = 524, NOMAXVALUE = 525, NOMINVALUE = 526, 
                 NOWAIT = 527, NODEGROUP = 528, NONE = 529, ODBC = 530, 
                 OFFLINE = 531, OFFSET = 532, OF = 533, OJ = 534, OLD_PASSWORD = 535, 
                 ONE = 536, ONLINE = 537, ONLY = 538, OPEN = 539, OPTIMIZER_COSTS = 540, 
                 OPTIONS = 541, OWNER = 542, PACK_KEYS = 543, PAGE = 544, 
                 PAGE_COMPRESSED = 545, PAGE_COMPRESSION_LEVEL = 546, PARSER = 547, 
                 PARTIAL = 548, PARTITIONING = 549, PARTITIONS = 550, PASSWORD = 551, 
                 PASSWORD_LOCK_TIME = 552, PHASE = 553, PLUGIN = 554, PLUGIN_DIR = 555, 
                 PLUGINS = 556, PORT = 557, PRECEDES = 558, PRECEDING = 559, 
                 PREPARE = 560, PRESERVE = 561, PREV = 562, PROCESSLIST = 563, 
                 PROFILE = 564, PROFILES = 565, PROXY = 566, QUERY = 567, 
                 QUICK = 568, REBUILD = 569, RECOVER = 570, RECURSIVE = 571, 
                 REDO_BUFFER_SIZE = 572, REDUNDANT = 573, RELAY = 574, RELAY_LOG_FILE = 575, 
                 RELAY_LOG_POS = 576, RELAYLOG = 577, REMOVE = 578, REORGANIZE = 579, 
                 REPAIR = 580, REPLICATE_DO_DB = 581, REPLICATE_DO_TABLE = 582, 
                 REPLICATE_IGNORE_DB = 583, REPLICATE_IGNORE_TABLE = 584, 
                 REPLICATE_REWRITE_DB = 585, REPLICATE_WILD_DO_TABLE = 586, 
                 REPLICATE_WILD_IGNORE_TABLE = 587, REPLICATION = 588, RESET = 589, 
                 RESTART = 590, RESUME = 591, RETURNED_SQLSTATE = 592, RETURNING = 593, 
                 RETURNS = 594, REUSE = 595, ROLE = 596, ROLLBACK = 597, 
                 ROLLUP = 598, ROTATE = 599, ROW = 600, ROWS = 601, ROW_FORMAT = 602, 
                 RTREE = 603, SAVEPOINT = 604, SCHEDULE = 605, SECURITY = 606, 
                 SEQUENCE = 607, SERVER = 608, SESSION = 609, SHARE = 610, 
                 SHARED = 611, SIGNED = 612, SIMPLE = 613, SLAVE = 614, 
                 SLOW = 615, SNAPSHOT = 616, SOCKET = 617, SOME = 618, SONAME = 619, 
                 SOUNDS = 620, SOURCE = 621, SQL_AFTER_GTIDS = 622, SQL_AFTER_MTS_GAPS = 623, 
                 SQL_BEFORE_GTIDS = 624, SQL_BUFFER_RESULT = 625, SQL_CACHE = 626, 
                 SQL_NO_CACHE = 627, SQL_THREAD = 628, START = 629, STARTS = 630, 
                 STATS_AUTO_RECALC = 631, STATS_PERSISTENT = 632, STATS_SAMPLE_PAGES = 633, 
                 STATUS = 634, STOP = 635, STORAGE = 636, STORED = 637, 
                 STRING = 638, SUBCLASS_ORIGIN = 639, SUBJECT = 640, SUBPARTITION = 641, 
                 SUBPARTITIONS = 642, SUSPEND = 643, SWAPS = 644, SWITCHES = 645, 
                 TABLE_NAME = 646, TABLESPACE = 647, TABLE_TYPE = 648, TEMPORARY = 649, 
                 TEMPTABLE = 650, THAN = 651, TRADITIONAL = 652, TRANSACTION = 653, 
                 TRANSACTIONAL = 654, TRIGGERS = 655, TRUNCATE = 656, UNBOUNDED = 657, 
                 UNDEFINED = 658, UNDOFILE = 659, UNDO_BUFFER_SIZE = 660, 
                 UNINSTALL = 661, UNKNOWN = 662, UNTIL = 663, UPGRADE = 664, 
                 USER = 665, USE_FRM = 666, USER_RESOURCES = 667, VALIDATION = 668, 
                 VALUE = 669, VARIABLES = 670, VIEW = 671, VIRTUAL = 672, 
                 VISIBLE = 673, WAIT = 674, WARNINGS = 675, WINDOW = 676, 
                 WITHOUT = 677, WORK = 678, WRAPPER = 679, X509 = 680, XA = 681, 
                 XML = 682, YES = 683, EUR = 684, USA = 685, JIS = 686, 
                 ISO = 687, INTERNAL = 688, QUARTER = 689, MONTH = 690, 
                 DAY = 691, HOUR = 692, MINUTE = 693, WEEK = 694, SECOND = 695, 
                 MICROSECOND = 696, ADMIN = 697, APPLICATION_PASSWORD_ADMIN = 698, 
                 AUDIT_ABORT_EXEMPT = 699, AUDIT_ADMIN = 700, AUTHENTICATION_POLICY_ADMIN = 701, 
                 BACKUP_ADMIN = 702, BINLOG_ADMIN = 703, BINLOG_ENCRYPTION_ADMIN = 704, 
                 CLONE_ADMIN = 705, CONNECTION_ADMIN = 706, ENCRYPTION_KEY_ADMIN = 707, 
                 EXECUTE = 708, FILE = 709, FIREWALL_ADMIN = 710, FIREWALL_EXEMPT = 711, 
                 FIREWALL_USER = 712, FLUSH_OPTIMIZER_COSTS = 713, FLUSH_STATUS = 714, 
                 FLUSH_TABLES = 715, FLUSH_USER_RESOURCES = 716, GROUP_REPLICATION_ADMIN = 717, 
                 INNODB_REDO_LOG_ARCHIVE = 718, INNODB_REDO_LOG_ENABLE = 719, 
                 INVOKE = 720, LAMBDA = 721, NDB_STORED_USER = 722, PASSWORDLESS_USER_ADMIN = 723, 
                 PERSIST_RO_VARIABLES_ADMIN = 724, PRIVILEGES = 725, PROCESS = 726, 
                 RELOAD = 727, REPLICATION_APPLIER = 728, REPLICATION_SLAVE_ADMIN = 729, 
                 RESOURCE_GROUP_ADMIN = 730, RESOURCE_GROUP_USER = 731, 
                 ROLE_ADMIN = 732, ROUTINE = 733, S3 = 734, SERVICE_CONNECTION_ADMIN = 735, 
                 SESSION_VARIABLES_ADMIN = 736, SET_USER_ID = 737, SHOW_ROUTINE = 738, 
                 SHUTDOWN = 739, SUPER = 740, SYSTEM_VARIABLES_ADMIN = 741, 
                 TABLES = 742, TABLE_ENCRYPTION_ADMIN = 743, VERSION_TOKEN_ADMIN = 744, 
                 XA_RECOVER_ADMIN = 745, ARMSCII8 = 746, ASCII = 747, BIG5 = 748, 
                 CP1250 = 749, CP1251 = 750, CP1256 = 751, CP1257 = 752, 
                 CP850 = 753, CP852 = 754, CP866 = 755, CP932 = 756, DEC8 = 757, 
                 EUCJPMS = 758, EUCKR = 759, GB18030 = 760, GB2312 = 761, 
                 GBK = 762, GEOSTD8 = 763, GREEK = 764, HEBREW = 765, HP8 = 766, 
                 KEYBCS2 = 767, KOI8R = 768, KOI8U = 769, LATIN1 = 770, 
                 LATIN2 = 771, LATIN5 = 772, LATIN7 = 773, MACCE = 774, 
                 MACROMAN = 775, SJIS = 776, SWE7 = 777, TIS620 = 778, UCS2 = 779, 
                 UJIS = 780, UTF16 = 781, UTF16LE = 782, UTF32 = 783, UTF8 = 784, 
                 UTF8MB3 = 785, UTF8MB4 = 786, ARCHIVE = 787, BLACKHOLE = 788, 
                 CSV = 789, FEDERATED = 790, INNODB = 791, MEMORY = 792, 
                 MRG_MYISAM = 793, MYISAM = 794, NDB = 795, NDBCLUSTER = 796, 
                 PERFORMANCE_SCHEMA = 797, TOKUDB = 798, REPEATABLE = 799, 
                 COMMITTED = 800, UNCOMMITTED = 801, SERIALIZABLE = 802, 
                 GEOMETRYCOLLECTION = 803, GEOMCOLLECTION = 804, GEOMETRY = 805, 
                 LINESTRING = 806, MULTILINESTRING = 807, MULTIPOINT = 808, 
                 MULTIPOLYGON = 809, POINT = 810, POLYGON = 811, ABS = 812, 
                 ACOS = 813, ADDDATE = 814, ADDTIME = 815, AES_DECRYPT = 816, 
                 AES_ENCRYPT = 817, AREA = 818, ASBINARY = 819, ASIN = 820, 
                 ASTEXT = 821, ASWKB = 822, ASWKT = 823, ASYMMETRIC_DECRYPT = 824, 
                 ASYMMETRIC_DERIVE = 825, ASYMMETRIC_ENCRYPT = 826, ASYMMETRIC_SIGN = 827, 
                 ASYMMETRIC_VERIFY = 828, ATAN = 829, ATAN2 = 830, BENCHMARK = 831, 
                 BIN = 832, BIT_COUNT = 833, BIT_LENGTH = 834, BUFFER = 835, 
                 CATALOG_NAME = 836, CEIL = 837, CEILING = 838, CENTROID = 839, 
                 CHARACTER_LENGTH = 840, CHARSET = 841, CHAR_LENGTH = 842, 
                 COERCIBILITY = 843, COLLATION = 844, COMPRESS = 845, CONCAT = 846, 
                 CONCAT_WS = 847, CONNECTION_ID = 848, CONV = 849, CONVERT_TZ = 850, 
                 COS = 851, COT = 852, CRC32 = 853, CREATE_ASYMMETRIC_PRIV_KEY = 854, 
                 CREATE_ASYMMETRIC_PUB_KEY = 855, CREATE_DH_PARAMETERS = 856, 
                 CREATE_DIGEST = 857, CROSSES = 858, DATEDIFF = 859, DATE_FORMAT = 860, 
                 DAYNAME = 861, DAYOFMONTH = 862, DAYOFWEEK = 863, DAYOFYEAR = 864, 
                 DECODE = 865, DEGREES = 866, DES_DECRYPT = 867, DES_ENCRYPT = 868, 
                 DIMENSION = 869, DISJOINT = 870, ELT = 871, ENCODE = 872, 
                 ENCRYPT = 873, ENDPOINT = 874, ENGINE_ATTRIBUTE = 875, 
                 ENVELOPE = 876, EQUALS = 877, EXP = 878, EXPORT_SET = 879, 
                 EXTERIORRING = 880, EXTRACTVALUE = 881, FIELD = 882, FIND_IN_SET = 883, 
                 FLOOR = 884, FORMAT = 885, FOUND_ROWS = 886, FROM_BASE64 = 887, 
                 FROM_DAYS = 888, FROM_UNIXTIME = 889, GEOMCOLLFROMTEXT = 890, 
                 GEOMCOLLFROMWKB = 891, GEOMETRYCOLLECTIONFROMTEXT = 892, 
                 GEOMETRYCOLLECTIONFROMWKB = 893, GEOMETRYFROMTEXT = 894, 
                 GEOMETRYFROMWKB = 895, GEOMETRYN = 896, GEOMETRYTYPE = 897, 
                 GEOMFROMTEXT = 898, GEOMFROMWKB = 899, GET_FORMAT = 900, 
                 GET_LOCK = 901, GLENGTH = 902, GREATEST = 903, GTID_SUBSET = 904, 
                 GTID_SUBTRACT = 905, HEX = 906, IFNULL = 907, INET6_ATON = 908, 
                 INET6_NTOA = 909, INET_ATON = 910, INET_NTOA = 911, INSTR = 912, 
                 INTERIORRINGN = 913, INTERSECTS = 914, ISCLOSED = 915, 
                 ISEMPTY = 916, ISNULL = 917, ISSIMPLE = 918, IS_FREE_LOCK = 919, 
                 IS_IPV4 = 920, IS_IPV4_COMPAT = 921, IS_IPV4_MAPPED = 922, 
                 IS_IPV6 = 923, IS_USED_LOCK = 924, LAST_INSERT_ID = 925, 
                 LCASE = 926, LEAST = 927, LENGTH = 928, LINEFROMTEXT = 929, 
                 LINEFROMWKB = 930, LINESTRINGFROMTEXT = 931, LINESTRINGFROMWKB = 932, 
                 LN = 933, LOAD_FILE = 934, LOCATE = 935, LOG = 936, LOG10 = 937, 
                 LOG2 = 938, LOWER = 939, LPAD = 940, LTRIM = 941, MAKEDATE = 942, 
                 MAKETIME = 943, MAKE_SET = 944, MASTER_POS_WAIT = 945, 
                 MBRCONTAINS = 946, MBRDISJOINT = 947, MBREQUAL = 948, MBRINTERSECTS = 949, 
                 MBROVERLAPS = 950, MBRTOUCHES = 951, MBRWITHIN = 952, MD5 = 953, 
                 MLINEFROMTEXT = 954, MLINEFROMWKB = 955, MONTHNAME = 956, 
                 MPOINTFROMTEXT = 957, MPOINTFROMWKB = 958, MPOLYFROMTEXT = 959, 
                 MPOLYFROMWKB = 960, MULTILINESTRINGFROMTEXT = 961, MULTILINESTRINGFROMWKB = 962, 
                 MULTIPOINTFROMTEXT = 963, MULTIPOINTFROMWKB = 964, MULTIPOLYGONFROMTEXT = 965, 
                 MULTIPOLYGONFROMWKB = 966, NAME_CONST = 967, NULLIF = 968, 
                 NUMGEOMETRIES = 969, NUMINTERIORRINGS = 970, NUMPOINTS = 971, 
                 OCT = 972, OCTET_LENGTH = 973, ORD = 974, OVERLAPS = 975, 
                 PERIOD_ADD = 976, PERIOD_DIFF = 977, PI = 978, POINTFROMTEXT = 979, 
                 POINTFROMWKB = 980, POINTN = 981, POLYFROMTEXT = 982, POLYFROMWKB = 983, 
                 POLYGONFROMTEXT = 984, POLYGONFROMWKB = 985, POW = 986, 
                 POWER = 987, QUOTE = 988, RADIANS = 989, RAND = 990, RANDOM = 991, 
                 RANDOM_BYTES = 992, RELEASE_LOCK = 993, REVERSE = 994, 
                 ROUND = 995, ROW_COUNT = 996, RPAD = 997, RTRIM = 998, 
                 SEC_TO_TIME = 999, SECONDARY_ENGINE_ATTRIBUTE = 1000, SESSION_USER = 1001, 
                 SHA = 1002, SHA1 = 1003, SHA2 = 1004, SCHEMA_NAME = 1005, 
                 SIGN = 1006, SIN = 1007, SLEEP = 1008, SOUNDEX = 1009, 
                 SQL_THREAD_WAIT_AFTER_GTIDS = 1010, SQRT = 1011, SRID = 1012, 
                 STARTPOINT = 1013, STRCMP = 1014, STR_TO_DATE = 1015, ST_AREA = 1016, 
                 ST_ASBINARY = 1017, ST_ASTEXT = 1018, ST_ASWKB = 1019, 
                 ST_ASWKT = 1020, ST_BUFFER = 1021, ST_CENTROID = 1022, 
                 ST_CONTAINS = 1023, ST_CROSSES = 1024, ST_DIFFERENCE = 1025, 
                 ST_DIMENSION = 1026, ST_DISJOINT = 1027, ST_DISTANCE = 1028, 
                 ST_ENDPOINT = 1029, ST_ENVELOPE = 1030, ST_EQUALS = 1031, 
                 ST_EXTERIORRING = 1032, ST_GEOMCOLLFROMTEXT = 1033, ST_GEOMCOLLFROMTXT = 1034, 
                 ST_GEOMCOLLFROMWKB = 1035, ST_GEOMETRYCOLLECTIONFROMTEXT = 1036, 
                 ST_GEOMETRYCOLLECTIONFROMWKB = 1037, ST_GEOMETRYFROMTEXT = 1038, 
                 ST_GEOMETRYFROMWKB = 1039, ST_GEOMETRYN = 1040, ST_GEOMETRYTYPE = 1041, 
                 ST_GEOMFROMTEXT = 1042, ST_GEOMFROMWKB = 1043, ST_INTERIORRINGN = 1044, 
                 ST_INTERSECTION = 1045, ST_INTERSECTS = 1046, ST_ISCLOSED = 1047, 
                 ST_ISEMPTY = 1048, ST_ISSIMPLE = 1049, ST_LINEFROMTEXT = 1050, 
                 ST_LINEFROMWKB = 1051, ST_LINESTRINGFROMTEXT = 1052, ST_LINESTRINGFROMWKB = 1053, 
                 ST_NUMGEOMETRIES = 1054, ST_NUMINTERIORRING = 1055, ST_NUMINTERIORRINGS = 1056, 
                 ST_NUMPOINTS = 1057, ST_OVERLAPS = 1058, ST_POINTFROMTEXT = 1059, 
                 ST_POINTFROMWKB = 1060, ST_POINTN = 1061, ST_POLYFROMTEXT = 1062, 
                 ST_POLYFROMWKB = 1063, ST_POLYGONFROMTEXT = 1064, ST_POLYGONFROMWKB = 1065, 
                 ST_SRID = 1066, ST_STARTPOINT = 1067, ST_SYMDIFFERENCE = 1068, 
                 ST_TOUCHES = 1069, ST_UNION = 1070, ST_WITHIN = 1071, ST_X = 1072, 
                 ST_Y = 1073, SUBDATE = 1074, SUBSTRING_INDEX = 1075, SUBTIME = 1076, 
                 SYSTEM_USER = 1077, TAN = 1078, TIMEDIFF = 1079, TIMESTAMPADD = 1080, 
                 TIMESTAMPDIFF = 1081, TIME_FORMAT = 1082, TIME_TO_SEC = 1083, 
                 TOUCHES = 1084, TO_BASE64 = 1085, TO_DAYS = 1086, TO_SECONDS = 1087, 
                 TP_CONNECTION_ADMIN = 1088, UCASE = 1089, UNCOMPRESS = 1090, 
                 UNCOMPRESSED_LENGTH = 1091, UNHEX = 1092, UNIX_TIMESTAMP = 1093, 
                 UPDATEXML = 1094, UPPER = 1095, UUID = 1096, UUID_SHORT = 1097, 
                 VALIDATE_PASSWORD_STRENGTH = 1098, VERSION = 1099, WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS = 1100, 
                 WEEKDAY = 1101, WEEKOFYEAR = 1102, WEIGHT_STRING = 1103, 
                 WITHIN = 1104, YEARWEEK = 1105, Y_FUNCTION = 1106, X_FUNCTION = 1107, 
                 VAR_ASSIGN = 1108, PLUS_ASSIGN = 1109, MINUS_ASSIGN = 1110, 
                 MULT_ASSIGN = 1111, DIV_ASSIGN = 1112, MOD_ASSIGN = 1113, 
                 AND_ASSIGN = 1114, XOR_ASSIGN = 1115, OR_ASSIGN = 1116, 
                 STAR = 1117, DIVIDE = 1118, MODULE = 1119, PLUS = 1120, 
                 MINUS = 1121, DIV = 1122, MOD = 1123, EQUAL_SYMBOL = 1124, 
                 GREATER_SYMBOL = 1125, LESS_SYMBOL = 1126, EXCLAMATION_SYMBOL = 1127, 
                 BIT_NOT_OP = 1128, BIT_OR_OP = 1129, BIT_AND_OP = 1130, 
                 BIT_XOR_OP = 1131, DOT = 1132, LR_BRACKET = 1133, RR_BRACKET = 1134, 
                 COMMA = 1135, SEMI = 1136, AT_SIGN = 1137, ZERO_DECIMAL = 1138, 
                 ONE_DECIMAL = 1139, TWO_DECIMAL = 1140, SINGLE_QUOTE_SYMB = 1141, 
                 DOUBLE_QUOTE_SYMB = 1142, REVERSE_QUOTE_SYMB = 1143, COLON_SYMB = 1144, 
                 CHARSET_REVERSE_QOUTE_STRING = 1145, FILESIZE_LITERAL = 1146, 
                 START_NATIONAL_STRING_LITERAL = 1147, STRING_LITERAL = 1148, 
                 DECIMAL_LITERAL = 1149, HEXADECIMAL_LITERAL = 1150, REAL_LITERAL = 1151, 
                 NULL_SPEC_LITERAL = 1152, BIT_STRING = 1153, STRING_CHARSET_NAME = 1154, 
                 DOT_ID = 1155, ID = 1156, REVERSE_QUOTE_ID = 1157, HOST_IP_ADDRESS = 1158, 
                 LOCAL_ID = 1159, GLOBAL_ID = 1160, ERROR_RECONGNIGION = 1161
	}

	public
	static let RULE_root = 0, RULE_sqlStatements = 1, RULE_sqlStatement = 2, 
            RULE_emptyStatement_ = 3, RULE_ddlStatement = 4, RULE_dmlStatement = 5, 
            RULE_transactionStatement = 6, RULE_replicationStatement = 7, 
            RULE_preparedStatement = 8, RULE_compoundStatement = 9, RULE_administrationStatement = 10, 
            RULE_utilityStatement = 11, RULE_createDatabase = 12, RULE_createEvent = 13, 
            RULE_createIndex = 14, RULE_createLogfileGroup = 15, RULE_createProcedure = 16, 
            RULE_createFunction = 17, RULE_createRole = 18, RULE_createServer = 19, 
            RULE_createTable = 20, RULE_createTablespaceInnodb = 21, RULE_createTablespaceNdb = 22, 
            RULE_createTrigger = 23, RULE_withClause = 24, RULE_commonTableExpressions = 25, 
            RULE_cteName = 26, RULE_cteColumnName = 27, RULE_createView = 28, 
            RULE_createDatabaseOption = 29, RULE_charSet = 30, RULE_currentUserExpression = 31, 
            RULE_ownerStatement = 32, RULE_scheduleExpression = 33, RULE_timestampValue = 34, 
            RULE_intervalExpr = 35, RULE_intervalType = 36, RULE_enableType = 37, 
            RULE_indexType = 38, RULE_indexOption = 39, RULE_procedureParameter = 40, 
            RULE_functionParameter = 41, RULE_routineOption = 42, RULE_serverOption = 43, 
            RULE_createDefinitions = 44, RULE_createDefinition = 45, RULE_columnDefinition = 46, 
            RULE_columnConstraint = 47, RULE_tableConstraint = 48, RULE_referenceDefinition = 49, 
            RULE_referenceAction = 50, RULE_referenceControlType = 51, RULE_indexColumnDefinition = 52, 
            RULE_tableOption = 53, RULE_tableType = 54, RULE_tablespaceStorage = 55, 
            RULE_partitionDefinitions = 56, RULE_partitionFunctionDefinition = 57, 
            RULE_subpartitionFunctionDefinition = 58, RULE_partitionDefinition = 59, 
            RULE_partitionDefinerAtom = 60, RULE_partitionDefinerVector = 61, 
            RULE_subpartitionDefinition = 62, RULE_partitionOption = 63, 
            RULE_alterDatabase = 64, RULE_alterEvent = 65, RULE_alterFunction = 66, 
            RULE_alterInstance = 67, RULE_alterLogfileGroup = 68, RULE_alterProcedure = 69, 
            RULE_alterServer = 70, RULE_alterTable = 71, RULE_alterTablespace = 72, 
            RULE_alterView = 73, RULE_alterSpecification = 74, RULE_alterPartitionSpecification = 75, 
            RULE_dropDatabase = 76, RULE_dropEvent = 77, RULE_dropIndex = 78, 
            RULE_dropLogfileGroup = 79, RULE_dropProcedure = 80, RULE_dropFunction = 81, 
            RULE_dropServer = 82, RULE_dropTable = 83, RULE_dropTablespace = 84, 
            RULE_dropTrigger = 85, RULE_dropView = 86, RULE_dropRole = 87, 
            RULE_setRole = 88, RULE_renameTable = 89, RULE_renameTableClause = 90, 
            RULE_truncateTable = 91, RULE_callStatement = 92, RULE_deleteStatement = 93, 
            RULE_doStatement = 94, RULE_handlerStatement = 95, RULE_insertStatement = 96, 
            RULE_loadDataStatement = 97, RULE_loadXmlStatement = 98, RULE_replaceStatement = 99, 
            RULE_selectStatement = 100, RULE_updateStatement = 101, RULE_valuesStatement = 102, 
            RULE_insertStatementValue = 103, RULE_updatedElement = 104, 
            RULE_assignmentField = 105, RULE_lockClause = 106, RULE_singleDeleteStatement = 107, 
            RULE_multipleDeleteStatement = 108, RULE_handlerOpenStatement = 109, 
            RULE_handlerReadIndexStatement = 110, RULE_handlerReadStatement = 111, 
            RULE_handlerCloseStatement = 112, RULE_singleUpdateStatement = 113, 
            RULE_multipleUpdateStatement = 114, RULE_orderByClause = 115, 
            RULE_orderByExpression = 116, RULE_tableSources = 117, RULE_tableSource = 118, 
            RULE_tableSourceItem = 119, RULE_indexHint = 120, RULE_indexHintType = 121, 
            RULE_joinPart = 122, RULE_joinSpec = 123, RULE_queryExpression = 124, 
            RULE_queryExpressionNointo = 125, RULE_querySpecification = 126, 
            RULE_querySpecificationNointo = 127, RULE_unionParenthesis = 128, 
            RULE_unionStatement = 129, RULE_lateralStatement = 130, RULE_jsonTable = 131, 
            RULE_jsonColumnList = 132, RULE_jsonColumn = 133, RULE_jsonOnEmpty = 134, 
            RULE_jsonOnError = 135, RULE_selectSpec = 136, RULE_selectElements = 137, 
            RULE_selectElement = 138, RULE_selectIntoExpression = 139, RULE_selectFieldsInto = 140, 
            RULE_selectLinesInto = 141, RULE_fromClause = 142, RULE_groupByClause = 143, 
            RULE_havingClause = 144, RULE_windowClause = 145, RULE_groupByItem = 146, 
            RULE_limitClause = 147, RULE_limitClauseAtom = 148, RULE_startTransaction = 149, 
            RULE_beginWork = 150, RULE_commitWork = 151, RULE_rollbackWork = 152, 
            RULE_savepointStatement = 153, RULE_rollbackStatement = 154, 
            RULE_releaseStatement = 155, RULE_lockTables = 156, RULE_unlockTables = 157, 
            RULE_setAutocommitStatement = 158, RULE_setTransactionStatement = 159, 
            RULE_transactionMode = 160, RULE_lockTableElement = 161, RULE_lockAction = 162, 
            RULE_transactionOption = 163, RULE_transactionLevel = 164, RULE_changeMaster = 165, 
            RULE_changeReplicationFilter = 166, RULE_purgeBinaryLogs = 167, 
            RULE_resetMaster = 168, RULE_resetSlave = 169, RULE_startSlave = 170, 
            RULE_stopSlave = 171, RULE_startGroupReplication = 172, RULE_stopGroupReplication = 173, 
            RULE_masterOption = 174, RULE_stringMasterOption = 175, RULE_decimalMasterOption = 176, 
            RULE_boolMasterOption = 177, RULE_channelOption = 178, RULE_replicationFilter = 179, 
            RULE_tablePair = 180, RULE_threadType = 181, RULE_untilOption = 182, 
            RULE_connectionOption = 183, RULE_gtuidSet = 184, RULE_xaStartTransaction = 185, 
            RULE_xaEndTransaction = 186, RULE_xaPrepareStatement = 187, 
            RULE_xaCommitWork = 188, RULE_xaRollbackWork = 189, RULE_xaRecoverWork = 190, 
            RULE_prepareStatement = 191, RULE_executeStatement = 192, RULE_deallocatePrepare = 193, 
            RULE_routineBody = 194, RULE_blockStatement = 195, RULE_caseStatement = 196, 
            RULE_ifStatement = 197, RULE_iterateStatement = 198, RULE_leaveStatement = 199, 
            RULE_loopStatement = 200, RULE_repeatStatement = 201, RULE_returnStatement = 202, 
            RULE_whileStatement = 203, RULE_cursorStatement = 204, RULE_declareVariable = 205, 
            RULE_declareCondition = 206, RULE_declareCursor = 207, RULE_declareHandler = 208, 
            RULE_handlerConditionValue = 209, RULE_procedureSqlStatement = 210, 
            RULE_caseAlternative = 211, RULE_elifAlternative = 212, RULE_alterUser = 213, 
            RULE_createUser = 214, RULE_dropUser = 215, RULE_grantStatement = 216, 
            RULE_roleOption = 217, RULE_grantProxy = 218, RULE_renameUser = 219, 
            RULE_revokeStatement = 220, RULE_revokeProxy = 221, RULE_setPasswordStatement = 222, 
            RULE_userSpecification = 223, RULE_userAuthOption = 224, RULE_authOptionClause = 225, 
            RULE_authenticationRule = 226, RULE_tlsOption = 227, RULE_userResourceOption = 228, 
            RULE_userPasswordOption = 229, RULE_userLockOption = 230, RULE_privelegeClause = 231, 
            RULE_privilege = 232, RULE_privilegeLevel = 233, RULE_renameUserClause = 234, 
            RULE_analyzeTable = 235, RULE_checkTable = 236, RULE_checksumTable = 237, 
            RULE_optimizeTable = 238, RULE_repairTable = 239, RULE_checkTableOption = 240, 
            RULE_createUdfunction = 241, RULE_installPlugin = 242, RULE_uninstallPlugin = 243, 
            RULE_setStatement = 244, RULE_showStatement = 245, RULE_variableClause = 246, 
            RULE_showCommonEntity = 247, RULE_showFilter = 248, RULE_showGlobalInfoClause = 249, 
            RULE_showSchemaEntity = 250, RULE_showProfileType = 251, RULE_binlogStatement = 252, 
            RULE_cacheIndexStatement = 253, RULE_flushStatement = 254, RULE_killStatement = 255, 
            RULE_loadIndexIntoCache = 256, RULE_resetStatement = 257, RULE_shutdownStatement = 258, 
            RULE_tableIndexes = 259, RULE_flushOption = 260, RULE_flushTableOption = 261, 
            RULE_loadedTableIndexes = 262, RULE_simpleDescribeStatement = 263, 
            RULE_fullDescribeStatement = 264, RULE_helpStatement = 265, 
            RULE_useStatement = 266, RULE_signalStatement = 267, RULE_resignalStatement = 268, 
            RULE_signalConditionInformation = 269, RULE_withStatement = 270, 
            RULE_tableStatement = 271, RULE_diagnosticsStatement = 272, 
            RULE_diagnosticsConditionInformationName = 273, RULE_describeObjectClause = 274, 
            RULE_fullId = 275, RULE_tableName = 276, RULE_roleName = 277, 
            RULE_fullColumnName = 278, RULE_indexColumnName = 279, RULE_simpleUserName = 280, 
            RULE_hostName = 281, RULE_userName = 282, RULE_mysqlVariable = 283, 
            RULE_charsetName = 284, RULE_collationName = 285, RULE_engineName = 286, 
            RULE_engineNameBase = 287, RULE_uuidSet = 288, RULE_xid = 289, 
            RULE_xuidStringId = 290, RULE_authPlugin = 291, RULE_uid = 292, 
            RULE_simpleId = 293, RULE_dottedId = 294, RULE_decimalLiteral = 295, 
            RULE_fileSizeLiteral = 296, RULE_stringLiteral = 297, RULE_booleanLiteral = 298, 
            RULE_hexadecimalLiteral = 299, RULE_nullNotnull = 300, RULE_constant = 301, 
            RULE_dataType = 302, RULE_collectionOptions = 303, RULE_convertedDataType = 304, 
            RULE_lengthOneDimension = 305, RULE_lengthTwoDimension = 306, 
            RULE_lengthTwoOptionalDimension = 307, RULE_uidList = 308, RULE_fullColumnNameList = 309, 
            RULE_tables = 310, RULE_indexColumnNames = 311, RULE_expressions = 312, 
            RULE_expressionsWithDefaults = 313, RULE_constants = 314, RULE_simpleStrings = 315, 
            RULE_userVariables = 316, RULE_defaultValue = 317, RULE_currentTimestamp = 318, 
            RULE_expressionOrDefault = 319, RULE_ifExists = 320, RULE_ifNotExists = 321, 
            RULE_orReplace = 322, RULE_waitNowaitClause = 323, RULE_functionCall = 324, 
            RULE_specificFunction = 325, RULE_caseFuncAlternative = 326, 
            RULE_levelsInWeightString = 327, RULE_levelInWeightListElement = 328, 
            RULE_aggregateWindowedFunction = 329, RULE_nonAggregateWindowedFunction = 330, 
            RULE_overClause = 331, RULE_windowSpec = 332, RULE_windowName = 333, 
            RULE_frameClause = 334, RULE_frameUnits = 335, RULE_frameExtent = 336, 
            RULE_frameBetween = 337, RULE_frameRange = 338, RULE_partitionClause = 339, 
            RULE_scalarFunctionName = 340, RULE_passwordFunctionClause = 341, 
            RULE_functionArgs = 342, RULE_functionArg = 343, RULE_expression = 344, 
            RULE_predicate = 345, RULE_expressionAtom = 346, RULE_unaryOperator = 347, 
            RULE_comparisonOperator = 348, RULE_logicalOperator = 349, RULE_bitOperator = 350, 
            RULE_multOperator = 351, RULE_addOperator = 352, RULE_jsonOperator = 353, 
            RULE_charsetNameBase = 354, RULE_transactionLevelBase = 355, 
            RULE_privilegesBase = 356, RULE_intervalTypeBase = 357, RULE_dataTypeBase = 358, 
            RULE_keywordsCanBeId = 359, RULE_functionNameBase = 360

	public
	static let ruleNames: [String] = [
		"root", "sqlStatements", "sqlStatement", "emptyStatement_", "ddlStatement", 
		"dmlStatement", "transactionStatement", "replicationStatement", "preparedStatement", 
		"compoundStatement", "administrationStatement", "utilityStatement", "createDatabase", 
		"createEvent", "createIndex", "createLogfileGroup", "createProcedure", 
		"createFunction", "createRole", "createServer", "createTable", "createTablespaceInnodb", 
		"createTablespaceNdb", "createTrigger", "withClause", "commonTableExpressions", 
		"cteName", "cteColumnName", "createView", "createDatabaseOption", "charSet", 
		"currentUserExpression", "ownerStatement", "scheduleExpression", "timestampValue", 
		"intervalExpr", "intervalType", "enableType", "indexType", "indexOption", 
		"procedureParameter", "functionParameter", "routineOption", "serverOption", 
		"createDefinitions", "createDefinition", "columnDefinition", "columnConstraint", 
		"tableConstraint", "referenceDefinition", "referenceAction", "referenceControlType", 
		"indexColumnDefinition", "tableOption", "tableType", "tablespaceStorage", 
		"partitionDefinitions", "partitionFunctionDefinition", "subpartitionFunctionDefinition", 
		"partitionDefinition", "partitionDefinerAtom", "partitionDefinerVector", 
		"subpartitionDefinition", "partitionOption", "alterDatabase", "alterEvent", 
		"alterFunction", "alterInstance", "alterLogfileGroup", "alterProcedure", 
		"alterServer", "alterTable", "alterTablespace", "alterView", "alterSpecification", 
		"alterPartitionSpecification", "dropDatabase", "dropEvent", "dropIndex", 
		"dropLogfileGroup", "dropProcedure", "dropFunction", "dropServer", "dropTable", 
		"dropTablespace", "dropTrigger", "dropView", "dropRole", "setRole", "renameTable", 
		"renameTableClause", "truncateTable", "callStatement", "deleteStatement", 
		"doStatement", "handlerStatement", "insertStatement", "loadDataStatement", 
		"loadXmlStatement", "replaceStatement", "selectStatement", "updateStatement", 
		"valuesStatement", "insertStatementValue", "updatedElement", "assignmentField", 
		"lockClause", "singleDeleteStatement", "multipleDeleteStatement", "handlerOpenStatement", 
		"handlerReadIndexStatement", "handlerReadStatement", "handlerCloseStatement", 
		"singleUpdateStatement", "multipleUpdateStatement", "orderByClause", "orderByExpression", 
		"tableSources", "tableSource", "tableSourceItem", "indexHint", "indexHintType", 
		"joinPart", "joinSpec", "queryExpression", "queryExpressionNointo", "querySpecification", 
		"querySpecificationNointo", "unionParenthesis", "unionStatement", "lateralStatement", 
		"jsonTable", "jsonColumnList", "jsonColumn", "jsonOnEmpty", "jsonOnError", 
		"selectSpec", "selectElements", "selectElement", "selectIntoExpression", 
		"selectFieldsInto", "selectLinesInto", "fromClause", "groupByClause", 
		"havingClause", "windowClause", "groupByItem", "limitClause", "limitClauseAtom", 
		"startTransaction", "beginWork", "commitWork", "rollbackWork", "savepointStatement", 
		"rollbackStatement", "releaseStatement", "lockTables", "unlockTables", 
		"setAutocommitStatement", "setTransactionStatement", "transactionMode", 
		"lockTableElement", "lockAction", "transactionOption", "transactionLevel", 
		"changeMaster", "changeReplicationFilter", "purgeBinaryLogs", "resetMaster", 
		"resetSlave", "startSlave", "stopSlave", "startGroupReplication", "stopGroupReplication", 
		"masterOption", "stringMasterOption", "decimalMasterOption", "boolMasterOption", 
		"channelOption", "replicationFilter", "tablePair", "threadType", "untilOption", 
		"connectionOption", "gtuidSet", "xaStartTransaction", "xaEndTransaction", 
		"xaPrepareStatement", "xaCommitWork", "xaRollbackWork", "xaRecoverWork", 
		"prepareStatement", "executeStatement", "deallocatePrepare", "routineBody", 
		"blockStatement", "caseStatement", "ifStatement", "iterateStatement", 
		"leaveStatement", "loopStatement", "repeatStatement", "returnStatement", 
		"whileStatement", "cursorStatement", "declareVariable", "declareCondition", 
		"declareCursor", "declareHandler", "handlerConditionValue", "procedureSqlStatement", 
		"caseAlternative", "elifAlternative", "alterUser", "createUser", "dropUser", 
		"grantStatement", "roleOption", "grantProxy", "renameUser", "revokeStatement", 
		"revokeProxy", "setPasswordStatement", "userSpecification", "userAuthOption", 
		"authOptionClause", "authenticationRule", "tlsOption", "userResourceOption", 
		"userPasswordOption", "userLockOption", "privelegeClause", "privilege", 
		"privilegeLevel", "renameUserClause", "analyzeTable", "checkTable", "checksumTable", 
		"optimizeTable", "repairTable", "checkTableOption", "createUdfunction", 
		"installPlugin", "uninstallPlugin", "setStatement", "showStatement", "variableClause", 
		"showCommonEntity", "showFilter", "showGlobalInfoClause", "showSchemaEntity", 
		"showProfileType", "binlogStatement", "cacheIndexStatement", "flushStatement", 
		"killStatement", "loadIndexIntoCache", "resetStatement", "shutdownStatement", 
		"tableIndexes", "flushOption", "flushTableOption", "loadedTableIndexes", 
		"simpleDescribeStatement", "fullDescribeStatement", "helpStatement", "useStatement", 
		"signalStatement", "resignalStatement", "signalConditionInformation", 
		"withStatement", "tableStatement", "diagnosticsStatement", "diagnosticsConditionInformationName", 
		"describeObjectClause", "fullId", "tableName", "roleName", "fullColumnName", 
		"indexColumnName", "simpleUserName", "hostName", "userName", "mysqlVariable", 
		"charsetName", "collationName", "engineName", "engineNameBase", "uuidSet", 
		"xid", "xuidStringId", "authPlugin", "uid", "simpleId", "dottedId", "decimalLiteral", 
		"fileSizeLiteral", "stringLiteral", "booleanLiteral", "hexadecimalLiteral", 
		"nullNotnull", "constant", "dataType", "collectionOptions", "convertedDataType", 
		"lengthOneDimension", "lengthTwoDimension", "lengthTwoOptionalDimension", 
		"uidList", "fullColumnNameList", "tables", "indexColumnNames", "expressions", 
		"expressionsWithDefaults", "constants", "simpleStrings", "userVariables", 
		"defaultValue", "currentTimestamp", "expressionOrDefault", "ifExists", 
		"ifNotExists", "orReplace", "waitNowaitClause", "functionCall", "specificFunction", 
		"caseFuncAlternative", "levelsInWeightString", "levelInWeightListElement", 
		"aggregateWindowedFunction", "nonAggregateWindowedFunction", "overClause", 
		"windowSpec", "windowName", "frameClause", "frameUnits", "frameExtent", 
		"frameBetween", "frameRange", "partitionClause", "scalarFunctionName", 
		"passwordFunctionClause", "functionArgs", "functionArg", "expression", 
		"predicate", "expressionAtom", "unaryOperator", "comparisonOperator", 
		"logicalOperator", "bitOperator", "multOperator", "addOperator", "jsonOperator", 
		"charsetNameBase", "transactionLevelBase", "privilegesBase", "intervalTypeBase", 
		"dataTypeBase", "keywordsCanBeId", "functionNameBase"
	]

	private static let _LITERAL_NAMES: [String?] = [
		nil, nil, nil, nil, nil, "'ADD'", "'ALL'", "'ALTER'", "'ALWAYS'", "'ANALYZE'", 
		"'AND'", "'ARRAY'", "'AS'", "'ASC'", "'ATTRIBUTE'", "'BEFORE'", "'BETWEEN'", 
		"'BOTH'", "'BUCKETS'", "'BY'", "'CALL'", "'CASCADE'", "'CASE'", "'CAST'", 
		"'CHANGE'", "'CHARACTER'", "'CHECK'", "'COLLATE'", "'COLUMN'", "'CONDITION'", 
		"'CONSTRAINT'", "'CONTINUE'", "'CONVERT'", "'CREATE'", "'CROSS'", "'CURRENT'", 
		"'CURRENT_ROLE'", "'CURRENT_USER'", "'CURSOR'", "'DATABASE'", "'DATABASES'", 
		"'DECLARE'", "'DEFAULT'", "'DELAYED'", "'DELETE'", "'DESC'", "'DESCRIBE'", 
		"'DETERMINISTIC'", "'DIAGNOSTICS'", "'DISTINCT'", "'DISTINCTROW'", "'DROP'", 
		"'EACH'", "'ELSE'", "'ELSEIF'", "'EMPTY'", "'ENCLOSED'", "'ENFORCED'", 
		"'ESCAPED'", "'EXCEPT'", "'EXISTS'", "'EXIT'", "'EXPLAIN'", "'FALSE'", 
		"'FETCH'", "'FOR'", "'FORCE'", "'FOREIGN'", "'FROM'", "'FULLTEXT'", "'GENERATED'", 
		"'GET'", "'GRANT'", "'GROUP'", "'HAVING'", "'HIGH_PRIORITY'", "'HISTOGRAM'", 
		"'IF'", "'IGNORE'", "'IGNORED'", "'IN'", "'INDEX'", "'INFILE'", "'INNER'", 
		"'INOUT'", "'INSERT'", "'INTERVAL'", "'INTO'", "'IS'", "'ITERATE'", "'JOIN'", 
		"'KEY'", "'KEYS'", "'KILL'", "'LATERAL'", "'LEADING'", "'LEAVE'", "'LEFT'", 
		"'LIKE'", "'LIMIT'", "'LINEAR'", "'LINES'", "'LOAD'", "'LOCK'", "'LOCKED'", 
		"'LOOP'", "'LOW_PRIORITY'", "'MASTER_BIND'", "'MASTER_SSL_VERIFY_SERVER_CERT'", 
		"'MATCH'", "'MAXVALUE'", "'MINVALUE'", "'MODIFIES'", "'NATURAL'", "'NOT'", 
		"'NO_WRITE_TO_BINLOG'", "'NULL'", "'NUMBER'", "'ON'", "'OPTIMIZE'", "'OPTION'", 
		"'OPTIONAL'", "'OPTIONALLY'", "'OR'", "'ORDER'", "'OUT'", "'OUTER'", "'OUTFILE'", 
		"'OVER'", "'PARTITION'", "'PRIMARY'", "'PROCEDURE'", "'PURGE'", "'RANGE'", 
		"'READ'", "'READS'", "'REFERENCES'", "'REGEXP'", "'RELEASE'", "'RENAME'", 
		"'REPEAT'", "'REPLACE'", "'REQUIRE'", "'RESIGNAL'", "'RESTRICT'", "'RETAIN'", 
		"'RETURN'", "'REVOKE'", "'RIGHT'", "'RLIKE'", "'SCHEMA'", "'SCHEMAS'", 
		"'SELECT'", "'SET'", "'SEPARATOR'", "'SHOW'", "'SIGNAL'", "'SKIP'", "'SKIP_QUERY_REWRITE'", 
		"'SPATIAL'", "'SQL'", "'SQLEXCEPTION'", "'SQLSTATE'", "'SQLWARNING'", 
		"'SQL_BIG_RESULT'", "'SQL_CALC_FOUND_ROWS'", "'SQL_SMALL_RESULT'", "'SSL'", 
		"'STACKED'", "'STARTING'", "'STATEMENT'", "'STRAIGHT_JOIN'", "'TABLE'", 
		"'TERMINATED'", "'THEN'", "'TO'", "'TRAILING'", "'TRIGGER'", "'TRUE'", 
		"'UNDO'", "'UNION'", "'UNIQUE'", "'UNLOCK'", "'UNSIGNED'", "'UPDATE'", 
		"'USAGE'", "'USE'", "'USING'", "'VALUES'", "'WHEN'", "'WHERE'", "'WHILE'", 
		"'WITH'", "'WRITE'", "'XOR'", "'ZEROFILL'", "'TINYINT'", "'SMALLINT'", 
		"'MEDIUMINT'", "'MIDDLEINT'", "'INT'", "'INT1'", "'INT2'", "'INT3'", "'INT4'", 
		"'INT8'", "'INTEGER'", "'BIGINT'", "'REAL'", "'DOUBLE'", "'PRECISION'", 
		"'FLOAT'", "'FLOAT4'", "'FLOAT8'", "'DECIMAL'", "'DEC'", "'NUMERIC'", 
		"'DATE'", "'TIME'", "'TIMESTAMP'", "'DATETIME'", "'YEAR'", "'CHAR'", "'VARCHAR'", 
		"'NVARCHAR'", "'NATIONAL'", "'BINARY'", "'VARBINARY'", "'TINYBLOB'", "'BLOB'", 
		"'MEDIUMBLOB'", "'LONG'", "'LONGBLOB'", "'TINYTEXT'", "'TEXT'", "'MEDIUMTEXT'", 
		"'LONGTEXT'", "'ENUM'", "'VARYING'", "'SERIAL'", "'YEAR_MONTH'", "'DAY_HOUR'", 
		"'DAY_MINUTE'", "'DAY_SECOND'", "'HOUR_MINUTE'", "'HOUR_SECOND'", "'MINUTE_SECOND'", 
		"'SECOND_MICROSECOND'", "'MINUTE_MICROSECOND'", "'HOUR_MICROSECOND'", 
		"'DAY_MICROSECOND'", "'JSON_ARRAY'", "'JSON_ARRAYAGG'", "'JSON_ARRAY_APPEND'", 
		"'JSON_ARRAY_INSERT'", "'JSON_CONTAINS'", "'JSON_CONTAINS_PATH'", "'JSON_DEPTH'", 
		"'JSON_EXTRACT'", "'JSON_INSERT'", "'JSON_KEYS'", "'JSON_LENGTH'", "'JSON_MERGE'", 
		"'JSON_MERGE_PATCH'", "'JSON_MERGE_PRESERVE'", "'JSON_OBJECT'", "'JSON_OBJECTAGG'", 
		"'JSON_OVERLAPS'", "'JSON_PRETTY'", "'JSON_QUOTE'", "'JSON_REMOVE'", "'JSON_REPLACE'", 
		"'JSON_SCHEMA_VALID'", "'JSON_SCHEMA_VALIDATION_REPORT'", "'JSON_SEARCH'", 
		"'JSON_SET'", "'JSON_STORAGE_FREE'", "'JSON_STORAGE_SIZE'", "'JSON_TABLE'", 
		"'JSON_TYPE'", "'JSON_UNQUOTE'", "'JSON_VALID'", "'JSON_VALUE'", "'NESTED'", 
		"'ORDINALITY'", "'PATH'", "'AVG'", "'BIT_AND'", "'BIT_OR'", "'BIT_XOR'", 
		"'COUNT'", "'CUME_DIST'", "'DENSE_RANK'", "'FIRST_VALUE'", "'GROUP_CONCAT'", 
		"'LAG'", "'LAST_VALUE'", "'LEAD'", "'MAX'", "'MIN'", "'NTILE'", "'NTH_VALUE'", 
		"'PERCENT_RANK'", "'RANK'", "'ROW_NUMBER'", "'STD'", "'STDDEV'", "'STDDEV_POP'", 
		"'STDDEV_SAMP'", "'SUM'", "'VAR_POP'", "'VAR_SAMP'", "'VARIANCE'", "'CURRENT_DATE'", 
		"'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'LOCALTIME'", "'CURDATE'", "'CURTIME'", 
		"'DATE_ADD'", "'DATE_SUB'", "'EXTRACT'", "'LOCALTIMESTAMP'", "'NOW'", 
		"'POSITION'", "'SUBSTR'", "'SUBSTRING'", "'SYSDATE'", "'TRIM'", "'UTC_DATE'", 
		"'UTC_TIME'", "'UTC_TIMESTAMP'", "'ACCOUNT'", "'ACTION'", "'AFTER'", "'AGGREGATE'", 
		"'ALGORITHM'", "'ANY'", "'AT'", "'AUTHORS'", "'AUTOCOMMIT'", "'AUTOEXTEND_SIZE'", 
		"'AUTO_INCREMENT'", "'AVG_ROW_LENGTH'", "'BEGIN'", "'BINLOG'", "'BIT'", 
		"'BLOCK'", "'BOOL'", "'BOOLEAN'", "'BTREE'", "'CACHE'", "'CASCADED'", 
		"'CHAIN'", "'CHANGED'", "'CHANNEL'", "'CHECKSUM'", "'PAGE_CHECKSUM'", 
		"'CIPHER'", "'CLASS_ORIGIN'", "'CLIENT'", "'CLOSE'", "'CLUSTERING'", "'COALESCE'", 
		"'CODE'", "'COLUMNS'", "'COLUMN_FORMAT'", "'COLUMN_NAME'", "'COMMENT'", 
		"'COMMIT'", "'COMPACT'", "'COMPLETION'", "'COMPRESSED'", "'COMPRESSION'", 
		"'CONCURRENT'", "'CONNECT'", "'CONNECTION'", "'CONSISTENT'", "'CONSTRAINT_CATALOG'", 
		"'CONSTRAINT_SCHEMA'", "'CONSTRAINT_NAME'", "'CONTAINS'", "'CONTEXT'", 
		"'CONTRIBUTORS'", "'COPY'", "'CPU'", "'CYCLE'", "'CURSOR_NAME'", "'DATA'", 
		"'DATAFILE'", "'DEALLOCATE'", "'DEFAULT_AUTH'", "'DEFINER'", "'DELAY_KEY_WRITE'", 
		"'DES_KEY_FILE'", "'DIRECTORY'", "'DISABLE'", "'DISCARD'", "'DISK'", "'DO'", 
		"'DUMPFILE'", "'DUPLICATE'", "'DYNAMIC'", "'ENABLE'", "'ENCRYPTED'", "'ENCRYPTION'", 
		"'ENCRYPTION_KEY_ID'", "'END'", "'ENDS'", "'ENGINE'", "'ENGINES'", "'ERROR'", 
		"'ERRORS'", "'ESCAPE'", "'EVEN'", "'EVENT'", "'EVENTS'", "'EVERY'", "'EXCHANGE'", 
		"'EXCLUSIVE'", "'EXPIRE'", "'EXPORT'", "'EXTENDED'", "'EXTENT_SIZE'", 
		"'FAILED_LOGIN_ATTEMPTS'", "'FAST'", "'FAULTS'", "'FIELDS'", "'FILE_BLOCK_SIZE'", 
		"'FILTER'", "'FIRST'", "'FIXED'", "'FLUSH'", "'FOLLOWING'", "'FOLLOWS'", 
		"'FOUND'", "'FULL'", "'FUNCTION'", "'GENERAL'", "'GLOBAL'", "'GRANTS'", 
		"'GROUP_REPLICATION'", "'HANDLER'", "'HASH'", "'HELP'", "'HISTORY'", "'HOST'", 
		"'HOSTS'", "'IDENTIFIED'", "'IGNORE_SERVER_IDS'", "'IMPORT'", "'INCREMENT'", 
		"'INDEXES'", "'INITIAL_SIZE'", "'INPLACE'", "'INSERT_METHOD'", "'INSTALL'", 
		"'INSTANCE'", "'INSTANT'", "'INVISIBLE'", "'INVOKER'", "'IO'", "'IO_THREAD'", 
		"'IPC'", "'ISOLATION'", "'ISSUER'", "'JSON'", "'KEY_BLOCK_SIZE'", "'LANGUAGE'", 
		"'LAST'", "'LEAVES'", "'LESS'", "'LEVEL'", "'LIST'", "'LOCAL'", "'LOGFILE'", 
		"'LOGS'", "'MASTER'", "'MASTER_AUTO_POSITION'", "'MASTER_CONNECT_RETRY'", 
		"'MASTER_DELAY'", "'MASTER_HEARTBEAT_PERIOD'", "'MASTER_HOST'", "'MASTER_LOG_FILE'", 
		"'MASTER_LOG_POS'", "'MASTER_PASSWORD'", "'MASTER_PORT'", "'MASTER_RETRY_COUNT'", 
		"'MASTER_SSL'", "'MASTER_SSL_CA'", "'MASTER_SSL_CAPATH'", "'MASTER_SSL_CERT'", 
		"'MASTER_SSL_CIPHER'", "'MASTER_SSL_CRL'", "'MASTER_SSL_CRLPATH'", "'MASTER_SSL_KEY'", 
		"'MASTER_TLS_VERSION'", "'MASTER_USER'", "'MAX_CONNECTIONS_PER_HOUR'", 
		"'MAX_QUERIES_PER_HOUR'", "'MAX_ROWS'", "'MAX_SIZE'", "'MAX_UPDATES_PER_HOUR'", 
		"'MAX_USER_CONNECTIONS'", "'MEDIUM'", "'MEMBER'", "'MERGE'", "'MESSAGE_TEXT'", 
		"'MID'", "'MIGRATE'", "'MIN_ROWS'", "'MODE'", "'MODIFY'", "'MUTEX'", "'MYSQL'", 
		"'MYSQL_ERRNO'", "'NAME'", "'NAMES'", "'NCHAR'", "'NEVER'", "'NEXT'", 
		"'NO'", "'NOCACHE'", "'NOCOPY'", "'NOCYCLE'", "'NOMAXVALUE'", "'NOMINVALUE'", 
		"'NOWAIT'", "'NODEGROUP'", "'NONE'", "'ODBC'", "'OFFLINE'", "'OFFSET'", 
		"'OF'", "'OJ'", "'OLD_PASSWORD'", "'ONE'", "'ONLINE'", "'ONLY'", "'OPEN'", 
		"'OPTIMIZER_COSTS'", "'OPTIONS'", "'OWNER'", "'PACK_KEYS'", "'PAGE'", 
		"'PAGE_COMPRESSED'", "'PAGE_COMPRESSION_LEVEL'", "'PARSER'", "'PARTIAL'", 
		"'PARTITIONING'", "'PARTITIONS'", "'PASSWORD'", "'PASSWORD_LOCK_TIME'", 
		"'PHASE'", "'PLUGIN'", "'PLUGIN_DIR'", "'PLUGINS'", "'PORT'", "'PRECEDES'", 
		"'PRECEDING'", "'PREPARE'", "'PRESERVE'", "'PREV'", "'PROCESSLIST'", "'PROFILE'", 
		"'PROFILES'", "'PROXY'", "'QUERY'", "'QUICK'", "'REBUILD'", "'RECOVER'", 
		"'RECURSIVE'", "'REDO_BUFFER_SIZE'", "'REDUNDANT'", "'RELAY'", "'RELAY_LOG_FILE'", 
		"'RELAY_LOG_POS'", "'RELAYLOG'", "'REMOVE'", "'REORGANIZE'", "'REPAIR'", 
		"'REPLICATE_DO_DB'", "'REPLICATE_DO_TABLE'", "'REPLICATE_IGNORE_DB'", 
		"'REPLICATE_IGNORE_TABLE'", "'REPLICATE_REWRITE_DB'", "'REPLICATE_WILD_DO_TABLE'", 
		"'REPLICATE_WILD_IGNORE_TABLE'", "'REPLICATION'", "'RESET'", "'RESTART'", 
		"'RESUME'", "'RETURNED_SQLSTATE'", "'RETURNING'", "'RETURNS'", "'REUSE'", 
		"'ROLE'", "'ROLLBACK'", "'ROLLUP'", "'ROTATE'", "'ROW'", "'ROWS'", "'ROW_FORMAT'", 
		"'RTREE'", "'SAVEPOINT'", "'SCHEDULE'", "'SECURITY'", "'SEQUENCE'", "'SERVER'", 
		"'SESSION'", "'SHARE'", "'SHARED'", "'SIGNED'", "'SIMPLE'", "'SLAVE'", 
		"'SLOW'", "'SNAPSHOT'", "'SOCKET'", "'SOME'", "'SONAME'", "'SOUNDS'", 
		"'SOURCE'", "'SQL_AFTER_GTIDS'", "'SQL_AFTER_MTS_GAPS'", "'SQL_BEFORE_GTIDS'", 
		"'SQL_BUFFER_RESULT'", "'SQL_CACHE'", "'SQL_NO_CACHE'", "'SQL_THREAD'", 
		"'START'", "'STARTS'", "'STATS_AUTO_RECALC'", "'STATS_PERSISTENT'", "'STATS_SAMPLE_PAGES'", 
		"'STATUS'", "'STOP'", "'STORAGE'", "'STORED'", "'STRING'", "'SUBCLASS_ORIGIN'", 
		"'SUBJECT'", "'SUBPARTITION'", "'SUBPARTITIONS'", "'SUSPEND'", "'SWAPS'", 
		"'SWITCHES'", "'TABLE_NAME'", "'TABLESPACE'", "'TABLE_TYPE'", "'TEMPORARY'", 
		"'TEMPTABLE'", "'THAN'", "'TRADITIONAL'", "'TRANSACTION'", "'TRANSACTIONAL'", 
		"'TRIGGERS'", "'TRUNCATE'", "'UNBOUNDED'", "'UNDEFINED'", "'UNDOFILE'", 
		"'UNDO_BUFFER_SIZE'", "'UNINSTALL'", "'UNKNOWN'", "'UNTIL'", "'UPGRADE'", 
		"'USER'", "'USE_FRM'", "'USER_RESOURCES'", "'VALIDATION'", "'VALUE'", 
		"'VARIABLES'", "'VIEW'", "'VIRTUAL'", "'VISIBLE'", "'WAIT'", "'WARNINGS'", 
		"'WINDOW'", "'WITHOUT'", "'WORK'", "'WRAPPER'", "'X509'", "'XA'", "'XML'", 
		"'YES'", "'EUR'", "'USA'", "'JIS'", "'ISO'", "'INTERNAL'", "'QUARTER'", 
		"'MONTH'", "'DAY'", "'HOUR'", "'MINUTE'", "'WEEK'", "'SECOND'", "'MICROSECOND'", 
		"'ADMIN'", "'APPLICATION_PASSWORD_ADMIN'", "'AUDIT_ABORT_EXEMPT'", "'AUDIT_ADMIN'", 
		"'AUTHENTICATION_POLICY_ADMIN'", "'BACKUP_ADMIN'", "'BINLOG_ADMIN'", "'BINLOG_ENCRYPTION_ADMIN'", 
		"'CLONE_ADMIN'", "'CONNECTION_ADMIN'", "'ENCRYPTION_KEY_ADMIN'", "'EXECUTE'", 
		"'FILE'", "'FIREWALL_ADMIN'", "'FIREWALL_EXEMPT'", "'FIREWALL_USER'", 
		"'FLUSH_OPTIMIZER_COSTS'", "'FLUSH_STATUS'", "'FLUSH_TABLES'", "'FLUSH_USER_RESOURCES'", 
		"'GROUP_REPLICATION_ADMIN'", "'INNODB_REDO_LOG_ARCHIVE'", "'INNODB_REDO_LOG_ENABLE'", 
		"'INVOKE'", "'LAMBDA'", "'NDB_STORED_USER'", "'PASSWORDLESS_USER_ADMIN'", 
		"'PERSIST_RO_VARIABLES_ADMIN'", "'PRIVILEGES'", "'PROCESS'", "'RELOAD'", 
		"'REPLICATION_APPLIER'", "'REPLICATION_SLAVE_ADMIN'", "'RESOURCE_GROUP_ADMIN'", 
		"'RESOURCE_GROUP_USER'", "'ROLE_ADMIN'", "'ROUTINE'", "'S3'", "'SERVICE_CONNECTION_ADMIN'", 
		nil, "'SET_USER_ID'", "'SHOW_ROUTINE'", "'SHUTDOWN'", "'SUPER'", "'SYSTEM_VARIABLES_ADMIN'", 
		"'TABLES'", "'TABLE_ENCRYPTION_ADMIN'", "'VERSION_TOKEN_ADMIN'", "'XA_RECOVER_ADMIN'", 
		"'ARMSCII8'", "'ASCII'", "'BIG5'", "'CP1250'", "'CP1251'", "'CP1256'", 
		"'CP1257'", "'CP850'", "'CP852'", "'CP866'", "'CP932'", "'DEC8'", "'EUCJPMS'", 
		"'EUCKR'", "'GB18030'", "'GB2312'", "'GBK'", "'GEOSTD8'", "'GREEK'", "'HEBREW'", 
		"'HP8'", "'KEYBCS2'", "'KOI8R'", "'KOI8U'", "'LATIN1'", "'LATIN2'", "'LATIN5'", 
		"'LATIN7'", "'MACCE'", "'MACROMAN'", "'SJIS'", "'SWE7'", "'TIS620'", "'UCS2'", 
		"'UJIS'", "'UTF16'", "'UTF16LE'", "'UTF32'", "'UTF8'", "'UTF8MB3'", "'UTF8MB4'", 
		"'ARCHIVE'", "'BLACKHOLE'", "'CSV'", "'FEDERATED'", "'INNODB'", "'MEMORY'", 
		"'MRG_MYISAM'", "'MYISAM'", "'NDB'", "'NDBCLUSTER'", "'PERFORMANCE_SCHEMA'", 
		"'TOKUDB'", "'REPEATABLE'", "'COMMITTED'", "'UNCOMMITTED'", "'SERIALIZABLE'", 
		"'GEOMETRYCOLLECTION'", "'GEOMCOLLECTION'", "'GEOMETRY'", "'LINESTRING'", 
		"'MULTILINESTRING'", "'MULTIPOINT'", "'MULTIPOLYGON'", "'POINT'", "'POLYGON'", 
		"'ABS'", "'ACOS'", "'ADDDATE'", "'ADDTIME'", "'AES_DECRYPT'", "'AES_ENCRYPT'", 
		"'AREA'", "'ASBINARY'", "'ASIN'", "'ASTEXT'", "'ASWKB'", "'ASWKT'", "'ASYMMETRIC_DECRYPT'", 
		"'ASYMMETRIC_DERIVE'", "'ASYMMETRIC_ENCRYPT'", "'ASYMMETRIC_SIGN'", "'ASYMMETRIC_VERIFY'", 
		"'ATAN'", "'ATAN2'", "'BENCHMARK'", "'BIN'", "'BIT_COUNT'", "'BIT_LENGTH'", 
		"'BUFFER'", "'CATALOG_NAME'", "'CEIL'", "'CEILING'", "'CENTROID'", "'CHARACTER_LENGTH'", 
		"'CHARSET'", "'CHAR_LENGTH'", "'COERCIBILITY'", "'COLLATION'", "'COMPRESS'", 
		"'CONCAT'", "'CONCAT_WS'", "'CONNECTION_ID'", "'CONV'", "'CONVERT_TZ'", 
		"'COS'", "'COT'", "'CRC32'", "'CREATE_ASYMMETRIC_PRIV_KEY'", "'CREATE_ASYMMETRIC_PUB_KEY'", 
		"'CREATE_DH_PARAMETERS'", "'CREATE_DIGEST'", "'CROSSES'", "'DATEDIFF'", 
		"'DATE_FORMAT'", "'DAYNAME'", "'DAYOFMONTH'", "'DAYOFWEEK'", "'DAYOFYEAR'", 
		"'DECODE'", "'DEGREES'", "'DES_DECRYPT'", "'DES_ENCRYPT'", "'DIMENSION'", 
		"'DISJOINT'", "'ELT'", "'ENCODE'", "'ENCRYPT'", "'ENDPOINT'", "'ENGINE_ATTRIBUTE'", 
		"'ENVELOPE'", "'EQUALS'", "'EXP'", "'EXPORT_SET'", "'EXTERIORRING'", "'EXTRACTVALUE'", 
		"'FIELD'", "'FIND_IN_SET'", "'FLOOR'", "'FORMAT'", "'FOUND_ROWS'", "'FROM_BASE64'", 
		"'FROM_DAYS'", "'FROM_UNIXTIME'", "'GEOMCOLLFROMTEXT'", "'GEOMCOLLFROMWKB'", 
		"'GEOMETRYCOLLECTIONFROMTEXT'", "'GEOMETRYCOLLECTIONFROMWKB'", "'GEOMETRYFROMTEXT'", 
		"'GEOMETRYFROMWKB'", "'GEOMETRYN'", "'GEOMETRYTYPE'", "'GEOMFROMTEXT'", 
		"'GEOMFROMWKB'", "'GET_FORMAT'", "'GET_LOCK'", "'GLENGTH'", "'GREATEST'", 
		"'GTID_SUBSET'", "'GTID_SUBTRACT'", "'HEX'", "'IFNULL'", "'INET6_ATON'", 
		"'INET6_NTOA'", "'INET_ATON'", "'INET_NTOA'", "'INSTR'", "'INTERIORRINGN'", 
		"'INTERSECTS'", "'ISCLOSED'", "'ISEMPTY'", "'ISNULL'", "'ISSIMPLE'", "'IS_FREE_LOCK'", 
		"'IS_IPV4'", "'IS_IPV4_COMPAT'", "'IS_IPV4_MAPPED'", "'IS_IPV6'", "'IS_USED_LOCK'", 
		"'LAST_INSERT_ID'", "'LCASE'", "'LEAST'", "'LENGTH'", "'LINEFROMTEXT'", 
		"'LINEFROMWKB'", "'LINESTRINGFROMTEXT'", "'LINESTRINGFROMWKB'", "'LN'", 
		"'LOAD_FILE'", "'LOCATE'", "'LOG'", "'LOG10'", "'LOG2'", "'LOWER'", "'LPAD'", 
		"'LTRIM'", "'MAKEDATE'", "'MAKETIME'", "'MAKE_SET'", "'MASTER_POS_WAIT'", 
		"'MBRCONTAINS'", "'MBRDISJOINT'", "'MBREQUAL'", "'MBRINTERSECTS'", "'MBROVERLAPS'", 
		"'MBRTOUCHES'", "'MBRWITHIN'", "'MD5'", "'MLINEFROMTEXT'", "'MLINEFROMWKB'", 
		"'MONTHNAME'", "'MPOINTFROMTEXT'", "'MPOINTFROMWKB'", "'MPOLYFROMTEXT'", 
		"'MPOLYFROMWKB'", "'MULTILINESTRINGFROMTEXT'", "'MULTILINESTRINGFROMWKB'", 
		"'MULTIPOINTFROMTEXT'", "'MULTIPOINTFROMWKB'", "'MULTIPOLYGONFROMTEXT'", 
		"'MULTIPOLYGONFROMWKB'", "'NAME_CONST'", "'NULLIF'", "'NUMGEOMETRIES'", 
		"'NUMINTERIORRINGS'", "'NUMPOINTS'", "'OCT'", "'OCTET_LENGTH'", "'ORD'", 
		"'OVERLAPS'", "'PERIOD_ADD'", "'PERIOD_DIFF'", "'PI'", "'POINTFROMTEXT'", 
		"'POINTFROMWKB'", "'POINTN'", "'POLYFROMTEXT'", "'POLYFROMWKB'", "'POLYGONFROMTEXT'", 
		"'POLYGONFROMWKB'", "'POW'", "'POWER'", "'QUOTE'", "'RADIANS'", "'RAND'", 
		"'RANDOM'", "'RANDOM_BYTES'", "'RELEASE_LOCK'", "'REVERSE'", "'ROUND'", 
		"'ROW_COUNT'", "'RPAD'", "'RTRIM'", "'SEC_TO_TIME'", "'SECONDARY_ENGINE_ATTRIBUTE'", 
		"'SESSION_USER'", "'SHA'", "'SHA1'", "'SHA2'", "'SCHEMA_NAME'", "'SIGN'", 
		"'SIN'", "'SLEEP'", "'SOUNDEX'", "'SQL_THREAD_WAIT_AFTER_GTIDS'", "'SQRT'", 
		"'SRID'", "'STARTPOINT'", "'STRCMP'", "'STR_TO_DATE'", "'ST_AREA'", "'ST_ASBINARY'", 
		"'ST_ASTEXT'", "'ST_ASWKB'", "'ST_ASWKT'", "'ST_BUFFER'", "'ST_CENTROID'", 
		"'ST_CONTAINS'", "'ST_CROSSES'", "'ST_DIFFERENCE'", "'ST_DIMENSION'", 
		"'ST_DISJOINT'", "'ST_DISTANCE'", "'ST_ENDPOINT'", "'ST_ENVELOPE'", "'ST_EQUALS'", 
		"'ST_EXTERIORRING'", "'ST_GEOMCOLLFROMTEXT'", "'ST_GEOMCOLLFROMTXT'", 
		"'ST_GEOMCOLLFROMWKB'", "'ST_GEOMETRYCOLLECTIONFROMTEXT'", "'ST_GEOMETRYCOLLECTIONFROMWKB'", 
		"'ST_GEOMETRYFROMTEXT'", "'ST_GEOMETRYFROMWKB'", "'ST_GEOMETRYN'", "'ST_GEOMETRYTYPE'", 
		"'ST_GEOMFROMTEXT'", "'ST_GEOMFROMWKB'", "'ST_INTERIORRINGN'", "'ST_INTERSECTION'", 
		"'ST_INTERSECTS'", "'ST_ISCLOSED'", "'ST_ISEMPTY'", "'ST_ISSIMPLE'", "'ST_LINEFROMTEXT'", 
		"'ST_LINEFROMWKB'", "'ST_LINESTRINGFROMTEXT'", "'ST_LINESTRINGFROMWKB'", 
		"'ST_NUMGEOMETRIES'", "'ST_NUMINTERIORRING'", "'ST_NUMINTERIORRINGS'", 
		"'ST_NUMPOINTS'", "'ST_OVERLAPS'", "'ST_POINTFROMTEXT'", "'ST_POINTFROMWKB'", 
		"'ST_POINTN'", "'ST_POLYFROMTEXT'", "'ST_POLYFROMWKB'", "'ST_POLYGONFROMTEXT'", 
		"'ST_POLYGONFROMWKB'", "'ST_SRID'", "'ST_STARTPOINT'", "'ST_SYMDIFFERENCE'", 
		"'ST_TOUCHES'", "'ST_UNION'", "'ST_WITHIN'", "'ST_X'", "'ST_Y'", "'SUBDATE'", 
		"'SUBSTRING_INDEX'", "'SUBTIME'", "'SYSTEM_USER'", "'TAN'", "'TIMEDIFF'", 
		"'TIMESTAMPADD'", "'TIMESTAMPDIFF'", "'TIME_FORMAT'", "'TIME_TO_SEC'", 
		"'TOUCHES'", "'TO_BASE64'", "'TO_DAYS'", "'TO_SECONDS'", "'TP_CONNECTION_ADMIN'", 
		"'UCASE'", "'UNCOMPRESS'", "'UNCOMPRESSED_LENGTH'", "'UNHEX'", "'UNIX_TIMESTAMP'", 
		"'UPDATEXML'", "'UPPER'", "'UUID'", "'UUID_SHORT'", "'VALIDATE_PASSWORD_STRENGTH'", 
		"'VERSION'", "'WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS'", "'WEEKDAY'", "'WEEKOFYEAR'", 
		"'WEIGHT_STRING'", "'WITHIN'", "'YEARWEEK'", "'Y'", "'X'", "':='", "'+='", 
		"'-='", "'*='", "'/='", "'%='", "'&='", "'^='", "'|='", "'*'", "'/'", 
		"'%'", "'+'", "'-'", "'DIV'", "'MOD'", "'='", "'>'", "'<'", "'!'", "'~'", 
		"'|'", "'&'", "'^'", "'.'", "'('", "')'", "','", "';'", "'@'", "'0'", 
		"'1'", "'2'", "'''", "'\"'", "'`'", "':'"
	]
	private static let _SYMBOLIC_NAMES: [String?] = [
		nil, "SPACE", "SPEC_MYSQL_COMMENT", "COMMENT_INPUT", "LINE_COMMENT", "ADD", 
		"ALL", "ALTER", "ALWAYS", "ANALYZE", "AND", "ARRAY", "AS", "ASC", "ATTRIBUTE", 
		"BEFORE", "BETWEEN", "BOTH", "BUCKETS", "BY", "CALL", "CASCADE", "CASE", 
		"CAST", "CHANGE", "CHARACTER", "CHECK", "COLLATE", "COLUMN", "CONDITION", 
		"CONSTRAINT", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT", "CURRENT_ROLE", 
		"CURRENT_USER", "CURSOR", "DATABASE", "DATABASES", "DECLARE", "DEFAULT", 
		"DELAYED", "DELETE", "DESC", "DESCRIBE", "DETERMINISTIC", "DIAGNOSTICS", 
		"DISTINCT", "DISTINCTROW", "DROP", "EACH", "ELSE", "ELSEIF", "EMPTY", 
		"ENCLOSED", "ENFORCED", "ESCAPED", "EXCEPT", "EXISTS", "EXIT", "EXPLAIN", 
		"FALSE", "FETCH", "FOR", "FORCE", "FOREIGN", "FROM", "FULLTEXT", "GENERATED", 
		"GET", "GRANT", "GROUP", "HAVING", "HIGH_PRIORITY", "HISTOGRAM", "IF", 
		"IGNORE", "IGNORED", "IN", "INDEX", "INFILE", "INNER", "INOUT", "INSERT", 
		"INTERVAL", "INTO", "IS", "ITERATE", "JOIN", "KEY", "KEYS", "KILL", "LATERAL", 
		"LEADING", "LEAVE", "LEFT", "LIKE", "LIMIT", "LINEAR", "LINES", "LOAD", 
		"LOCK", "LOCKED", "LOOP", "LOW_PRIORITY", "MASTER_BIND", "MASTER_SSL_VERIFY_SERVER_CERT", 
		"MATCH", "MAXVALUE", "MINVALUE", "MODIFIES", "NATURAL", "NOT", "NO_WRITE_TO_BINLOG", 
		"NULL_LITERAL", "NUMBER", "ON", "OPTIMIZE", "OPTION", "OPTIONAL", "OPTIONALLY", 
		"OR", "ORDER", "OUT", "OUTER", "OUTFILE", "OVER", "PARTITION", "PRIMARY", 
		"PROCEDURE", "PURGE", "RANGE", "READ", "READS", "REFERENCES", "REGEXP", 
		"RELEASE", "RENAME", "REPEAT", "REPLACE", "REQUIRE", "RESIGNAL", "RESTRICT", 
		"RETAIN", "RETURN", "REVOKE", "RIGHT", "RLIKE", "SCHEMA", "SCHEMAS", "SELECT", 
		"SET", "SEPARATOR", "SHOW", "SIGNAL", "SKIP_", "SKIP_QUERY_REWRITE", "SPATIAL", 
		"SQL", "SQLEXCEPTION", "SQLSTATE", "SQLWARNING", "SQL_BIG_RESULT", "SQL_CALC_FOUND_ROWS", 
		"SQL_SMALL_RESULT", "SSL", "STACKED", "STARTING", "STATEMENT", "STRAIGHT_JOIN", 
		"TABLE", "TERMINATED", "THEN", "TO", "TRAILING", "TRIGGER", "TRUE", "UNDO", 
		"UNION", "UNIQUE", "UNLOCK", "UNSIGNED", "UPDATE", "USAGE", "USE", "USING", 
		"VALUES", "WHEN", "WHERE", "WHILE", "WITH", "WRITE", "XOR", "ZEROFILL", 
		"TINYINT", "SMALLINT", "MEDIUMINT", "MIDDLEINT", "INT", "INT1", "INT2", 
		"INT3", "INT4", "INT8", "INTEGER", "BIGINT", "REAL", "DOUBLE", "PRECISION", 
		"FLOAT", "FLOAT4", "FLOAT8", "DECIMAL", "DEC", "NUMERIC", "DATE", "TIME", 
		"TIMESTAMP", "DATETIME", "YEAR", "CHAR", "VARCHAR", "NVARCHAR", "NATIONAL", 
		"BINARY", "VARBINARY", "TINYBLOB", "BLOB", "MEDIUMBLOB", "LONG", "LONGBLOB", 
		"TINYTEXT", "TEXT", "MEDIUMTEXT", "LONGTEXT", "ENUM", "VARYING", "SERIAL", 
		"YEAR_MONTH", "DAY_HOUR", "DAY_MINUTE", "DAY_SECOND", "HOUR_MINUTE", "HOUR_SECOND", 
		"MINUTE_SECOND", "SECOND_MICROSECOND", "MINUTE_MICROSECOND", "HOUR_MICROSECOND", 
		"DAY_MICROSECOND", "JSON_ARRAY", "JSON_ARRAYAGG", "JSON_ARRAY_APPEND", 
		"JSON_ARRAY_INSERT", "JSON_CONTAINS", "JSON_CONTAINS_PATH", "JSON_DEPTH", 
		"JSON_EXTRACT", "JSON_INSERT", "JSON_KEYS", "JSON_LENGTH", "JSON_MERGE", 
		"JSON_MERGE_PATCH", "JSON_MERGE_PRESERVE", "JSON_OBJECT", "JSON_OBJECTAGG", 
		"JSON_OVERLAPS", "JSON_PRETTY", "JSON_QUOTE", "JSON_REMOVE", "JSON_REPLACE", 
		"JSON_SCHEMA_VALID", "JSON_SCHEMA_VALIDATION_REPORT", "JSON_SEARCH", "JSON_SET", 
		"JSON_STORAGE_FREE", "JSON_STORAGE_SIZE", "JSON_TABLE", "JSON_TYPE", "JSON_UNQUOTE", 
		"JSON_VALID", "JSON_VALUE", "NESTED", "ORDINALITY", "PATH", "AVG", "BIT_AND", 
		"BIT_OR", "BIT_XOR", "COUNT", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", 
		"GROUP_CONCAT", "LAG", "LAST_VALUE", "LEAD", "MAX", "MIN", "NTILE", "NTH_VALUE", 
		"PERCENT_RANK", "RANK", "ROW_NUMBER", "STD", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", 
		"SUM", "VAR_POP", "VAR_SAMP", "VARIANCE", "CURRENT_DATE", "CURRENT_TIME", 
		"CURRENT_TIMESTAMP", "LOCALTIME", "CURDATE", "CURTIME", "DATE_ADD", "DATE_SUB", 
		"EXTRACT", "LOCALTIMESTAMP", "NOW", "POSITION", "SUBSTR", "SUBSTRING", 
		"SYSDATE", "TRIM", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "ACCOUNT", 
		"ACTION", "AFTER", "AGGREGATE", "ALGORITHM", "ANY", "AT", "AUTHORS", "AUTOCOMMIT", 
		"AUTOEXTEND_SIZE", "AUTO_INCREMENT", "AVG_ROW_LENGTH", "BEGIN", "BINLOG", 
		"BIT", "BLOCK", "BOOL", "BOOLEAN", "BTREE", "CACHE", "CASCADED", "CHAIN", 
		"CHANGED", "CHANNEL", "CHECKSUM", "PAGE_CHECKSUM", "CIPHER", "CLASS_ORIGIN", 
		"CLIENT", "CLOSE", "CLUSTERING", "COALESCE", "CODE", "COLUMNS", "COLUMN_FORMAT", 
		"COLUMN_NAME", "COMMENT", "COMMIT", "COMPACT", "COMPLETION", "COMPRESSED", 
		"COMPRESSION", "CONCURRENT", "CONNECT", "CONNECTION", "CONSISTENT", "CONSTRAINT_CATALOG", 
		"CONSTRAINT_SCHEMA", "CONSTRAINT_NAME", "CONTAINS", "CONTEXT", "CONTRIBUTORS", 
		"COPY", "CPU", "CYCLE", "CURSOR_NAME", "DATA", "DATAFILE", "DEALLOCATE", 
		"DEFAULT_AUTH", "DEFINER", "DELAY_KEY_WRITE", "DES_KEY_FILE", "DIRECTORY", 
		"DISABLE", "DISCARD", "DISK", "DO", "DUMPFILE", "DUPLICATE", "DYNAMIC", 
		"ENABLE", "ENCRYPTED", "ENCRYPTION", "ENCRYPTION_KEY_ID", "END", "ENDS", 
		"ENGINE", "ENGINES", "ERROR", "ERRORS", "ESCAPE", "EVEN", "EVENT", "EVENTS", 
		"EVERY", "EXCHANGE", "EXCLUSIVE", "EXPIRE", "EXPORT", "EXTENDED", "EXTENT_SIZE", 
		"FAILED_LOGIN_ATTEMPTS", "FAST", "FAULTS", "FIELDS", "FILE_BLOCK_SIZE", 
		"FILTER", "FIRST", "FIXED", "FLUSH", "FOLLOWING", "FOLLOWS", "FOUND", 
		"FULL", "FUNCTION", "GENERAL", "GLOBAL", "GRANTS", "GROUP_REPLICATION", 
		"HANDLER", "HASH", "HELP", "HISTORY", "HOST", "HOSTS", "IDENTIFIED", "IGNORE_SERVER_IDS", 
		"IMPORT", "INCREMENT", "INDEXES", "INITIAL_SIZE", "INPLACE", "INSERT_METHOD", 
		"INSTALL", "INSTANCE", "INSTANT", "INVISIBLE", "INVOKER", "IO", "IO_THREAD", 
		"IPC", "ISOLATION", "ISSUER", "JSON", "KEY_BLOCK_SIZE", "LANGUAGE", "LAST", 
		"LEAVES", "LESS", "LEVEL", "LIST", "LOCAL", "LOGFILE", "LOGS", "MASTER", 
		"MASTER_AUTO_POSITION", "MASTER_CONNECT_RETRY", "MASTER_DELAY", "MASTER_HEARTBEAT_PERIOD", 
		"MASTER_HOST", "MASTER_LOG_FILE", "MASTER_LOG_POS", "MASTER_PASSWORD", 
		"MASTER_PORT", "MASTER_RETRY_COUNT", "MASTER_SSL", "MASTER_SSL_CA", "MASTER_SSL_CAPATH", 
		"MASTER_SSL_CERT", "MASTER_SSL_CIPHER", "MASTER_SSL_CRL", "MASTER_SSL_CRLPATH", 
		"MASTER_SSL_KEY", "MASTER_TLS_VERSION", "MASTER_USER", "MAX_CONNECTIONS_PER_HOUR", 
		"MAX_QUERIES_PER_HOUR", "MAX_ROWS", "MAX_SIZE", "MAX_UPDATES_PER_HOUR", 
		"MAX_USER_CONNECTIONS", "MEDIUM", "MEMBER", "MERGE", "MESSAGE_TEXT", "MID", 
		"MIGRATE", "MIN_ROWS", "MODE", "MODIFY", "MUTEX", "MYSQL", "MYSQL_ERRNO", 
		"NAME", "NAMES", "NCHAR", "NEVER", "NEXT", "NO", "NOCACHE", "NOCOPY", 
		"NOCYCLE", "NOMAXVALUE", "NOMINVALUE", "NOWAIT", "NODEGROUP", "NONE", 
		"ODBC", "OFFLINE", "OFFSET", "OF", "OJ", "OLD_PASSWORD", "ONE", "ONLINE", 
		"ONLY", "OPEN", "OPTIMIZER_COSTS", "OPTIONS", "OWNER", "PACK_KEYS", "PAGE", 
		"PAGE_COMPRESSED", "PAGE_COMPRESSION_LEVEL", "PARSER", "PARTIAL", "PARTITIONING", 
		"PARTITIONS", "PASSWORD", "PASSWORD_LOCK_TIME", "PHASE", "PLUGIN", "PLUGIN_DIR", 
		"PLUGINS", "PORT", "PRECEDES", "PRECEDING", "PREPARE", "PRESERVE", "PREV", 
		"PROCESSLIST", "PROFILE", "PROFILES", "PROXY", "QUERY", "QUICK", "REBUILD", 
		"RECOVER", "RECURSIVE", "REDO_BUFFER_SIZE", "REDUNDANT", "RELAY", "RELAY_LOG_FILE", 
		"RELAY_LOG_POS", "RELAYLOG", "REMOVE", "REORGANIZE", "REPAIR", "REPLICATE_DO_DB", 
		"REPLICATE_DO_TABLE", "REPLICATE_IGNORE_DB", "REPLICATE_IGNORE_TABLE", 
		"REPLICATE_REWRITE_DB", "REPLICATE_WILD_DO_TABLE", "REPLICATE_WILD_IGNORE_TABLE", 
		"REPLICATION", "RESET", "RESTART", "RESUME", "RETURNED_SQLSTATE", "RETURNING", 
		"RETURNS", "REUSE", "ROLE", "ROLLBACK", "ROLLUP", "ROTATE", "ROW", "ROWS", 
		"ROW_FORMAT", "RTREE", "SAVEPOINT", "SCHEDULE", "SECURITY", "SEQUENCE", 
		"SERVER", "SESSION", "SHARE", "SHARED", "SIGNED", "SIMPLE", "SLAVE", "SLOW", 
		"SNAPSHOT", "SOCKET", "SOME", "SONAME", "SOUNDS", "SOURCE", "SQL_AFTER_GTIDS", 
		"SQL_AFTER_MTS_GAPS", "SQL_BEFORE_GTIDS", "SQL_BUFFER_RESULT", "SQL_CACHE", 
		"SQL_NO_CACHE", "SQL_THREAD", "START", "STARTS", "STATS_AUTO_RECALC", 
		"STATS_PERSISTENT", "STATS_SAMPLE_PAGES", "STATUS", "STOP", "STORAGE", 
		"STORED", "STRING", "SUBCLASS_ORIGIN", "SUBJECT", "SUBPARTITION", "SUBPARTITIONS", 
		"SUSPEND", "SWAPS", "SWITCHES", "TABLE_NAME", "TABLESPACE", "TABLE_TYPE", 
		"TEMPORARY", "TEMPTABLE", "THAN", "TRADITIONAL", "TRANSACTION", "TRANSACTIONAL", 
		"TRIGGERS", "TRUNCATE", "UNBOUNDED", "UNDEFINED", "UNDOFILE", "UNDO_BUFFER_SIZE", 
		"UNINSTALL", "UNKNOWN", "UNTIL", "UPGRADE", "USER", "USE_FRM", "USER_RESOURCES", 
		"VALIDATION", "VALUE", "VARIABLES", "VIEW", "VIRTUAL", "VISIBLE", "WAIT", 
		"WARNINGS", "WINDOW", "WITHOUT", "WORK", "WRAPPER", "X509", "XA", "XML", 
		"YES", "EUR", "USA", "JIS", "ISO", "INTERNAL", "QUARTER", "MONTH", "DAY", 
		"HOUR", "MINUTE", "WEEK", "SECOND", "MICROSECOND", "ADMIN", "APPLICATION_PASSWORD_ADMIN", 
		"AUDIT_ABORT_EXEMPT", "AUDIT_ADMIN", "AUTHENTICATION_POLICY_ADMIN", "BACKUP_ADMIN", 
		"BINLOG_ADMIN", "BINLOG_ENCRYPTION_ADMIN", "CLONE_ADMIN", "CONNECTION_ADMIN", 
		"ENCRYPTION_KEY_ADMIN", "EXECUTE", "FILE", "FIREWALL_ADMIN", "FIREWALL_EXEMPT", 
		"FIREWALL_USER", "FLUSH_OPTIMIZER_COSTS", "FLUSH_STATUS", "FLUSH_TABLES", 
		"FLUSH_USER_RESOURCES", "GROUP_REPLICATION_ADMIN", "INNODB_REDO_LOG_ARCHIVE", 
		"INNODB_REDO_LOG_ENABLE", "INVOKE", "LAMBDA", "NDB_STORED_USER", "PASSWORDLESS_USER_ADMIN", 
		"PERSIST_RO_VARIABLES_ADMIN", "PRIVILEGES", "PROCESS", "RELOAD", "REPLICATION_APPLIER", 
		"REPLICATION_SLAVE_ADMIN", "RESOURCE_GROUP_ADMIN", "RESOURCE_GROUP_USER", 
		"ROLE_ADMIN", "ROUTINE", "S3", "SERVICE_CONNECTION_ADMIN", "SESSION_VARIABLES_ADMIN", 
		"SET_USER_ID", "SHOW_ROUTINE", "SHUTDOWN", "SUPER", "SYSTEM_VARIABLES_ADMIN", 
		"TABLES", "TABLE_ENCRYPTION_ADMIN", "VERSION_TOKEN_ADMIN", "XA_RECOVER_ADMIN", 
		"ARMSCII8", "ASCII", "BIG5", "CP1250", "CP1251", "CP1256", "CP1257", "CP850", 
		"CP852", "CP866", "CP932", "DEC8", "EUCJPMS", "EUCKR", "GB18030", "GB2312", 
		"GBK", "GEOSTD8", "GREEK", "HEBREW", "HP8", "KEYBCS2", "KOI8R", "KOI8U", 
		"LATIN1", "LATIN2", "LATIN5", "LATIN7", "MACCE", "MACROMAN", "SJIS", "SWE7", 
		"TIS620", "UCS2", "UJIS", "UTF16", "UTF16LE", "UTF32", "UTF8", "UTF8MB3", 
		"UTF8MB4", "ARCHIVE", "BLACKHOLE", "CSV", "FEDERATED", "INNODB", "MEMORY", 
		"MRG_MYISAM", "MYISAM", "NDB", "NDBCLUSTER", "PERFORMANCE_SCHEMA", "TOKUDB", 
		"REPEATABLE", "COMMITTED", "UNCOMMITTED", "SERIALIZABLE", "GEOMETRYCOLLECTION", 
		"GEOMCOLLECTION", "GEOMETRY", "LINESTRING", "MULTILINESTRING", "MULTIPOINT", 
		"MULTIPOLYGON", "POINT", "POLYGON", "ABS", "ACOS", "ADDDATE", "ADDTIME", 
		"AES_DECRYPT", "AES_ENCRYPT", "AREA", "ASBINARY", "ASIN", "ASTEXT", "ASWKB", 
		"ASWKT", "ASYMMETRIC_DECRYPT", "ASYMMETRIC_DERIVE", "ASYMMETRIC_ENCRYPT", 
		"ASYMMETRIC_SIGN", "ASYMMETRIC_VERIFY", "ATAN", "ATAN2", "BENCHMARK", 
		"BIN", "BIT_COUNT", "BIT_LENGTH", "BUFFER", "CATALOG_NAME", "CEIL", "CEILING", 
		"CENTROID", "CHARACTER_LENGTH", "CHARSET", "CHAR_LENGTH", "COERCIBILITY", 
		"COLLATION", "COMPRESS", "CONCAT", "CONCAT_WS", "CONNECTION_ID", "CONV", 
		"CONVERT_TZ", "COS", "COT", "CRC32", "CREATE_ASYMMETRIC_PRIV_KEY", "CREATE_ASYMMETRIC_PUB_KEY", 
		"CREATE_DH_PARAMETERS", "CREATE_DIGEST", "CROSSES", "DATEDIFF", "DATE_FORMAT", 
		"DAYNAME", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "DECODE", "DEGREES", 
		"DES_DECRYPT", "DES_ENCRYPT", "DIMENSION", "DISJOINT", "ELT", "ENCODE", 
		"ENCRYPT", "ENDPOINT", "ENGINE_ATTRIBUTE", "ENVELOPE", "EQUALS", "EXP", 
		"EXPORT_SET", "EXTERIORRING", "EXTRACTVALUE", "FIELD", "FIND_IN_SET", 
		"FLOOR", "FORMAT", "FOUND_ROWS", "FROM_BASE64", "FROM_DAYS", "FROM_UNIXTIME", 
		"GEOMCOLLFROMTEXT", "GEOMCOLLFROMWKB", "GEOMETRYCOLLECTIONFROMTEXT", "GEOMETRYCOLLECTIONFROMWKB", 
		"GEOMETRYFROMTEXT", "GEOMETRYFROMWKB", "GEOMETRYN", "GEOMETRYTYPE", "GEOMFROMTEXT", 
		"GEOMFROMWKB", "GET_FORMAT", "GET_LOCK", "GLENGTH", "GREATEST", "GTID_SUBSET", 
		"GTID_SUBTRACT", "HEX", "IFNULL", "INET6_ATON", "INET6_NTOA", "INET_ATON", 
		"INET_NTOA", "INSTR", "INTERIORRINGN", "INTERSECTS", "ISCLOSED", "ISEMPTY", 
		"ISNULL", "ISSIMPLE", "IS_FREE_LOCK", "IS_IPV4", "IS_IPV4_COMPAT", "IS_IPV4_MAPPED", 
		"IS_IPV6", "IS_USED_LOCK", "LAST_INSERT_ID", "LCASE", "LEAST", "LENGTH", 
		"LINEFROMTEXT", "LINEFROMWKB", "LINESTRINGFROMTEXT", "LINESTRINGFROMWKB", 
		"LN", "LOAD_FILE", "LOCATE", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", 
		"LTRIM", "MAKEDATE", "MAKETIME", "MAKE_SET", "MASTER_POS_WAIT", "MBRCONTAINS", 
		"MBRDISJOINT", "MBREQUAL", "MBRINTERSECTS", "MBROVERLAPS", "MBRTOUCHES", 
		"MBRWITHIN", "MD5", "MLINEFROMTEXT", "MLINEFROMWKB", "MONTHNAME", "MPOINTFROMTEXT", 
		"MPOINTFROMWKB", "MPOLYFROMTEXT", "MPOLYFROMWKB", "MULTILINESTRINGFROMTEXT", 
		"MULTILINESTRINGFROMWKB", "MULTIPOINTFROMTEXT", "MULTIPOINTFROMWKB", "MULTIPOLYGONFROMTEXT", 
		"MULTIPOLYGONFROMWKB", "NAME_CONST", "NULLIF", "NUMGEOMETRIES", "NUMINTERIORRINGS", 
		"NUMPOINTS", "OCT", "OCTET_LENGTH", "ORD", "OVERLAPS", "PERIOD_ADD", "PERIOD_DIFF", 
		"PI", "POINTFROMTEXT", "POINTFROMWKB", "POINTN", "POLYFROMTEXT", "POLYFROMWKB", 
		"POLYGONFROMTEXT", "POLYGONFROMWKB", "POW", "POWER", "QUOTE", "RADIANS", 
		"RAND", "RANDOM", "RANDOM_BYTES", "RELEASE_LOCK", "REVERSE", "ROUND", 
		"ROW_COUNT", "RPAD", "RTRIM", "SEC_TO_TIME", "SECONDARY_ENGINE_ATTRIBUTE", 
		"SESSION_USER", "SHA", "SHA1", "SHA2", "SCHEMA_NAME", "SIGN", "SIN", "SLEEP", 
		"SOUNDEX", "SQL_THREAD_WAIT_AFTER_GTIDS", "SQRT", "SRID", "STARTPOINT", 
		"STRCMP", "STR_TO_DATE", "ST_AREA", "ST_ASBINARY", "ST_ASTEXT", "ST_ASWKB", 
		"ST_ASWKT", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", "ST_CROSSES", "ST_DIFFERENCE", 
		"ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_ENDPOINT", "ST_ENVELOPE", 
		"ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMCOLLFROMTEXT", "ST_GEOMCOLLFROMTXT", 
		"ST_GEOMCOLLFROMWKB", "ST_GEOMETRYCOLLECTIONFROMTEXT", "ST_GEOMETRYCOLLECTIONFROMWKB", 
		"ST_GEOMETRYFROMTEXT", "ST_GEOMETRYFROMWKB", "ST_GEOMETRYN", "ST_GEOMETRYTYPE", 
		"ST_GEOMFROMTEXT", "ST_GEOMFROMWKB", "ST_INTERIORRINGN", "ST_INTERSECTION", 
		"ST_INTERSECTS", "ST_ISCLOSED", "ST_ISEMPTY", "ST_ISSIMPLE", "ST_LINEFROMTEXT", 
		"ST_LINEFROMWKB", "ST_LINESTRINGFROMTEXT", "ST_LINESTRINGFROMWKB", "ST_NUMGEOMETRIES", 
		"ST_NUMINTERIORRING", "ST_NUMINTERIORRINGS", "ST_NUMPOINTS", "ST_OVERLAPS", 
		"ST_POINTFROMTEXT", "ST_POINTFROMWKB", "ST_POINTN", "ST_POLYFROMTEXT", 
		"ST_POLYFROMWKB", "ST_POLYGONFROMTEXT", "ST_POLYGONFROMWKB", "ST_SRID", 
		"ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", "ST_UNION", "ST_WITHIN", 
		"ST_X", "ST_Y", "SUBDATE", "SUBSTRING_INDEX", "SUBTIME", "SYSTEM_USER", 
		"TAN", "TIMEDIFF", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIME_FORMAT", "TIME_TO_SEC", 
		"TOUCHES", "TO_BASE64", "TO_DAYS", "TO_SECONDS", "TP_CONNECTION_ADMIN", 
		"UCASE", "UNCOMPRESS", "UNCOMPRESSED_LENGTH", "UNHEX", "UNIX_TIMESTAMP", 
		"UPDATEXML", "UPPER", "UUID", "UUID_SHORT", "VALIDATE_PASSWORD_STRENGTH", 
		"VERSION", "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS", "WEEKDAY", "WEEKOFYEAR", 
		"WEIGHT_STRING", "WITHIN", "YEARWEEK", "Y_FUNCTION", "X_FUNCTION", "VAR_ASSIGN", 
		"PLUS_ASSIGN", "MINUS_ASSIGN", "MULT_ASSIGN", "DIV_ASSIGN", "MOD_ASSIGN", 
		"AND_ASSIGN", "XOR_ASSIGN", "OR_ASSIGN", "STAR", "DIVIDE", "MODULE", "PLUS", 
		"MINUS", "DIV", "MOD", "EQUAL_SYMBOL", "GREATER_SYMBOL", "LESS_SYMBOL", 
		"EXCLAMATION_SYMBOL", "BIT_NOT_OP", "BIT_OR_OP", "BIT_AND_OP", "BIT_XOR_OP", 
		"DOT", "LR_BRACKET", "RR_BRACKET", "COMMA", "SEMI", "AT_SIGN", "ZERO_DECIMAL", 
		"ONE_DECIMAL", "TWO_DECIMAL", "SINGLE_QUOTE_SYMB", "DOUBLE_QUOTE_SYMB", 
		"REVERSE_QUOTE_SYMB", "COLON_SYMB", "CHARSET_REVERSE_QOUTE_STRING", "FILESIZE_LITERAL", 
		"START_NATIONAL_STRING_LITERAL", "STRING_LITERAL", "DECIMAL_LITERAL", 
		"HEXADECIMAL_LITERAL", "REAL_LITERAL", "NULL_SPEC_LITERAL", "BIT_STRING", 
		"STRING_CHARSET_NAME", "DOT_ID", "ID", "REVERSE_QUOTE_ID", "HOST_IP_ADDRESS", 
		"LOCAL_ID", "GLOBAL_ID", "ERROR_RECONGNIGION"
	]
	public
	static let VOCABULARY = Vocabulary(_LITERAL_NAMES, _SYMBOLIC_NAMES)

	override open
	func getGrammarFileName() -> String { return "MySqlParser.g4" }

	override open
	func getRuleNames() -> [String] { return MySqlParser.ruleNames }

	override open
	func getSerializedATN() -> [Int] { return MySqlParser._serializedATN }

	override open
	func getATN() -> ATN { return MySqlParser._ATN }


	override open
	func getVocabulary() -> Vocabulary {
	    return MySqlParser.VOCABULARY
	}

	override public
	init(_ input:TokenStream) throws {
	    RuntimeMetaData.checkVersion("4.13.1", RuntimeMetaData.VERSION)
		try super.init(input)
		_interp = ParserATNSimulator(self,MySqlParser._ATN,MySqlParser._decisionToDFA, MySqlParser._sharedContextCache)
	}


	public class RootContext: ParserRuleContext {
			open
			func EOF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EOF.rawValue, 0)
			}
			open
			func sqlStatements() -> SqlStatementsContext? {
				return getRuleContext(SqlStatementsContext.self, 0)
			}
			open
			func MINUS() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.MINUS.rawValue)
			}
			open
			func MINUS(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUS.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_root
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRoot(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRoot(self)
			}
		}
	}
	@discardableResult
	 open func root() throws -> RootContext {
		var _localctx: RootContext
		_localctx = RootContext(_ctx, getState())
		try enterRule(_localctx, 0, MySqlParser.RULE_root)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(723)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 4614060972218253952) != 0) || ((Int64((_la - 71)) & ~0x3f) == 0 && ((Int64(1) << (_la - 71)) & 2306124490637066243) != 0) || ((Int64((_la - 138)) & ~0x3f) == 0 && ((Int64(1) << (_la - 138)) & 19509751503569451) != 0) || ((Int64((_la - 344)) & ~0x3f) == 0 && ((Int64(1) << (_la - 344)) & 36099165796700291) != 0) || ((Int64((_la - 432)) & ~0x3f) == 0 && ((Int64(1) << (_la - 432)) & 16782337) != 0) || ((Int64((_la - 560)) & ~0x3f) == 0 && ((Int64(1) << (_la - 560)) & 17730162917377) != 0) || ((Int64((_la - 629)) & ~0x3f) == 0 && ((Int64(1) << (_la - 629)) & 4503604056555585) != 0) || _la == MySqlParser.Tokens.EXECUTE.rawValue || _la == MySqlParser.Tokens.SHUTDOWN.rawValue || _la == MySqlParser.Tokens.LR_BRACKET.rawValue || _la == MySqlParser.Tokens.SEMI.rawValue) {
		 		setState(722)
		 		try sqlStatements()

		 	}

		 	setState(727)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.MINUS.rawValue) {
		 		setState(725)
		 		try match(MySqlParser.Tokens.MINUS.rawValue)
		 		setState(726)
		 		try match(MySqlParser.Tokens.MINUS.rawValue)

		 	}

		 	setState(729)
		 	try match(MySqlParser.Tokens.EOF.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SqlStatementsContext: ParserRuleContext {
			open
			func sqlStatement() -> [SqlStatementContext] {
				return getRuleContexts(SqlStatementContext.self)
			}
			open
			func sqlStatement(_ i: Int) -> SqlStatementContext? {
				return getRuleContext(SqlStatementContext.self, i)
			}
			open
			func emptyStatement_() -> [EmptyStatement_Context] {
				return getRuleContexts(EmptyStatement_Context.self)
			}
			open
			func emptyStatement_(_ i: Int) -> EmptyStatement_Context? {
				return getRuleContext(EmptyStatement_Context.self, i)
			}
			open
			func SEMI() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.SEMI.rawValue)
			}
			open
			func SEMI(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SEMI.rawValue, i)
			}
			open
			func MINUS() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.MINUS.rawValue)
			}
			open
			func MINUS(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUS.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_sqlStatements
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSqlStatements(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSqlStatements(self)
			}
		}
	}
	@discardableResult
	 open func sqlStatements() throws -> SqlStatementsContext {
		var _localctx: SqlStatementsContext
		_localctx = SqlStatementsContext(_ctx, getState())
		try enterRule(_localctx, 2, MySqlParser.RULE_sqlStatements)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(742)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,5,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(740)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .ALTER:fallthrough
		 			case .ANALYZE:fallthrough
		 			case .CALL:fallthrough
		 			case .CHANGE:fallthrough
		 			case .CHECK:fallthrough
		 			case .CREATE:fallthrough
		 			case .DELETE:fallthrough
		 			case .DESC:fallthrough
		 			case .DESCRIBE:fallthrough
		 			case .DROP:fallthrough
		 			case .EXPLAIN:fallthrough
		 			case .GET:fallthrough
		 			case .GRANT:fallthrough
		 			case .INSERT:fallthrough
		 			case .KILL:fallthrough
		 			case .LOAD:fallthrough
		 			case .LOCK:fallthrough
		 			case .OPTIMIZE:fallthrough
		 			case .PURGE:fallthrough
		 			case .RELEASE:fallthrough
		 			case .RENAME:fallthrough
		 			case .REPLACE:fallthrough
		 			case .RESIGNAL:fallthrough
		 			case .REVOKE:fallthrough
		 			case .SELECT:fallthrough
		 			case .SET:fallthrough
		 			case .SHOW:fallthrough
		 			case .SIGNAL:fallthrough
		 			case .TABLE:fallthrough
		 			case .UNLOCK:fallthrough
		 			case .UPDATE:fallthrough
		 			case .USE:fallthrough
		 			case .VALUES:fallthrough
		 			case .WITH:fallthrough
		 			case .BEGIN:fallthrough
		 			case .BINLOG:fallthrough
		 			case .CACHE:fallthrough
		 			case .CHECKSUM:fallthrough
		 			case .COMMIT:fallthrough
		 			case .DEALLOCATE:fallthrough
		 			case .DO:fallthrough
		 			case .FLUSH:fallthrough
		 			case .HANDLER:fallthrough
		 			case .HELP:fallthrough
		 			case .INSTALL:fallthrough
		 			case .PREPARE:fallthrough
		 			case .REPAIR:fallthrough
		 			case .RESET:fallthrough
		 			case .ROLLBACK:fallthrough
		 			case .SAVEPOINT:fallthrough
		 			case .START:fallthrough
		 			case .STOP:fallthrough
		 			case .TRUNCATE:fallthrough
		 			case .UNINSTALL:fallthrough
		 			case .XA:fallthrough
		 			case .EXECUTE:fallthrough
		 			case .SHUTDOWN:fallthrough
		 			case .LR_BRACKET:
		 				setState(731)
		 				try sqlStatement()
		 				setState(734)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (_la == MySqlParser.Tokens.MINUS.rawValue) {
		 					setState(732)
		 					try match(MySqlParser.Tokens.MINUS.rawValue)
		 					setState(733)
		 					try match(MySqlParser.Tokens.MINUS.rawValue)

		 				}

		 				setState(737)
		 				try _errHandler.sync(self)
		 				switch (try getInterpreter().adaptivePredict(_input,3,_ctx)) {
		 				case 1:
		 					setState(736)
		 					try match(MySqlParser.Tokens.SEMI.rawValue)

		 					break
		 				default: break
		 				}

		 				break

		 			case .SEMI:
		 				setState(739)
		 				try emptyStatement_()

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 	 
		 		}
		 		setState(744)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,5,_ctx)
		 	}
		 	setState(754)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ALTER:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .CALL:fallthrough
		 	case .CHANGE:fallthrough
		 	case .CHECK:fallthrough
		 	case .CREATE:fallthrough
		 	case .DELETE:fallthrough
		 	case .DESC:fallthrough
		 	case .DESCRIBE:fallthrough
		 	case .DROP:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .GET:fallthrough
		 	case .GRANT:fallthrough
		 	case .INSERT:fallthrough
		 	case .KILL:fallthrough
		 	case .LOAD:fallthrough
		 	case .LOCK:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .PURGE:fallthrough
		 	case .RELEASE:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESIGNAL:fallthrough
		 	case .REVOKE:fallthrough
		 	case .SELECT:fallthrough
		 	case .SET:fallthrough
		 	case .SHOW:fallthrough
		 	case .SIGNAL:fallthrough
		 	case .TABLE:fallthrough
		 	case .UNLOCK:fallthrough
		 	case .UPDATE:fallthrough
		 	case .USE:fallthrough
		 	case .VALUES:fallthrough
		 	case .WITH:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BINLOG:fallthrough
		 	case .CACHE:fallthrough
		 	case .CHECKSUM:fallthrough
		 	case .COMMIT:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DO:fallthrough
		 	case .FLUSH:fallthrough
		 	case .HANDLER:fallthrough
		 	case .HELP:fallthrough
		 	case .INSTALL:fallthrough
		 	case .PREPARE:fallthrough
		 	case .REPAIR:fallthrough
		 	case .RESET:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .START:fallthrough
		 	case .STOP:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .UNINSTALL:fallthrough
		 	case .XA:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .LR_BRACKET:
		 		setState(745)
		 		try sqlStatement()
		 		setState(751)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,7,_ctx)) {
		 		case 1:
		 			setState(748)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.MINUS.rawValue) {
		 				setState(746)
		 				try match(MySqlParser.Tokens.MINUS.rawValue)
		 				setState(747)
		 				try match(MySqlParser.Tokens.MINUS.rawValue)

		 			}

		 			setState(750)
		 			try match(MySqlParser.Tokens.SEMI.rawValue)

		 			break
		 		default: break
		 		}

		 		break

		 	case .SEMI:
		 		setState(753)
		 		try emptyStatement_()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SqlStatementContext: ParserRuleContext {
			open
			func ddlStatement() -> DdlStatementContext? {
				return getRuleContext(DdlStatementContext.self, 0)
			}
			open
			func dmlStatement() -> DmlStatementContext? {
				return getRuleContext(DmlStatementContext.self, 0)
			}
			open
			func transactionStatement() -> TransactionStatementContext? {
				return getRuleContext(TransactionStatementContext.self, 0)
			}
			open
			func replicationStatement() -> ReplicationStatementContext? {
				return getRuleContext(ReplicationStatementContext.self, 0)
			}
			open
			func preparedStatement() -> PreparedStatementContext? {
				return getRuleContext(PreparedStatementContext.self, 0)
			}
			open
			func administrationStatement() -> AdministrationStatementContext? {
				return getRuleContext(AdministrationStatementContext.self, 0)
			}
			open
			func utilityStatement() -> UtilityStatementContext? {
				return getRuleContext(UtilityStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_sqlStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSqlStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSqlStatement(self)
			}
		}
	}
	@discardableResult
	 open func sqlStatement() throws -> SqlStatementContext {
		var _localctx: SqlStatementContext
		_localctx = SqlStatementContext(_ctx, getState())
		try enterRule(_localctx, 4, MySqlParser.RULE_sqlStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(763)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,9, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(756)
		 		try ddlStatement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(757)
				try dmlStatement()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(758)
		 		try transactionStatement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(759)
		 		try replicationStatement()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(760)
		 		try preparedStatement()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(761)
		 		try administrationStatement()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(762)
		 		try utilityStatement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EmptyStatement_Context: ParserRuleContext {
			open
			func SEMI() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SEMI.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_emptyStatement_
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterEmptyStatement_(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitEmptyStatement_(self)
			}
		}
	}
	@discardableResult
	 open func emptyStatement_() throws -> EmptyStatement_Context {
		var _localctx: EmptyStatement_Context
		_localctx = EmptyStatement_Context(_ctx, getState())
		try enterRule(_localctx, 6, MySqlParser.RULE_emptyStatement_)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(765)
		 	try match(MySqlParser.Tokens.SEMI.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DdlStatementContext: ParserRuleContext {
			open
			func createDatabase() -> CreateDatabaseContext? {
				return getRuleContext(CreateDatabaseContext.self, 0)
			}
			open
			func createEvent() -> CreateEventContext? {
				return getRuleContext(CreateEventContext.self, 0)
			}
			open
			func createIndex() -> CreateIndexContext? {
				return getRuleContext(CreateIndexContext.self, 0)
			}
			open
			func createLogfileGroup() -> CreateLogfileGroupContext? {
				return getRuleContext(CreateLogfileGroupContext.self, 0)
			}
			open
			func createProcedure() -> CreateProcedureContext? {
				return getRuleContext(CreateProcedureContext.self, 0)
			}
			open
			func createFunction() -> CreateFunctionContext? {
				return getRuleContext(CreateFunctionContext.self, 0)
			}
			open
			func createServer() -> CreateServerContext? {
				return getRuleContext(CreateServerContext.self, 0)
			}
			open
			func createTable() -> CreateTableContext? {
				return getRuleContext(CreateTableContext.self, 0)
			}
			open
			func createTablespaceInnodb() -> CreateTablespaceInnodbContext? {
				return getRuleContext(CreateTablespaceInnodbContext.self, 0)
			}
			open
			func createTablespaceNdb() -> CreateTablespaceNdbContext? {
				return getRuleContext(CreateTablespaceNdbContext.self, 0)
			}
			open
			func createTrigger() -> CreateTriggerContext? {
				return getRuleContext(CreateTriggerContext.self, 0)
			}
			open
			func createView() -> CreateViewContext? {
				return getRuleContext(CreateViewContext.self, 0)
			}
			open
			func createRole() -> CreateRoleContext? {
				return getRuleContext(CreateRoleContext.self, 0)
			}
			open
			func alterDatabase() -> AlterDatabaseContext? {
				return getRuleContext(AlterDatabaseContext.self, 0)
			}
			open
			func alterEvent() -> AlterEventContext? {
				return getRuleContext(AlterEventContext.self, 0)
			}
			open
			func alterFunction() -> AlterFunctionContext? {
				return getRuleContext(AlterFunctionContext.self, 0)
			}
			open
			func alterInstance() -> AlterInstanceContext? {
				return getRuleContext(AlterInstanceContext.self, 0)
			}
			open
			func alterLogfileGroup() -> AlterLogfileGroupContext? {
				return getRuleContext(AlterLogfileGroupContext.self, 0)
			}
			open
			func alterProcedure() -> AlterProcedureContext? {
				return getRuleContext(AlterProcedureContext.self, 0)
			}
			open
			func alterServer() -> AlterServerContext? {
				return getRuleContext(AlterServerContext.self, 0)
			}
			open
			func alterTable() -> AlterTableContext? {
				return getRuleContext(AlterTableContext.self, 0)
			}
			open
			func alterTablespace() -> AlterTablespaceContext? {
				return getRuleContext(AlterTablespaceContext.self, 0)
			}
			open
			func alterView() -> AlterViewContext? {
				return getRuleContext(AlterViewContext.self, 0)
			}
			open
			func dropDatabase() -> DropDatabaseContext? {
				return getRuleContext(DropDatabaseContext.self, 0)
			}
			open
			func dropEvent() -> DropEventContext? {
				return getRuleContext(DropEventContext.self, 0)
			}
			open
			func dropIndex() -> DropIndexContext? {
				return getRuleContext(DropIndexContext.self, 0)
			}
			open
			func dropLogfileGroup() -> DropLogfileGroupContext? {
				return getRuleContext(DropLogfileGroupContext.self, 0)
			}
			open
			func dropProcedure() -> DropProcedureContext? {
				return getRuleContext(DropProcedureContext.self, 0)
			}
			open
			func dropFunction() -> DropFunctionContext? {
				return getRuleContext(DropFunctionContext.self, 0)
			}
			open
			func dropServer() -> DropServerContext? {
				return getRuleContext(DropServerContext.self, 0)
			}
			open
			func dropTable() -> DropTableContext? {
				return getRuleContext(DropTableContext.self, 0)
			}
			open
			func dropTablespace() -> DropTablespaceContext? {
				return getRuleContext(DropTablespaceContext.self, 0)
			}
			open
			func dropTrigger() -> DropTriggerContext? {
				return getRuleContext(DropTriggerContext.self, 0)
			}
			open
			func dropView() -> DropViewContext? {
				return getRuleContext(DropViewContext.self, 0)
			}
			open
			func dropRole() -> DropRoleContext? {
				return getRuleContext(DropRoleContext.self, 0)
			}
			open
			func setRole() -> SetRoleContext? {
				return getRuleContext(SetRoleContext.self, 0)
			}
			open
			func renameTable() -> RenameTableContext? {
				return getRuleContext(RenameTableContext.self, 0)
			}
			open
			func truncateTable() -> TruncateTableContext? {
				return getRuleContext(TruncateTableContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_ddlStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDdlStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDdlStatement(self)
			}
		}
	}
	@discardableResult
	 open func ddlStatement() throws -> DdlStatementContext {
		var _localctx: DdlStatementContext
		_localctx = DdlStatementContext(_ctx, getState())
		try enterRule(_localctx, 8, MySqlParser.RULE_ddlStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(805)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,10, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(767)
		 		try createDatabase()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(768)
		 		try createEvent()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(769)
		 		try createIndex()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(770)
		 		try createLogfileGroup()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(771)
		 		try createProcedure()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(772)
		 		try createFunction()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(773)
		 		try createServer()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(774)
		 		try createTable()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(775)
		 		try createTablespaceInnodb()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(776)
		 		try createTablespaceNdb()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(777)
		 		try createTrigger()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(778)
		 		try createView()

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(779)
		 		try createRole()

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(780)
		 		try alterDatabase()

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(781)
		 		try alterEvent()

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(782)
		 		try alterFunction()

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(783)
		 		try alterInstance()

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(784)
		 		try alterLogfileGroup()

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(785)
		 		try alterProcedure()

		 		break
		 	case 20:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(786)
		 		try alterServer()

		 		break
		 	case 21:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(787)
		 		try alterTable()

		 		break
		 	case 22:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(788)
		 		try alterTablespace()

		 		break
		 	case 23:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(789)
		 		try alterView()

		 		break
		 	case 24:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(790)
		 		try dropDatabase()

		 		break
		 	case 25:
		 		try enterOuterAlt(_localctx, 25)
		 		setState(791)
		 		try dropEvent()

		 		break
		 	case 26:
		 		try enterOuterAlt(_localctx, 26)
		 		setState(792)
		 		try dropIndex()

		 		break
		 	case 27:
		 		try enterOuterAlt(_localctx, 27)
		 		setState(793)
		 		try dropLogfileGroup()

		 		break
		 	case 28:
		 		try enterOuterAlt(_localctx, 28)
		 		setState(794)
		 		try dropProcedure()

		 		break
		 	case 29:
		 		try enterOuterAlt(_localctx, 29)
		 		setState(795)
		 		try dropFunction()

		 		break
		 	case 30:
		 		try enterOuterAlt(_localctx, 30)
		 		setState(796)
		 		try dropServer()

		 		break
		 	case 31:
		 		try enterOuterAlt(_localctx, 31)
		 		setState(797)
		 		try dropTable()

		 		break
		 	case 32:
		 		try enterOuterAlt(_localctx, 32)
		 		setState(798)
		 		try dropTablespace()

		 		break
		 	case 33:
		 		try enterOuterAlt(_localctx, 33)
		 		setState(799)
		 		try dropTrigger()

		 		break
		 	case 34:
		 		try enterOuterAlt(_localctx, 34)
		 		setState(800)
		 		try dropView()

		 		break
		 	case 35:
		 		try enterOuterAlt(_localctx, 35)
		 		setState(801)
		 		try dropRole()

		 		break
		 	case 36:
		 		try enterOuterAlt(_localctx, 36)
		 		setState(802)
		 		try setRole()

		 		break
		 	case 37:
		 		try enterOuterAlt(_localctx, 37)
		 		setState(803)
		 		try renameTable()

		 		break
		 	case 38:
		 		try enterOuterAlt(_localctx, 38)
		 		setState(804)
		 		try truncateTable()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DmlStatementContext: ParserRuleContext {
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
			open
			func insertStatement() -> InsertStatementContext? {
				return getRuleContext(InsertStatementContext.self, 0)
			}
			open
			func updateStatement() -> UpdateStatementContext? {
				return getRuleContext(UpdateStatementContext.self, 0)
			}
			open
			func deleteStatement() -> DeleteStatementContext? {
				return getRuleContext(DeleteStatementContext.self, 0)
			}
			open
			func replaceStatement() -> ReplaceStatementContext? {
				return getRuleContext(ReplaceStatementContext.self, 0)
			}
			open
			func callStatement() -> CallStatementContext? {
				return getRuleContext(CallStatementContext.self, 0)
			}
			open
			func loadDataStatement() -> LoadDataStatementContext? {
				return getRuleContext(LoadDataStatementContext.self, 0)
			}
			open
			func loadXmlStatement() -> LoadXmlStatementContext? {
				return getRuleContext(LoadXmlStatementContext.self, 0)
			}
			open
			func doStatement() -> DoStatementContext? {
				return getRuleContext(DoStatementContext.self, 0)
			}
			open
			func handlerStatement() -> HandlerStatementContext? {
				return getRuleContext(HandlerStatementContext.self, 0)
			}
			open
			func valuesStatement() -> ValuesStatementContext? {
				return getRuleContext(ValuesStatementContext.self, 0)
			}
			open
			func withStatement() -> WithStatementContext? {
				return getRuleContext(WithStatementContext.self, 0)
			}
			open
			func tableStatement() -> TableStatementContext? {
				return getRuleContext(TableStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dmlStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDmlStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDmlStatement(self)
			}
		}
	}
	@discardableResult
	 open func dmlStatement() throws -> DmlStatementContext {
		var _localctx: DmlStatementContext
		_localctx = DmlStatementContext(_ctx, getState())
		try enterRule(_localctx, 10, MySqlParser.RULE_dmlStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(820)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,11, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(807)
		 		try selectStatement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(808)
		 		try insertStatement()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(809)
		 		try updateStatement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(810)
		 		try deleteStatement()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(811)
		 		try replaceStatement()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(812)
		 		try callStatement()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(813)
		 		try loadDataStatement()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(814)
		 		try loadXmlStatement()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(815)
		 		try doStatement()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(816)
		 		try handlerStatement()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(817)
		 		try valuesStatement()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(818)
		 		try withStatement()

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(819)
		 		try tableStatement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TransactionStatementContext: ParserRuleContext {
			open
			func startTransaction() -> StartTransactionContext? {
				return getRuleContext(StartTransactionContext.self, 0)
			}
			open
			func beginWork() -> BeginWorkContext? {
				return getRuleContext(BeginWorkContext.self, 0)
			}
			open
			func commitWork() -> CommitWorkContext? {
				return getRuleContext(CommitWorkContext.self, 0)
			}
			open
			func rollbackWork() -> RollbackWorkContext? {
				return getRuleContext(RollbackWorkContext.self, 0)
			}
			open
			func savepointStatement() -> SavepointStatementContext? {
				return getRuleContext(SavepointStatementContext.self, 0)
			}
			open
			func rollbackStatement() -> RollbackStatementContext? {
				return getRuleContext(RollbackStatementContext.self, 0)
			}
			open
			func releaseStatement() -> ReleaseStatementContext? {
				return getRuleContext(ReleaseStatementContext.self, 0)
			}
			open
			func lockTables() -> LockTablesContext? {
				return getRuleContext(LockTablesContext.self, 0)
			}
			open
			func unlockTables() -> UnlockTablesContext? {
				return getRuleContext(UnlockTablesContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_transactionStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTransactionStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTransactionStatement(self)
			}
		}
	}
	@discardableResult
	 open func transactionStatement() throws -> TransactionStatementContext {
		var _localctx: TransactionStatementContext
		_localctx = TransactionStatementContext(_ctx, getState())
		try enterRule(_localctx, 12, MySqlParser.RULE_transactionStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(831)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,12, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(822)
		 		try startTransaction()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(823)
		 		try beginWork()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(824)
		 		try commitWork()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(825)
		 		try rollbackWork()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(826)
		 		try savepointStatement()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(827)
		 		try rollbackStatement()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(828)
		 		try releaseStatement()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(829)
		 		try lockTables()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(830)
		 		try unlockTables()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReplicationStatementContext: ParserRuleContext {
			open
			func changeMaster() -> ChangeMasterContext? {
				return getRuleContext(ChangeMasterContext.self, 0)
			}
			open
			func changeReplicationFilter() -> ChangeReplicationFilterContext? {
				return getRuleContext(ChangeReplicationFilterContext.self, 0)
			}
			open
			func purgeBinaryLogs() -> PurgeBinaryLogsContext? {
				return getRuleContext(PurgeBinaryLogsContext.self, 0)
			}
			open
			func resetMaster() -> ResetMasterContext? {
				return getRuleContext(ResetMasterContext.self, 0)
			}
			open
			func resetSlave() -> ResetSlaveContext? {
				return getRuleContext(ResetSlaveContext.self, 0)
			}
			open
			func startSlave() -> StartSlaveContext? {
				return getRuleContext(StartSlaveContext.self, 0)
			}
			open
			func stopSlave() -> StopSlaveContext? {
				return getRuleContext(StopSlaveContext.self, 0)
			}
			open
			func startGroupReplication() -> StartGroupReplicationContext? {
				return getRuleContext(StartGroupReplicationContext.self, 0)
			}
			open
			func stopGroupReplication() -> StopGroupReplicationContext? {
				return getRuleContext(StopGroupReplicationContext.self, 0)
			}
			open
			func xaStartTransaction() -> XaStartTransactionContext? {
				return getRuleContext(XaStartTransactionContext.self, 0)
			}
			open
			func xaEndTransaction() -> XaEndTransactionContext? {
				return getRuleContext(XaEndTransactionContext.self, 0)
			}
			open
			func xaPrepareStatement() -> XaPrepareStatementContext? {
				return getRuleContext(XaPrepareStatementContext.self, 0)
			}
			open
			func xaCommitWork() -> XaCommitWorkContext? {
				return getRuleContext(XaCommitWorkContext.self, 0)
			}
			open
			func xaRollbackWork() -> XaRollbackWorkContext? {
				return getRuleContext(XaRollbackWorkContext.self, 0)
			}
			open
			func xaRecoverWork() -> XaRecoverWorkContext? {
				return getRuleContext(XaRecoverWorkContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_replicationStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterReplicationStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitReplicationStatement(self)
			}
		}
	}
	@discardableResult
	 open func replicationStatement() throws -> ReplicationStatementContext {
		var _localctx: ReplicationStatementContext
		_localctx = ReplicationStatementContext(_ctx, getState())
		try enterRule(_localctx, 14, MySqlParser.RULE_replicationStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(848)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,13, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(833)
		 		try changeMaster()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(834)
		 		try changeReplicationFilter()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(835)
		 		try purgeBinaryLogs()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(836)
		 		try resetMaster()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(837)
		 		try resetSlave()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(838)
		 		try startSlave()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(839)
		 		try stopSlave()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(840)
		 		try startGroupReplication()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(841)
		 		try stopGroupReplication()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(842)
		 		try xaStartTransaction()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(843)
		 		try xaEndTransaction()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(844)
		 		try xaPrepareStatement()

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(845)
		 		try xaCommitWork()

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(846)
		 		try xaRollbackWork()

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(847)
		 		try xaRecoverWork()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PreparedStatementContext: ParserRuleContext {
			open
			func prepareStatement() -> PrepareStatementContext? {
				return getRuleContext(PrepareStatementContext.self, 0)
			}
			open
			func executeStatement() -> ExecuteStatementContext? {
				return getRuleContext(ExecuteStatementContext.self, 0)
			}
			open
			func deallocatePrepare() -> DeallocatePrepareContext? {
				return getRuleContext(DeallocatePrepareContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_preparedStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPreparedStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPreparedStatement(self)
			}
		}
	}
	@discardableResult
	 open func preparedStatement() throws -> PreparedStatementContext {
		var _localctx: PreparedStatementContext
		_localctx = PreparedStatementContext(_ctx, getState())
		try enterRule(_localctx, 16, MySqlParser.RULE_preparedStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(853)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .PREPARE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(850)
		 		try prepareStatement()

		 		break

		 	case .EXECUTE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(851)
		 		try executeStatement()

		 		break
		 	case .DROP:fallthrough
		 	case .DEALLOCATE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(852)
		 		try deallocatePrepare()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CompoundStatementContext: ParserRuleContext {
			open
			func blockStatement() -> BlockStatementContext? {
				return getRuleContext(BlockStatementContext.self, 0)
			}
			open
			func caseStatement() -> CaseStatementContext? {
				return getRuleContext(CaseStatementContext.self, 0)
			}
			open
			func ifStatement() -> IfStatementContext? {
				return getRuleContext(IfStatementContext.self, 0)
			}
			open
			func leaveStatement() -> LeaveStatementContext? {
				return getRuleContext(LeaveStatementContext.self, 0)
			}
			open
			func loopStatement() -> LoopStatementContext? {
				return getRuleContext(LoopStatementContext.self, 0)
			}
			open
			func repeatStatement() -> RepeatStatementContext? {
				return getRuleContext(RepeatStatementContext.self, 0)
			}
			open
			func whileStatement() -> WhileStatementContext? {
				return getRuleContext(WhileStatementContext.self, 0)
			}
			open
			func iterateStatement() -> IterateStatementContext? {
				return getRuleContext(IterateStatementContext.self, 0)
			}
			open
			func returnStatement() -> ReturnStatementContext? {
				return getRuleContext(ReturnStatementContext.self, 0)
			}
			open
			func cursorStatement() -> CursorStatementContext? {
				return getRuleContext(CursorStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_compoundStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCompoundStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCompoundStatement(self)
			}
		}
	}
	@discardableResult
	 open func compoundStatement() throws -> CompoundStatementContext {
		var _localctx: CompoundStatementContext
		_localctx = CompoundStatementContext(_ctx, getState())
		try enterRule(_localctx, 18, MySqlParser.RULE_compoundStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(865)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,15, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(855)
		 		try blockStatement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(856)
		 		try caseStatement()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(857)
		 		try ifStatement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(858)
		 		try leaveStatement()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(859)
		 		try loopStatement()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(860)
		 		try repeatStatement()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(861)
		 		try whileStatement()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(862)
		 		try iterateStatement()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(863)
		 		try returnStatement()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(864)
		 		try cursorStatement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AdministrationStatementContext: ParserRuleContext {
			open
			func alterUser() -> AlterUserContext? {
				return getRuleContext(AlterUserContext.self, 0)
			}
			open
			func createUser() -> CreateUserContext? {
				return getRuleContext(CreateUserContext.self, 0)
			}
			open
			func dropUser() -> DropUserContext? {
				return getRuleContext(DropUserContext.self, 0)
			}
			open
			func grantStatement() -> GrantStatementContext? {
				return getRuleContext(GrantStatementContext.self, 0)
			}
			open
			func grantProxy() -> GrantProxyContext? {
				return getRuleContext(GrantProxyContext.self, 0)
			}
			open
			func renameUser() -> RenameUserContext? {
				return getRuleContext(RenameUserContext.self, 0)
			}
			open
			func revokeStatement() -> RevokeStatementContext? {
				return getRuleContext(RevokeStatementContext.self, 0)
			}
			open
			func revokeProxy() -> RevokeProxyContext? {
				return getRuleContext(RevokeProxyContext.self, 0)
			}
			open
			func analyzeTable() -> AnalyzeTableContext? {
				return getRuleContext(AnalyzeTableContext.self, 0)
			}
			open
			func checkTable() -> CheckTableContext? {
				return getRuleContext(CheckTableContext.self, 0)
			}
			open
			func checksumTable() -> ChecksumTableContext? {
				return getRuleContext(ChecksumTableContext.self, 0)
			}
			open
			func optimizeTable() -> OptimizeTableContext? {
				return getRuleContext(OptimizeTableContext.self, 0)
			}
			open
			func repairTable() -> RepairTableContext? {
				return getRuleContext(RepairTableContext.self, 0)
			}
			open
			func createUdfunction() -> CreateUdfunctionContext? {
				return getRuleContext(CreateUdfunctionContext.self, 0)
			}
			open
			func installPlugin() -> InstallPluginContext? {
				return getRuleContext(InstallPluginContext.self, 0)
			}
			open
			func uninstallPlugin() -> UninstallPluginContext? {
				return getRuleContext(UninstallPluginContext.self, 0)
			}
			open
			func setStatement() -> SetStatementContext? {
				return getRuleContext(SetStatementContext.self, 0)
			}
			open
			func showStatement() -> ShowStatementContext? {
				return getRuleContext(ShowStatementContext.self, 0)
			}
			open
			func binlogStatement() -> BinlogStatementContext? {
				return getRuleContext(BinlogStatementContext.self, 0)
			}
			open
			func cacheIndexStatement() -> CacheIndexStatementContext? {
				return getRuleContext(CacheIndexStatementContext.self, 0)
			}
			open
			func flushStatement() -> FlushStatementContext? {
				return getRuleContext(FlushStatementContext.self, 0)
			}
			open
			func killStatement() -> KillStatementContext? {
				return getRuleContext(KillStatementContext.self, 0)
			}
			open
			func loadIndexIntoCache() -> LoadIndexIntoCacheContext? {
				return getRuleContext(LoadIndexIntoCacheContext.self, 0)
			}
			open
			func resetStatement() -> ResetStatementContext? {
				return getRuleContext(ResetStatementContext.self, 0)
			}
			open
			func shutdownStatement() -> ShutdownStatementContext? {
				return getRuleContext(ShutdownStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_administrationStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAdministrationStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAdministrationStatement(self)
			}
		}
	}
	@discardableResult
	 open func administrationStatement() throws -> AdministrationStatementContext {
		var _localctx: AdministrationStatementContext
		_localctx = AdministrationStatementContext(_ctx, getState())
		try enterRule(_localctx, 20, MySqlParser.RULE_administrationStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(892)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,16, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(867)
		 		try alterUser()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(868)
		 		try createUser()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(869)
		 		try dropUser()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(870)
		 		try grantStatement()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(871)
		 		try grantProxy()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(872)
		 		try renameUser()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(873)
		 		try revokeStatement()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(874)
		 		try revokeProxy()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(875)
		 		try analyzeTable()

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(876)
		 		try checkTable()

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(877)
		 		try checksumTable()

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(878)
		 		try optimizeTable()

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(879)
		 		try repairTable()

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(880)
		 		try createUdfunction()

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(881)
		 		try installPlugin()

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(882)
		 		try uninstallPlugin()

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(883)
		 		try setStatement()

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(884)
		 		try showStatement()

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(885)
		 		try binlogStatement()

		 		break
		 	case 20:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(886)
		 		try cacheIndexStatement()

		 		break
		 	case 21:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(887)
		 		try flushStatement()

		 		break
		 	case 22:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(888)
		 		try killStatement()

		 		break
		 	case 23:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(889)
		 		try loadIndexIntoCache()

		 		break
		 	case 24:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(890)
		 		try resetStatement()

		 		break
		 	case 25:
		 		try enterOuterAlt(_localctx, 25)
		 		setState(891)
		 		try shutdownStatement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UtilityStatementContext: ParserRuleContext {
			open
			func simpleDescribeStatement() -> SimpleDescribeStatementContext? {
				return getRuleContext(SimpleDescribeStatementContext.self, 0)
			}
			open
			func fullDescribeStatement() -> FullDescribeStatementContext? {
				return getRuleContext(FullDescribeStatementContext.self, 0)
			}
			open
			func helpStatement() -> HelpStatementContext? {
				return getRuleContext(HelpStatementContext.self, 0)
			}
			open
			func useStatement() -> UseStatementContext? {
				return getRuleContext(UseStatementContext.self, 0)
			}
			open
			func signalStatement() -> SignalStatementContext? {
				return getRuleContext(SignalStatementContext.self, 0)
			}
			open
			func resignalStatement() -> ResignalStatementContext? {
				return getRuleContext(ResignalStatementContext.self, 0)
			}
			open
			func diagnosticsStatement() -> DiagnosticsStatementContext? {
				return getRuleContext(DiagnosticsStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_utilityStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUtilityStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUtilityStatement(self)
			}
		}
	}
	@discardableResult
	 open func utilityStatement() throws -> UtilityStatementContext {
		var _localctx: UtilityStatementContext
		_localctx = UtilityStatementContext(_ctx, getState())
		try enterRule(_localctx, 22, MySqlParser.RULE_utilityStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(901)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,17, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(894)
		 		try simpleDescribeStatement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(895)
		 		try fullDescribeStatement()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(896)
		 		try helpStatement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(897)
		 		try useStatement()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(898)
		 		try signalStatement()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(899)
		 		try resignalStatement()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(900)
		 		try diagnosticsStatement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateDatabaseContext: ParserRuleContext {
		open var dbFormat: Token!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func DATABASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATABASE.rawValue, 0)
			}
			open
			func SCHEMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEMA.rawValue, 0)
			}
			open
			func ifNotExists() -> IfNotExistsContext? {
				return getRuleContext(IfNotExistsContext.self, 0)
			}
			open
			func createDatabaseOption() -> [CreateDatabaseOptionContext] {
				return getRuleContexts(CreateDatabaseOptionContext.self)
			}
			open
			func createDatabaseOption(_ i: Int) -> CreateDatabaseOptionContext? {
				return getRuleContext(CreateDatabaseOptionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createDatabase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateDatabase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateDatabase(self)
			}
		}
	}
	@discardableResult
	 open func createDatabase() throws -> CreateDatabaseContext {
		var _localctx: CreateDatabaseContext
		_localctx = CreateDatabaseContext(_ctx, getState())
		try enterRule(_localctx, 24, MySqlParser.RULE_createDatabase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(903)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(904)
		 	_localctx.castdown(CreateDatabaseContext.self).dbFormat = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.DATABASE.rawValue || _la == MySqlParser.Tokens.SCHEMA.rawValue)) {
		 		_localctx.castdown(CreateDatabaseContext.self).dbFormat = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(906)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,18,_ctx)) {
		 	case 1:
		 		setState(905)
		 		try ifNotExists()

		 		break
		 	default: break
		 	}
		 	setState(908)
		 	try uid()
		 	setState(912)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 4398214283264) != 0) || _la == MySqlParser.Tokens.READ.rawValue || _la == MySqlParser.Tokens.CHAR.rawValue || _la == MySqlParser.Tokens.ENCRYPTION.rawValue || _la == MySqlParser.Tokens.CHARSET.rawValue) {
		 		setState(909)
		 		try createDatabaseOption()


		 		setState(914)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateEventContext: ParserRuleContext {
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func EVENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVENT.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func ON() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ON.rawValue)
			}
			open
			func ON(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, i)
			}
			open
			func SCHEDULE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEDULE.rawValue, 0)
			}
			open
			func scheduleExpression() -> ScheduleExpressionContext? {
				return getRuleContext(ScheduleExpressionContext.self, 0)
			}
			open
			func DO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DO.rawValue, 0)
			}
			open
			func routineBody() -> RoutineBodyContext? {
				return getRuleContext(RoutineBodyContext.self, 0)
			}
			open
			func ownerStatement() -> OwnerStatementContext? {
				return getRuleContext(OwnerStatementContext.self, 0)
			}
			open
			func ifNotExists() -> IfNotExistsContext? {
				return getRuleContext(IfNotExistsContext.self, 0)
			}
			open
			func COMPLETION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMPLETION.rawValue, 0)
			}
			open
			func PRESERVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRESERVE.rawValue, 0)
			}
			open
			func enableType() -> EnableTypeContext? {
				return getRuleContext(EnableTypeContext.self, 0)
			}
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createEvent
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateEvent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateEvent(self)
			}
		}
	}
	@discardableResult
	 open func createEvent() throws -> CreateEventContext {
		var _localctx: CreateEventContext
		_localctx = CreateEventContext(_ctx, getState())
		try enterRule(_localctx, 26, MySqlParser.RULE_createEvent)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(915)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(917)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.DEFINER.rawValue) {
		 		setState(916)
		 		try ownerStatement()

		 	}

		 	setState(919)
		 	try match(MySqlParser.Tokens.EVENT.rawValue)
		 	setState(921)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,21,_ctx)) {
		 	case 1:
		 		setState(920)
		 		try ifNotExists()

		 		break
		 	default: break
		 	}
		 	setState(923)
		 	try fullId()
		 	setState(924)
		 	try match(MySqlParser.Tokens.ON.rawValue)
		 	setState(925)
		 	try match(MySqlParser.Tokens.SCHEDULE.rawValue)
		 	setState(926)
		 	try scheduleExpression()
		 	setState(933)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ON.rawValue) {
		 		setState(927)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(928)
		 		try match(MySqlParser.Tokens.COMPLETION.rawValue)
		 		setState(930)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.NOT.rawValue) {
		 			setState(929)
		 			try match(MySqlParser.Tokens.NOT.rawValue)

		 		}

		 		setState(932)
		 		try match(MySqlParser.Tokens.PRESERVE.rawValue)

		 	}

		 	setState(936)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.DISABLE.rawValue || _la == MySqlParser.Tokens.ENABLE.rawValue) {
		 		setState(935)
		 		try enableType()

		 	}

		 	setState(940)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.COMMENT.rawValue) {
		 		setState(938)
		 		try match(MySqlParser.Tokens.COMMENT.rawValue)
		 		setState(939)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 	}

		 	setState(942)
		 	try match(MySqlParser.Tokens.DO.rawValue)
		 	setState(943)
		 	try routineBody()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateIndexContext: ParserRuleContext {
		open var intimeAction: Token!
		open var indexCategory: Token!
		open var algType: Token!
		open var lockType: Token!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func indexType() -> IndexTypeContext? {
				return getRuleContext(IndexTypeContext.self, 0)
			}
			open
			func indexOption() -> [IndexOptionContext] {
				return getRuleContexts(IndexOptionContext.self)
			}
			open
			func indexOption(_ i: Int) -> IndexOptionContext? {
				return getRuleContext(IndexOptionContext.self, i)
			}
			open
			func ALGORITHM() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ALGORITHM.rawValue)
			}
			open
			func ALGORITHM(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALGORITHM.rawValue, i)
			}
			open
			func LOCK() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LOCK.rawValue)
			}
			open
			func LOCK(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCK.rawValue, i)
			}
			open
			func ONLINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONLINE.rawValue, 0)
			}
			open
			func OFFLINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OFFLINE.rawValue, 0)
			}
			open
			func UNIQUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNIQUE.rawValue, 0)
			}
			open
			func FULLTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FULLTEXT.rawValue, 0)
			}
			open
			func SPATIAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SPATIAL.rawValue, 0)
			}
			open
			func DEFAULT() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.DEFAULT.rawValue)
			}
			open
			func DEFAULT(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, i)
			}
			open
			func INPLACE() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.INPLACE.rawValue)
			}
			open
			func INPLACE(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INPLACE.rawValue, i)
			}
			open
			func COPY() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COPY.rawValue)
			}
			open
			func COPY(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COPY.rawValue, i)
			}
			open
			func NONE() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.NONE.rawValue)
			}
			open
			func NONE(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NONE.rawValue, i)
			}
			open
			func SHARED() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.SHARED.rawValue)
			}
			open
			func SHARED(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHARED.rawValue, i)
			}
			open
			func EXCLUSIVE() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EXCLUSIVE.rawValue)
			}
			open
			func EXCLUSIVE(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXCLUSIVE.rawValue, i)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createIndex
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateIndex(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateIndex(self)
			}
		}
	}
	@discardableResult
	 open func createIndex() throws -> CreateIndexContext {
		var _localctx: CreateIndexContext
		_localctx = CreateIndexContext(_ctx, getState())
		try enterRule(_localctx, 28, MySqlParser.RULE_createIndex)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(945)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(947)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.OFFLINE.rawValue || _la == MySqlParser.Tokens.ONLINE.rawValue) {
		 		setState(946)
		 		_localctx.castdown(CreateIndexContext.self).intimeAction = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.OFFLINE.rawValue || _la == MySqlParser.Tokens.ONLINE.rawValue)) {
		 			_localctx.castdown(CreateIndexContext.self).intimeAction = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(950)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.FULLTEXT.rawValue || _la == MySqlParser.Tokens.SPATIAL.rawValue || _la == MySqlParser.Tokens.UNIQUE.rawValue) {
		 		setState(949)
		 		_localctx.castdown(CreateIndexContext.self).indexCategory = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FULLTEXT.rawValue || _la == MySqlParser.Tokens.SPATIAL.rawValue || _la == MySqlParser.Tokens.UNIQUE.rawValue)) {
		 			_localctx.castdown(CreateIndexContext.self).indexCategory = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(952)
		 	try match(MySqlParser.Tokens.INDEX.rawValue)
		 	setState(953)
		 	try uid()
		 	setState(955)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.USING.rawValue) {
		 		setState(954)
		 		try indexType()

		 	}

		 	setState(957)
		 	try match(MySqlParser.Tokens.ON.rawValue)
		 	setState(958)
		 	try tableName()
		 	setState(959)
		 	try indexColumnNames()
		 	setState(963)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,29,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(960)
		 			try indexOption()

		 	 
		 		}
		 		setState(965)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,29,_ctx)
		 	}
		 	setState(978)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,33,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(976)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .ALGORITHM:
		 				setState(966)
		 				try match(MySqlParser.Tokens.ALGORITHM.rawValue)
		 				setState(968)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 					setState(967)
		 					try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 				}

		 				setState(970)
		 				_localctx.castdown(CreateIndexContext.self).algType = try _input.LT(1)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.COPY.rawValue || _la == MySqlParser.Tokens.INPLACE.rawValue)) {
		 					_localctx.castdown(CreateIndexContext.self).algType = try _errHandler.recoverInline(self) as Token
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 				break

		 			case .LOCK:
		 				setState(971)
		 				try match(MySqlParser.Tokens.LOCK.rawValue)
		 				setState(973)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 					setState(972)
		 					try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 				}

		 				setState(975)
		 				_localctx.castdown(CreateIndexContext.self).lockType = try _input.LT(1)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.EXCLUSIVE.rawValue || _la == MySqlParser.Tokens.NONE.rawValue || _la == MySqlParser.Tokens.SHARED.rawValue)) {
		 					_localctx.castdown(CreateIndexContext.self).lockType = try _errHandler.recoverInline(self) as Token
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 	 
		 		}
		 		setState(980)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,33,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateLogfileGroupContext: ParserRuleContext {
		open var undoFile: Token!
		open var initSize: FileSizeLiteralContext!
		open var undoSize: FileSizeLiteralContext!
		open var redoSize: FileSizeLiteralContext!
		open var comment: Token!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func LOGFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOGFILE.rawValue, 0)
			}
			open
			func GROUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func UNDOFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNDOFILE.rawValue, 0)
			}
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func engineName() -> EngineNameContext? {
				return getRuleContext(EngineNameContext.self, 0)
			}
			open
			func STRING_LITERAL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.STRING_LITERAL.rawValue)
			}
			open
			func STRING_LITERAL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, i)
			}
			open
			func INITIAL_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INITIAL_SIZE.rawValue, 0)
			}
			open
			func UNDO_BUFFER_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNDO_BUFFER_SIZE.rawValue, 0)
			}
			open
			func REDO_BUFFER_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REDO_BUFFER_SIZE.rawValue, 0)
			}
			open
			func NODEGROUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NODEGROUP.rawValue, 0)
			}
			open
			func WAIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WAIT.rawValue, 0)
			}
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
			open
			func fileSizeLiteral() -> [FileSizeLiteralContext] {
				return getRuleContexts(FileSizeLiteralContext.self)
			}
			open
			func fileSizeLiteral(_ i: Int) -> FileSizeLiteralContext? {
				return getRuleContext(FileSizeLiteralContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createLogfileGroup
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateLogfileGroup(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateLogfileGroup(self)
			}
		}
	}
	@discardableResult
	 open func createLogfileGroup() throws -> CreateLogfileGroupContext {
		var _localctx: CreateLogfileGroupContext
		_localctx = CreateLogfileGroupContext(_ctx, getState())
		try enterRule(_localctx, 30, MySqlParser.RULE_createLogfileGroup)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(981)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(982)
		 	try match(MySqlParser.Tokens.LOGFILE.rawValue)
		 	setState(983)
		 	try match(MySqlParser.Tokens.GROUP.rawValue)
		 	setState(984)
		 	try uid()
		 	setState(985)
		 	try match(MySqlParser.Tokens.ADD.rawValue)
		 	setState(986)
		 	try match(MySqlParser.Tokens.UNDOFILE.rawValue)
		 	setState(987)
		 	try {
		 			let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 			_localctx.castdown(CreateLogfileGroupContext.self).undoFile = assignmentValue
		 	     }()

		 	setState(993)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.INITIAL_SIZE.rawValue) {
		 		setState(988)
		 		try match(MySqlParser.Tokens.INITIAL_SIZE.rawValue)
		 		setState(990)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(989)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(992)
		 		try {
		 				let assignmentValue = try fileSizeLiteral()
		 				_localctx.castdown(CreateLogfileGroupContext.self).initSize = assignmentValue
		 		     }()


		 	}

		 	setState(1000)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.UNDO_BUFFER_SIZE.rawValue) {
		 		setState(995)
		 		try match(MySqlParser.Tokens.UNDO_BUFFER_SIZE.rawValue)
		 		setState(997)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(996)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(999)
		 		try {
		 				let assignmentValue = try fileSizeLiteral()
		 				_localctx.castdown(CreateLogfileGroupContext.self).undoSize = assignmentValue
		 		     }()


		 	}

		 	setState(1007)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.REDO_BUFFER_SIZE.rawValue) {
		 		setState(1002)
		 		try match(MySqlParser.Tokens.REDO_BUFFER_SIZE.rawValue)
		 		setState(1004)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1003)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1006)
		 		try {
		 				let assignmentValue = try fileSizeLiteral()
		 				_localctx.castdown(CreateLogfileGroupContext.self).redoSize = assignmentValue
		 		     }()


		 	}

		 	setState(1014)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.NODEGROUP.rawValue) {
		 		setState(1009)
		 		try match(MySqlParser.Tokens.NODEGROUP.rawValue)
		 		setState(1011)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1010)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1013)
		 		try uid()

		 	}

		 	setState(1017)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WAIT.rawValue) {
		 		setState(1016)
		 		try match(MySqlParser.Tokens.WAIT.rawValue)

		 	}

		 	setState(1024)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.COMMENT.rawValue) {
		 		setState(1019)
		 		try match(MySqlParser.Tokens.COMMENT.rawValue)
		 		setState(1021)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1020)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1023)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(CreateLogfileGroupContext.self).comment = assignmentValue
		 		     }()


		 	}

		 	setState(1026)
		 	try match(MySqlParser.Tokens.ENGINE.rawValue)
		 	setState(1028)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 		setState(1027)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 	}

		 	setState(1030)
		 	try engineName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateProcedureContext: ParserRuleContext {
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCEDURE.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func routineBody() -> RoutineBodyContext? {
				return getRuleContext(RoutineBodyContext.self, 0)
			}
			open
			func ownerStatement() -> OwnerStatementContext? {
				return getRuleContext(OwnerStatementContext.self, 0)
			}
			open
			func procedureParameter() -> [ProcedureParameterContext] {
				return getRuleContexts(ProcedureParameterContext.self)
			}
			open
			func procedureParameter(_ i: Int) -> ProcedureParameterContext? {
				return getRuleContext(ProcedureParameterContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func routineOption() -> [RoutineOptionContext] {
				return getRuleContexts(RoutineOptionContext.self)
			}
			open
			func routineOption(_ i: Int) -> RoutineOptionContext? {
				return getRuleContext(RoutineOptionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createProcedure
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateProcedure(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateProcedure(self)
			}
		}
	}
	@discardableResult
	 open func createProcedure() throws -> CreateProcedureContext {
		var _localctx: CreateProcedureContext
		_localctx = CreateProcedureContext(_ctx, getState())
		try enterRule(_localctx, 32, MySqlParser.RULE_createProcedure)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1032)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(1034)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.DEFINER.rawValue) {
		 		setState(1033)
		 		try ownerStatement()

		 	}

		 	setState(1036)
		 	try match(MySqlParser.Tokens.PROCEDURE.rawValue)
		 	setState(1037)
		 	try fullId()
		 	setState(1038)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(1040)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 151169654698547409) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 		setState(1039)
		 		try procedureParameter()

		 	}

		 	setState(1046)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(1042)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(1043)
		 		try procedureParameter()


		 		setState(1048)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1049)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(1053)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,49,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1050)
		 			try routineOption()

		 	 
		 		}
		 		setState(1055)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,49,_ctx)
		 	}
		 	setState(1056)
		 	try routineBody()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateFunctionContext: ParserRuleContext {
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FUNCTION.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func RETURNS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RETURNS.rawValue, 0)
			}
			open
			func dataType() -> DataTypeContext? {
				return getRuleContext(DataTypeContext.self, 0)
			}
			open
			func routineBody() -> RoutineBodyContext? {
				return getRuleContext(RoutineBodyContext.self, 0)
			}
			open
			func returnStatement() -> ReturnStatementContext? {
				return getRuleContext(ReturnStatementContext.self, 0)
			}
			open
			func ownerStatement() -> OwnerStatementContext? {
				return getRuleContext(OwnerStatementContext.self, 0)
			}
			open
			func AGGREGATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AGGREGATE.rawValue, 0)
			}
			open
			func ifNotExists() -> IfNotExistsContext? {
				return getRuleContext(IfNotExistsContext.self, 0)
			}
			open
			func functionParameter() -> [FunctionParameterContext] {
				return getRuleContexts(FunctionParameterContext.self)
			}
			open
			func functionParameter(_ i: Int) -> FunctionParameterContext? {
				return getRuleContext(FunctionParameterContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func routineOption() -> [RoutineOptionContext] {
				return getRuleContexts(RoutineOptionContext.self)
			}
			open
			func routineOption(_ i: Int) -> RoutineOptionContext? {
				return getRuleContext(RoutineOptionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createFunction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateFunction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateFunction(self)
			}
		}
	}
	@discardableResult
	 open func createFunction() throws -> CreateFunctionContext {
		var _localctx: CreateFunctionContext
		_localctx = CreateFunctionContext(_ctx, getState())
		try enterRule(_localctx, 34, MySqlParser.RULE_createFunction)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1058)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(1060)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.DEFINER.rawValue) {
		 		setState(1059)
		 		try ownerStatement()

		 	}

		 	setState(1063)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.AGGREGATE.rawValue) {
		 		setState(1062)
		 		try match(MySqlParser.Tokens.AGGREGATE.rawValue)

		 	}

		 	setState(1065)
		 	try match(MySqlParser.Tokens.FUNCTION.rawValue)
		 	setState(1067)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,52,_ctx)) {
		 	case 1:
		 		setState(1066)
		 		try ifNotExists()

		 		break
		 	default: break
		 	}
		 	setState(1069)
		 	try fullId()
		 	setState(1070)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(1072)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 		setState(1071)
		 		try functionParameter()

		 	}

		 	setState(1078)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(1074)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(1075)
		 		try functionParameter()


		 		setState(1080)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1081)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(1082)
		 	try match(MySqlParser.Tokens.RETURNS.rawValue)
		 	setState(1083)
		 	try dataType()
		 	setState(1087)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,55,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1084)
		 			try routineOption()

		 	 
		 		}
		 		setState(1089)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,55,_ctx)
		 	}
		 	setState(1092)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ALTER:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .ARRAY:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .BUCKETS:fallthrough
		 	case .CALL:fallthrough
		 	case .CHANGE:fallthrough
		 	case .CHECK:fallthrough
		 	case .CONDITION:fallthrough
		 	case .CREATE:fallthrough
		 	case .CURRENT:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DELETE:fallthrough
		 	case .DESC:fallthrough
		 	case .DESCRIBE:fallthrough
		 	case .DIAGNOSTICS:fallthrough
		 	case .DROP:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENFORCED:fallthrough
		 	case .EXCEPT:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .GET:fallthrough
		 	case .GRANT:fallthrough
		 	case .GROUP:fallthrough
		 	case .IF:fallthrough
		 	case .IGNORED:fallthrough
		 	case .INSERT:fallthrough
		 	case .KILL:fallthrough
		 	case .LATERAL:fallthrough
		 	case .LEFT:fallthrough
		 	case .LOAD:fallthrough
		 	case .LOCK:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .OPTIONAL:fallthrough
		 	case .ORDER:fallthrough
		 	case .PRIMARY:fallthrough
		 	case .PURGE:fallthrough
		 	case .RELEASE:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPEAT:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESIGNAL:fallthrough
		 	case .REVOKE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SELECT:fallthrough
		 	case .SET:fallthrough
		 	case .SHOW:fallthrough
		 	case .SIGNAL:fallthrough
		 	case .SKIP_QUERY_REWRITE:fallthrough
		 	case .STACKED:fallthrough
		 	case .TABLE:fallthrough
		 	case .UNLOCK:fallthrough
		 	case .UPDATE:fallthrough
		 	case .USE:fallthrough
		 	case .VALUES:fallthrough
		 	case .WITH:fallthrough
		 	case .DATE:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .DATETIME:fallthrough
		 	case .YEAR:fallthrough
		 	case .BINARY:fallthrough
		 	case .TEXT:fallthrough
		 	case .ENUM:fallthrough
		 	case .SERIAL:fallthrough
		 	case .JSON_ARRAY:fallthrough
		 	case .JSON_ARRAYAGG:fallthrough
		 	case .JSON_ARRAY_APPEND:fallthrough
		 	case .JSON_ARRAY_INSERT:fallthrough
		 	case .JSON_CONTAINS:fallthrough
		 	case .JSON_CONTAINS_PATH:fallthrough
		 	case .JSON_DEPTH:fallthrough
		 	case .JSON_EXTRACT:fallthrough
		 	case .JSON_INSERT:fallthrough
		 	case .JSON_KEYS:fallthrough
		 	case .JSON_LENGTH:fallthrough
		 	case .JSON_MERGE:fallthrough
		 	case .JSON_MERGE_PATCH:fallthrough
		 	case .JSON_MERGE_PRESERVE:fallthrough
		 	case .JSON_OBJECT:fallthrough
		 	case .JSON_OBJECTAGG:fallthrough
		 	case .JSON_OVERLAPS:fallthrough
		 	case .JSON_PRETTY:fallthrough
		 	case .JSON_QUOTE:fallthrough
		 	case .JSON_REMOVE:fallthrough
		 	case .JSON_REPLACE:fallthrough
		 	case .JSON_SCHEMA_VALID:fallthrough
		 	case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 	case .JSON_SEARCH:fallthrough
		 	case .JSON_SET:fallthrough
		 	case .JSON_STORAGE_FREE:fallthrough
		 	case .JSON_STORAGE_SIZE:fallthrough
		 	case .JSON_TABLE:fallthrough
		 	case .JSON_TYPE:fallthrough
		 	case .JSON_UNQUOTE:fallthrough
		 	case .JSON_VALID:fallthrough
		 	case .JSON_VALUE:fallthrough
		 	case .NESTED:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .PATH:fallthrough
		 	case .AVG:fallthrough
		 	case .BIT_AND:fallthrough
		 	case .BIT_OR:fallthrough
		 	case .BIT_XOR:fallthrough
		 	case .COUNT:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .GROUP_CONCAT:fallthrough
		 	case .LAG:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NTH_VALUE:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .STD:fallthrough
		 	case .STDDEV:fallthrough
		 	case .STDDEV_POP:fallthrough
		 	case .STDDEV_SAMP:fallthrough
		 	case .SUM:fallthrough
		 	case .VAR_POP:fallthrough
		 	case .VAR_SAMP:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .CURRENT_DATE:fallthrough
		 	case .CURRENT_TIME:fallthrough
		 	case .CURRENT_TIMESTAMP:fallthrough
		 	case .LOCALTIME:fallthrough
		 	case .CURDATE:fallthrough
		 	case .CURTIME:fallthrough
		 	case .DATE_ADD:fallthrough
		 	case .DATE_SUB:fallthrough
		 	case .LOCALTIMESTAMP:fallthrough
		 	case .NOW:fallthrough
		 	case .POSITION:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .SUBSTRING:fallthrough
		 	case .SYSDATE:fallthrough
		 	case .TRIM:fallthrough
		 	case .UTC_DATE:fallthrough
		 	case .UTC_TIME:fallthrough
		 	case .UTC_TIMESTAMP:fallthrough
		 	case .ACCOUNT:fallthrough
		 	case .ACTION:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALGORITHM:fallthrough
		 	case .ANY:fallthrough
		 	case .AT:fallthrough
		 	case .AUTHORS:fallthrough
		 	case .AUTOCOMMIT:fallthrough
		 	case .AUTOEXTEND_SIZE:fallthrough
		 	case .AUTO_INCREMENT:fallthrough
		 	case .AVG_ROW_LENGTH:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BINLOG:fallthrough
		 	case .BIT:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BOOL:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BTREE:fallthrough
		 	case .CACHE:fallthrough
		 	case .CASCADED:fallthrough
		 	case .CHAIN:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CHECKSUM:fallthrough
		 	case .PAGE_CHECKSUM:fallthrough
		 	case .CIPHER:fallthrough
		 	case .CLASS_ORIGIN:fallthrough
		 	case .CLIENT:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTERING:fallthrough
		 	case .COALESCE:fallthrough
		 	case .CODE:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COLUMN_FORMAT:fallthrough
		 	case .COLUMN_NAME:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMPACT:fallthrough
		 	case .COMPLETION:fallthrough
		 	case .COMPRESSED:fallthrough
		 	case .COMPRESSION:fallthrough
		 	case .CONCURRENT:fallthrough
		 	case .CONNECT:fallthrough
		 	case .CONNECTION:fallthrough
		 	case .CONSISTENT:fallthrough
		 	case .CONSTRAINT_CATALOG:fallthrough
		 	case .CONSTRAINT_SCHEMA:fallthrough
		 	case .CONSTRAINT_NAME:fallthrough
		 	case .CONTAINS:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTRIBUTORS:fallthrough
		 	case .COPY:fallthrough
		 	case .CPU:fallthrough
		 	case .CURSOR_NAME:fallthrough
		 	case .DATA:fallthrough
		 	case .DATAFILE:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DEFAULT_AUTH:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DELAY_KEY_WRITE:fallthrough
		 	case .DES_KEY_FILE:fallthrough
		 	case .DIRECTORY:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISCARD:fallthrough
		 	case .DISK:fallthrough
		 	case .DO:fallthrough
		 	case .DUMPFILE:fallthrough
		 	case .DUPLICATE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .END:fallthrough
		 	case .ENDS:fallthrough
		 	case .ENGINE:fallthrough
		 	case .ENGINES:fallthrough
		 	case .ERROR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVEN:fallthrough
		 	case .EVENT:fallthrough
		 	case .EVENTS:fallthrough
		 	case .EVERY:fallthrough
		 	case .EXCHANGE:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPIRE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .EXTENT_SIZE:fallthrough
		 	case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 	case .FAST:fallthrough
		 	case .FAULTS:fallthrough
		 	case .FIELDS:fallthrough
		 	case .FILE_BLOCK_SIZE:fallthrough
		 	case .FILTER:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIXED:fallthrough
		 	case .FLUSH:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FOUND:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GENERAL:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GRANTS:fallthrough
		 	case .GROUP_REPLICATION:fallthrough
		 	case .HANDLER:fallthrough
		 	case .HASH:fallthrough
		 	case .HELP:fallthrough
		 	case .HISTORY:fallthrough
		 	case .HOST:fallthrough
		 	case .HOSTS:fallthrough
		 	case .IDENTIFIED:fallthrough
		 	case .IGNORE_SERVER_IDS:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INDEXES:fallthrough
		 	case .INITIAL_SIZE:fallthrough
		 	case .INPLACE:fallthrough
		 	case .INSERT_METHOD:fallthrough
		 	case .INSTALL:fallthrough
		 	case .INSTANCE:fallthrough
		 	case .INSTANT:fallthrough
		 	case .INVISIBLE:fallthrough
		 	case .INVOKER:fallthrough
		 	case .IO:fallthrough
		 	case .IO_THREAD:fallthrough
		 	case .IPC:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ISSUER:fallthrough
		 	case .JSON:fallthrough
		 	case .KEY_BLOCK_SIZE:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LEAVES:fallthrough
		 	case .LESS:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOGFILE:fallthrough
		 	case .LOGS:fallthrough
		 	case .MASTER:fallthrough
		 	case .MASTER_AUTO_POSITION:fallthrough
		 	case .MASTER_CONNECT_RETRY:fallthrough
		 	case .MASTER_DELAY:fallthrough
		 	case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 	case .MASTER_HOST:fallthrough
		 	case .MASTER_LOG_FILE:fallthrough
		 	case .MASTER_LOG_POS:fallthrough
		 	case .MASTER_PASSWORD:fallthrough
		 	case .MASTER_PORT:fallthrough
		 	case .MASTER_RETRY_COUNT:fallthrough
		 	case .MASTER_SSL:fallthrough
		 	case .MASTER_SSL_CA:fallthrough
		 	case .MASTER_SSL_CAPATH:fallthrough
		 	case .MASTER_SSL_CERT:fallthrough
		 	case .MASTER_SSL_CIPHER:fallthrough
		 	case .MASTER_SSL_CRL:fallthrough
		 	case .MASTER_SSL_CRLPATH:fallthrough
		 	case .MASTER_SSL_KEY:fallthrough
		 	case .MASTER_TLS_VERSION:fallthrough
		 	case .MASTER_USER:fallthrough
		 	case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 	case .MAX_QUERIES_PER_HOUR:fallthrough
		 	case .MAX_ROWS:fallthrough
		 	case .MAX_SIZE:fallthrough
		 	case .MAX_UPDATES_PER_HOUR:fallthrough
		 	case .MAX_USER_CONNECTIONS:fallthrough
		 	case .MEDIUM:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MESSAGE_TEXT:fallthrough
		 	case .MID:fallthrough
		 	case .MIGRATE:fallthrough
		 	case .MIN_ROWS:fallthrough
		 	case .MODE:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MUTEX:fallthrough
		 	case .MYSQL:fallthrough
		 	case .MYSQL_ERRNO:fallthrough
		 	case .NAME:fallthrough
		 	case .NAMES:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NEVER:fallthrough
		 	case .NEXT:fallthrough
		 	case .NO:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOWAIT:fallthrough
		 	case .NODEGROUP:fallthrough
		 	case .NONE:fallthrough
		 	case .ODBC:fallthrough
		 	case .OFFLINE:fallthrough
		 	case .OFFSET:fallthrough
		 	case .OF:fallthrough
		 	case .OJ:fallthrough
		 	case .OLD_PASSWORD:fallthrough
		 	case .ONE:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .OPTIMIZER_COSTS:fallthrough
		 	case .OPTIONS:fallthrough
		 	case .OWNER:fallthrough
		 	case .PACK_KEYS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PARSER:fallthrough
		 	case .PARTIAL:fallthrough
		 	case .PARTITIONING:fallthrough
		 	case .PARTITIONS:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PASSWORD_LOCK_TIME:fallthrough
		 	case .PHASE:fallthrough
		 	case .PLUGIN:fallthrough
		 	case .PLUGIN_DIR:fallthrough
		 	case .PLUGINS:fallthrough
		 	case .PORT:fallthrough
		 	case .PRECEDES:fallthrough
		 	case .PREPARE:fallthrough
		 	case .PRESERVE:fallthrough
		 	case .PREV:fallthrough
		 	case .PROCESSLIST:fallthrough
		 	case .PROFILE:fallthrough
		 	case .PROFILES:fallthrough
		 	case .PROXY:fallthrough
		 	case .QUERY:fallthrough
		 	case .QUICK:fallthrough
		 	case .REBUILD:fallthrough
		 	case .RECOVER:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REDO_BUFFER_SIZE:fallthrough
		 	case .REDUNDANT:fallthrough
		 	case .RELAY:fallthrough
		 	case .RELAY_LOG_FILE:fallthrough
		 	case .RELAY_LOG_POS:fallthrough
		 	case .RELAYLOG:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REORGANIZE:fallthrough
		 	case .REPAIR:fallthrough
		 	case .REPLICATE_DO_DB:fallthrough
		 	case .REPLICATE_DO_TABLE:fallthrough
		 	case .REPLICATE_IGNORE_DB:fallthrough
		 	case .REPLICATE_IGNORE_TABLE:fallthrough
		 	case .REPLICATE_REWRITE_DB:fallthrough
		 	case .REPLICATE_WILD_DO_TABLE:fallthrough
		 	case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 	case .REPLICATION:fallthrough
		 	case .RESET:fallthrough
		 	case .RESUME:fallthrough
		 	case .RETURNED_SQLSTATE:fallthrough
		 	case .RETURNING:fallthrough
		 	case .RETURNS:fallthrough
		 	case .REUSE:fallthrough
		 	case .ROLE:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROTATE:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_FORMAT:fallthrough
		 	case .RTREE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEDULE:fallthrough
		 	case .SECURITY:fallthrough
		 	case .SERVER:fallthrough
		 	case .SESSION:fallthrough
		 	case .SHARE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SIGNED:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SLAVE:fallthrough
		 	case .SLOW:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOCKET:fallthrough
		 	case .SOME:fallthrough
		 	case .SONAME:fallthrough
		 	case .SOUNDS:fallthrough
		 	case .SOURCE:fallthrough
		 	case .SQL_AFTER_GTIDS:fallthrough
		 	case .SQL_AFTER_MTS_GAPS:fallthrough
		 	case .SQL_BEFORE_GTIDS:fallthrough
		 	case .SQL_BUFFER_RESULT:fallthrough
		 	case .SQL_CACHE:fallthrough
		 	case .SQL_NO_CACHE:fallthrough
		 	case .SQL_THREAD:fallthrough
		 	case .START:fallthrough
		 	case .STARTS:fallthrough
		 	case .STATS_AUTO_RECALC:fallthrough
		 	case .STATS_PERSISTENT:fallthrough
		 	case .STATS_SAMPLE_PAGES:fallthrough
		 	case .STATUS:fallthrough
		 	case .STOP:fallthrough
		 	case .STORAGE:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBCLASS_ORIGIN:fallthrough
		 	case .SUBJECT:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBPARTITIONS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .SWAPS:fallthrough
		 	case .SWITCHES:fallthrough
		 	case .TABLE_NAME:fallthrough
		 	case .TABLESPACE:fallthrough
		 	case .TABLE_TYPE:fallthrough
		 	case .TEMPORARY:fallthrough
		 	case .TEMPTABLE:fallthrough
		 	case .THAN:fallthrough
		 	case .TRADITIONAL:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSACTIONAL:fallthrough
		 	case .TRIGGERS:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDEFINED:fallthrough
		 	case .UNDOFILE:fallthrough
		 	case .UNDO_BUFFER_SIZE:fallthrough
		 	case .UNINSTALL:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPGRADE:fallthrough
		 	case .USER:fallthrough
		 	case .USE_FRM:fallthrough
		 	case .USER_RESOURCES:fallthrough
		 	case .VALIDATION:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARIABLES:fallthrough
		 	case .VIEW:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .VISIBLE:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNINGS:fallthrough
		 	case .WITHOUT:fallthrough
		 	case .WORK:fallthrough
		 	case .WRAPPER:fallthrough
		 	case .X509:fallthrough
		 	case .XA:fallthrough
		 	case .XML:fallthrough
		 	case .EUR:fallthrough
		 	case .USA:fallthrough
		 	case .JIS:fallthrough
		 	case .ISO:fallthrough
		 	case .INTERNAL:fallthrough
		 	case .QUARTER:fallthrough
		 	case .MONTH:fallthrough
		 	case .DAY:fallthrough
		 	case .HOUR:fallthrough
		 	case .MINUTE:fallthrough
		 	case .WEEK:fallthrough
		 	case .SECOND:fallthrough
		 	case .MICROSECOND:fallthrough
		 	case .ADMIN:fallthrough
		 	case .AUDIT_ABORT_EXEMPT:fallthrough
		 	case .AUDIT_ADMIN:fallthrough
		 	case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 	case .BACKUP_ADMIN:fallthrough
		 	case .BINLOG_ADMIN:fallthrough
		 	case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 	case .CLONE_ADMIN:fallthrough
		 	case .CONNECTION_ADMIN:fallthrough
		 	case .ENCRYPTION_KEY_ADMIN:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .FILE:fallthrough
		 	case .FIREWALL_ADMIN:fallthrough
		 	case .FIREWALL_EXEMPT:fallthrough
		 	case .FIREWALL_USER:fallthrough
		 	case .GROUP_REPLICATION_ADMIN:fallthrough
		 	case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 	case .INVOKE:fallthrough
		 	case .LAMBDA:fallthrough
		 	case .NDB_STORED_USER:fallthrough
		 	case .PASSWORDLESS_USER_ADMIN:fallthrough
		 	case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .PROCESS:fallthrough
		 	case .RELOAD:fallthrough
		 	case .REPLICATION_APPLIER:fallthrough
		 	case .REPLICATION_SLAVE_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_USER:fallthrough
		 	case .ROLE_ADMIN:fallthrough
		 	case .ROUTINE:fallthrough
		 	case .S3:fallthrough
		 	case .SESSION_VARIABLES_ADMIN:fallthrough
		 	case .SET_USER_ID:fallthrough
		 	case .SHOW_ROUTINE:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SUPER:fallthrough
		 	case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 	case .TABLES:fallthrough
		 	case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 	case .VERSION_TOKEN_ADMIN:fallthrough
		 	case .XA_RECOVER_ADMIN:fallthrough
		 	case .ARMSCII8:fallthrough
		 	case .ASCII:fallthrough
		 	case .BIG5:fallthrough
		 	case .CP1250:fallthrough
		 	case .CP1251:fallthrough
		 	case .CP1256:fallthrough
		 	case .CP1257:fallthrough
		 	case .CP850:fallthrough
		 	case .CP852:fallthrough
		 	case .CP866:fallthrough
		 	case .CP932:fallthrough
		 	case .DEC8:fallthrough
		 	case .EUCJPMS:fallthrough
		 	case .EUCKR:fallthrough
		 	case .GB18030:fallthrough
		 	case .GB2312:fallthrough
		 	case .GBK:fallthrough
		 	case .GEOSTD8:fallthrough
		 	case .GREEK:fallthrough
		 	case .HEBREW:fallthrough
		 	case .HP8:fallthrough
		 	case .KEYBCS2:fallthrough
		 	case .KOI8R:fallthrough
		 	case .KOI8U:fallthrough
		 	case .LATIN1:fallthrough
		 	case .LATIN2:fallthrough
		 	case .LATIN5:fallthrough
		 	case .LATIN7:fallthrough
		 	case .MACCE:fallthrough
		 	case .MACROMAN:fallthrough
		 	case .SJIS:fallthrough
		 	case .SWE7:fallthrough
		 	case .TIS620:fallthrough
		 	case .UCS2:fallthrough
		 	case .UJIS:fallthrough
		 	case .UTF16:fallthrough
		 	case .UTF16LE:fallthrough
		 	case .UTF32:fallthrough
		 	case .UTF8:fallthrough
		 	case .UTF8MB3:fallthrough
		 	case .UTF8MB4:fallthrough
		 	case .ARCHIVE:fallthrough
		 	case .BLACKHOLE:fallthrough
		 	case .CSV:fallthrough
		 	case .FEDERATED:fallthrough
		 	case .INNODB:fallthrough
		 	case .MEMORY:fallthrough
		 	case .MRG_MYISAM:fallthrough
		 	case .MYISAM:fallthrough
		 	case .NDB:fallthrough
		 	case .NDBCLUSTER:fallthrough
		 	case .PERFORMANCE_SCHEMA:fallthrough
		 	case .TOKUDB:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .GEOMETRYCOLLECTION:fallthrough
		 	case .LINESTRING:fallthrough
		 	case .MULTILINESTRING:fallthrough
		 	case .MULTIPOINT:fallthrough
		 	case .MULTIPOLYGON:fallthrough
		 	case .POINT:fallthrough
		 	case .POLYGON:fallthrough
		 	case .ABS:fallthrough
		 	case .ACOS:fallthrough
		 	case .ADDDATE:fallthrough
		 	case .ADDTIME:fallthrough
		 	case .AES_DECRYPT:fallthrough
		 	case .AES_ENCRYPT:fallthrough
		 	case .AREA:fallthrough
		 	case .ASBINARY:fallthrough
		 	case .ASIN:fallthrough
		 	case .ASTEXT:fallthrough
		 	case .ASWKB:fallthrough
		 	case .ASWKT:fallthrough
		 	case .ASYMMETRIC_DECRYPT:fallthrough
		 	case .ASYMMETRIC_DERIVE:fallthrough
		 	case .ASYMMETRIC_ENCRYPT:fallthrough
		 	case .ASYMMETRIC_SIGN:fallthrough
		 	case .ASYMMETRIC_VERIFY:fallthrough
		 	case .ATAN:fallthrough
		 	case .ATAN2:fallthrough
		 	case .BENCHMARK:fallthrough
		 	case .BIN:fallthrough
		 	case .BIT_COUNT:fallthrough
		 	case .BIT_LENGTH:fallthrough
		 	case .BUFFER:fallthrough
		 	case .CATALOG_NAME:fallthrough
		 	case .CEIL:fallthrough
		 	case .CEILING:fallthrough
		 	case .CENTROID:fallthrough
		 	case .CHARACTER_LENGTH:fallthrough
		 	case .CHARSET:fallthrough
		 	case .CHAR_LENGTH:fallthrough
		 	case .COERCIBILITY:fallthrough
		 	case .COLLATION:fallthrough
		 	case .COMPRESS:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_WS:fallthrough
		 	case .CONNECTION_ID:fallthrough
		 	case .CONV:fallthrough
		 	case .CONVERT_TZ:fallthrough
		 	case .COS:fallthrough
		 	case .COT:fallthrough
		 	case .CRC32:fallthrough
		 	case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 	case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 	case .CREATE_DH_PARAMETERS:fallthrough
		 	case .CREATE_DIGEST:fallthrough
		 	case .CROSSES:fallthrough
		 	case .DATEDIFF:fallthrough
		 	case .DATE_FORMAT:fallthrough
		 	case .DAYNAME:fallthrough
		 	case .DAYOFMONTH:fallthrough
		 	case .DAYOFWEEK:fallthrough
		 	case .DAYOFYEAR:fallthrough
		 	case .DECODE:fallthrough
		 	case .DEGREES:fallthrough
		 	case .DES_DECRYPT:fallthrough
		 	case .DES_ENCRYPT:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISJOINT:fallthrough
		 	case .ELT:fallthrough
		 	case .ENCODE:fallthrough
		 	case .ENCRYPT:fallthrough
		 	case .ENDPOINT:fallthrough
		 	case .ENGINE_ATTRIBUTE:fallthrough
		 	case .ENVELOPE:fallthrough
		 	case .EQUALS:fallthrough
		 	case .EXP:fallthrough
		 	case .EXPORT_SET:fallthrough
		 	case .EXTERIORRING:fallthrough
		 	case .EXTRACTVALUE:fallthrough
		 	case .FIELD:fallthrough
		 	case .FIND_IN_SET:fallthrough
		 	case .FLOOR:fallthrough
		 	case .FORMAT:fallthrough
		 	case .FOUND_ROWS:fallthrough
		 	case .FROM_BASE64:fallthrough
		 	case .FROM_DAYS:fallthrough
		 	case .FROM_UNIXTIME:fallthrough
		 	case .GEOMCOLLFROMTEXT:fallthrough
		 	case .GEOMCOLLFROMWKB:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .GEOMETRYFROMTEXT:fallthrough
		 	case .GEOMETRYFROMWKB:fallthrough
		 	case .GEOMETRYN:fallthrough
		 	case .GEOMETRYTYPE:fallthrough
		 	case .GEOMFROMTEXT:fallthrough
		 	case .GEOMFROMWKB:fallthrough
		 	case .GET_FORMAT:fallthrough
		 	case .GET_LOCK:fallthrough
		 	case .GLENGTH:fallthrough
		 	case .GREATEST:fallthrough
		 	case .GTID_SUBSET:fallthrough
		 	case .GTID_SUBTRACT:fallthrough
		 	case .HEX:fallthrough
		 	case .IFNULL:fallthrough
		 	case .INET6_ATON:fallthrough
		 	case .INET6_NTOA:fallthrough
		 	case .INET_ATON:fallthrough
		 	case .INET_NTOA:fallthrough
		 	case .INSTR:fallthrough
		 	case .INTERIORRINGN:fallthrough
		 	case .INTERSECTS:fallthrough
		 	case .ISCLOSED:fallthrough
		 	case .ISEMPTY:fallthrough
		 	case .ISNULL:fallthrough
		 	case .ISSIMPLE:fallthrough
		 	case .IS_FREE_LOCK:fallthrough
		 	case .IS_IPV4:fallthrough
		 	case .IS_IPV4_COMPAT:fallthrough
		 	case .IS_IPV4_MAPPED:fallthrough
		 	case .IS_IPV6:fallthrough
		 	case .IS_USED_LOCK:fallthrough
		 	case .LAST_INSERT_ID:fallthrough
		 	case .LCASE:fallthrough
		 	case .LEAST:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LINEFROMTEXT:fallthrough
		 	case .LINEFROMWKB:fallthrough
		 	case .LINESTRINGFROMTEXT:fallthrough
		 	case .LINESTRINGFROMWKB:fallthrough
		 	case .LN:fallthrough
		 	case .LOAD_FILE:fallthrough
		 	case .LOCATE:fallthrough
		 	case .LOG:fallthrough
		 	case .LOG10:fallthrough
		 	case .LOG2:fallthrough
		 	case .LOWER:fallthrough
		 	case .LPAD:fallthrough
		 	case .LTRIM:fallthrough
		 	case .MAKEDATE:fallthrough
		 	case .MAKETIME:fallthrough
		 	case .MAKE_SET:fallthrough
		 	case .MASTER_POS_WAIT:fallthrough
		 	case .MBRCONTAINS:fallthrough
		 	case .MBRDISJOINT:fallthrough
		 	case .MBREQUAL:fallthrough
		 	case .MBRINTERSECTS:fallthrough
		 	case .MBROVERLAPS:fallthrough
		 	case .MBRTOUCHES:fallthrough
		 	case .MBRWITHIN:fallthrough
		 	case .MD5:fallthrough
		 	case .MLINEFROMTEXT:fallthrough
		 	case .MLINEFROMWKB:fallthrough
		 	case .MONTHNAME:fallthrough
		 	case .MPOINTFROMTEXT:fallthrough
		 	case .MPOINTFROMWKB:fallthrough
		 	case .MPOLYFROMTEXT:fallthrough
		 	case .MPOLYFROMWKB:fallthrough
		 	case .MULTILINESTRINGFROMTEXT:fallthrough
		 	case .MULTILINESTRINGFROMWKB:fallthrough
		 	case .MULTIPOINTFROMTEXT:fallthrough
		 	case .MULTIPOINTFROMWKB:fallthrough
		 	case .MULTIPOLYGONFROMTEXT:fallthrough
		 	case .MULTIPOLYGONFROMWKB:fallthrough
		 	case .NAME_CONST:fallthrough
		 	case .NULLIF:fallthrough
		 	case .NUMGEOMETRIES:fallthrough
		 	case .NUMINTERIORRINGS:fallthrough
		 	case .NUMPOINTS:fallthrough
		 	case .OCT:fallthrough
		 	case .OCTET_LENGTH:fallthrough
		 	case .ORD:fallthrough
		 	case .OVERLAPS:fallthrough
		 	case .PERIOD_ADD:fallthrough
		 	case .PERIOD_DIFF:fallthrough
		 	case .PI:fallthrough
		 	case .POINTFROMTEXT:fallthrough
		 	case .POINTFROMWKB:fallthrough
		 	case .POINTN:fallthrough
		 	case .POLYFROMTEXT:fallthrough
		 	case .POLYFROMWKB:fallthrough
		 	case .POLYGONFROMTEXT:fallthrough
		 	case .POLYGONFROMWKB:fallthrough
		 	case .POW:fallthrough
		 	case .POWER:fallthrough
		 	case .QUOTE:fallthrough
		 	case .RADIANS:fallthrough
		 	case .RAND:fallthrough
		 	case .RANDOM:fallthrough
		 	case .RANDOM_BYTES:fallthrough
		 	case .RELEASE_LOCK:fallthrough
		 	case .REVERSE:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_COUNT:fallthrough
		 	case .RPAD:fallthrough
		 	case .RTRIM:fallthrough
		 	case .SEC_TO_TIME:fallthrough
		 	case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 	case .SESSION_USER:fallthrough
		 	case .SHA:fallthrough
		 	case .SHA1:fallthrough
		 	case .SHA2:fallthrough
		 	case .SCHEMA_NAME:fallthrough
		 	case .SIGN:fallthrough
		 	case .SIN:fallthrough
		 	case .SLEEP:fallthrough
		 	case .SOUNDEX:fallthrough
		 	case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 	case .SQRT:fallthrough
		 	case .SRID:fallthrough
		 	case .STARTPOINT:fallthrough
		 	case .STRCMP:fallthrough
		 	case .STR_TO_DATE:fallthrough
		 	case .ST_AREA:fallthrough
		 	case .ST_ASBINARY:fallthrough
		 	case .ST_ASTEXT:fallthrough
		 	case .ST_ASWKB:fallthrough
		 	case .ST_ASWKT:fallthrough
		 	case .ST_BUFFER:fallthrough
		 	case .ST_CENTROID:fallthrough
		 	case .ST_CONTAINS:fallthrough
		 	case .ST_CROSSES:fallthrough
		 	case .ST_DIFFERENCE:fallthrough
		 	case .ST_DIMENSION:fallthrough
		 	case .ST_DISJOINT:fallthrough
		 	case .ST_DISTANCE:fallthrough
		 	case .ST_ENDPOINT:fallthrough
		 	case .ST_ENVELOPE:fallthrough
		 	case .ST_EQUALS:fallthrough
		 	case .ST_EXTERIORRING:fallthrough
		 	case .ST_GEOMCOLLFROMTEXT:fallthrough
		 	case .ST_GEOMCOLLFROMTXT:fallthrough
		 	case .ST_GEOMCOLLFROMWKB:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .ST_GEOMETRYFROMTEXT:fallthrough
		 	case .ST_GEOMETRYFROMWKB:fallthrough
		 	case .ST_GEOMETRYN:fallthrough
		 	case .ST_GEOMETRYTYPE:fallthrough
		 	case .ST_GEOMFROMTEXT:fallthrough
		 	case .ST_GEOMFROMWKB:fallthrough
		 	case .ST_INTERIORRINGN:fallthrough
		 	case .ST_INTERSECTION:fallthrough
		 	case .ST_INTERSECTS:fallthrough
		 	case .ST_ISCLOSED:fallthrough
		 	case .ST_ISEMPTY:fallthrough
		 	case .ST_ISSIMPLE:fallthrough
		 	case .ST_LINEFROMTEXT:fallthrough
		 	case .ST_LINEFROMWKB:fallthrough
		 	case .ST_LINESTRINGFROMTEXT:fallthrough
		 	case .ST_LINESTRINGFROMWKB:fallthrough
		 	case .ST_NUMGEOMETRIES:fallthrough
		 	case .ST_NUMINTERIORRING:fallthrough
		 	case .ST_NUMINTERIORRINGS:fallthrough
		 	case .ST_NUMPOINTS:fallthrough
		 	case .ST_OVERLAPS:fallthrough
		 	case .ST_POINTFROMTEXT:fallthrough
		 	case .ST_POINTFROMWKB:fallthrough
		 	case .ST_POINTN:fallthrough
		 	case .ST_POLYFROMTEXT:fallthrough
		 	case .ST_POLYFROMWKB:fallthrough
		 	case .ST_POLYGONFROMTEXT:fallthrough
		 	case .ST_POLYGONFROMWKB:fallthrough
		 	case .ST_SRID:fallthrough
		 	case .ST_STARTPOINT:fallthrough
		 	case .ST_SYMDIFFERENCE:fallthrough
		 	case .ST_TOUCHES:fallthrough
		 	case .ST_UNION:fallthrough
		 	case .ST_WITHIN:fallthrough
		 	case .ST_X:fallthrough
		 	case .ST_Y:fallthrough
		 	case .SUBDATE:fallthrough
		 	case .SUBSTRING_INDEX:fallthrough
		 	case .SUBTIME:fallthrough
		 	case .SYSTEM_USER:fallthrough
		 	case .TAN:fallthrough
		 	case .TIMEDIFF:fallthrough
		 	case .TIMESTAMPADD:fallthrough
		 	case .TIMESTAMPDIFF:fallthrough
		 	case .TIME_FORMAT:fallthrough
		 	case .TIME_TO_SEC:fallthrough
		 	case .TOUCHES:fallthrough
		 	case .TO_BASE64:fallthrough
		 	case .TO_DAYS:fallthrough
		 	case .TO_SECONDS:fallthrough
		 	case .TP_CONNECTION_ADMIN:fallthrough
		 	case .UCASE:fallthrough
		 	case .UNCOMPRESS:fallthrough
		 	case .UNCOMPRESSED_LENGTH:fallthrough
		 	case .UNHEX:fallthrough
		 	case .UNIX_TIMESTAMP:fallthrough
		 	case .UPDATEXML:fallthrough
		 	case .UPPER:fallthrough
		 	case .UUID:fallthrough
		 	case .UUID_SHORT:fallthrough
		 	case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 	case .VERSION:fallthrough
		 	case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 	case .WEEKDAY:fallthrough
		 	case .WEEKOFYEAR:fallthrough
		 	case .WEIGHT_STRING:fallthrough
		 	case .WITHIN:fallthrough
		 	case .YEARWEEK:fallthrough
		 	case .Y_FUNCTION:fallthrough
		 	case .X_FUNCTION:fallthrough
		 	case .MOD:fallthrough
		 	case .LR_BRACKET:fallthrough
		 	case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 	case .STRING_LITERAL:fallthrough
		 	case .ID:
		 		setState(1090)
		 		try routineBody()

		 		break

		 	case .RETURN:
		 		setState(1091)
		 		try returnStatement()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateRoleContext: ParserRuleContext {
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func ROLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLE.rawValue, 0)
			}
			open
			func roleName() -> [RoleNameContext] {
				return getRuleContexts(RoleNameContext.self)
			}
			open
			func roleName(_ i: Int) -> RoleNameContext? {
				return getRuleContext(RoleNameContext.self, i)
			}
			open
			func ifNotExists() -> IfNotExistsContext? {
				return getRuleContext(IfNotExistsContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createRole
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateRole(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateRole(self)
			}
		}
	}
	@discardableResult
	 open func createRole() throws -> CreateRoleContext {
		var _localctx: CreateRoleContext
		_localctx = CreateRoleContext(_ctx, getState())
		try enterRule(_localctx, 36, MySqlParser.RULE_createRole)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1094)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(1095)
		 	try match(MySqlParser.Tokens.ROLE.rawValue)
		 	setState(1097)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,57,_ctx)) {
		 	case 1:
		 		setState(1096)
		 		try ifNotExists()

		 		break
		 	default: break
		 	}
		 	setState(1099)
		 	try roleName()
		 	setState(1104)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(1100)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(1101)
		 		try roleName()


		 		setState(1106)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateServerContext: ParserRuleContext {
		open var wrapperName: Token!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func SERVER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SERVER.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func FOREIGN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOREIGN.rawValue, 0)
			}
			open
			func DATA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATA.rawValue, 0)
			}
			open
			func WRAPPER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WRAPPER.rawValue, 0)
			}
			open
			func OPTIONS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTIONS.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func serverOption() -> [ServerOptionContext] {
				return getRuleContexts(ServerOptionContext.self)
			}
			open
			func serverOption(_ i: Int) -> ServerOptionContext? {
				return getRuleContext(ServerOptionContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func MYSQL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MYSQL.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createServer
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateServer(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateServer(self)
			}
		}
	}
	@discardableResult
	 open func createServer() throws -> CreateServerContext {
		var _localctx: CreateServerContext
		_localctx = CreateServerContext(_ctx, getState())
		try enterRule(_localctx, 38, MySqlParser.RULE_createServer)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1107)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(1108)
		 	try match(MySqlParser.Tokens.SERVER.rawValue)
		 	setState(1109)
		 	try uid()
		 	setState(1110)
		 	try match(MySqlParser.Tokens.FOREIGN.rawValue)
		 	setState(1111)
		 	try match(MySqlParser.Tokens.DATA.rawValue)
		 	setState(1112)
		 	try match(MySqlParser.Tokens.WRAPPER.rawValue)
		 	setState(1113)
		 	_localctx.castdown(CreateServerContext.self).wrapperName = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.MYSQL.rawValue || _la == MySqlParser.Tokens.STRING_LITERAL.rawValue)) {
		 		_localctx.castdown(CreateServerContext.self).wrapperName = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1114)
		 	try match(MySqlParser.Tokens.OPTIONS.rawValue)
		 	setState(1115)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(1116)
		 	try serverOption()
		 	setState(1121)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(1117)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(1118)
		 		try serverOption()


		 		setState(1123)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1124)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateTableContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createTable
		}
	}
	public class CopyCreateTableContext: CreateTableContext {
		public var parenthesisTable: TableNameContext!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tableName() -> [TableNameContext] {
				return getRuleContexts(TableNameContext.self)
			}
			open
			func tableName(_ i: Int) -> TableNameContext? {
				return getRuleContext(TableNameContext.self, i)
			}
			open
			func LIKE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIKE.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func TEMPORARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TEMPORARY.rawValue, 0)
			}
			open
			func ifNotExists() -> IfNotExistsContext? {
				return getRuleContext(IfNotExistsContext.self, 0)
			}

		public
		init(_ ctx: CreateTableContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCopyCreateTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCopyCreateTable(self)
			}
		}
	}
	public class ColumnCreateTableContext: CreateTableContext {
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func createDefinitions() -> CreateDefinitionsContext? {
				return getRuleContext(CreateDefinitionsContext.self, 0)
			}
			open
			func TEMPORARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TEMPORARY.rawValue, 0)
			}
			open
			func ifNotExists() -> IfNotExistsContext? {
				return getRuleContext(IfNotExistsContext.self, 0)
			}
			open
			func tableOption() -> [TableOptionContext] {
				return getRuleContexts(TableOptionContext.self)
			}
			open
			func tableOption(_ i: Int) -> TableOptionContext? {
				return getRuleContext(TableOptionContext.self, i)
			}
			open
			func partitionDefinitions() -> PartitionDefinitionsContext? {
				return getRuleContext(PartitionDefinitionsContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: CreateTableContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterColumnCreateTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitColumnCreateTable(self)
			}
		}
	}
	public class QueryCreateTableContext: CreateTableContext {
		public var keyViolate: Token!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
			open
			func TEMPORARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TEMPORARY.rawValue, 0)
			}
			open
			func ifNotExists() -> IfNotExistsContext? {
				return getRuleContext(IfNotExistsContext.self, 0)
			}
			open
			func createDefinitions() -> CreateDefinitionsContext? {
				return getRuleContext(CreateDefinitionsContext.self, 0)
			}
			open
			func tableOption() -> [TableOptionContext] {
				return getRuleContexts(TableOptionContext.self)
			}
			open
			func tableOption(_ i: Int) -> TableOptionContext? {
				return getRuleContext(TableOptionContext.self, i)
			}
			open
			func partitionDefinitions() -> PartitionDefinitionsContext? {
				return getRuleContext(PartitionDefinitionsContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
			open
			func IGNORE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE.rawValue, 0)
			}
			open
			func REPLACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLACE.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: CreateTableContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterQueryCreateTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitQueryCreateTable(self)
			}
		}
	}
	@discardableResult
	 open func createTable() throws -> CreateTableContext {
		var _localctx: CreateTableContext
		_localctx = CreateTableContext(_ctx, getState())
		try enterRule(_localctx, 40, MySqlParser.RULE_createTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(1204)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,78, _ctx)) {
		 	case 1:
		 		_localctx =  CopyCreateTableContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1126)
		 		try match(MySqlParser.Tokens.CREATE.rawValue)
		 		setState(1128)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.TEMPORARY.rawValue) {
		 			setState(1127)
		 			try match(MySqlParser.Tokens.TEMPORARY.rawValue)

		 		}

		 		setState(1130)
		 		try match(MySqlParser.Tokens.TABLE.rawValue)
		 		setState(1132)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,61,_ctx)) {
		 		case 1:
		 			setState(1131)
		 			try ifNotExists()

		 			break
		 		default: break
		 		}
		 		setState(1134)
		 		try tableName()
		 		setState(1142)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .LIKE:
		 			setState(1135)
		 			try match(MySqlParser.Tokens.LIKE.rawValue)
		 			setState(1136)
		 			try tableName()

		 			break

		 		case .LR_BRACKET:
		 			setState(1137)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(1138)
		 			try match(MySqlParser.Tokens.LIKE.rawValue)
		 			setState(1139)
		 			try {
		 					let assignmentValue = try tableName()
		 					_localctx.castdown(CopyCreateTableContext.self).parenthesisTable = assignmentValue
		 			     }()

		 			setState(1140)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 2:
		 		_localctx =  QueryCreateTableContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1144)
		 		try match(MySqlParser.Tokens.CREATE.rawValue)
		 		setState(1146)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.TEMPORARY.rawValue) {
		 			setState(1145)
		 			try match(MySqlParser.Tokens.TEMPORARY.rawValue)

		 		}

		 		setState(1148)
		 		try match(MySqlParser.Tokens.TABLE.rawValue)
		 		setState(1150)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,64,_ctx)) {
		 		case 1:
		 			setState(1149)
		 			try ifNotExists()

		 			break
		 		default: break
		 		}
		 		setState(1152)
		 		try tableName()
		 		setState(1154)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,65,_ctx)) {
		 		case 1:
		 			setState(1153)
		 			try createDefinitions()

		 			break
		 		default: break
		 		}
		 		setState(1166)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64((_la - 25)) & ~0x3f) == 0 && ((Int64(1) << (_la - 25)) & 72057594038059013) != 0) || _la == MySqlParser.Tokens.UNION.rawValue || _la == MySqlParser.Tokens.CHAR.rawValue || ((Int64((_la - 341)) & ~0x3f) == 0 && ((Int64(1) << (_la - 341)) & 4644375904747527) != 0) || ((Int64((_la - 405)) & ~0x3f) == 0 && ((Int64(1) << (_la - 405)) & 4612811918334230547) != 0) || ((Int64((_la - 500)) & ~0x3f) == 0 && ((Int64(1) << (_la - 500)) & 2366149022974977) != 0) || ((Int64((_la - 602)) & ~0x3f) == 0 && ((Int64(1) << (_la - 602)) & 4609173815820289) != 0) || _la == MySqlParser.Tokens.CHARSET.rawValue || _la == MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue || _la == MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue || _la == MySqlParser.Tokens.STRING_LITERAL.rawValue) {
		 			setState(1156)
		 			try tableOption()
		 			setState(1163)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (((Int64((_la - 25)) & ~0x3f) == 0 && ((Int64(1) << (_la - 25)) & 72057594038059013) != 0) || _la == MySqlParser.Tokens.UNION.rawValue || _la == MySqlParser.Tokens.CHAR.rawValue || ((Int64((_la - 341)) & ~0x3f) == 0 && ((Int64(1) << (_la - 341)) & 4644375904747527) != 0) || ((Int64((_la - 405)) & ~0x3f) == 0 && ((Int64(1) << (_la - 405)) & 4612811918334230547) != 0) || ((Int64((_la - 500)) & ~0x3f) == 0 && ((Int64(1) << (_la - 500)) & 2366149022974977) != 0) || ((Int64((_la - 602)) & ~0x3f) == 0 && ((Int64(1) << (_la - 602)) & 4609173815820289) != 0) || _la == MySqlParser.Tokens.CHARSET.rawValue || _la == MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue || _la == MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue || _la == MySqlParser.Tokens.COMMA.rawValue || _la == MySqlParser.Tokens.STRING_LITERAL.rawValue) {
		 				setState(1158)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 					setState(1157)
		 					try match(MySqlParser.Tokens.COMMA.rawValue)

		 				}

		 				setState(1160)
		 				try tableOption()


		 				setState(1165)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}

		 		}

		 		setState(1169)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.PARTITION.rawValue) {
		 			setState(1168)
		 			try partitionDefinitions()

		 		}

		 		setState(1172)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.IGNORE.rawValue || _la == MySqlParser.Tokens.REPLACE.rawValue) {
		 			setState(1171)
		 			_localctx.castdown(QueryCreateTableContext.self).keyViolate = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.IGNORE.rawValue || _la == MySqlParser.Tokens.REPLACE.rawValue)) {
		 				_localctx.castdown(QueryCreateTableContext.self).keyViolate = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(1175)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.AS.rawValue) {
		 			setState(1174)
		 			try match(MySqlParser.Tokens.AS.rawValue)

		 		}

		 		setState(1177)
		 		try selectStatement()

		 		break
		 	case 3:
		 		_localctx =  ColumnCreateTableContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1179)
		 		try match(MySqlParser.Tokens.CREATE.rawValue)
		 		setState(1181)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.TEMPORARY.rawValue) {
		 			setState(1180)
		 			try match(MySqlParser.Tokens.TEMPORARY.rawValue)

		 		}

		 		setState(1183)
		 		try match(MySqlParser.Tokens.TABLE.rawValue)
		 		setState(1185)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,73,_ctx)) {
		 		case 1:
		 			setState(1184)
		 			try ifNotExists()

		 			break
		 		default: break
		 		}
		 		setState(1187)
		 		try tableName()
		 		setState(1188)
		 		try createDefinitions()
		 		setState(1199)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,76,_ctx)) {
		 		case 1:
		 			setState(1189)
		 			try tableOption()
		 			setState(1196)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,75,_ctx)
		 			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 				if ( _alt==1 ) {
		 					setState(1191)
		 					try _errHandler.sync(self)
		 					_la = try _input.LA(1)
		 					if (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 						setState(1190)
		 						try match(MySqlParser.Tokens.COMMA.rawValue)

		 					}

		 					setState(1193)
		 					try tableOption()

		 			 
		 				}
		 				setState(1198)
		 				try _errHandler.sync(self)
		 				_alt = try getInterpreter().adaptivePredict(_input,75,_ctx)
		 			}

		 			break
		 		default: break
		 		}
		 		setState(1202)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.PARTITION.rawValue) {
		 			setState(1201)
		 			try partitionDefinitions()

		 		}


		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateTablespaceInnodbContext: ParserRuleContext {
		open var datafile: Token!
		open var fileBlockSize: FileSizeLiteralContext!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func DATAFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATAFILE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func FILE_BLOCK_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FILE_BLOCK_SIZE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func engineName() -> EngineNameContext? {
				return getRuleContext(EngineNameContext.self, 0)
			}
			open
			func fileSizeLiteral() -> FileSizeLiteralContext? {
				return getRuleContext(FileSizeLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createTablespaceInnodb
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateTablespaceInnodb(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateTablespaceInnodb(self)
			}
		}
	}
	@discardableResult
	 open func createTablespaceInnodb() throws -> CreateTablespaceInnodbContext {
		var _localctx: CreateTablespaceInnodbContext
		_localctx = CreateTablespaceInnodbContext(_ctx, getState())
		try enterRule(_localctx, 42, MySqlParser.RULE_createTablespaceInnodb)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1206)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(1207)
		 	try match(MySqlParser.Tokens.TABLESPACE.rawValue)
		 	setState(1208)
		 	try uid()
		 	setState(1209)
		 	try match(MySqlParser.Tokens.ADD.rawValue)
		 	setState(1210)
		 	try match(MySqlParser.Tokens.DATAFILE.rawValue)
		 	setState(1211)
		 	try {
		 			let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 			_localctx.castdown(CreateTablespaceInnodbContext.self).datafile = assignmentValue
		 	     }()

		 	setState(1215)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.FILE_BLOCK_SIZE.rawValue) {
		 		setState(1212)
		 		try match(MySqlParser.Tokens.FILE_BLOCK_SIZE.rawValue)
		 		setState(1213)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(1214)
		 		try {
		 				let assignmentValue = try fileSizeLiteral()
		 				_localctx.castdown(CreateTablespaceInnodbContext.self).fileBlockSize = assignmentValue
		 		     }()


		 	}

		 	setState(1222)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ENGINE.rawValue) {
		 		setState(1217)
		 		try match(MySqlParser.Tokens.ENGINE.rawValue)
		 		setState(1219)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1218)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1221)
		 		try engineName()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateTablespaceNdbContext: ParserRuleContext {
		open var datafile: Token!
		open var extentSize: FileSizeLiteralContext!
		open var initialSize: FileSizeLiteralContext!
		open var autoextendSize: FileSizeLiteralContext!
		open var maxSize: FileSizeLiteralContext!
		open var comment: Token!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func DATAFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATAFILE.rawValue, 0)
			}
			open
			func USE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USE.rawValue, 0)
			}
			open
			func LOGFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOGFILE.rawValue, 0)
			}
			open
			func GROUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP.rawValue, 0)
			}
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func engineName() -> EngineNameContext? {
				return getRuleContext(EngineNameContext.self, 0)
			}
			open
			func STRING_LITERAL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.STRING_LITERAL.rawValue)
			}
			open
			func STRING_LITERAL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, i)
			}
			open
			func EXTENT_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXTENT_SIZE.rawValue, 0)
			}
			open
			func INITIAL_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INITIAL_SIZE.rawValue, 0)
			}
			open
			func AUTOEXTEND_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTOEXTEND_SIZE.rawValue, 0)
			}
			open
			func MAX_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_SIZE.rawValue, 0)
			}
			open
			func NODEGROUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NODEGROUP.rawValue, 0)
			}
			open
			func WAIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WAIT.rawValue, 0)
			}
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
			open
			func fileSizeLiteral() -> [FileSizeLiteralContext] {
				return getRuleContexts(FileSizeLiteralContext.self)
			}
			open
			func fileSizeLiteral(_ i: Int) -> FileSizeLiteralContext? {
				return getRuleContext(FileSizeLiteralContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createTablespaceNdb
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateTablespaceNdb(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateTablespaceNdb(self)
			}
		}
	}
	@discardableResult
	 open func createTablespaceNdb() throws -> CreateTablespaceNdbContext {
		var _localctx: CreateTablespaceNdbContext
		_localctx = CreateTablespaceNdbContext(_ctx, getState())
		try enterRule(_localctx, 44, MySqlParser.RULE_createTablespaceNdb)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1224)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(1225)
		 	try match(MySqlParser.Tokens.TABLESPACE.rawValue)
		 	setState(1226)
		 	try uid()
		 	setState(1227)
		 	try match(MySqlParser.Tokens.ADD.rawValue)
		 	setState(1228)
		 	try match(MySqlParser.Tokens.DATAFILE.rawValue)
		 	setState(1229)
		 	try {
		 			let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 			_localctx.castdown(CreateTablespaceNdbContext.self).datafile = assignmentValue
		 	     }()

		 	setState(1230)
		 	try match(MySqlParser.Tokens.USE.rawValue)
		 	setState(1231)
		 	try match(MySqlParser.Tokens.LOGFILE.rawValue)
		 	setState(1232)
		 	try match(MySqlParser.Tokens.GROUP.rawValue)
		 	setState(1233)
		 	try uid()
		 	setState(1239)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.EXTENT_SIZE.rawValue) {
		 		setState(1234)
		 		try match(MySqlParser.Tokens.EXTENT_SIZE.rawValue)
		 		setState(1236)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1235)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1238)
		 		try {
		 				let assignmentValue = try fileSizeLiteral()
		 				_localctx.castdown(CreateTablespaceNdbContext.self).extentSize = assignmentValue
		 		     }()


		 	}

		 	setState(1246)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.INITIAL_SIZE.rawValue) {
		 		setState(1241)
		 		try match(MySqlParser.Tokens.INITIAL_SIZE.rawValue)
		 		setState(1243)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1242)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1245)
		 		try {
		 				let assignmentValue = try fileSizeLiteral()
		 				_localctx.castdown(CreateTablespaceNdbContext.self).initialSize = assignmentValue
		 		     }()


		 	}

		 	setState(1253)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.AUTOEXTEND_SIZE.rawValue) {
		 		setState(1248)
		 		try match(MySqlParser.Tokens.AUTOEXTEND_SIZE.rawValue)
		 		setState(1250)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1249)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1252)
		 		try {
		 				let assignmentValue = try fileSizeLiteral()
		 				_localctx.castdown(CreateTablespaceNdbContext.self).autoextendSize = assignmentValue
		 		     }()


		 	}

		 	setState(1260)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.MAX_SIZE.rawValue) {
		 		setState(1255)
		 		try match(MySqlParser.Tokens.MAX_SIZE.rawValue)
		 		setState(1257)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1256)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1259)
		 		try {
		 				let assignmentValue = try fileSizeLiteral()
		 				_localctx.castdown(CreateTablespaceNdbContext.self).maxSize = assignmentValue
		 		     }()


		 	}

		 	setState(1267)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.NODEGROUP.rawValue) {
		 		setState(1262)
		 		try match(MySqlParser.Tokens.NODEGROUP.rawValue)
		 		setState(1264)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1263)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1266)
		 		try uid()

		 	}

		 	setState(1270)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WAIT.rawValue) {
		 		setState(1269)
		 		try match(MySqlParser.Tokens.WAIT.rawValue)

		 	}

		 	setState(1277)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.COMMENT.rawValue) {
		 		setState(1272)
		 		try match(MySqlParser.Tokens.COMMENT.rawValue)
		 		setState(1274)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1273)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1276)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(CreateTablespaceNdbContext.self).comment = assignmentValue
		 		     }()


		 	}

		 	setState(1279)
		 	try match(MySqlParser.Tokens.ENGINE.rawValue)
		 	setState(1281)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 		setState(1280)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 	}

		 	setState(1283)
		 	try engineName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateTriggerContext: ParserRuleContext {
		open var thisTrigger: FullIdContext!
		open var triggerTime: Token!
		open var triggerEvent: Token!
		open var triggerPlace: Token!
		open var otherTrigger: FullIdContext!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func TRIGGER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRIGGER.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func EACH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EACH.rawValue, 0)
			}
			open
			func ROW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROW.rawValue, 0)
			}
			open
			func routineBody() -> RoutineBodyContext? {
				return getRuleContext(RoutineBodyContext.self, 0)
			}
			open
			func fullId() -> [FullIdContext] {
				return getRuleContexts(FullIdContext.self)
			}
			open
			func fullId(_ i: Int) -> FullIdContext? {
				return getRuleContext(FullIdContext.self, i)
			}
			open
			func BEFORE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BEFORE.rawValue, 0)
			}
			open
			func AFTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AFTER.rawValue, 0)
			}
			open
			func INSERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSERT.rawValue, 0)
			}
			open
			func UPDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPDATE.rawValue, 0)
			}
			open
			func DELETE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DELETE.rawValue, 0)
			}
			open
			func ownerStatement() -> OwnerStatementContext? {
				return getRuleContext(OwnerStatementContext.self, 0)
			}
			open
			func FOLLOWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOLLOWS.rawValue, 0)
			}
			open
			func PRECEDES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRECEDES.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createTrigger
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateTrigger(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateTrigger(self)
			}
		}
	}
	@discardableResult
	 open func createTrigger() throws -> CreateTriggerContext {
		var _localctx: CreateTriggerContext
		_localctx = CreateTriggerContext(_ctx, getState())
		try enterRule(_localctx, 46, MySqlParser.RULE_createTrigger)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1285)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(1287)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.DEFINER.rawValue) {
		 		setState(1286)
		 		try ownerStatement()

		 	}

		 	setState(1289)
		 	try match(MySqlParser.Tokens.TRIGGER.rawValue)
		 	setState(1290)
		 	try {
		 			let assignmentValue = try fullId()
		 			_localctx.castdown(CreateTriggerContext.self).thisTrigger = assignmentValue
		 	     }()

		 	setState(1291)
		 	_localctx.castdown(CreateTriggerContext.self).triggerTime = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.BEFORE.rawValue || _la == MySqlParser.Tokens.AFTER.rawValue)) {
		 		_localctx.castdown(CreateTriggerContext.self).triggerTime = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1292)
		 	_localctx.castdown(CreateTriggerContext.self).triggerEvent = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.DELETE.rawValue || _la == MySqlParser.Tokens.INSERT.rawValue || _la == MySqlParser.Tokens.UPDATE.rawValue)) {
		 		_localctx.castdown(CreateTriggerContext.self).triggerEvent = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(1293)
		 	try match(MySqlParser.Tokens.ON.rawValue)
		 	setState(1294)
		 	try tableName()
		 	setState(1295)
		 	try match(MySqlParser.Tokens.FOR.rawValue)
		 	setState(1296)
		 	try match(MySqlParser.Tokens.EACH.rawValue)
		 	setState(1297)
		 	try match(MySqlParser.Tokens.ROW.rawValue)
		 	setState(1300)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,97,_ctx)) {
		 	case 1:
		 		setState(1298)
		 		_localctx.castdown(CreateTriggerContext.self).triggerPlace = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FOLLOWS.rawValue || _la == MySqlParser.Tokens.PRECEDES.rawValue)) {
		 			_localctx.castdown(CreateTriggerContext.self).triggerPlace = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1299)
		 		try {
		 				let assignmentValue = try fullId()
		 				_localctx.castdown(CreateTriggerContext.self).otherTrigger = assignmentValue
		 		     }()


		 		break
		 	default: break
		 	}
		 	setState(1302)
		 	try routineBody()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WithClauseContext: ParserRuleContext {
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func commonTableExpressions() -> CommonTableExpressionsContext? {
				return getRuleContext(CommonTableExpressionsContext.self, 0)
			}
			open
			func RECURSIVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RECURSIVE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_withClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterWithClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitWithClause(self)
			}
		}
	}
	@discardableResult
	 open func withClause() throws -> WithClauseContext {
		var _localctx: WithClauseContext
		_localctx = WithClauseContext(_ctx, getState())
		try enterRule(_localctx, 48, MySqlParser.RULE_withClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1304)
		 	try match(MySqlParser.Tokens.WITH.rawValue)
		 	setState(1306)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,98,_ctx)) {
		 	case 1:
		 		setState(1305)
		 		try match(MySqlParser.Tokens.RECURSIVE.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(1308)
		 	try commonTableExpressions()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CommonTableExpressionsContext: ParserRuleContext {
			open
			func cteName() -> CteNameContext? {
				return getRuleContext(CteNameContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func dmlStatement() -> DmlStatementContext? {
				return getRuleContext(DmlStatementContext.self, 0)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func cteColumnName() -> [CteColumnNameContext] {
				return getRuleContexts(CteColumnNameContext.self)
			}
			open
			func cteColumnName(_ i: Int) -> CteColumnNameContext? {
				return getRuleContext(CteColumnNameContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func commonTableExpressions() -> CommonTableExpressionsContext? {
				return getRuleContext(CommonTableExpressionsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_commonTableExpressions
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCommonTableExpressions(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCommonTableExpressions(self)
			}
		}
	}
	@discardableResult
	 open func commonTableExpressions() throws -> CommonTableExpressionsContext {
		var _localctx: CommonTableExpressionsContext
		_localctx = CommonTableExpressionsContext(_ctx, getState())
		try enterRule(_localctx, 50, MySqlParser.RULE_commonTableExpressions)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1310)
		 	try cteName()
		 	setState(1322)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 		setState(1311)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1312)
		 		try cteColumnName()
		 		setState(1317)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(1313)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(1314)
		 			try cteColumnName()


		 			setState(1319)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(1320)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(1324)
		 	try match(MySqlParser.Tokens.AS.rawValue)
		 	setState(1325)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(1326)
		 	try dmlStatement()
		 	setState(1327)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(1330)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,101,_ctx)) {
		 	case 1:
		 		setState(1328)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(1329)
		 		try commonTableExpressions()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CteNameContext: ParserRuleContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_cteName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCteName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCteName(self)
			}
		}
	}
	@discardableResult
	 open func cteName() throws -> CteNameContext {
		var _localctx: CteNameContext
		_localctx = CteNameContext(_ctx, getState())
		try enterRule(_localctx, 52, MySqlParser.RULE_cteName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1332)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CteColumnNameContext: ParserRuleContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_cteColumnName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCteColumnName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCteColumnName(self)
			}
		}
	}
	@discardableResult
	 open func cteColumnName() throws -> CteColumnNameContext {
		var _localctx: CteColumnNameContext
		_localctx = CteColumnNameContext(_ctx, getState())
		try enterRule(_localctx, 54, MySqlParser.RULE_cteColumnName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1334)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateViewContext: ParserRuleContext {
		open var algType: Token!
		open var secContext: Token!
		open var checkOption: Token!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func VIEW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VIEW.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func orReplace() -> OrReplaceContext? {
				return getRuleContext(OrReplaceContext.self, 0)
			}
			open
			func ALGORITHM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALGORITHM.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func ownerStatement() -> OwnerStatementContext? {
				return getRuleContext(OwnerStatementContext.self, 0)
			}
			open
			func SQL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL.rawValue, 0)
			}
			open
			func SECURITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SECURITY.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func UNDEFINED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNDEFINED.rawValue, 0)
			}
			open
			func MERGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MERGE.rawValue, 0)
			}
			open
			func TEMPTABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TEMPTABLE.rawValue, 0)
			}
			open
			func DEFINER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFINER.rawValue, 0)
			}
			open
			func INVOKER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INVOKER.rawValue, 0)
			}
			open
			func withClause() -> WithClauseContext? {
				return getRuleContext(WithClauseContext.self, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func CHECK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECK.rawValue, 0)
			}
			open
			func OPTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTION.rawValue, 0)
			}
			open
			func CASCADED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CASCADED.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createView
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateView(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateView(self)
			}
		}
	}
	@discardableResult
	 open func createView() throws -> CreateViewContext {
		var _localctx: CreateViewContext
		_localctx = CreateViewContext(_ctx, getState())
		try enterRule(_localctx, 56, MySqlParser.RULE_createView)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1336)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(1338)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.OR.rawValue) {
		 		setState(1337)
		 		try orReplace()

		 	}

		 	setState(1343)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ALGORITHM.rawValue) {
		 		setState(1340)
		 		try match(MySqlParser.Tokens.ALGORITHM.rawValue)
		 		setState(1341)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(1342)
		 		_localctx.castdown(CreateViewContext.self).algType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.MERGE.rawValue || _la == MySqlParser.Tokens.TEMPTABLE.rawValue || _la == MySqlParser.Tokens.UNDEFINED.rawValue)) {
		 			_localctx.castdown(CreateViewContext.self).algType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(1346)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.DEFINER.rawValue) {
		 		setState(1345)
		 		try ownerStatement()

		 	}

		 	setState(1351)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.SQL.rawValue) {
		 		setState(1348)
		 		try match(MySqlParser.Tokens.SQL.rawValue)
		 		setState(1349)
		 		try match(MySqlParser.Tokens.SECURITY.rawValue)
		 		setState(1350)
		 		_localctx.castdown(CreateViewContext.self).secContext = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFINER.rawValue || _la == MySqlParser.Tokens.INVOKER.rawValue)) {
		 			_localctx.castdown(CreateViewContext.self).secContext = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(1353)
		 	try match(MySqlParser.Tokens.VIEW.rawValue)
		 	setState(1354)
		 	try fullId()
		 	setState(1359)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 		setState(1355)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1356)
		 		try uidList()
		 		setState(1357)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(1361)
		 	try match(MySqlParser.Tokens.AS.rawValue)
		 	setState(1381)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,111, _ctx)) {
		 	case 1:
		 		setState(1362)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1364)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.WITH.rawValue) {
		 			setState(1363)
		 			try withClause()

		 		}

		 		setState(1366)
		 		try selectStatement()
		 		setState(1367)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 2:
		 		setState(1370)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.WITH.rawValue) {
		 			setState(1369)
		 			try withClause()

		 		}

		 		setState(1372)
		 		try selectStatement()
		 		setState(1379)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,110,_ctx)) {
		 		case 1:
		 			setState(1373)
		 			try match(MySqlParser.Tokens.WITH.rawValue)
		 			setState(1375)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.CASCADED.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue) {
		 				setState(1374)
		 				_localctx.castdown(CreateViewContext.self).checkOption = try _input.LT(1)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.CASCADED.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue)) {
		 					_localctx.castdown(CreateViewContext.self).checkOption = try _errHandler.recoverInline(self) as Token
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 			}

		 			setState(1377)
		 			try match(MySqlParser.Tokens.CHECK.rawValue)
		 			setState(1378)
		 			try match(MySqlParser.Tokens.OPTION.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateDatabaseOptionContext: ParserRuleContext {
			open
			func charSet() -> CharSetContext? {
				return getRuleContext(CharSetContext.self, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func DEFAULT() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.DEFAULT.rawValue)
			}
			open
			func DEFAULT(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, i)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func COLLATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATE.rawValue, 0)
			}
			open
			func collationName() -> CollationNameContext? {
				return getRuleContext(CollationNameContext.self, 0)
			}
			open
			func ENCRYPTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENCRYPTION.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func READ() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.READ.rawValue, 0)
			}
			open
			func ONLY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONLY.rawValue, 0)
			}
			open
			func ZERO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZERO_DECIMAL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createDatabaseOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateDatabaseOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateDatabaseOption(self)
			}
		}
	}
	@discardableResult
	 open func createDatabaseOption() throws -> CreateDatabaseOptionContext {
		var _localctx: CreateDatabaseOptionContext
		_localctx = CreateDatabaseOptionContext(_ctx, getState())
		try enterRule(_localctx, 58, MySqlParser.RULE_createDatabaseOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1416)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,120, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1384)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DEFAULT.rawValue) {
		 			setState(1383)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 		}

		 		setState(1386)
		 		try charSet()
		 		setState(1388)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1387)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1392)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .BINARY:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:
		 			setState(1390)
		 			try charsetName()

		 			break

		 		case .DEFAULT:
		 			setState(1391)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1395)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DEFAULT.rawValue) {
		 			setState(1394)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 		}

		 		setState(1397)
		 		try match(MySqlParser.Tokens.COLLATE.rawValue)
		 		setState(1399)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1398)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1401)
		 		try collationName()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1403)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DEFAULT.rawValue) {
		 			setState(1402)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 		}

		 		setState(1405)
		 		try match(MySqlParser.Tokens.ENCRYPTION.rawValue)
		 		setState(1407)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1406)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1409)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1410)
		 		try match(MySqlParser.Tokens.READ.rawValue)
		 		setState(1411)
		 		try match(MySqlParser.Tokens.ONLY.rawValue)
		 		setState(1413)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1412)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1415)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.ZERO_DECIMAL.rawValue || _la == MySqlParser.Tokens.ONE_DECIMAL.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CharSetContext: ParserRuleContext {
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func CHARSET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARSET.rawValue, 0)
			}
			open
			func CHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHAR.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_charSet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCharSet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCharSet(self)
			}
		}
	}
	@discardableResult
	 open func charSet() throws -> CharSetContext {
		var _localctx: CharSetContext
		_localctx = CharSetContext(_ctx, getState())
		try enterRule(_localctx, 60, MySqlParser.RULE_charSet)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1423)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CHARACTER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1418)
		 		try match(MySqlParser.Tokens.CHARACTER.rawValue)
		 		setState(1419)
		 		try match(MySqlParser.Tokens.SET.rawValue)

		 		break

		 	case .CHARSET:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1420)
		 		try match(MySqlParser.Tokens.CHARSET.rawValue)

		 		break

		 	case .CHAR:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1421)
		 		try match(MySqlParser.Tokens.CHAR.rawValue)
		 		setState(1422)
		 		try match(MySqlParser.Tokens.SET.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CurrentUserExpressionContext: ParserRuleContext {
			open
			func CURRENT_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT_USER.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_currentUserExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCurrentUserExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCurrentUserExpression(self)
			}
		}
	}
	@discardableResult
	 open func currentUserExpression() throws -> CurrentUserExpressionContext {
		var _localctx: CurrentUserExpressionContext
		_localctx = CurrentUserExpressionContext(_ctx, getState())
		try enterRule(_localctx, 62, MySqlParser.RULE_currentUserExpression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1425)
		 	try match(MySqlParser.Tokens.CURRENT_USER.rawValue)
		 	setState(1428)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,122,_ctx)) {
		 	case 1:
		 		setState(1426)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1427)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OwnerStatementContext: ParserRuleContext {
			open
			func DEFINER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFINER.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}
			open
			func currentUserExpression() -> CurrentUserExpressionContext? {
				return getRuleContext(CurrentUserExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_ownerStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterOwnerStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitOwnerStatement(self)
			}
		}
	}
	@discardableResult
	 open func ownerStatement() throws -> OwnerStatementContext {
		var _localctx: OwnerStatementContext
		_localctx = OwnerStatementContext(_ctx, getState())
		try enterRule(_localctx, 64, MySqlParser.RULE_ownerStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1430)
		 	try match(MySqlParser.Tokens.DEFINER.rawValue)
		 	setState(1431)
		 	try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 	setState(1434)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,123, _ctx)) {
		 	case 1:
		 		setState(1432)
		 		try userName()

		 		break
		 	case 2:
		 		setState(1433)
		 		try currentUserExpression()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScheduleExpressionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_scheduleExpression
		}
	}
	public class PreciseScheduleContext: ScheduleExpressionContext {
			open
			func AT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AT.rawValue, 0)
			}
			open
			func timestampValue() -> TimestampValueContext? {
				return getRuleContext(TimestampValueContext.self, 0)
			}
			open
			func intervalExpr() -> [IntervalExprContext] {
				return getRuleContexts(IntervalExprContext.self)
			}
			open
			func intervalExpr(_ i: Int) -> IntervalExprContext? {
				return getRuleContext(IntervalExprContext.self, i)
			}

		public
		init(_ ctx: ScheduleExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPreciseSchedule(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPreciseSchedule(self)
			}
		}
	}
	public class IntervalScheduleContext: ScheduleExpressionContext {
		public var startTimestamp: TimestampValueContext!
		public var _intervalExpr: IntervalExprContext!
		public var startIntervals: [IntervalExprContext] = [IntervalExprContext]()
		public var endTimestamp: TimestampValueContext!
		public var endIntervals: [IntervalExprContext] = [IntervalExprContext]()
			open
			func EVERY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVERY.rawValue, 0)
			}
			open
			func intervalType() -> IntervalTypeContext? {
				return getRuleContext(IntervalTypeContext.self, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func STARTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STARTS.rawValue, 0)
			}
			open
			func ENDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENDS.rawValue, 0)
			}
			open
			func timestampValue() -> [TimestampValueContext] {
				return getRuleContexts(TimestampValueContext.self)
			}
			open
			func timestampValue(_ i: Int) -> TimestampValueContext? {
				return getRuleContext(TimestampValueContext.self, i)
			}
			open
			func intervalExpr() -> [IntervalExprContext] {
				return getRuleContexts(IntervalExprContext.self)
			}
			open
			func intervalExpr(_ i: Int) -> IntervalExprContext? {
				return getRuleContext(IntervalExprContext.self, i)
			}

		public
		init(_ ctx: ScheduleExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIntervalSchedule(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIntervalSchedule(self)
			}
		}
	}
	@discardableResult
	 open func scheduleExpression() throws -> ScheduleExpressionContext {
		var _localctx: ScheduleExpressionContext
		_localctx = ScheduleExpressionContext(_ctx, getState())
		try enterRule(_localctx, 66, MySqlParser.RULE_scheduleExpression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1470)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .AT:
		 		_localctx =  PreciseScheduleContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1436)
		 		try match(MySqlParser.Tokens.AT.rawValue)
		 		setState(1437)
		 		try timestampValue()
		 		setState(1441)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.PLUS.rawValue) {
		 			setState(1438)
		 			try intervalExpr()


		 			setState(1443)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break

		 	case .EVERY:
		 		_localctx =  IntervalScheduleContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1444)
		 		try match(MySqlParser.Tokens.EVERY.rawValue)
		 		setState(1447)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,125, _ctx)) {
		 		case 1:
		 			setState(1445)
		 			try decimalLiteral()

		 			break
		 		case 2:
		 			setState(1446)
		 			try expression(0)

		 			break
		 		default: break
		 		}
		 		setState(1449)
		 		try intervalType()
		 		setState(1458)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.STARTS.rawValue) {
		 			setState(1450)
		 			try match(MySqlParser.Tokens.STARTS.rawValue)
		 			setState(1451)
		 			try {
		 					let assignmentValue = try timestampValue()
		 					_localctx.castdown(IntervalScheduleContext.self).startTimestamp = assignmentValue
		 			     }()

		 			setState(1455)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (_la == MySqlParser.Tokens.PLUS.rawValue) {
		 				setState(1452)
		 				try {
		 						let assignmentValue = try intervalExpr()
		 						_localctx.castdown(IntervalScheduleContext.self)._intervalExpr = assignmentValue
		 				     }()

		 				_localctx.castdown(IntervalScheduleContext.self).startIntervals.append(_localctx.castdown(IntervalScheduleContext.self)._intervalExpr)


		 				setState(1457)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}

		 		}

		 		setState(1468)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.ENDS.rawValue) {
		 			setState(1460)
		 			try match(MySqlParser.Tokens.ENDS.rawValue)
		 			setState(1461)
		 			try {
		 					let assignmentValue = try timestampValue()
		 					_localctx.castdown(IntervalScheduleContext.self).endTimestamp = assignmentValue
		 			     }()

		 			setState(1465)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (_la == MySqlParser.Tokens.PLUS.rawValue) {
		 				setState(1462)
		 				try {
		 						let assignmentValue = try intervalExpr()
		 						_localctx.castdown(IntervalScheduleContext.self)._intervalExpr = assignmentValue
		 				     }()

		 				_localctx.castdown(IntervalScheduleContext.self).endIntervals.append(_localctx.castdown(IntervalScheduleContext.self)._intervalExpr)


		 				setState(1467)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}

		 		}


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TimestampValueContext: ParserRuleContext {
			open
			func CURRENT_TIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT_TIMESTAMP.rawValue, 0)
			}
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_timestampValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTimestampValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTimestampValue(self)
			}
		}
	}
	@discardableResult
	 open func timestampValue() throws -> TimestampValueContext {
		var _localctx: TimestampValueContext
		_localctx = TimestampValueContext(_ctx, getState())
		try enterRule(_localctx, 68, MySqlParser.RULE_timestampValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1476)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,131, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1472)
		 		try match(MySqlParser.Tokens.CURRENT_TIMESTAMP.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1473)
		 		try stringLiteral()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1474)
		 		try decimalLiteral()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1475)
		 		try expression(0)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntervalExprContext: ParserRuleContext {
			open
			func PLUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PLUS.rawValue, 0)
			}
			open
			func INTERVAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTERVAL.rawValue, 0)
			}
			open
			func intervalType() -> IntervalTypeContext? {
				return getRuleContext(IntervalTypeContext.self, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_intervalExpr
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIntervalExpr(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIntervalExpr(self)
			}
		}
	}
	@discardableResult
	 open func intervalExpr() throws -> IntervalExprContext {
		var _localctx: IntervalExprContext
		_localctx = IntervalExprContext(_ctx, getState())
		try enterRule(_localctx, 70, MySqlParser.RULE_intervalExpr)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1478)
		 	try match(MySqlParser.Tokens.PLUS.rawValue)
		 	setState(1479)
		 	try match(MySqlParser.Tokens.INTERVAL.rawValue)
		 	setState(1482)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,132, _ctx)) {
		 	case 1:
		 		setState(1480)
		 		try decimalLiteral()

		 		break
		 	case 2:
		 		setState(1481)
		 		try expression(0)

		 		break
		 	default: break
		 	}
		 	setState(1484)
		 	try intervalType()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntervalTypeContext: ParserRuleContext {
			open
			func intervalTypeBase() -> IntervalTypeBaseContext? {
				return getRuleContext(IntervalTypeBaseContext.self, 0)
			}
			open
			func YEAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.YEAR.rawValue, 0)
			}
			open
			func YEAR_MONTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.YEAR_MONTH.rawValue, 0)
			}
			open
			func DAY_HOUR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DAY_HOUR.rawValue, 0)
			}
			open
			func DAY_MINUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DAY_MINUTE.rawValue, 0)
			}
			open
			func DAY_SECOND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DAY_SECOND.rawValue, 0)
			}
			open
			func HOUR_MINUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HOUR_MINUTE.rawValue, 0)
			}
			open
			func HOUR_SECOND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HOUR_SECOND.rawValue, 0)
			}
			open
			func MINUTE_SECOND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUTE_SECOND.rawValue, 0)
			}
			open
			func SECOND_MICROSECOND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SECOND_MICROSECOND.rawValue, 0)
			}
			open
			func MINUTE_MICROSECOND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUTE_MICROSECOND.rawValue, 0)
			}
			open
			func HOUR_MICROSECOND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HOUR_MICROSECOND.rawValue, 0)
			}
			open
			func DAY_MICROSECOND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DAY_MICROSECOND.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_intervalType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIntervalType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIntervalType(self)
			}
		}
	}
	@discardableResult
	 open func intervalType() throws -> IntervalTypeContext {
		var _localctx: IntervalTypeContext
		_localctx = IntervalTypeContext(_ctx, getState())
		try enterRule(_localctx, 72, MySqlParser.RULE_intervalType)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1499)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .QUARTER:fallthrough
		 	case .MONTH:fallthrough
		 	case .DAY:fallthrough
		 	case .HOUR:fallthrough
		 	case .MINUTE:fallthrough
		 	case .WEEK:fallthrough
		 	case .SECOND:fallthrough
		 	case .MICROSECOND:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1486)
		 		try intervalTypeBase()

		 		break

		 	case .YEAR:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1487)
		 		try match(MySqlParser.Tokens.YEAR.rawValue)

		 		break

		 	case .YEAR_MONTH:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1488)
		 		try match(MySqlParser.Tokens.YEAR_MONTH.rawValue)

		 		break

		 	case .DAY_HOUR:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1489)
		 		try match(MySqlParser.Tokens.DAY_HOUR.rawValue)

		 		break

		 	case .DAY_MINUTE:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1490)
		 		try match(MySqlParser.Tokens.DAY_MINUTE.rawValue)

		 		break

		 	case .DAY_SECOND:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1491)
		 		try match(MySqlParser.Tokens.DAY_SECOND.rawValue)

		 		break

		 	case .HOUR_MINUTE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1492)
		 		try match(MySqlParser.Tokens.HOUR_MINUTE.rawValue)

		 		break

		 	case .HOUR_SECOND:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1493)
		 		try match(MySqlParser.Tokens.HOUR_SECOND.rawValue)

		 		break

		 	case .MINUTE_SECOND:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1494)
		 		try match(MySqlParser.Tokens.MINUTE_SECOND.rawValue)

		 		break

		 	case .SECOND_MICROSECOND:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1495)
		 		try match(MySqlParser.Tokens.SECOND_MICROSECOND.rawValue)

		 		break

		 	case .MINUTE_MICROSECOND:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1496)
		 		try match(MySqlParser.Tokens.MINUTE_MICROSECOND.rawValue)

		 		break

		 	case .HOUR_MICROSECOND:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(1497)
		 		try match(MySqlParser.Tokens.HOUR_MICROSECOND.rawValue)

		 		break

		 	case .DAY_MICROSECOND:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(1498)
		 		try match(MySqlParser.Tokens.DAY_MICROSECOND.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EnableTypeContext: ParserRuleContext {
			open
			func ENABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENABLE.rawValue, 0)
			}
			open
			func DISABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISABLE.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func SLAVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SLAVE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_enableType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterEnableType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitEnableType(self)
			}
		}
	}
	@discardableResult
	 open func enableType() throws -> EnableTypeContext {
		var _localctx: EnableTypeContext
		_localctx = EnableTypeContext(_ctx, getState())
		try enterRule(_localctx, 74, MySqlParser.RULE_enableType)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1506)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,134, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1501)
		 		try match(MySqlParser.Tokens.ENABLE.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1502)
		 		try match(MySqlParser.Tokens.DISABLE.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1503)
		 		try match(MySqlParser.Tokens.DISABLE.rawValue)
		 		setState(1504)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(1505)
		 		try match(MySqlParser.Tokens.SLAVE.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexTypeContext: ParserRuleContext {
			open
			func USING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USING.rawValue, 0)
			}
			open
			func BTREE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BTREE.rawValue, 0)
			}
			open
			func HASH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HASH.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_indexType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIndexType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIndexType(self)
			}
		}
	}
	@discardableResult
	 open func indexType() throws -> IndexTypeContext {
		var _localctx: IndexTypeContext
		_localctx = IndexTypeContext(_ctx, getState())
		try enterRule(_localctx, 76, MySqlParser.RULE_indexType)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1508)
		 	try match(MySqlParser.Tokens.USING.rawValue)
		 	setState(1509)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.BTREE.rawValue || _la == MySqlParser.Tokens.HASH.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexOptionContext: ParserRuleContext {
			open
			func KEY_BLOCK_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY_BLOCK_SIZE.rawValue, 0)
			}
			open
			func fileSizeLiteral() -> FileSizeLiteralContext? {
				return getRuleContext(FileSizeLiteralContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func indexType() -> IndexTypeContext? {
				return getRuleContext(IndexTypeContext.self, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func PARSER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARSER.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func VISIBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VISIBLE.rawValue, 0)
			}
			open
			func INVISIBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INVISIBLE.rawValue, 0)
			}
			open
			func ENGINE_ATTRIBUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue, 0)
			}
			open
			func SECONDARY_ENGINE_ATTRIBUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_indexOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIndexOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIndexOption(self)
			}
		}
	}
	@discardableResult
	 open func indexOption() throws -> IndexOptionContext {
		var _localctx: IndexOptionContext
		_localctx = IndexOptionContext(_ctx, getState())
		try enterRule(_localctx, 78, MySqlParser.RULE_indexOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1533)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .KEY_BLOCK_SIZE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1511)
		 		try match(MySqlParser.Tokens.KEY_BLOCK_SIZE.rawValue)
		 		setState(1513)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1512)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1515)
		 		try fileSizeLiteral()

		 		break

		 	case .USING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1516)
		 		try indexType()

		 		break

		 	case .WITH:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1517)
		 		try match(MySqlParser.Tokens.WITH.rawValue)
		 		setState(1518)
		 		try match(MySqlParser.Tokens.PARSER.rawValue)
		 		setState(1519)
		 		try uid()

		 		break

		 	case .COMMENT:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1520)
		 		try match(MySqlParser.Tokens.COMMENT.rawValue)
		 		setState(1521)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case .INVISIBLE:fallthrough
		 	case .VISIBLE:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1522)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.INVISIBLE.rawValue || _la == MySqlParser.Tokens.VISIBLE.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .ENGINE_ATTRIBUTE:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1523)
		 		try match(MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue)
		 		setState(1525)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1524)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1527)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .SECONDARY_ENGINE_ATTRIBUTE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1528)
		 		try match(MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue)
		 		setState(1530)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1529)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1532)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureParameterContext: ParserRuleContext {
		open var direction: Token!
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func dataType() -> DataTypeContext? {
				return getRuleContext(DataTypeContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, 0)
			}
			open
			func OUT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OUT.rawValue, 0)
			}
			open
			func INOUT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INOUT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_procedureParameter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterProcedureParameter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitProcedureParameter(self)
			}
		}
	}
	@discardableResult
	 open func procedureParameter() throws -> ProcedureParameterContext {
		var _localctx: ProcedureParameterContext
		_localctx = ProcedureParameterContext(_ctx, getState())
		try enterRule(_localctx, 80, MySqlParser.RULE_procedureParameter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1536)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64((_la - 80)) & ~0x3f) == 0 && ((Int64(1) << (_la - 80)) & 35184372088849) != 0)) {
		 		setState(1535)
		 		_localctx.castdown(ProcedureParameterContext.self).direction = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 80)) & ~0x3f) == 0 && ((Int64(1) << (_la - 80)) & 35184372088849) != 0))) {
		 			_localctx.castdown(ProcedureParameterContext.self).direction = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(1538)
		 	try uid()
		 	setState(1539)
		 	try dataType()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FunctionParameterContext: ParserRuleContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func dataType() -> DataTypeContext? {
				return getRuleContext(DataTypeContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_functionParameter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFunctionParameter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFunctionParameter(self)
			}
		}
	}
	@discardableResult
	 open func functionParameter() throws -> FunctionParameterContext {
		var _localctx: FunctionParameterContext
		_localctx = FunctionParameterContext(_ctx, getState())
		try enterRule(_localctx, 82, MySqlParser.RULE_functionParameter)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1541)
		 	try uid()
		 	setState(1542)
		 	try dataType()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RoutineOptionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_routineOption
		}
	}
	public class RoutineBehaviorContext: RoutineOptionContext {
			open
			func DETERMINISTIC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DETERMINISTIC.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}

		public
		init(_ ctx: RoutineOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRoutineBehavior(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRoutineBehavior(self)
			}
		}
	}
	public class RoutineLanguageContext: RoutineOptionContext {
			open
			func LANGUAGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LANGUAGE.rawValue, 0)
			}
			open
			func SQL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL.rawValue, 0)
			}

		public
		init(_ ctx: RoutineOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRoutineLanguage(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRoutineLanguage(self)
			}
		}
	}
	public class RoutineCommentContext: RoutineOptionContext {
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: RoutineOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRoutineComment(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRoutineComment(self)
			}
		}
	}
	public class RoutineSecurityContext: RoutineOptionContext {
		public var context: Token!
			open
			func SQL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL.rawValue, 0)
			}
			open
			func SECURITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SECURITY.rawValue, 0)
			}
			open
			func DEFINER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFINER.rawValue, 0)
			}
			open
			func INVOKER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INVOKER.rawValue, 0)
			}

		public
		init(_ ctx: RoutineOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRoutineSecurity(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRoutineSecurity(self)
			}
		}
	}
	public class RoutineDataContext: RoutineOptionContext {
			open
			func CONTAINS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONTAINS.rawValue, 0)
			}
			open
			func SQL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL.rawValue, 0)
			}
			open
			func NO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NO.rawValue, 0)
			}
			open
			func READS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.READS.rawValue, 0)
			}
			open
			func DATA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATA.rawValue, 0)
			}
			open
			func MODIFIES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MODIFIES.rawValue, 0)
			}

		public
		init(_ ctx: RoutineOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRoutineData(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRoutineData(self)
			}
		}
	}
	@discardableResult
	 open func routineOption() throws -> RoutineOptionContext {
		var _localctx: RoutineOptionContext
		_localctx = RoutineOptionContext(_ctx, getState())
		try enterRule(_localctx, 84, MySqlParser.RULE_routineOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1567)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .COMMENT:
		 		_localctx =  RoutineCommentContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1544)
		 		try match(MySqlParser.Tokens.COMMENT.rawValue)
		 		setState(1545)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .LANGUAGE:
		 		_localctx =  RoutineLanguageContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1546)
		 		try match(MySqlParser.Tokens.LANGUAGE.rawValue)
		 		setState(1547)
		 		try match(MySqlParser.Tokens.SQL.rawValue)

		 		break
		 	case .DETERMINISTIC:fallthrough
		 	case .NOT:
		 		_localctx =  RoutineBehaviorContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1549)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.NOT.rawValue) {
		 			setState(1548)
		 			try match(MySqlParser.Tokens.NOT.rawValue)

		 		}

		 		setState(1551)
		 		try match(MySqlParser.Tokens.DETERMINISTIC.rawValue)

		 		break
		 	case .MODIFIES:fallthrough
		 	case .READS:fallthrough
		 	case .CONTAINS:fallthrough
		 	case .NO:
		 		_localctx =  RoutineDataContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1562)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CONTAINS:
		 			setState(1552)
		 			try match(MySqlParser.Tokens.CONTAINS.rawValue)
		 			setState(1553)
		 			try match(MySqlParser.Tokens.SQL.rawValue)

		 			break

		 		case .NO:
		 			setState(1554)
		 			try match(MySqlParser.Tokens.NO.rawValue)
		 			setState(1555)
		 			try match(MySqlParser.Tokens.SQL.rawValue)

		 			break

		 		case .READS:
		 			setState(1556)
		 			try match(MySqlParser.Tokens.READS.rawValue)
		 			setState(1557)
		 			try match(MySqlParser.Tokens.SQL.rawValue)
		 			setState(1558)
		 			try match(MySqlParser.Tokens.DATA.rawValue)

		 			break

		 		case .MODIFIES:
		 			setState(1559)
		 			try match(MySqlParser.Tokens.MODIFIES.rawValue)
		 			setState(1560)
		 			try match(MySqlParser.Tokens.SQL.rawValue)
		 			setState(1561)
		 			try match(MySqlParser.Tokens.DATA.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .SQL:
		 		_localctx =  RoutineSecurityContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1564)
		 		try match(MySqlParser.Tokens.SQL.rawValue)
		 		setState(1565)
		 		try match(MySqlParser.Tokens.SECURITY.rawValue)
		 		setState(1566)
		 		_localctx.castdown(RoutineSecurityContext.self).context = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFINER.rawValue || _la == MySqlParser.Tokens.INVOKER.rawValue)) {
		 			_localctx.castdown(RoutineSecurityContext.self).context = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ServerOptionContext: ParserRuleContext {
			open
			func HOST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HOST.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func DATABASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATABASE.rawValue, 0)
			}
			open
			func USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER.rawValue, 0)
			}
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD.rawValue, 0)
			}
			open
			func SOCKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SOCKET.rawValue, 0)
			}
			open
			func OWNER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OWNER.rawValue, 0)
			}
			open
			func PORT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PORT.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_serverOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterServerOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitServerOption(self)
			}
		}
	}
	@discardableResult
	 open func serverOption() throws -> ServerOptionContext {
		var _localctx: ServerOptionContext
		_localctx = ServerOptionContext(_ctx, getState())
		try enterRule(_localctx, 86, MySqlParser.RULE_serverOption)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1583)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .HOST:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1569)
		 		try match(MySqlParser.Tokens.HOST.rawValue)
		 		setState(1570)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .DATABASE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1571)
		 		try match(MySqlParser.Tokens.DATABASE.rawValue)
		 		setState(1572)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .USER:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1573)
		 		try match(MySqlParser.Tokens.USER.rawValue)
		 		setState(1574)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .PASSWORD:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1575)
		 		try match(MySqlParser.Tokens.PASSWORD.rawValue)
		 		setState(1576)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .SOCKET:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1577)
		 		try match(MySqlParser.Tokens.SOCKET.rawValue)
		 		setState(1578)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .OWNER:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1579)
		 		try match(MySqlParser.Tokens.OWNER.rawValue)
		 		setState(1580)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .PORT:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1581)
		 		try match(MySqlParser.Tokens.PORT.rawValue)
		 		setState(1582)
		 		try decimalLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateDefinitionsContext: ParserRuleContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func createDefinition() -> [CreateDefinitionContext] {
				return getRuleContexts(CreateDefinitionContext.self)
			}
			open
			func createDefinition(_ i: Int) -> CreateDefinitionContext? {
				return getRuleContext(CreateDefinitionContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createDefinitions
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateDefinitions(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateDefinitions(self)
			}
		}
	}
	@discardableResult
	 open func createDefinitions() throws -> CreateDefinitionsContext {
		var _localctx: CreateDefinitionsContext
		_localctx = CreateDefinitionsContext(_ctx, getState())
		try enterRule(_localctx, 88, MySqlParser.RULE_createDefinitions)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1585)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(1586)
		 	try createDefinition()
		 	setState(1591)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(1587)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(1588)
		 		try createDefinition()


		 		setState(1593)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(1594)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateDefinitionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createDefinition
		}
	}
	public class ColumnDeclarationContext: CreateDefinitionContext {
			open
			func fullColumnName() -> FullColumnNameContext? {
				return getRuleContext(FullColumnNameContext.self, 0)
			}
			open
			func columnDefinition() -> ColumnDefinitionContext? {
				return getRuleContext(ColumnDefinitionContext.self, 0)
			}

		public
		init(_ ctx: CreateDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterColumnDeclaration(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitColumnDeclaration(self)
			}
		}
	}
	public class ConstraintDeclarationContext: CreateDefinitionContext {
			open
			func tableConstraint() -> TableConstraintContext? {
				return getRuleContext(TableConstraintContext.self, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
			open
			func ENFORCED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENFORCED.rawValue, 0)
			}

		public
		init(_ ctx: CreateDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterConstraintDeclaration(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitConstraintDeclaration(self)
			}
		}
	}
	public class IndexDeclarationContext: CreateDefinitionContext {
			open
			func indexColumnDefinition() -> IndexColumnDefinitionContext? {
				return getRuleContext(IndexColumnDefinitionContext.self, 0)
			}

		public
		init(_ ctx: CreateDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIndexDeclaration(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIndexDeclaration(self)
			}
		}
	}
	@discardableResult
	 open func createDefinition() throws -> CreateDefinitionContext {
		var _localctx: CreateDefinitionContext
		_localctx = CreateDefinitionContext(_ctx, getState())
		try enterRule(_localctx, 90, MySqlParser.RULE_createDefinition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1607)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,147, _ctx)) {
		 	case 1:
		 		_localctx =  ColumnDeclarationContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1596)
		 		try fullColumnName()
		 		setState(1597)
		 		try columnDefinition()

		 		break
		 	case 2:
		 		_localctx =  ConstraintDeclarationContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1599)
		 		try tableConstraint()
		 		setState(1601)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.NOT.rawValue) {
		 			setState(1600)
		 			try match(MySqlParser.Tokens.NOT.rawValue)

		 		}

		 		setState(1604)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.ENFORCED.rawValue) {
		 			setState(1603)
		 			try match(MySqlParser.Tokens.ENFORCED.rawValue)

		 		}


		 		break
		 	case 3:
		 		_localctx =  IndexDeclarationContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1606)
		 		try indexColumnDefinition()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ColumnDefinitionContext: ParserRuleContext {
			open
			func dataType() -> DataTypeContext? {
				return getRuleContext(DataTypeContext.self, 0)
			}
			open
			func columnConstraint() -> [ColumnConstraintContext] {
				return getRuleContexts(ColumnConstraintContext.self)
			}
			open
			func columnConstraint(_ i: Int) -> ColumnConstraintContext? {
				return getRuleContext(ColumnConstraintContext.self, i)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
			open
			func ENFORCED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENFORCED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_columnDefinition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterColumnDefinition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitColumnDefinition(self)
			}
		}
	}
	@discardableResult
	 open func columnDefinition() throws -> ColumnDefinitionContext {
		var _localctx: ColumnDefinitionContext
		_localctx = ColumnDefinitionContext(_ctx, getState())
		try enterRule(_localctx, 92, MySqlParser.RULE_columnDefinition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1609)
		 	try dataType()
		 	setState(1613)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,148,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(1610)
		 			try columnConstraint()

		 	 
		 		}
		 		setState(1615)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,148,_ctx)
		 	}
		 	setState(1617)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.NOT.rawValue) {
		 		setState(1616)
		 		try match(MySqlParser.Tokens.NOT.rawValue)

		 	}

		 	setState(1620)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ENFORCED.rawValue) {
		 		setState(1619)
		 		try match(MySqlParser.Tokens.ENFORCED.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ColumnConstraintContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_columnConstraint
		}
	}
	public class StorageColumnConstraintContext: ColumnConstraintContext {
		public var storageval: Token!
			open
			func STORAGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STORAGE.rawValue, 0)
			}
			open
			func DISK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISK.rawValue, 0)
			}
			open
			func MEMORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEMORY.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterStorageColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitStorageColumnConstraint(self)
			}
		}
	}
	public class VisibilityColumnConstraintContext: ColumnConstraintContext {
			open
			func VISIBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VISIBLE.rawValue, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterVisibilityColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitVisibilityColumnConstraint(self)
			}
		}
	}
	public class AutoIncrementColumnConstraintContext: ColumnConstraintContext {
			open
			func AUTO_INCREMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTO_INCREMENT.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func UPDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPDATE.rawValue, 0)
			}
			open
			func currentTimestamp() -> CurrentTimestampContext? {
				return getRuleContext(CurrentTimestampContext.self, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAutoIncrementColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAutoIncrementColumnConstraint(self)
			}
		}
	}
	public class CommentColumnConstraintContext: ColumnConstraintContext {
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCommentColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCommentColumnConstraint(self)
			}
		}
	}
	public class UniqueKeyColumnConstraintContext: ColumnConstraintContext {
			open
			func UNIQUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNIQUE.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUniqueKeyColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUniqueKeyColumnConstraint(self)
			}
		}
	}
	public class SerialDefaultColumnConstraintContext: ColumnConstraintContext {
			open
			func SERIAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SERIAL.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUE.rawValue, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSerialDefaultColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSerialDefaultColumnConstraint(self)
			}
		}
	}
	public class GeneratedColumnConstraintContext: ColumnConstraintContext {
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func GENERATED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GENERATED.rawValue, 0)
			}
			open
			func ALWAYS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALWAYS.rawValue, 0)
			}
			open
			func VIRTUAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VIRTUAL.rawValue, 0)
			}
			open
			func STORED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STORED.rawValue, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterGeneratedColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitGeneratedColumnConstraint(self)
			}
		}
	}
	public class FormatColumnConstraintContext: ColumnConstraintContext {
		public var colformat: Token!
			open
			func COLUMN_FORMAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN_FORMAT.rawValue, 0)
			}
			open
			func FIXED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIXED.rawValue, 0)
			}
			open
			func DYNAMIC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DYNAMIC.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFormatColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFormatColumnConstraint(self)
			}
		}
	}
	public class CollateColumnConstraintContext: ColumnConstraintContext {
			open
			func COLLATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATE.rawValue, 0)
			}
			open
			func collationName() -> CollationNameContext? {
				return getRuleContext(CollationNameContext.self, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCollateColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCollateColumnConstraint(self)
			}
		}
	}
	public class PrimaryKeyColumnConstraintContext: ColumnConstraintContext {
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func PRIMARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRIMARY.rawValue, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPrimaryKeyColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPrimaryKeyColumnConstraint(self)
			}
		}
	}
	public class CheckColumnConstraintContext: ColumnConstraintContext {
		public var name: UidContext!
			open
			func CHECK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECK.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func CONSTRAINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCheckColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCheckColumnConstraint(self)
			}
		}
	}
	public class NullColumnConstraintContext: ColumnConstraintContext {
			open
			func nullNotnull() -> NullNotnullContext? {
				return getRuleContext(NullNotnullContext.self, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterNullColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitNullColumnConstraint(self)
			}
		}
	}
	public class DefaultColumnConstraintContext: ColumnConstraintContext {
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func defaultValue() -> DefaultValueContext? {
				return getRuleContext(DefaultValueContext.self, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDefaultColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDefaultColumnConstraint(self)
			}
		}
	}
	public class ReferenceColumnConstraintContext: ColumnConstraintContext {
			open
			func referenceDefinition() -> ReferenceDefinitionContext? {
				return getRuleContext(ReferenceDefinitionContext.self, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterReferenceColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitReferenceColumnConstraint(self)
			}
		}
	}
	public class InvisibilityColumnConstraintContext: ColumnConstraintContext {
			open
			func INVISIBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INVISIBLE.rawValue, 0)
			}

		public
		init(_ ctx: ColumnConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterInvisibilityColumnConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitInvisibilityColumnConstraint(self)
			}
		}
	}
	@discardableResult
	 open func columnConstraint() throws -> ColumnConstraintContext {
		var _localctx: ColumnConstraintContext
		_localctx = ColumnConstraintContext(_ctx, getState())
		try enterRule(_localctx, 94, MySqlParser.RULE_columnConstraint)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1675)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NOT:fallthrough
		 	case .NULL_LITERAL:fallthrough
		 	case .NULL_SPEC_LITERAL:
		 		_localctx =  NullColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1622)
		 		try nullNotnull()

		 		break

		 	case .DEFAULT:
		 		_localctx =  DefaultColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1623)
		 		try match(MySqlParser.Tokens.DEFAULT.rawValue)
		 		setState(1624)
		 		try defaultValue()

		 		break

		 	case .VISIBLE:
		 		_localctx =  VisibilityColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1625)
		 		try match(MySqlParser.Tokens.VISIBLE.rawValue)

		 		break

		 	case .INVISIBLE:
		 		_localctx =  InvisibilityColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1626)
		 		try match(MySqlParser.Tokens.INVISIBLE.rawValue)

		 		break
		 	case .ON:fallthrough
		 	case .AUTO_INCREMENT:
		 		_localctx =  AutoIncrementColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1631)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .AUTO_INCREMENT:
		 			setState(1627)
		 			try match(MySqlParser.Tokens.AUTO_INCREMENT.rawValue)

		 			break

		 		case .ON:
		 			setState(1628)
		 			try match(MySqlParser.Tokens.ON.rawValue)
		 			setState(1629)
		 			try match(MySqlParser.Tokens.UPDATE.rawValue)
		 			setState(1630)
		 			try currentTimestamp()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case .KEY:fallthrough
		 	case .PRIMARY:
		 		_localctx =  PrimaryKeyColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1634)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.PRIMARY.rawValue) {
		 			setState(1633)
		 			try match(MySqlParser.Tokens.PRIMARY.rawValue)

		 		}

		 		setState(1636)
		 		try match(MySqlParser.Tokens.KEY.rawValue)

		 		break

		 	case .UNIQUE:
		 		_localctx =  UniqueKeyColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1637)
		 		try match(MySqlParser.Tokens.UNIQUE.rawValue)
		 		setState(1639)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,153,_ctx)) {
		 		case 1:
		 			setState(1638)
		 			try match(MySqlParser.Tokens.KEY.rawValue)

		 			break
		 		default: break
		 		}

		 		break

		 	case .COMMENT:
		 		_localctx =  CommentColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1641)
		 		try match(MySqlParser.Tokens.COMMENT.rawValue)
		 		setState(1642)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .COLUMN_FORMAT:
		 		_localctx =  FormatColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1643)
		 		try match(MySqlParser.Tokens.COLUMN_FORMAT.rawValue)
		 		setState(1644)
		 		_localctx.castdown(FormatColumnConstraintContext.self).colformat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.DYNAMIC.rawValue || _la == MySqlParser.Tokens.FIXED.rawValue)) {
		 			_localctx.castdown(FormatColumnConstraintContext.self).colformat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .STORAGE:
		 		_localctx =  StorageColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1645)
		 		try match(MySqlParser.Tokens.STORAGE.rawValue)
		 		setState(1646)
		 		_localctx.castdown(StorageColumnConstraintContext.self).storageval = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.DISK.rawValue || _la == MySqlParser.Tokens.MEMORY.rawValue)) {
		 			_localctx.castdown(StorageColumnConstraintContext.self).storageval = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .REFERENCES:
		 		_localctx =  ReferenceColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1647)
		 		try referenceDefinition()

		 		break

		 	case .COLLATE:
		 		_localctx =  CollateColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 12)
		 		setState(1648)
		 		try match(MySqlParser.Tokens.COLLATE.rawValue)
		 		setState(1649)
		 		try collationName()

		 		break
		 	case .AS:fallthrough
		 	case .GENERATED:
		 		_localctx =  GeneratedColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 13)
		 		setState(1652)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.GENERATED.rawValue) {
		 			setState(1650)
		 			try match(MySqlParser.Tokens.GENERATED.rawValue)
		 			setState(1651)
		 			try match(MySqlParser.Tokens.ALWAYS.rawValue)

		 		}

		 		setState(1654)
		 		try match(MySqlParser.Tokens.AS.rawValue)
		 		setState(1655)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1656)
		 		try expression(0)
		 		setState(1657)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(1659)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.STORED.rawValue || _la == MySqlParser.Tokens.VIRTUAL.rawValue) {
		 			setState(1658)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.STORED.rawValue || _la == MySqlParser.Tokens.VIRTUAL.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}


		 		break

		 	case .SERIAL:
		 		_localctx =  SerialDefaultColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 14)
		 		setState(1661)
		 		try match(MySqlParser.Tokens.SERIAL.rawValue)
		 		setState(1662)
		 		try match(MySqlParser.Tokens.DEFAULT.rawValue)
		 		setState(1663)
		 		try match(MySqlParser.Tokens.VALUE.rawValue)

		 		break
		 	case .CHECK:fallthrough
		 	case .CONSTRAINT:
		 		_localctx =  CheckColumnConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 15)
		 		setState(1668)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CONSTRAINT.rawValue) {
		 			setState(1664)
		 			try match(MySqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(1666)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 				setState(1665)
		 				try {
		 						let assignmentValue = try uid()
		 						_localctx.castdown(CheckColumnConstraintContext.self).name = assignmentValue
		 				     }()


		 			}


		 		}

		 		setState(1670)
		 		try match(MySqlParser.Tokens.CHECK.rawValue)
		 		setState(1671)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1672)
		 		try expression(0)
		 		setState(1673)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TableConstraintContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tableConstraint
		}
	}
	public class UniqueKeyTableConstraintContext: TableConstraintContext {
		public var name: UidContext!
		public var indexFormat: Token!
		public var index: UidContext!
			open
			func UNIQUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNIQUE.rawValue, 0)
			}
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func CONSTRAINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT.rawValue, 0)
			}
			open
			func indexType() -> IndexTypeContext? {
				return getRuleContext(IndexTypeContext.self, 0)
			}
			open
			func indexOption() -> [IndexOptionContext] {
				return getRuleContexts(IndexOptionContext.self)
			}
			open
			func indexOption(_ i: Int) -> IndexOptionContext? {
				return getRuleContext(IndexOptionContext.self, i)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}

		public
		init(_ ctx: TableConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUniqueKeyTableConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUniqueKeyTableConstraint(self)
			}
		}
	}
	public class CheckTableConstraintContext: TableConstraintContext {
		public var name: UidContext!
			open
			func CHECK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECK.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func CONSTRAINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}

		public
		init(_ ctx: TableConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCheckTableConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCheckTableConstraint(self)
			}
		}
	}
	public class PrimaryKeyTableConstraintContext: TableConstraintContext {
		public var name: UidContext!
		public var index: UidContext!
			open
			func PRIMARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRIMARY.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func CONSTRAINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT.rawValue, 0)
			}
			open
			func indexType() -> IndexTypeContext? {
				return getRuleContext(IndexTypeContext.self, 0)
			}
			open
			func indexOption() -> [IndexOptionContext] {
				return getRuleContexts(IndexOptionContext.self)
			}
			open
			func indexOption(_ i: Int) -> IndexOptionContext? {
				return getRuleContext(IndexOptionContext.self, i)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}

		public
		init(_ ctx: TableConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPrimaryKeyTableConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPrimaryKeyTableConstraint(self)
			}
		}
	}
	public class ForeignKeyTableConstraintContext: TableConstraintContext {
		public var name: UidContext!
		public var index: UidContext!
			open
			func FOREIGN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOREIGN.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func referenceDefinition() -> ReferenceDefinitionContext? {
				return getRuleContext(ReferenceDefinitionContext.self, 0)
			}
			open
			func CONSTRAINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}

		public
		init(_ ctx: TableConstraintContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterForeignKeyTableConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitForeignKeyTableConstraint(self)
			}
		}
	}
	@discardableResult
	 open func tableConstraint() throws -> TableConstraintContext {
		var _localctx: TableConstraintContext
		_localctx = TableConstraintContext(_ctx, getState())
		try enterRule(_localctx, 96, MySqlParser.RULE_tableConstraint)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1746)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,175, _ctx)) {
		 	case 1:
		 		_localctx =  PrimaryKeyTableConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1681)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CONSTRAINT.rawValue) {
		 			setState(1677)
		 			try match(MySqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(1679)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,159,_ctx)) {
		 			case 1:
		 				setState(1678)
		 				try {
		 						let assignmentValue = try uid()
		 						_localctx.castdown(PrimaryKeyTableConstraintContext.self).name = assignmentValue
		 				     }()


		 				break
		 			default: break
		 			}

		 		}

		 		setState(1683)
		 		try match(MySqlParser.Tokens.PRIMARY.rawValue)
		 		setState(1684)
		 		try match(MySqlParser.Tokens.KEY.rawValue)
		 		setState(1686)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(1685)
		 			try {
		 					let assignmentValue = try uid()
		 					_localctx.castdown(PrimaryKeyTableConstraintContext.self).index = assignmentValue
		 			     }()


		 		}

		 		setState(1689)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.USING.rawValue) {
		 			setState(1688)
		 			try indexType()

		 		}

		 		setState(1691)
		 		try indexColumnNames()
		 		setState(1695)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.USING.rawValue || _la == MySqlParser.Tokens.WITH.rawValue || _la == MySqlParser.Tokens.COMMENT.rawValue || _la == MySqlParser.Tokens.INVISIBLE.rawValue || _la == MySqlParser.Tokens.KEY_BLOCK_SIZE.rawValue || _la == MySqlParser.Tokens.VISIBLE.rawValue || _la == MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue || _la == MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue) {
		 			setState(1692)
		 			try indexOption()


		 			setState(1697)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		_localctx =  UniqueKeyTableConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1702)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CONSTRAINT.rawValue) {
		 			setState(1698)
		 			try match(MySqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(1700)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 				setState(1699)
		 				try {
		 						let assignmentValue = try uid()
		 						_localctx.castdown(UniqueKeyTableConstraintContext.self).name = assignmentValue
		 				     }()


		 			}


		 		}

		 		setState(1704)
		 		try match(MySqlParser.Tokens.UNIQUE.rawValue)
		 		setState(1706)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue) {
		 			setState(1705)
		 			_localctx.castdown(UniqueKeyTableConstraintContext.self).indexFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue)) {
		 				_localctx.castdown(UniqueKeyTableConstraintContext.self).indexFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(1709)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(1708)
		 			try {
		 					let assignmentValue = try uid()
		 					_localctx.castdown(UniqueKeyTableConstraintContext.self).index = assignmentValue
		 			     }()


		 		}

		 		setState(1712)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.USING.rawValue) {
		 			setState(1711)
		 			try indexType()

		 		}

		 		setState(1714)
		 		try indexColumnNames()
		 		setState(1718)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.USING.rawValue || _la == MySqlParser.Tokens.WITH.rawValue || _la == MySqlParser.Tokens.COMMENT.rawValue || _la == MySqlParser.Tokens.INVISIBLE.rawValue || _la == MySqlParser.Tokens.KEY_BLOCK_SIZE.rawValue || _la == MySqlParser.Tokens.VISIBLE.rawValue || _la == MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue || _la == MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue) {
		 			setState(1715)
		 			try indexOption()


		 			setState(1720)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 3:
		 		_localctx =  ForeignKeyTableConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1725)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CONSTRAINT.rawValue) {
		 			setState(1721)
		 			try match(MySqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(1723)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 				setState(1722)
		 				try {
		 						let assignmentValue = try uid()
		 						_localctx.castdown(ForeignKeyTableConstraintContext.self).name = assignmentValue
		 				     }()


		 			}


		 		}

		 		setState(1727)
		 		try match(MySqlParser.Tokens.FOREIGN.rawValue)
		 		setState(1728)
		 		try match(MySqlParser.Tokens.KEY.rawValue)
		 		setState(1730)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(1729)
		 			try {
		 					let assignmentValue = try uid()
		 					_localctx.castdown(ForeignKeyTableConstraintContext.self).index = assignmentValue
		 			     }()


		 		}

		 		setState(1732)
		 		try indexColumnNames()
		 		setState(1733)
		 		try referenceDefinition()

		 		break
		 	case 4:
		 		_localctx =  CheckTableConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1739)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CONSTRAINT.rawValue) {
		 			setState(1735)
		 			try match(MySqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(1737)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 				setState(1736)
		 				try {
		 						let assignmentValue = try uid()
		 						_localctx.castdown(CheckTableConstraintContext.self).name = assignmentValue
		 				     }()


		 			}


		 		}

		 		setState(1741)
		 		try match(MySqlParser.Tokens.CHECK.rawValue)
		 		setState(1742)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(1743)
		 		try expression(0)
		 		setState(1744)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReferenceDefinitionContext: ParserRuleContext {
		open var matchType: Token!
			open
			func REFERENCES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REFERENCES.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func MATCH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MATCH.rawValue, 0)
			}
			open
			func referenceAction() -> ReferenceActionContext? {
				return getRuleContext(ReferenceActionContext.self, 0)
			}
			open
			func FULL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FULL.rawValue, 0)
			}
			open
			func PARTIAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTIAL.rawValue, 0)
			}
			open
			func SIMPLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SIMPLE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_referenceDefinition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterReferenceDefinition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitReferenceDefinition(self)
			}
		}
	}
	@discardableResult
	 open func referenceDefinition() throws -> ReferenceDefinitionContext {
		var _localctx: ReferenceDefinitionContext
		_localctx = ReferenceDefinitionContext(_ctx, getState())
		try enterRule(_localctx, 98, MySqlParser.RULE_referenceDefinition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(1748)
		 	try match(MySqlParser.Tokens.REFERENCES.rawValue)
		 	setState(1749)
		 	try tableName()
		 	setState(1751)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,176,_ctx)) {
		 	case 1:
		 		setState(1750)
		 		try indexColumnNames()

		 		break
		 	default: break
		 	}
		 	setState(1755)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.MATCH.rawValue) {
		 		setState(1753)
		 		try match(MySqlParser.Tokens.MATCH.rawValue)
		 		setState(1754)
		 		_localctx.castdown(ReferenceDefinitionContext.self).matchType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FULL.rawValue || _la == MySqlParser.Tokens.PARTIAL.rawValue || _la == MySqlParser.Tokens.SIMPLE.rawValue)) {
		 			_localctx.castdown(ReferenceDefinitionContext.self).matchType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(1758)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,178,_ctx)) {
		 	case 1:
		 		setState(1757)
		 		try referenceAction()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReferenceActionContext: ParserRuleContext {
		open var onDelete: ReferenceControlTypeContext!
		open var onUpdate: ReferenceControlTypeContext!
			open
			func ON() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ON.rawValue)
			}
			open
			func ON(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, i)
			}
			open
			func DELETE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DELETE.rawValue, 0)
			}
			open
			func referenceControlType() -> [ReferenceControlTypeContext] {
				return getRuleContexts(ReferenceControlTypeContext.self)
			}
			open
			func referenceControlType(_ i: Int) -> ReferenceControlTypeContext? {
				return getRuleContext(ReferenceControlTypeContext.self, i)
			}
			open
			func UPDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPDATE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_referenceAction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterReferenceAction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitReferenceAction(self)
			}
		}
	}
	@discardableResult
	 open func referenceAction() throws -> ReferenceActionContext {
		var _localctx: ReferenceActionContext
		_localctx = ReferenceActionContext(_ctx, getState())
		try enterRule(_localctx, 100, MySqlParser.RULE_referenceAction)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1776)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,181, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1760)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(1761)
		 		try match(MySqlParser.Tokens.DELETE.rawValue)
		 		setState(1762)
		 		try {
		 				let assignmentValue = try referenceControlType()
		 				_localctx.castdown(ReferenceActionContext.self).onDelete = assignmentValue
		 		     }()

		 		setState(1766)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,179,_ctx)) {
		 		case 1:
		 			setState(1763)
		 			try match(MySqlParser.Tokens.ON.rawValue)
		 			setState(1764)
		 			try match(MySqlParser.Tokens.UPDATE.rawValue)
		 			setState(1765)
		 			try {
		 					let assignmentValue = try referenceControlType()
		 					_localctx.castdown(ReferenceActionContext.self).onUpdate = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1768)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(1769)
		 		try match(MySqlParser.Tokens.UPDATE.rawValue)
		 		setState(1770)
		 		try {
		 				let assignmentValue = try referenceControlType()
		 				_localctx.castdown(ReferenceActionContext.self).onUpdate = assignmentValue
		 		     }()

		 		setState(1774)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,180,_ctx)) {
		 		case 1:
		 			setState(1771)
		 			try match(MySqlParser.Tokens.ON.rawValue)
		 			setState(1772)
		 			try match(MySqlParser.Tokens.DELETE.rawValue)
		 			setState(1773)
		 			try {
		 					let assignmentValue = try referenceControlType()
		 					_localctx.castdown(ReferenceActionContext.self).onDelete = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReferenceControlTypeContext: ParserRuleContext {
			open
			func RESTRICT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESTRICT.rawValue, 0)
			}
			open
			func CASCADE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CASCADE.rawValue, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func NULL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NULL_LITERAL.rawValue, 0)
			}
			open
			func NO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NO.rawValue, 0)
			}
			open
			func ACTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ACTION.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_referenceControlType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterReferenceControlType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitReferenceControlType(self)
			}
		}
	}
	@discardableResult
	 open func referenceControlType() throws -> ReferenceControlTypeContext {
		var _localctx: ReferenceControlTypeContext
		_localctx = ReferenceControlTypeContext(_ctx, getState())
		try enterRule(_localctx, 102, MySqlParser.RULE_referenceControlType)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1786)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,182, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1778)
		 		try match(MySqlParser.Tokens.RESTRICT.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1779)
		 		try match(MySqlParser.Tokens.CASCADE.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1780)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(1781)
		 		try match(MySqlParser.Tokens.NULL_LITERAL.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1782)
		 		try match(MySqlParser.Tokens.NO.rawValue)
		 		setState(1783)
		 		try match(MySqlParser.Tokens.ACTION.rawValue)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1784)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(1785)
		 		try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexColumnDefinitionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_indexColumnDefinition
		}
	}
	public class SpecialIndexDeclarationContext: IndexColumnDefinitionContext {
		public var indexFormat: Token!
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func FULLTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FULLTEXT.rawValue, 0)
			}
			open
			func SPATIAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SPATIAL.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func indexOption() -> [IndexOptionContext] {
				return getRuleContexts(IndexOptionContext.self)
			}
			open
			func indexOption(_ i: Int) -> IndexOptionContext? {
				return getRuleContext(IndexOptionContext.self, i)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}

		public
		init(_ ctx: IndexColumnDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSpecialIndexDeclaration(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSpecialIndexDeclaration(self)
			}
		}
	}
	public class SimpleIndexDeclarationContext: IndexColumnDefinitionContext {
		public var indexFormat: Token!
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func indexType() -> IndexTypeContext? {
				return getRuleContext(IndexTypeContext.self, 0)
			}
			open
			func indexOption() -> [IndexOptionContext] {
				return getRuleContexts(IndexOptionContext.self)
			}
			open
			func indexOption(_ i: Int) -> IndexOptionContext? {
				return getRuleContext(IndexOptionContext.self, i)
			}

		public
		init(_ ctx: IndexColumnDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSimpleIndexDeclaration(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSimpleIndexDeclaration(self)
			}
		}
	}
	@discardableResult
	 open func indexColumnDefinition() throws -> IndexColumnDefinitionContext {
		var _localctx: IndexColumnDefinitionContext
		_localctx = IndexColumnDefinitionContext(_ctx, getState())
		try enterRule(_localctx, 104, MySqlParser.RULE_indexColumnDefinition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(1816)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .INDEX:fallthrough
		 	case .KEY:
		 		_localctx =  SimpleIndexDeclarationContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1788)
		 		_localctx.castdown(SimpleIndexDeclarationContext.self).indexFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue)) {
		 			_localctx.castdown(SimpleIndexDeclarationContext.self).indexFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1790)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(1789)
		 			try uid()

		 		}

		 		setState(1793)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.USING.rawValue) {
		 			setState(1792)
		 			try indexType()

		 		}

		 		setState(1795)
		 		try indexColumnNames()
		 		setState(1799)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.USING.rawValue || _la == MySqlParser.Tokens.WITH.rawValue || _la == MySqlParser.Tokens.COMMENT.rawValue || _la == MySqlParser.Tokens.INVISIBLE.rawValue || _la == MySqlParser.Tokens.KEY_BLOCK_SIZE.rawValue || _la == MySqlParser.Tokens.VISIBLE.rawValue || _la == MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue || _la == MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue) {
		 			setState(1796)
		 			try indexOption()


		 			setState(1801)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case .FULLTEXT:fallthrough
		 	case .SPATIAL:
		 		_localctx =  SpecialIndexDeclarationContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1802)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FULLTEXT.rawValue || _la == MySqlParser.Tokens.SPATIAL.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1804)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue) {
		 			setState(1803)
		 			_localctx.castdown(SpecialIndexDeclarationContext.self).indexFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue)) {
		 				_localctx.castdown(SpecialIndexDeclarationContext.self).indexFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(1807)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(1806)
		 			try uid()

		 		}

		 		setState(1809)
		 		try indexColumnNames()
		 		setState(1813)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.USING.rawValue || _la == MySqlParser.Tokens.WITH.rawValue || _la == MySqlParser.Tokens.COMMENT.rawValue || _la == MySqlParser.Tokens.INVISIBLE.rawValue || _la == MySqlParser.Tokens.KEY_BLOCK_SIZE.rawValue || _la == MySqlParser.Tokens.VISIBLE.rawValue || _la == MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue || _la == MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue) {
		 			setState(1810)
		 			try indexOption()


		 			setState(1815)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TableOptionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tableOption
		}
	}
	public class TableOptionEngineContext: TableOptionContext {
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func engineName() -> EngineNameContext? {
				return getRuleContext(EngineNameContext.self, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionEngine(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionEngine(self)
			}
		}
	}
	public class TableOptionMaxRowsContext: TableOptionContext {
			open
			func MAX_ROWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_ROWS.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionMaxRows(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionMaxRows(self)
			}
		}
	}
	public class TableOptionCollateContext: TableOptionContext {
			open
			func COLLATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATE.rawValue, 0)
			}
			open
			func collationName() -> CollationNameContext? {
				return getRuleContext(CollationNameContext.self, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionCollate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionCollate(self)
			}
		}
	}
	public class TableOptionPersistentContext: TableOptionContext {
		public var extBoolValue: Token!
			open
			func STATS_PERSISTENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATS_PERSISTENT.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func ZERO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZERO_DECIMAL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionPersistent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionPersistent(self)
			}
		}
	}
	public class TableOptionTablespaceContext: TableOptionContext {
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func tablespaceStorage() -> TablespaceStorageContext? {
				return getRuleContext(TablespaceStorageContext.self, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionTablespace(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionTablespace(self)
			}
		}
	}
	public class TableOptionAutoextendSizeContext: TableOptionContext {
			open
			func AUTOEXTEND_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTOEXTEND_SIZE.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionAutoextendSize(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionAutoextendSize(self)
			}
		}
	}
	public class TableOptionPageCompressedContext: TableOptionContext {
			open
			func PAGE_COMPRESSED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PAGE_COMPRESSED.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func ZERO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZERO_DECIMAL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionPageCompressed(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionPageCompressed(self)
			}
		}
	}
	public class TableOptionStartTransactionContext: TableOptionContext {
			open
			func START() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.START.rawValue, 0)
			}
			open
			func TRANSACTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRANSACTION.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionStartTransaction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionStartTransaction(self)
			}
		}
	}
	public class TableOptionPackKeysContext: TableOptionContext {
		public var extBoolValue: Token!
			open
			func PACK_KEYS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PACK_KEYS.rawValue, 0)
			}
			open
			func ZERO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZERO_DECIMAL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionPackKeys(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionPackKeys(self)
			}
		}
	}
	public class TableOptionPasswordContext: TableOptionContext {
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionPassword(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionPassword(self)
			}
		}
	}
	public class TableOptionUnionContext: TableOptionContext {
			open
			func UNION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNION.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func tables() -> TablesContext? {
				return getRuleContext(TablesContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionUnion(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionUnion(self)
			}
		}
	}
	public class TableOptionSamplePageContext: TableOptionContext {
			open
			func STATS_SAMPLE_PAGES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATS_SAMPLE_PAGES.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionSamplePage(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionSamplePage(self)
			}
		}
	}
	public class TableOptionCharsetContext: TableOptionContext {
			open
			func charSet() -> CharSetContext? {
				return getRuleContext(CharSetContext.self, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func DEFAULT() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.DEFAULT.rawValue)
			}
			open
			func DEFAULT(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, i)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionCharset(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionCharset(self)
			}
		}
	}
	public class TableOptionIndexDirectoryContext: TableOptionContext {
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func DIRECTORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DIRECTORY.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionIndexDirectory(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionIndexDirectory(self)
			}
		}
	}
	public class TableOptionTableTypeContext: TableOptionContext {
			open
			func TABLE_TYPE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE_TYPE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func tableType() -> TableTypeContext? {
				return getRuleContext(TableTypeContext.self, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionTableType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionTableType(self)
			}
		}
	}
	public class TableOptionKeyBlockSizeContext: TableOptionContext {
			open
			func KEY_BLOCK_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY_BLOCK_SIZE.rawValue, 0)
			}
			open
			func fileSizeLiteral() -> FileSizeLiteralContext? {
				return getRuleContext(FileSizeLiteralContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionKeyBlockSize(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionKeyBlockSize(self)
			}
		}
	}
	public class TableOptionEncryptionContext: TableOptionContext {
			open
			func ENCRYPTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENCRYPTION.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionEncryption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionEncryption(self)
			}
		}
	}
	public class TableOptionDataDirectoryContext: TableOptionContext {
			open
			func DIRECTORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DIRECTORY.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func DATA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATA.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionDataDirectory(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionDataDirectory(self)
			}
		}
	}
	public class TableOptionRecalculationContext: TableOptionContext {
		public var extBoolValue: Token!
			open
			func STATS_AUTO_RECALC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATS_AUTO_RECALC.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func ZERO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZERO_DECIMAL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionRecalculation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionRecalculation(self)
			}
		}
	}
	public class TableOptionAutoIncrementContext: TableOptionContext {
			open
			func AUTO_INCREMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTO_INCREMENT.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionAutoIncrement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionAutoIncrement(self)
			}
		}
	}
	public class TableOptionEncryptionKeyIdContext: TableOptionContext {
			open
			func ENCRYPTION_KEY_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENCRYPTION_KEY_ID.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionEncryptionKeyId(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionEncryptionKeyId(self)
			}
		}
	}
	public class TableOptionChecksumContext: TableOptionContext {
		public var boolValue: Token!
			open
			func CHECKSUM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECKSUM.rawValue, 0)
			}
			open
			func PAGE_CHECKSUM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PAGE_CHECKSUM.rawValue, 0)
			}
			open
			func ZERO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZERO_DECIMAL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionChecksum(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionChecksum(self)
			}
		}
	}
	public class TableOptionDelayContext: TableOptionContext {
		public var boolValue: Token!
			open
			func DELAY_KEY_WRITE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DELAY_KEY_WRITE.rawValue, 0)
			}
			open
			func ZERO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZERO_DECIMAL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionDelay(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionDelay(self)
			}
		}
	}
	public class TableOptionConnectionContext: TableOptionContext {
			open
			func CONNECTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONNECTION.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionConnection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionConnection(self)
			}
		}
	}
	public class TableOptionTransactionalContext: TableOptionContext {
			open
			func TRANSACTIONAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRANSACTIONAL.rawValue, 0)
			}
			open
			func ZERO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZERO_DECIMAL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionTransactional(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionTransactional(self)
			}
		}
	}
	public class TableOptionPageCompressionLevelContext: TableOptionContext {
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func PAGE_COMPRESSION_LEVEL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PAGE_COMPRESSION_LEVEL.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionPageCompressionLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionPageCompressionLevel(self)
			}
		}
	}
	public class TableOptionSecondaryEngineAttributeContext: TableOptionContext {
			open
			func SECONDARY_ENGINE_ATTRIBUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionSecondaryEngineAttribute(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionSecondaryEngineAttribute(self)
			}
		}
	}
	public class TableOptionCommentContext: TableOptionContext {
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionComment(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionComment(self)
			}
		}
	}
	public class TableOptionAverageContext: TableOptionContext {
			open
			func AVG_ROW_LENGTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AVG_ROW_LENGTH.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionAverage(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionAverage(self)
			}
		}
	}
	public class TableOptionRowFormatContext: TableOptionContext {
		public var rowFormat: Token!
			open
			func ROW_FORMAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROW_FORMAT.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func DYNAMIC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DYNAMIC.rawValue, 0)
			}
			open
			func FIXED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIXED.rawValue, 0)
			}
			open
			func COMPRESSED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMPRESSED.rawValue, 0)
			}
			open
			func REDUNDANT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REDUNDANT.rawValue, 0)
			}
			open
			func COMPACT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMPACT.rawValue, 0)
			}
			open
			func ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ID.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionRowFormat(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionRowFormat(self)
			}
		}
	}
	public class TableOptionCompressionContext: TableOptionContext {
			open
			func COMPRESSION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMPRESSION.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ID.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionCompression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionCompression(self)
			}
		}
	}
	public class TableOptionInsertMethodContext: TableOptionContext {
		public var insertMethod: Token!
			open
			func INSERT_METHOD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSERT_METHOD.rawValue, 0)
			}
			open
			func NO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NO.rawValue, 0)
			}
			open
			func FIRST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIRST.rawValue, 0)
			}
			open
			func LAST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LAST.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionInsertMethod(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionInsertMethod(self)
			}
		}
	}
	public class TableOptionEngineAttributeContext: TableOptionContext {
			open
			func ENGINE_ATTRIBUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionEngineAttribute(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionEngineAttribute(self)
			}
		}
	}
	public class TableOptionMinRowsContext: TableOptionContext {
			open
			func MIN_ROWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MIN_ROWS.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: TableOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableOptionMinRows(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableOptionMinRows(self)
			}
		}
	}
	@discardableResult
	 open func tableOption() throws -> TableOptionContext {
		var _localctx: TableOptionContext
		_localctx = TableOptionContext(_ctx, getState())
		try enterRule(_localctx, 106, MySqlParser.RULE_tableOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2003)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,227, _ctx)) {
		 	case 1:
		 		_localctx =  TableOptionEngineContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(1818)
		 		try match(MySqlParser.Tokens.ENGINE.rawValue)
		 		setState(1820)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1819)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1823)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,191,_ctx)) {
		 		case 1:
		 			setState(1822)
		 			try engineName()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		_localctx =  TableOptionEngineAttributeContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(1825)
		 		try match(MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue)
		 		setState(1827)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1826)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1829)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 3:
		 		_localctx =  TableOptionAutoextendSizeContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(1830)
		 		try match(MySqlParser.Tokens.AUTOEXTEND_SIZE.rawValue)
		 		setState(1832)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1831)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1834)
		 		try decimalLiteral()

		 		break
		 	case 4:
		 		_localctx =  TableOptionAutoIncrementContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(1835)
		 		try match(MySqlParser.Tokens.AUTO_INCREMENT.rawValue)
		 		setState(1837)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1836)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1839)
		 		try decimalLiteral()

		 		break
		 	case 5:
		 		_localctx =  TableOptionAverageContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(1840)
		 		try match(MySqlParser.Tokens.AVG_ROW_LENGTH.rawValue)
		 		setState(1842)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1841)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1844)
		 		try decimalLiteral()

		 		break
		 	case 6:
		 		_localctx =  TableOptionCharsetContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(1846)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DEFAULT.rawValue) {
		 			setState(1845)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 		}

		 		setState(1848)
		 		try charSet()
		 		setState(1850)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1849)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1854)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .BINARY:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:
		 			setState(1852)
		 			try charsetName()

		 			break

		 		case .DEFAULT:
		 			setState(1853)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 7:
		 		_localctx =  TableOptionChecksumContext(_localctx);
		 		try enterOuterAlt(_localctx, 7)
		 		setState(1856)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.CHECKSUM.rawValue || _la == MySqlParser.Tokens.PAGE_CHECKSUM.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1858)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1857)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1860)
		 		_localctx.castdown(TableOptionChecksumContext.self).boolValue = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ZERO_DECIMAL.rawValue || _la == MySqlParser.Tokens.ONE_DECIMAL.rawValue)) {
		 			_localctx.castdown(TableOptionChecksumContext.self).boolValue = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 8:
		 		_localctx =  TableOptionCollateContext(_localctx);
		 		try enterOuterAlt(_localctx, 8)
		 		setState(1862)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DEFAULT.rawValue) {
		 			setState(1861)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 		}

		 		setState(1864)
		 		try match(MySqlParser.Tokens.COLLATE.rawValue)
		 		setState(1866)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1865)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1868)
		 		try collationName()

		 		break
		 	case 9:
		 		_localctx =  TableOptionCommentContext(_localctx);
		 		try enterOuterAlt(_localctx, 9)
		 		setState(1869)
		 		try match(MySqlParser.Tokens.COMMENT.rawValue)
		 		setState(1871)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1870)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1873)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 10:
		 		_localctx =  TableOptionCompressionContext(_localctx);
		 		try enterOuterAlt(_localctx, 10)
		 		setState(1874)
		 		try match(MySqlParser.Tokens.COMPRESSION.rawValue)
		 		setState(1876)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1875)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1878)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.STRING_LITERAL.rawValue || _la == MySqlParser.Tokens.ID.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 11:
		 		_localctx =  TableOptionConnectionContext(_localctx);
		 		try enterOuterAlt(_localctx, 11)
		 		setState(1879)
		 		try match(MySqlParser.Tokens.CONNECTION.rawValue)
		 		setState(1881)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1880)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1883)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 12:
		 		_localctx =  TableOptionDataDirectoryContext(_localctx);
		 		try enterOuterAlt(_localctx, 12)
		 		setState(1884)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.DATA.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1885)
		 		try match(MySqlParser.Tokens.DIRECTORY.rawValue)
		 		setState(1887)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1886)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1889)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 13:
		 		_localctx =  TableOptionDelayContext(_localctx);
		 		try enterOuterAlt(_localctx, 13)
		 		setState(1890)
		 		try match(MySqlParser.Tokens.DELAY_KEY_WRITE.rawValue)
		 		setState(1892)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1891)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1894)
		 		_localctx.castdown(TableOptionDelayContext.self).boolValue = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ZERO_DECIMAL.rawValue || _la == MySqlParser.Tokens.ONE_DECIMAL.rawValue)) {
		 			_localctx.castdown(TableOptionDelayContext.self).boolValue = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 14:
		 		_localctx =  TableOptionEncryptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 14)
		 		setState(1895)
		 		try match(MySqlParser.Tokens.ENCRYPTION.rawValue)
		 		setState(1897)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1896)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1899)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 15:
		 		_localctx =  TableOptionPageCompressedContext(_localctx);
		 		try enterOuterAlt(_localctx, 15)
		 		setState(1900)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.PAGE_COMPRESSED.rawValue || _la == MySqlParser.Tokens.STRING_LITERAL.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1902)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1901)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1904)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ZERO_DECIMAL.rawValue || _la == MySqlParser.Tokens.ONE_DECIMAL.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 16:
		 		_localctx =  TableOptionPageCompressionLevelContext(_localctx);
		 		try enterOuterAlt(_localctx, 16)
		 		setState(1905)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.PAGE_COMPRESSION_LEVEL.rawValue || _la == MySqlParser.Tokens.STRING_LITERAL.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(1907)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1906)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1909)
		 		try decimalLiteral()

		 		break
		 	case 17:
		 		_localctx =  TableOptionEncryptionKeyIdContext(_localctx);
		 		try enterOuterAlt(_localctx, 17)
		 		setState(1910)
		 		try match(MySqlParser.Tokens.ENCRYPTION_KEY_ID.rawValue)
		 		setState(1912)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1911)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1914)
		 		try decimalLiteral()

		 		break
		 	case 18:
		 		_localctx =  TableOptionIndexDirectoryContext(_localctx);
		 		try enterOuterAlt(_localctx, 18)
		 		setState(1915)
		 		try match(MySqlParser.Tokens.INDEX.rawValue)
		 		setState(1916)
		 		try match(MySqlParser.Tokens.DIRECTORY.rawValue)
		 		setState(1918)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1917)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1920)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 19:
		 		_localctx =  TableOptionInsertMethodContext(_localctx);
		 		try enterOuterAlt(_localctx, 19)
		 		setState(1921)
		 		try match(MySqlParser.Tokens.INSERT_METHOD.rawValue)
		 		setState(1923)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1922)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1925)
		 		_localctx.castdown(TableOptionInsertMethodContext.self).insertMethod = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FIRST.rawValue || _la == MySqlParser.Tokens.LAST.rawValue || _la == MySqlParser.Tokens.NO.rawValue)) {
		 			_localctx.castdown(TableOptionInsertMethodContext.self).insertMethod = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 20:
		 		_localctx =  TableOptionKeyBlockSizeContext(_localctx);
		 		try enterOuterAlt(_localctx, 20)
		 		setState(1926)
		 		try match(MySqlParser.Tokens.KEY_BLOCK_SIZE.rawValue)
		 		setState(1928)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1927)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1930)
		 		try fileSizeLiteral()

		 		break
		 	case 21:
		 		_localctx =  TableOptionMaxRowsContext(_localctx);
		 		try enterOuterAlt(_localctx, 21)
		 		setState(1931)
		 		try match(MySqlParser.Tokens.MAX_ROWS.rawValue)
		 		setState(1933)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1932)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1935)
		 		try decimalLiteral()

		 		break
		 	case 22:
		 		_localctx =  TableOptionMinRowsContext(_localctx);
		 		try enterOuterAlt(_localctx, 22)
		 		setState(1936)
		 		try match(MySqlParser.Tokens.MIN_ROWS.rawValue)
		 		setState(1938)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1937)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1940)
		 		try decimalLiteral()

		 		break
		 	case 23:
		 		_localctx =  TableOptionPackKeysContext(_localctx);
		 		try enterOuterAlt(_localctx, 23)
		 		setState(1941)
		 		try match(MySqlParser.Tokens.PACK_KEYS.rawValue)
		 		setState(1943)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1942)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1945)
		 		_localctx.castdown(TableOptionPackKeysContext.self).extBoolValue = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.ZERO_DECIMAL.rawValue || _la == MySqlParser.Tokens.ONE_DECIMAL.rawValue)) {
		 			_localctx.castdown(TableOptionPackKeysContext.self).extBoolValue = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 24:
		 		_localctx =  TableOptionPasswordContext(_localctx);
		 		try enterOuterAlt(_localctx, 24)
		 		setState(1946)
		 		try match(MySqlParser.Tokens.PASSWORD.rawValue)
		 		setState(1948)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1947)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1950)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 25:
		 		_localctx =  TableOptionRowFormatContext(_localctx);
		 		try enterOuterAlt(_localctx, 25)
		 		setState(1951)
		 		try match(MySqlParser.Tokens.ROW_FORMAT.rawValue)
		 		setState(1953)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1952)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1955)
		 		_localctx.castdown(TableOptionRowFormatContext.self).rowFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || ((Int64((_la - 370)) & ~0x3f) == 0 && ((Int64(1) << (_la - 370)) & 2305843013508661253) != 0) || _la == MySqlParser.Tokens.REDUNDANT.rawValue || _la == MySqlParser.Tokens.ID.rawValue)) {
		 			_localctx.castdown(TableOptionRowFormatContext.self).rowFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 26:
		 		_localctx =  TableOptionStartTransactionContext(_localctx);
		 		try enterOuterAlt(_localctx, 26)
		 		setState(1956)
		 		try match(MySqlParser.Tokens.START.rawValue)
		 		setState(1957)
		 		try match(MySqlParser.Tokens.TRANSACTION.rawValue)

		 		break
		 	case 27:
		 		_localctx =  TableOptionSecondaryEngineAttributeContext(_localctx);
		 		try enterOuterAlt(_localctx, 27)
		 		setState(1958)
		 		try match(MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue)
		 		setState(1960)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1959)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1962)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 28:
		 		_localctx =  TableOptionRecalculationContext(_localctx);
		 		try enterOuterAlt(_localctx, 28)
		 		setState(1963)
		 		try match(MySqlParser.Tokens.STATS_AUTO_RECALC.rawValue)
		 		setState(1965)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1964)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1967)
		 		_localctx.castdown(TableOptionRecalculationContext.self).extBoolValue = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.ZERO_DECIMAL.rawValue || _la == MySqlParser.Tokens.ONE_DECIMAL.rawValue)) {
		 			_localctx.castdown(TableOptionRecalculationContext.self).extBoolValue = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 29:
		 		_localctx =  TableOptionPersistentContext(_localctx);
		 		try enterOuterAlt(_localctx, 29)
		 		setState(1968)
		 		try match(MySqlParser.Tokens.STATS_PERSISTENT.rawValue)
		 		setState(1970)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1969)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1972)
		 		_localctx.castdown(TableOptionPersistentContext.self).extBoolValue = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.ZERO_DECIMAL.rawValue || _la == MySqlParser.Tokens.ONE_DECIMAL.rawValue)) {
		 			_localctx.castdown(TableOptionPersistentContext.self).extBoolValue = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 30:
		 		_localctx =  TableOptionSamplePageContext(_localctx);
		 		try enterOuterAlt(_localctx, 30)
		 		setState(1973)
		 		try match(MySqlParser.Tokens.STATS_SAMPLE_PAGES.rawValue)
		 		setState(1975)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1974)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1979)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .DEFAULT:
		 			setState(1977)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		case .ZERO_DECIMAL:fallthrough
		 		case .ONE_DECIMAL:fallthrough
		 		case .TWO_DECIMAL:fallthrough
		 		case .DECIMAL_LITERAL:fallthrough
		 		case .REAL_LITERAL:
		 			setState(1978)
		 			try decimalLiteral()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 31:
		 		_localctx =  TableOptionTablespaceContext(_localctx);
		 		try enterOuterAlt(_localctx, 31)
		 		setState(1981)
		 		try match(MySqlParser.Tokens.TABLESPACE.rawValue)
		 		setState(1982)
		 		try uid()
		 		setState(1984)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,224,_ctx)) {
		 		case 1:
		 			setState(1983)
		 			try tablespaceStorage()

		 			break
		 		default: break
		 		}

		 		break
		 	case 32:
		 		_localctx =  TableOptionTableTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 32)
		 		setState(1986)
		 		try match(MySqlParser.Tokens.TABLE_TYPE.rawValue)
		 		setState(1987)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(1988)
		 		try tableType()

		 		break
		 	case 33:
		 		_localctx =  TableOptionTablespaceContext(_localctx);
		 		try enterOuterAlt(_localctx, 33)
		 		setState(1989)
		 		try tablespaceStorage()

		 		break
		 	case 34:
		 		_localctx =  TableOptionTransactionalContext(_localctx);
		 		try enterOuterAlt(_localctx, 34)
		 		setState(1990)
		 		try match(MySqlParser.Tokens.TRANSACTIONAL.rawValue)
		 		setState(1992)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1991)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1994)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ZERO_DECIMAL.rawValue || _la == MySqlParser.Tokens.ONE_DECIMAL.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 35:
		 		_localctx =  TableOptionUnionContext(_localctx);
		 		try enterOuterAlt(_localctx, 35)
		 		setState(1995)
		 		try match(MySqlParser.Tokens.UNION.rawValue)
		 		setState(1997)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(1996)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(1999)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2000)
		 		try tables()
		 		setState(2001)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TableTypeContext: ParserRuleContext {
			open
			func MYSQL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MYSQL.rawValue, 0)
			}
			open
			func ODBC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ODBC.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tableType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableType(self)
			}
		}
	}
	@discardableResult
	 open func tableType() throws -> TableTypeContext {
		var _localctx: TableTypeContext
		_localctx = TableTypeContext(_ctx, getState())
		try enterRule(_localctx, 108, MySqlParser.RULE_tableType)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2005)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.MYSQL.rawValue || _la == MySqlParser.Tokens.ODBC.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TablespaceStorageContext: ParserRuleContext {
			open
			func STORAGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STORAGE.rawValue, 0)
			}
			open
			func DISK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISK.rawValue, 0)
			}
			open
			func MEMORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEMORY.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tablespaceStorage
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTablespaceStorage(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTablespaceStorage(self)
			}
		}
	}
	@discardableResult
	 open func tablespaceStorage() throws -> TablespaceStorageContext {
		var _localctx: TablespaceStorageContext
		_localctx = TablespaceStorageContext(_ctx, getState())
		try enterRule(_localctx, 110, MySqlParser.RULE_tablespaceStorage)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2007)
		 	try match(MySqlParser.Tokens.STORAGE.rawValue)
		 	setState(2008)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.DISK.rawValue || _la == MySqlParser.Tokens.MEMORY.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PartitionDefinitionsContext: ParserRuleContext {
		open var count: DecimalLiteralContext!
		open var subCount: DecimalLiteralContext!
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func BY() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.BY.rawValue)
			}
			open
			func BY(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, i)
			}
			open
			func partitionFunctionDefinition() -> PartitionFunctionDefinitionContext? {
				return getRuleContext(PartitionFunctionDefinitionContext.self, 0)
			}
			open
			func PARTITIONS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITIONS.rawValue, 0)
			}
			open
			func SUBPARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBPARTITION.rawValue, 0)
			}
			open
			func subpartitionFunctionDefinition() -> SubpartitionFunctionDefinitionContext? {
				return getRuleContext(SubpartitionFunctionDefinitionContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func partitionDefinition() -> [PartitionDefinitionContext] {
				return getRuleContexts(PartitionDefinitionContext.self)
			}
			open
			func partitionDefinition(_ i: Int) -> PartitionDefinitionContext? {
				return getRuleContext(PartitionDefinitionContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func decimalLiteral() -> [DecimalLiteralContext] {
				return getRuleContexts(DecimalLiteralContext.self)
			}
			open
			func decimalLiteral(_ i: Int) -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, i)
			}
			open
			func SUBPARTITIONS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBPARTITIONS.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_partitionDefinitions
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionDefinitions(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionDefinitions(self)
			}
		}
	}
	@discardableResult
	 open func partitionDefinitions() throws -> PartitionDefinitionsContext {
		var _localctx: PartitionDefinitionsContext
		_localctx = PartitionDefinitionsContext(_ctx, getState())
		try enterRule(_localctx, 112, MySqlParser.RULE_partitionDefinitions)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2010)
		 	try match(MySqlParser.Tokens.PARTITION.rawValue)
		 	setState(2011)
		 	try match(MySqlParser.Tokens.BY.rawValue)
		 	setState(2012)
		 	try partitionFunctionDefinition()
		 	setState(2015)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.PARTITIONS.rawValue) {
		 		setState(2013)
		 		try match(MySqlParser.Tokens.PARTITIONS.rawValue)
		 		setState(2014)
		 		try {
		 				let assignmentValue = try decimalLiteral()
		 				_localctx.castdown(PartitionDefinitionsContext.self).count = assignmentValue
		 		     }()


		 	}

		 	setState(2024)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.SUBPARTITION.rawValue) {
		 		setState(2017)
		 		try match(MySqlParser.Tokens.SUBPARTITION.rawValue)
		 		setState(2018)
		 		try match(MySqlParser.Tokens.BY.rawValue)
		 		setState(2019)
		 		try subpartitionFunctionDefinition()
		 		setState(2022)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.SUBPARTITIONS.rawValue) {
		 			setState(2020)
		 			try match(MySqlParser.Tokens.SUBPARTITIONS.rawValue)
		 			setState(2021)
		 			try {
		 					let assignmentValue = try decimalLiteral()
		 					_localctx.castdown(PartitionDefinitionsContext.self).subCount = assignmentValue
		 			     }()


		 		}


		 	}

		 	setState(2037)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,232,_ctx)) {
		 	case 1:
		 		setState(2026)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2027)
		 		try partitionDefinition()
		 		setState(2032)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(2028)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(2029)
		 			try partitionDefinition()


		 			setState(2034)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2035)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PartitionFunctionDefinitionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_partitionFunctionDefinition
		}
	}
	public class PartitionFunctionKeyContext: PartitionFunctionDefinitionContext {
		public var algType: Token!
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func LINEAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINEAR.rawValue, 0)
			}
			open
			func ALGORITHM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALGORITHM.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
			open
			func TWO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TWO_DECIMAL.rawValue, 0)
			}

		public
		init(_ ctx: PartitionFunctionDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionFunctionKey(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionFunctionKey(self)
			}
		}
	}
	public class PartitionFunctionHashContext: PartitionFunctionDefinitionContext {
			open
			func HASH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HASH.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func LINEAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINEAR.rawValue, 0)
			}

		public
		init(_ ctx: PartitionFunctionDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionFunctionHash(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionFunctionHash(self)
			}
		}
	}
	public class PartitionFunctionListContext: PartitionFunctionDefinitionContext {
			open
			func LIST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIST.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COLUMNS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMNS.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}

		public
		init(_ ctx: PartitionFunctionDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionFunctionList(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionFunctionList(self)
			}
		}
	}
	public class PartitionFunctionRangeContext: PartitionFunctionDefinitionContext {
			open
			func RANGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RANGE.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COLUMNS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMNS.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}

		public
		init(_ ctx: PartitionFunctionDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionFunctionRange(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionFunctionRange(self)
			}
		}
	}
	@discardableResult
	 open func partitionFunctionDefinition() throws -> PartitionFunctionDefinitionContext {
		var _localctx: PartitionFunctionDefinitionContext
		_localctx = PartitionFunctionDefinitionContext(_ctx, getState())
		try enterRule(_localctx, 114, MySqlParser.RULE_partitionFunctionDefinition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2085)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,239, _ctx)) {
		 	case 1:
		 		_localctx =  PartitionFunctionHashContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2040)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LINEAR.rawValue) {
		 			setState(2039)
		 			try match(MySqlParser.Tokens.LINEAR.rawValue)

		 		}

		 		setState(2042)
		 		try match(MySqlParser.Tokens.HASH.rawValue)
		 		setState(2043)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2044)
		 		try expression(0)
		 		setState(2045)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 2:
		 		_localctx =  PartitionFunctionKeyContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2048)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LINEAR.rawValue) {
		 			setState(2047)
		 			try match(MySqlParser.Tokens.LINEAR.rawValue)

		 		}

		 		setState(2050)
		 		try match(MySqlParser.Tokens.KEY.rawValue)
		 		setState(2054)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.ALGORITHM.rawValue) {
		 			setState(2051)
		 			try match(MySqlParser.Tokens.ALGORITHM.rawValue)
		 			setState(2052)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 			setState(2053)
		 			_localctx.castdown(PartitionFunctionKeyContext.self).algType = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.ONE_DECIMAL.rawValue || _la == MySqlParser.Tokens.TWO_DECIMAL.rawValue)) {
		 				_localctx.castdown(PartitionFunctionKeyContext.self).algType = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(2056)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2058)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(2057)
		 			try uidList()

		 		}

		 		setState(2060)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 3:
		 		_localctx =  PartitionFunctionRangeContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2061)
		 		try match(MySqlParser.Tokens.RANGE.rawValue)
		 		setState(2071)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .LR_BRACKET:
		 			setState(2062)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2063)
		 			try expression(0)
		 			setState(2064)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break

		 		case .COLUMNS:
		 			setState(2066)
		 			try match(MySqlParser.Tokens.COLUMNS.rawValue)
		 			setState(2067)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2068)
		 			try uidList()
		 			setState(2069)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 4:
		 		_localctx =  PartitionFunctionListContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2073)
		 		try match(MySqlParser.Tokens.LIST.rawValue)
		 		setState(2083)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .LR_BRACKET:
		 			setState(2074)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2075)
		 			try expression(0)
		 			setState(2076)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break

		 		case .COLUMNS:
		 			setState(2078)
		 			try match(MySqlParser.Tokens.COLUMNS.rawValue)
		 			setState(2079)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2080)
		 			try uidList()
		 			setState(2081)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubpartitionFunctionDefinitionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_subpartitionFunctionDefinition
		}
	}
	public class SubPartitionFunctionHashContext: SubpartitionFunctionDefinitionContext {
			open
			func HASH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HASH.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func LINEAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINEAR.rawValue, 0)
			}

		public
		init(_ ctx: SubpartitionFunctionDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSubPartitionFunctionHash(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSubPartitionFunctionHash(self)
			}
		}
	}
	public class SubPartitionFunctionKeyContext: SubpartitionFunctionDefinitionContext {
		public var algType: Token!
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func LINEAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINEAR.rawValue, 0)
			}
			open
			func ALGORITHM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALGORITHM.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
			open
			func TWO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TWO_DECIMAL.rawValue, 0)
			}

		public
		init(_ ctx: SubpartitionFunctionDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSubPartitionFunctionKey(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSubPartitionFunctionKey(self)
			}
		}
	}
	@discardableResult
	 open func subpartitionFunctionDefinition() throws -> SubpartitionFunctionDefinitionContext {
		var _localctx: SubpartitionFunctionDefinitionContext
		_localctx = SubpartitionFunctionDefinitionContext(_ctx, getState())
		try enterRule(_localctx, 116, MySqlParser.RULE_subpartitionFunctionDefinition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2108)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,243, _ctx)) {
		 	case 1:
		 		_localctx =  SubPartitionFunctionHashContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2088)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LINEAR.rawValue) {
		 			setState(2087)
		 			try match(MySqlParser.Tokens.LINEAR.rawValue)

		 		}

		 		setState(2090)
		 		try match(MySqlParser.Tokens.HASH.rawValue)
		 		setState(2091)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2092)
		 		try expression(0)
		 		setState(2093)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 2:
		 		_localctx =  SubPartitionFunctionKeyContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2096)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LINEAR.rawValue) {
		 			setState(2095)
		 			try match(MySqlParser.Tokens.LINEAR.rawValue)

		 		}

		 		setState(2098)
		 		try match(MySqlParser.Tokens.KEY.rawValue)
		 		setState(2102)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.ALGORITHM.rawValue) {
		 			setState(2099)
		 			try match(MySqlParser.Tokens.ALGORITHM.rawValue)
		 			setState(2100)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 			setState(2101)
		 			_localctx.castdown(SubPartitionFunctionKeyContext.self).algType = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.ONE_DECIMAL.rawValue || _la == MySqlParser.Tokens.TWO_DECIMAL.rawValue)) {
		 				_localctx.castdown(SubPartitionFunctionKeyContext.self).algType = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(2104)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2105)
		 		try uidList()
		 		setState(2106)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PartitionDefinitionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_partitionDefinition
		}
	}
	public class PartitionComparisonContext: PartitionDefinitionContext {
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func VALUES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUES.rawValue, 0)
			}
			open
			func LESS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LESS.rawValue, 0)
			}
			open
			func THAN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.THAN.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func partitionDefinerAtom() -> [PartitionDefinerAtomContext] {
				return getRuleContexts(PartitionDefinerAtomContext.self)
			}
			open
			func partitionDefinerAtom(_ i: Int) -> PartitionDefinerAtomContext? {
				return getRuleContext(PartitionDefinerAtomContext.self, i)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func partitionOption() -> [PartitionOptionContext] {
				return getRuleContexts(PartitionOptionContext.self)
			}
			open
			func partitionOption(_ i: Int) -> PartitionOptionContext? {
				return getRuleContext(PartitionOptionContext.self, i)
			}
			open
			func subpartitionDefinition() -> [SubpartitionDefinitionContext] {
				return getRuleContexts(SubpartitionDefinitionContext.self)
			}
			open
			func subpartitionDefinition(_ i: Int) -> SubpartitionDefinitionContext? {
				return getRuleContext(SubpartitionDefinitionContext.self, i)
			}

		public
		init(_ ctx: PartitionDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionComparison(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionComparison(self)
			}
		}
	}
	public class PartitionListAtomContext: PartitionDefinitionContext {
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func VALUES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUES.rawValue, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func partitionDefinerAtom() -> [PartitionDefinerAtomContext] {
				return getRuleContexts(PartitionDefinerAtomContext.self)
			}
			open
			func partitionDefinerAtom(_ i: Int) -> PartitionDefinerAtomContext? {
				return getRuleContext(PartitionDefinerAtomContext.self, i)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func partitionOption() -> [PartitionOptionContext] {
				return getRuleContexts(PartitionOptionContext.self)
			}
			open
			func partitionOption(_ i: Int) -> PartitionOptionContext? {
				return getRuleContext(PartitionOptionContext.self, i)
			}
			open
			func subpartitionDefinition() -> [SubpartitionDefinitionContext] {
				return getRuleContexts(SubpartitionDefinitionContext.self)
			}
			open
			func subpartitionDefinition(_ i: Int) -> SubpartitionDefinitionContext? {
				return getRuleContext(SubpartitionDefinitionContext.self, i)
			}

		public
		init(_ ctx: PartitionDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionListAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionListAtom(self)
			}
		}
	}
	public class PartitionListVectorContext: PartitionDefinitionContext {
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func VALUES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUES.rawValue, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func partitionDefinerVector() -> [PartitionDefinerVectorContext] {
				return getRuleContexts(PartitionDefinerVectorContext.self)
			}
			open
			func partitionDefinerVector(_ i: Int) -> PartitionDefinerVectorContext? {
				return getRuleContext(PartitionDefinerVectorContext.self, i)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func partitionOption() -> [PartitionOptionContext] {
				return getRuleContexts(PartitionOptionContext.self)
			}
			open
			func partitionOption(_ i: Int) -> PartitionOptionContext? {
				return getRuleContext(PartitionOptionContext.self, i)
			}
			open
			func subpartitionDefinition() -> [SubpartitionDefinitionContext] {
				return getRuleContexts(SubpartitionDefinitionContext.self)
			}
			open
			func subpartitionDefinition(_ i: Int) -> SubpartitionDefinitionContext? {
				return getRuleContext(SubpartitionDefinitionContext.self, i)
			}

		public
		init(_ ctx: PartitionDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionListVector(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionListVector(self)
			}
		}
	}
	public class PartitionSimpleContext: PartitionDefinitionContext {
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func partitionOption() -> [PartitionOptionContext] {
				return getRuleContexts(PartitionOptionContext.self)
			}
			open
			func partitionOption(_ i: Int) -> PartitionOptionContext? {
				return getRuleContext(PartitionOptionContext.self, i)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func subpartitionDefinition() -> [SubpartitionDefinitionContext] {
				return getRuleContexts(SubpartitionDefinitionContext.self)
			}
			open
			func subpartitionDefinition(_ i: Int) -> SubpartitionDefinitionContext? {
				return getRuleContext(SubpartitionDefinitionContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: PartitionDefinitionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionSimple(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionSimple(self)
			}
		}
	}
	@discardableResult
	 open func partitionDefinition() throws -> PartitionDefinitionContext {
		var _localctx: PartitionDefinitionContext
		_localctx = PartitionDefinitionContext(_ctx, getState())
		try enterRule(_localctx, 118, MySqlParser.RULE_partitionDefinition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2256)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,262, _ctx)) {
		 	case 1:
		 		_localctx =  PartitionComparisonContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2110)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2111)
		 		try uid()
		 		setState(2112)
		 		try match(MySqlParser.Tokens.VALUES.rawValue)
		 		setState(2113)
		 		try match(MySqlParser.Tokens.LESS.rawValue)
		 		setState(2114)
		 		try match(MySqlParser.Tokens.THAN.rawValue)
		 		setState(2115)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2116)
		 		try partitionDefinerAtom()
		 		setState(2121)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(2117)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(2118)
		 			try partitionDefinerAtom()


		 			setState(2123)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2124)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(2128)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.INDEX.rawValue || ((Int64((_la - 368)) & ~0x3f) == 0 && ((Int64(1) << (_la - 368)) & 2199024304129) != 0) || ((Int64((_la - 500)) & ~0x3f) == 0 && ((Int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParser.Tokens.STORAGE.rawValue || _la == MySqlParser.Tokens.TABLESPACE.rawValue) {
		 			setState(2125)
		 			try partitionOption()


		 			setState(2130)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2142)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 			setState(2131)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2132)
		 			try subpartitionDefinition()
		 			setState(2137)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 				setState(2133)
		 				try match(MySqlParser.Tokens.COMMA.rawValue)
		 				setState(2134)
		 				try subpartitionDefinition()


		 				setState(2139)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(2140)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		}


		 		break
		 	case 2:
		 		_localctx =  PartitionComparisonContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2144)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2145)
		 		try uid()
		 		setState(2146)
		 		try match(MySqlParser.Tokens.VALUES.rawValue)
		 		setState(2147)
		 		try match(MySqlParser.Tokens.LESS.rawValue)
		 		setState(2148)
		 		try match(MySqlParser.Tokens.THAN.rawValue)
		 		setState(2149)
		 		try partitionDefinerAtom()
		 		setState(2153)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.INDEX.rawValue || ((Int64((_la - 368)) & ~0x3f) == 0 && ((Int64(1) << (_la - 368)) & 2199024304129) != 0) || ((Int64((_la - 500)) & ~0x3f) == 0 && ((Int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParser.Tokens.STORAGE.rawValue || _la == MySqlParser.Tokens.TABLESPACE.rawValue) {
		 			setState(2150)
		 			try partitionOption()


		 			setState(2155)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2167)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 			setState(2156)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2157)
		 			try subpartitionDefinition()
		 			setState(2162)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 				setState(2158)
		 				try match(MySqlParser.Tokens.COMMA.rawValue)
		 				setState(2159)
		 				try subpartitionDefinition()


		 				setState(2164)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(2165)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		}


		 		break
		 	case 3:
		 		_localctx =  PartitionListAtomContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2169)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2170)
		 		try uid()
		 		setState(2171)
		 		try match(MySqlParser.Tokens.VALUES.rawValue)
		 		setState(2172)
		 		try match(MySqlParser.Tokens.IN.rawValue)
		 		setState(2173)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2174)
		 		try partitionDefinerAtom()
		 		setState(2179)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(2175)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(2176)
		 			try partitionDefinerAtom()


		 			setState(2181)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2182)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(2186)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.INDEX.rawValue || ((Int64((_la - 368)) & ~0x3f) == 0 && ((Int64(1) << (_la - 368)) & 2199024304129) != 0) || ((Int64((_la - 500)) & ~0x3f) == 0 && ((Int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParser.Tokens.STORAGE.rawValue || _la == MySqlParser.Tokens.TABLESPACE.rawValue) {
		 			setState(2183)
		 			try partitionOption()


		 			setState(2188)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2200)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 			setState(2189)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2190)
		 			try subpartitionDefinition()
		 			setState(2195)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 				setState(2191)
		 				try match(MySqlParser.Tokens.COMMA.rawValue)
		 				setState(2192)
		 				try subpartitionDefinition()


		 				setState(2197)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(2198)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		}


		 		break
		 	case 4:
		 		_localctx =  PartitionListVectorContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2202)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2203)
		 		try uid()
		 		setState(2204)
		 		try match(MySqlParser.Tokens.VALUES.rawValue)
		 		setState(2205)
		 		try match(MySqlParser.Tokens.IN.rawValue)
		 		setState(2206)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2207)
		 		try partitionDefinerVector()
		 		setState(2212)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(2208)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(2209)
		 			try partitionDefinerVector()


		 			setState(2214)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2215)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(2219)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.INDEX.rawValue || ((Int64((_la - 368)) & ~0x3f) == 0 && ((Int64(1) << (_la - 368)) & 2199024304129) != 0) || ((Int64((_la - 500)) & ~0x3f) == 0 && ((Int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParser.Tokens.STORAGE.rawValue || _la == MySqlParser.Tokens.TABLESPACE.rawValue) {
		 			setState(2216)
		 			try partitionOption()


		 			setState(2221)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2233)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 			setState(2222)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2223)
		 			try subpartitionDefinition()
		 			setState(2228)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 				setState(2224)
		 				try match(MySqlParser.Tokens.COMMA.rawValue)
		 				setState(2225)
		 				try subpartitionDefinition()


		 				setState(2230)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(2231)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		}


		 		break
		 	case 5:
		 		_localctx =  PartitionSimpleContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2235)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2236)
		 		try uid()
		 		setState(2240)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.INDEX.rawValue || ((Int64((_la - 368)) & ~0x3f) == 0 && ((Int64(1) << (_la - 368)) & 2199024304129) != 0) || ((Int64((_la - 500)) & ~0x3f) == 0 && ((Int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParser.Tokens.STORAGE.rawValue || _la == MySqlParser.Tokens.TABLESPACE.rawValue) {
		 			setState(2237)
		 			try partitionOption()


		 			setState(2242)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2254)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 			setState(2243)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2244)
		 			try subpartitionDefinition()
		 			setState(2249)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 				setState(2245)
		 				try match(MySqlParser.Tokens.COMMA.rawValue)
		 				setState(2246)
		 				try subpartitionDefinition()


		 				setState(2251)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}
		 			setState(2252)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		}


		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PartitionDefinerAtomContext: ParserRuleContext {
			open
			func constant() -> ConstantContext? {
				return getRuleContext(ConstantContext.self, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func MAXVALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAXVALUE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_partitionDefinerAtom
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionDefinerAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionDefinerAtom(self)
			}
		}
	}
	@discardableResult
	 open func partitionDefinerAtom() throws -> PartitionDefinerAtomContext {
		var _localctx: PartitionDefinerAtomContext
		_localctx = PartitionDefinerAtomContext(_ctx, getState())
		try enterRule(_localctx, 120, MySqlParser.RULE_partitionDefinerAtom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2261)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,263, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2258)
		 		try constant()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2259)
		 		try expression(0)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2260)
		 		try match(MySqlParser.Tokens.MAXVALUE.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PartitionDefinerVectorContext: ParserRuleContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func partitionDefinerAtom() -> [PartitionDefinerAtomContext] {
				return getRuleContexts(PartitionDefinerAtomContext.self)
			}
			open
			func partitionDefinerAtom(_ i: Int) -> PartitionDefinerAtomContext? {
				return getRuleContext(PartitionDefinerAtomContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_partitionDefinerVector
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionDefinerVector(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionDefinerVector(self)
			}
		}
	}
	@discardableResult
	 open func partitionDefinerVector() throws -> PartitionDefinerVectorContext {
		var _localctx: PartitionDefinerVectorContext
		_localctx = PartitionDefinerVectorContext(_ctx, getState())
		try enterRule(_localctx, 122, MySqlParser.RULE_partitionDefinerVector)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2263)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(2264)
		 	try partitionDefinerAtom()
		 	setState(2267) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(2265)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(2266)
		 		try partitionDefinerAtom()


		 		setState(2269); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (_la == MySqlParser.Tokens.COMMA.rawValue)
		 	setState(2271)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SubpartitionDefinitionContext: ParserRuleContext {
			open
			func SUBPARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBPARTITION.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func partitionOption() -> [PartitionOptionContext] {
				return getRuleContexts(PartitionOptionContext.self)
			}
			open
			func partitionOption(_ i: Int) -> PartitionOptionContext? {
				return getRuleContext(PartitionOptionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_subpartitionDefinition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSubpartitionDefinition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSubpartitionDefinition(self)
			}
		}
	}
	@discardableResult
	 open func subpartitionDefinition() throws -> SubpartitionDefinitionContext {
		var _localctx: SubpartitionDefinitionContext
		_localctx = SubpartitionDefinitionContext(_ctx, getState())
		try enterRule(_localctx, 124, MySqlParser.RULE_subpartitionDefinition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2273)
		 	try match(MySqlParser.Tokens.SUBPARTITION.rawValue)
		 	setState(2274)
		 	try uid()
		 	setState(2278)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.INDEX.rawValue || ((Int64((_la - 368)) & ~0x3f) == 0 && ((Int64(1) << (_la - 368)) & 2199024304129) != 0) || ((Int64((_la - 500)) & ~0x3f) == 0 && ((Int64(1) << (_la - 500)) & 268436481) != 0) || _la == MySqlParser.Tokens.STORAGE.rawValue || _la == MySqlParser.Tokens.TABLESPACE.rawValue) {
		 		setState(2275)
		 		try partitionOption()


		 		setState(2280)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PartitionOptionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_partitionOption
		}
	}
	public class PartitionOptionCommentContext: PartitionOptionContext {
		public var comment: Token!
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: PartitionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionOptionComment(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionOptionComment(self)
			}
		}
	}
	public class PartitionOptionNodeGroupContext: PartitionOptionContext {
		public var nodegroup: UidContext!
			open
			func NODEGROUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NODEGROUP.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: PartitionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionOptionNodeGroup(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionOptionNodeGroup(self)
			}
		}
	}
	public class PartitionOptionIndexDirectoryContext: PartitionOptionContext {
		public var indexDirectory: Token!
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func DIRECTORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DIRECTORY.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: PartitionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionOptionIndexDirectory(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionOptionIndexDirectory(self)
			}
		}
	}
	public class PartitionOptionMaxRowsContext: PartitionOptionContext {
		public var maxRows: DecimalLiteralContext!
			open
			func MAX_ROWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_ROWS.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: PartitionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionOptionMaxRows(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionOptionMaxRows(self)
			}
		}
	}
	public class PartitionOptionTablespaceContext: PartitionOptionContext {
		public var tablespace: UidContext!
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: PartitionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionOptionTablespace(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionOptionTablespace(self)
			}
		}
	}
	public class PartitionOptionEngineContext: PartitionOptionContext {
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func engineName() -> EngineNameContext? {
				return getRuleContext(EngineNameContext.self, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func STORAGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STORAGE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: PartitionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionOptionEngine(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionOptionEngine(self)
			}
		}
	}
	public class PartitionOptionMinRowsContext: PartitionOptionContext {
		public var minRows: DecimalLiteralContext!
			open
			func MIN_ROWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MIN_ROWS.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: PartitionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionOptionMinRows(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionOptionMinRows(self)
			}
		}
	}
	public class PartitionOptionDataDirectoryContext: PartitionOptionContext {
		public var dataDirectory: Token!
			open
			func DATA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATA.rawValue, 0)
			}
			open
			func DIRECTORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DIRECTORY.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: PartitionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionOptionDataDirectory(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionOptionDataDirectory(self)
			}
		}
	}
	@discardableResult
	 open func partitionOption() throws -> PartitionOptionContext {
		var _localctx: PartitionOptionContext
		_localctx = PartitionOptionContext(_ctx, getState())
		try enterRule(_localctx, 126, MySqlParser.RULE_partitionOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2329)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DEFAULT:fallthrough
		 	case .ENGINE:fallthrough
		 	case .STORAGE:
		 		_localctx =  PartitionOptionEngineContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2282)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DEFAULT.rawValue) {
		 			setState(2281)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 		}

		 		setState(2285)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.STORAGE.rawValue) {
		 			setState(2284)
		 			try match(MySqlParser.Tokens.STORAGE.rawValue)

		 		}

		 		setState(2287)
		 		try match(MySqlParser.Tokens.ENGINE.rawValue)
		 		setState(2289)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(2288)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(2291)
		 		try engineName()

		 		break

		 	case .COMMENT:
		 		_localctx =  PartitionOptionCommentContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2292)
		 		try match(MySqlParser.Tokens.COMMENT.rawValue)
		 		setState(2294)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(2293)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(2296)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(PartitionOptionCommentContext.self).comment = assignmentValue
		 		     }()


		 		break

		 	case .DATA:
		 		_localctx =  PartitionOptionDataDirectoryContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2297)
		 		try match(MySqlParser.Tokens.DATA.rawValue)
		 		setState(2298)
		 		try match(MySqlParser.Tokens.DIRECTORY.rawValue)
		 		setState(2300)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(2299)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(2302)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(PartitionOptionDataDirectoryContext.self).dataDirectory = assignmentValue
		 		     }()


		 		break

		 	case .INDEX:
		 		_localctx =  PartitionOptionIndexDirectoryContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2303)
		 		try match(MySqlParser.Tokens.INDEX.rawValue)
		 		setState(2304)
		 		try match(MySqlParser.Tokens.DIRECTORY.rawValue)
		 		setState(2306)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(2305)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(2308)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(PartitionOptionIndexDirectoryContext.self).indexDirectory = assignmentValue
		 		     }()


		 		break

		 	case .MAX_ROWS:
		 		_localctx =  PartitionOptionMaxRowsContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2309)
		 		try match(MySqlParser.Tokens.MAX_ROWS.rawValue)
		 		setState(2311)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(2310)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(2313)
		 		try {
		 				let assignmentValue = try decimalLiteral()
		 				_localctx.castdown(PartitionOptionMaxRowsContext.self).maxRows = assignmentValue
		 		     }()


		 		break

		 	case .MIN_ROWS:
		 		_localctx =  PartitionOptionMinRowsContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2314)
		 		try match(MySqlParser.Tokens.MIN_ROWS.rawValue)
		 		setState(2316)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(2315)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(2318)
		 		try {
		 				let assignmentValue = try decimalLiteral()
		 				_localctx.castdown(PartitionOptionMinRowsContext.self).minRows = assignmentValue
		 		     }()


		 		break

		 	case .TABLESPACE:
		 		_localctx =  PartitionOptionTablespaceContext(_localctx);
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2319)
		 		try match(MySqlParser.Tokens.TABLESPACE.rawValue)
		 		setState(2321)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(2320)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(2323)
		 		try {
		 				let assignmentValue = try uid()
		 				_localctx.castdown(PartitionOptionTablespaceContext.self).tablespace = assignmentValue
		 		     }()


		 		break

		 	case .NODEGROUP:
		 		_localctx =  PartitionOptionNodeGroupContext(_localctx);
		 		try enterOuterAlt(_localctx, 8)
		 		setState(2324)
		 		try match(MySqlParser.Tokens.NODEGROUP.rawValue)
		 		setState(2326)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(2325)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(2328)
		 		try {
		 				let assignmentValue = try uid()
		 				_localctx.castdown(PartitionOptionNodeGroupContext.self).nodegroup = assignmentValue
		 		     }()


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterDatabaseContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterDatabase
		}
	}
	public class AlterUpgradeNameContext: AlterDatabaseContext {
		public var dbFormat: Token!
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func UPGRADE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPGRADE.rawValue, 0)
			}
			open
			func DATA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATA.rawValue, 0)
			}
			open
			func DIRECTORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DIRECTORY.rawValue, 0)
			}
			open
			func NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NAME.rawValue, 0)
			}
			open
			func DATABASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATABASE.rawValue, 0)
			}
			open
			func SCHEMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEMA.rawValue, 0)
			}

		public
		init(_ ctx: AlterDatabaseContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterUpgradeName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterUpgradeName(self)
			}
		}
	}
	public class AlterSimpleDatabaseContext: AlterDatabaseContext {
		public var dbFormat: Token!
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func DATABASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATABASE.rawValue, 0)
			}
			open
			func SCHEMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEMA.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func createDatabaseOption() -> [CreateDatabaseOptionContext] {
				return getRuleContexts(CreateDatabaseOptionContext.self)
			}
			open
			func createDatabaseOption(_ i: Int) -> CreateDatabaseOptionContext? {
				return getRuleContext(CreateDatabaseOptionContext.self, i)
			}

		public
		init(_ ctx: AlterDatabaseContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterSimpleDatabase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterSimpleDatabase(self)
			}
		}
	}
	@discardableResult
	 open func alterDatabase() throws -> AlterDatabaseContext {
		var _localctx: AlterDatabaseContext
		_localctx = AlterDatabaseContext(_ctx, getState())
		try enterRule(_localctx, 128, MySqlParser.RULE_alterDatabase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2349)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,279, _ctx)) {
		 	case 1:
		 		_localctx =  AlterSimpleDatabaseContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2331)
		 		try match(MySqlParser.Tokens.ALTER.rawValue)
		 		setState(2332)
		 		_localctx.castdown(AlterSimpleDatabaseContext.self).dbFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DATABASE.rawValue || _la == MySqlParser.Tokens.SCHEMA.rawValue)) {
		 			_localctx.castdown(AlterSimpleDatabaseContext.self).dbFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2334)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,277,_ctx)) {
		 		case 1:
		 			setState(2333)
		 			try uid()

		 			break
		 		default: break
		 		}
		 		setState(2337) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(2336)
		 			try createDatabaseOption()


		 			setState(2339); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 4398214283264) != 0) || _la == MySqlParser.Tokens.READ.rawValue || _la == MySqlParser.Tokens.CHAR.rawValue || _la == MySqlParser.Tokens.ENCRYPTION.rawValue || _la == MySqlParser.Tokens.CHARSET.rawValue)

		 		break
		 	case 2:
		 		_localctx =  AlterUpgradeNameContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2341)
		 		try match(MySqlParser.Tokens.ALTER.rawValue)
		 		setState(2342)
		 		_localctx.castdown(AlterUpgradeNameContext.self).dbFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DATABASE.rawValue || _la == MySqlParser.Tokens.SCHEMA.rawValue)) {
		 			_localctx.castdown(AlterUpgradeNameContext.self).dbFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2343)
		 		try uid()
		 		setState(2344)
		 		try match(MySqlParser.Tokens.UPGRADE.rawValue)
		 		setState(2345)
		 		try match(MySqlParser.Tokens.DATA.rawValue)
		 		setState(2346)
		 		try match(MySqlParser.Tokens.DIRECTORY.rawValue)
		 		setState(2347)
		 		try match(MySqlParser.Tokens.NAME.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterEventContext: ParserRuleContext {
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func EVENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVENT.rawValue, 0)
			}
			open
			func fullId() -> [FullIdContext] {
				return getRuleContexts(FullIdContext.self)
			}
			open
			func fullId(_ i: Int) -> FullIdContext? {
				return getRuleContext(FullIdContext.self, i)
			}
			open
			func ownerStatement() -> OwnerStatementContext? {
				return getRuleContext(OwnerStatementContext.self, 0)
			}
			open
			func ON() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ON.rawValue)
			}
			open
			func ON(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, i)
			}
			open
			func SCHEDULE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEDULE.rawValue, 0)
			}
			open
			func scheduleExpression() -> ScheduleExpressionContext? {
				return getRuleContext(ScheduleExpressionContext.self, 0)
			}
			open
			func COMPLETION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMPLETION.rawValue, 0)
			}
			open
			func PRESERVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRESERVE.rawValue, 0)
			}
			open
			func RENAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RENAME.rawValue, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func enableType() -> EnableTypeContext? {
				return getRuleContext(EnableTypeContext.self, 0)
			}
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func DO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DO.rawValue, 0)
			}
			open
			func routineBody() -> RoutineBodyContext? {
				return getRuleContext(RoutineBodyContext.self, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterEvent
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterEvent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterEvent(self)
			}
		}
	}
	@discardableResult
	 open func alterEvent() throws -> AlterEventContext {
		var _localctx: AlterEventContext
		_localctx = AlterEventContext(_ctx, getState())
		try enterRule(_localctx, 130, MySqlParser.RULE_alterEvent)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2351)
		 	try match(MySqlParser.Tokens.ALTER.rawValue)
		 	setState(2353)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.DEFINER.rawValue) {
		 		setState(2352)
		 		try ownerStatement()

		 	}

		 	setState(2355)
		 	try match(MySqlParser.Tokens.EVENT.rawValue)
		 	setState(2356)
		 	try fullId()
		 	setState(2360)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,281,_ctx)) {
		 	case 1:
		 		setState(2357)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(2358)
		 		try match(MySqlParser.Tokens.SCHEDULE.rawValue)
		 		setState(2359)
		 		try scheduleExpression()

		 		break
		 	default: break
		 	}
		 	setState(2368)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ON.rawValue) {
		 		setState(2362)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(2363)
		 		try match(MySqlParser.Tokens.COMPLETION.rawValue)
		 		setState(2365)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.NOT.rawValue) {
		 			setState(2364)
		 			try match(MySqlParser.Tokens.NOT.rawValue)

		 		}

		 		setState(2367)
		 		try match(MySqlParser.Tokens.PRESERVE.rawValue)

		 	}

		 	setState(2373)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,284,_ctx)) {
		 	case 1:
		 		setState(2370)
		 		try match(MySqlParser.Tokens.RENAME.rawValue)
		 		setState(2371)
		 		try match(MySqlParser.Tokens.TO.rawValue)
		 		setState(2372)
		 		try fullId()

		 		break
		 	default: break
		 	}
		 	setState(2376)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.DISABLE.rawValue || _la == MySqlParser.Tokens.ENABLE.rawValue) {
		 		setState(2375)
		 		try enableType()

		 	}

		 	setState(2380)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.COMMENT.rawValue) {
		 		setState(2378)
		 		try match(MySqlParser.Tokens.COMMENT.rawValue)
		 		setState(2379)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 	}

		 	setState(2384)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,287,_ctx)) {
		 	case 1:
		 		setState(2382)
		 		try match(MySqlParser.Tokens.DO.rawValue)
		 		setState(2383)
		 		try routineBody()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterFunctionContext: ParserRuleContext {
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FUNCTION.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func routineOption() -> [RoutineOptionContext] {
				return getRuleContexts(RoutineOptionContext.self)
			}
			open
			func routineOption(_ i: Int) -> RoutineOptionContext? {
				return getRuleContext(RoutineOptionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterFunction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterFunction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterFunction(self)
			}
		}
	}
	@discardableResult
	 open func alterFunction() throws -> AlterFunctionContext {
		var _localctx: AlterFunctionContext
		_localctx = AlterFunctionContext(_ctx, getState())
		try enterRule(_localctx, 132, MySqlParser.RULE_alterFunction)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2386)
		 	try match(MySqlParser.Tokens.ALTER.rawValue)
		 	setState(2387)
		 	try match(MySqlParser.Tokens.FUNCTION.rawValue)
		 	setState(2388)
		 	try fullId()
		 	setState(2392)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.DETERMINISTIC.rawValue || ((Int64((_la - 112)) & ~0x3f) == 0 && ((Int64(1) << (_la - 112)) & 281474985099269) != 0) || _la == MySqlParser.Tokens.COMMENT.rawValue || _la == MySqlParser.Tokens.CONTAINS.rawValue || _la == MySqlParser.Tokens.LANGUAGE.rawValue || _la == MySqlParser.Tokens.NO.rawValue) {
		 		setState(2389)
		 		try routineOption()


		 		setState(2394)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterInstanceContext: ParserRuleContext {
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func INSTANCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSTANCE.rawValue, 0)
			}
			open
			func ROTATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROTATE.rawValue, 0)
			}
			open
			func INNODB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INNODB.rawValue, 0)
			}
			open
			func MASTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterInstance
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterInstance(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterInstance(self)
			}
		}
	}
	@discardableResult
	 open func alterInstance() throws -> AlterInstanceContext {
		var _localctx: AlterInstanceContext
		_localctx = AlterInstanceContext(_ctx, getState())
		try enterRule(_localctx, 134, MySqlParser.RULE_alterInstance)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2395)
		 	try match(MySqlParser.Tokens.ALTER.rawValue)
		 	setState(2396)
		 	try match(MySqlParser.Tokens.INSTANCE.rawValue)
		 	setState(2397)
		 	try match(MySqlParser.Tokens.ROTATE.rawValue)
		 	setState(2398)
		 	try match(MySqlParser.Tokens.INNODB.rawValue)
		 	setState(2399)
		 	try match(MySqlParser.Tokens.MASTER.rawValue)
		 	setState(2400)
		 	try match(MySqlParser.Tokens.KEY.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterLogfileGroupContext: ParserRuleContext {
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func LOGFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOGFILE.rawValue, 0)
			}
			open
			func GROUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func UNDOFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNDOFILE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func engineName() -> EngineNameContext? {
				return getRuleContext(EngineNameContext.self, 0)
			}
			open
			func INITIAL_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INITIAL_SIZE.rawValue, 0)
			}
			open
			func fileSizeLiteral() -> FileSizeLiteralContext? {
				return getRuleContext(FileSizeLiteralContext.self, 0)
			}
			open
			func WAIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WAIT.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterLogfileGroup
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterLogfileGroup(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterLogfileGroup(self)
			}
		}
	}
	@discardableResult
	 open func alterLogfileGroup() throws -> AlterLogfileGroupContext {
		var _localctx: AlterLogfileGroupContext
		_localctx = AlterLogfileGroupContext(_ctx, getState())
		try enterRule(_localctx, 136, MySqlParser.RULE_alterLogfileGroup)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2402)
		 	try match(MySqlParser.Tokens.ALTER.rawValue)
		 	setState(2403)
		 	try match(MySqlParser.Tokens.LOGFILE.rawValue)
		 	setState(2404)
		 	try match(MySqlParser.Tokens.GROUP.rawValue)
		 	setState(2405)
		 	try uid()
		 	setState(2406)
		 	try match(MySqlParser.Tokens.ADD.rawValue)
		 	setState(2407)
		 	try match(MySqlParser.Tokens.UNDOFILE.rawValue)
		 	setState(2408)
		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 	setState(2414)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.INITIAL_SIZE.rawValue) {
		 		setState(2409)
		 		try match(MySqlParser.Tokens.INITIAL_SIZE.rawValue)
		 		setState(2411)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(2410)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(2413)
		 		try fileSizeLiteral()

		 	}

		 	setState(2417)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WAIT.rawValue) {
		 		setState(2416)
		 		try match(MySqlParser.Tokens.WAIT.rawValue)

		 	}

		 	setState(2419)
		 	try match(MySqlParser.Tokens.ENGINE.rawValue)
		 	setState(2421)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 		setState(2420)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 	}

		 	setState(2423)
		 	try engineName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterProcedureContext: ParserRuleContext {
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCEDURE.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func routineOption() -> [RoutineOptionContext] {
				return getRuleContexts(RoutineOptionContext.self)
			}
			open
			func routineOption(_ i: Int) -> RoutineOptionContext? {
				return getRuleContext(RoutineOptionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterProcedure
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterProcedure(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterProcedure(self)
			}
		}
	}
	@discardableResult
	 open func alterProcedure() throws -> AlterProcedureContext {
		var _localctx: AlterProcedureContext
		_localctx = AlterProcedureContext(_ctx, getState())
		try enterRule(_localctx, 138, MySqlParser.RULE_alterProcedure)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2425)
		 	try match(MySqlParser.Tokens.ALTER.rawValue)
		 	setState(2426)
		 	try match(MySqlParser.Tokens.PROCEDURE.rawValue)
		 	setState(2427)
		 	try fullId()
		 	setState(2431)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.DETERMINISTIC.rawValue || ((Int64((_la - 112)) & ~0x3f) == 0 && ((Int64(1) << (_la - 112)) & 281474985099269) != 0) || _la == MySqlParser.Tokens.COMMENT.rawValue || _la == MySqlParser.Tokens.CONTAINS.rawValue || _la == MySqlParser.Tokens.LANGUAGE.rawValue || _la == MySqlParser.Tokens.NO.rawValue) {
		 		setState(2428)
		 		try routineOption()


		 		setState(2433)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterServerContext: ParserRuleContext {
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func SERVER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SERVER.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func OPTIONS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTIONS.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func serverOption() -> [ServerOptionContext] {
				return getRuleContexts(ServerOptionContext.self)
			}
			open
			func serverOption(_ i: Int) -> ServerOptionContext? {
				return getRuleContext(ServerOptionContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterServer
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterServer(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterServer(self)
			}
		}
	}
	@discardableResult
	 open func alterServer() throws -> AlterServerContext {
		var _localctx: AlterServerContext
		_localctx = AlterServerContext(_ctx, getState())
		try enterRule(_localctx, 140, MySqlParser.RULE_alterServer)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2434)
		 	try match(MySqlParser.Tokens.ALTER.rawValue)
		 	setState(2435)
		 	try match(MySqlParser.Tokens.SERVER.rawValue)
		 	setState(2436)
		 	try uid()
		 	setState(2437)
		 	try match(MySqlParser.Tokens.OPTIONS.rawValue)
		 	setState(2438)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(2439)
		 	try serverOption()
		 	setState(2444)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(2440)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(2441)
		 		try serverOption()


		 		setState(2446)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(2447)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterTableContext: ParserRuleContext {
		open var intimeAction: Token!
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func IGNORE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE.rawValue, 0)
			}
			open
			func waitNowaitClause() -> WaitNowaitClauseContext? {
				return getRuleContext(WaitNowaitClauseContext.self, 0)
			}
			open
			func alterSpecification() -> [AlterSpecificationContext] {
				return getRuleContexts(AlterSpecificationContext.self)
			}
			open
			func alterSpecification(_ i: Int) -> AlterSpecificationContext? {
				return getRuleContext(AlterSpecificationContext.self, i)
			}
			open
			func partitionDefinitions() -> PartitionDefinitionsContext? {
				return getRuleContext(PartitionDefinitionsContext.self, 0)
			}
			open
			func ONLINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONLINE.rawValue, 0)
			}
			open
			func OFFLINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OFFLINE.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterTable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterTable(self)
			}
		}
	}
	@discardableResult
	 open func alterTable() throws -> AlterTableContext {
		var _localctx: AlterTableContext
		_localctx = AlterTableContext(_ctx, getState())
		try enterRule(_localctx, 142, MySqlParser.RULE_alterTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2449)
		 	try match(MySqlParser.Tokens.ALTER.rawValue)
		 	setState(2451)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.OFFLINE.rawValue || _la == MySqlParser.Tokens.ONLINE.rawValue) {
		 		setState(2450)
		 		_localctx.castdown(AlterTableContext.self).intimeAction = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.OFFLINE.rawValue || _la == MySqlParser.Tokens.ONLINE.rawValue)) {
		 			_localctx.castdown(AlterTableContext.self).intimeAction = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(2454)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IGNORE.rawValue) {
		 		setState(2453)
		 		try match(MySqlParser.Tokens.IGNORE.rawValue)

		 	}

		 	setState(2456)
		 	try match(MySqlParser.Tokens.TABLE.rawValue)
		 	setState(2457)
		 	try tableName()
		 	setState(2459)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.NOWAIT.rawValue || _la == MySqlParser.Tokens.WAIT.rawValue) {
		 		setState(2458)
		 		try waitNowaitClause()

		 	}

		 	setState(2469)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,299,_ctx)) {
		 	case 1:
		 		setState(2461)
		 		try alterSpecification()
		 		setState(2466)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(2462)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(2463)
		 			try alterSpecification()


		 			setState(2468)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}
		 	setState(2472)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.PARTITION.rawValue) {
		 		setState(2471)
		 		try partitionDefinitions()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterTablespaceContext: ParserRuleContext {
		open var objectAction: Token!
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func DATAFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATAFILE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func engineName() -> EngineNameContext? {
				return getRuleContext(EngineNameContext.self, 0)
			}
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func INITIAL_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INITIAL_SIZE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
			open
			func fileSizeLiteral() -> FileSizeLiteralContext? {
				return getRuleContext(FileSizeLiteralContext.self, 0)
			}
			open
			func WAIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WAIT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterTablespace
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterTablespace(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterTablespace(self)
			}
		}
	}
	@discardableResult
	 open func alterTablespace() throws -> AlterTablespaceContext {
		var _localctx: AlterTablespaceContext
		_localctx = AlterTablespaceContext(_ctx, getState())
		try enterRule(_localctx, 144, MySqlParser.RULE_alterTablespace)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2474)
		 	try match(MySqlParser.Tokens.ALTER.rawValue)
		 	setState(2475)
		 	try match(MySqlParser.Tokens.TABLESPACE.rawValue)
		 	setState(2476)
		 	try uid()
		 	setState(2477)
		 	_localctx.castdown(AlterTablespaceContext.self).objectAction = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.ADD.rawValue || _la == MySqlParser.Tokens.DROP.rawValue)) {
		 		_localctx.castdown(AlterTablespaceContext.self).objectAction = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2478)
		 	try match(MySqlParser.Tokens.DATAFILE.rawValue)
		 	setState(2479)
		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 	setState(2483)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.INITIAL_SIZE.rawValue) {
		 		setState(2480)
		 		try match(MySqlParser.Tokens.INITIAL_SIZE.rawValue)
		 		setState(2481)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(2482)
		 		try fileSizeLiteral()

		 	}

		 	setState(2486)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WAIT.rawValue) {
		 		setState(2485)
		 		try match(MySqlParser.Tokens.WAIT.rawValue)

		 	}

		 	setState(2488)
		 	try match(MySqlParser.Tokens.ENGINE.rawValue)
		 	setState(2490)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 		setState(2489)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 	}

		 	setState(2492)
		 	try engineName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterViewContext: ParserRuleContext {
		open var algType: Token!
		open var secContext: Token!
		open var checkOpt: Token!
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func VIEW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VIEW.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
			open
			func ALGORITHM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALGORITHM.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func ownerStatement() -> OwnerStatementContext? {
				return getRuleContext(OwnerStatementContext.self, 0)
			}
			open
			func SQL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL.rawValue, 0)
			}
			open
			func SECURITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SECURITY.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func CHECK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECK.rawValue, 0)
			}
			open
			func OPTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTION.rawValue, 0)
			}
			open
			func UNDEFINED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNDEFINED.rawValue, 0)
			}
			open
			func MERGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MERGE.rawValue, 0)
			}
			open
			func TEMPTABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TEMPTABLE.rawValue, 0)
			}
			open
			func DEFINER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFINER.rawValue, 0)
			}
			open
			func INVOKER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INVOKER.rawValue, 0)
			}
			open
			func CASCADED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CASCADED.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterView
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterView(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterView(self)
			}
		}
	}
	@discardableResult
	 open func alterView() throws -> AlterViewContext {
		var _localctx: AlterViewContext
		_localctx = AlterViewContext(_ctx, getState())
		try enterRule(_localctx, 146, MySqlParser.RULE_alterView)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2494)
		 	try match(MySqlParser.Tokens.ALTER.rawValue)
		 	setState(2498)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ALGORITHM.rawValue) {
		 		setState(2495)
		 		try match(MySqlParser.Tokens.ALGORITHM.rawValue)
		 		setState(2496)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(2497)
		 		_localctx.castdown(AlterViewContext.self).algType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.MERGE.rawValue || _la == MySqlParser.Tokens.TEMPTABLE.rawValue || _la == MySqlParser.Tokens.UNDEFINED.rawValue)) {
		 			_localctx.castdown(AlterViewContext.self).algType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(2501)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.DEFINER.rawValue) {
		 		setState(2500)
		 		try ownerStatement()

		 	}

		 	setState(2506)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.SQL.rawValue) {
		 		setState(2503)
		 		try match(MySqlParser.Tokens.SQL.rawValue)
		 		setState(2504)
		 		try match(MySqlParser.Tokens.SECURITY.rawValue)
		 		setState(2505)
		 		_localctx.castdown(AlterViewContext.self).secContext = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFINER.rawValue || _la == MySqlParser.Tokens.INVOKER.rawValue)) {
		 			_localctx.castdown(AlterViewContext.self).secContext = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(2508)
		 	try match(MySqlParser.Tokens.VIEW.rawValue)
		 	setState(2509)
		 	try fullId()
		 	setState(2514)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 		setState(2510)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2511)
		 		try uidList()
		 		setState(2512)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(2516)
		 	try match(MySqlParser.Tokens.AS.rawValue)
		 	setState(2517)
		 	try selectStatement()
		 	setState(2524)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,309,_ctx)) {
		 	case 1:
		 		setState(2518)
		 		try match(MySqlParser.Tokens.WITH.rawValue)
		 		setState(2520)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CASCADED.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue) {
		 			setState(2519)
		 			_localctx.castdown(AlterViewContext.self).checkOpt = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.CASCADED.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue)) {
		 				_localctx.castdown(AlterViewContext.self).checkOpt = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(2522)
		 		try match(MySqlParser.Tokens.CHECK.rawValue)
		 		setState(2523)
		 		try match(MySqlParser.Tokens.OPTION.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterSpecificationContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterSpecification
		}
	}
	public class AlterByAlterColumnDefaultContext: AlterSpecificationContext {
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func COLUMN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN.rawValue, 0)
			}
			open
			func VISIBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VISIBLE.rawValue, 0)
			}
			open
			func INVISIBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INVISIBLE.rawValue, 0)
			}
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAlterColumnDefault(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAlterColumnDefault(self)
			}
		}
	}
	public class AlterByDisableKeysContext: AlterSpecificationContext {
			open
			func DISABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISABLE.rawValue, 0)
			}
			open
			func KEYS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEYS.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByDisableKeys(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByDisableKeys(self)
			}
		}
	}
	public class AlterByDefaultCharsetContext: AlterSpecificationContext {
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func COLLATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATE.rawValue, 0)
			}
			open
			func collationName() -> CollationNameContext? {
				return getRuleContext(CollationNameContext.self, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByDefaultCharset(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByDefaultCharset(self)
			}
		}
	}
	public class AlterByRenameColumnContext: AlterSpecificationContext {
		public var oldColumn: UidContext!
		public var newColumn: UidContext!
			open
			func RENAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RENAME.rawValue, 0)
			}
			open
			func COLUMN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN.rawValue, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByRenameColumn(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByRenameColumn(self)
			}
		}
	}
	public class AlterByConvertCharsetContext: AlterSpecificationContext {
			open
			func CONVERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONVERT.rawValue, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func CHARSET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARSET.rawValue, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func COLLATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATE.rawValue, 0)
			}
			open
			func collationName() -> CollationNameContext? {
				return getRuleContext(CollationNameContext.self, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByConvertCharset(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByConvertCharset(self)
			}
		}
	}
	public class AlterByAddForeignKeyContext: AlterSpecificationContext {
		public var name: UidContext!
		public var indexName: UidContext!
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func FOREIGN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOREIGN.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func referenceDefinition() -> ReferenceDefinitionContext? {
				return getRuleContext(ReferenceDefinitionContext.self, 0)
			}
			open
			func CONSTRAINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAddForeignKey(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAddForeignKey(self)
			}
		}
	}
	public class AlterByRenameIndexContext: AlterSpecificationContext {
		public var indexFormat: Token!
			open
			func RENAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RENAME.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByRenameIndex(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByRenameIndex(self)
			}
		}
	}
	public class AlterByRenameContext: AlterSpecificationContext {
		public var renameFormat: Token!
			open
			func RENAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RENAME.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByRename(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByRename(self)
			}
		}
	}
	public class AlterByImportTablespaceContext: AlterSpecificationContext {
			open
			func IMPORT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IMPORT.rawValue, 0)
			}
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByImportTablespace(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByImportTablespace(self)
			}
		}
	}
	public class AlterByAddDefinitionsContext: AlterSpecificationContext {
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func createDefinition() -> [CreateDefinitionContext] {
				return getRuleContexts(CreateDefinitionContext.self)
			}
			open
			func createDefinition(_ i: Int) -> CreateDefinitionContext? {
				return getRuleContext(CreateDefinitionContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COLUMN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAddDefinitions(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAddDefinitions(self)
			}
		}
	}
	public class AlterByAlterCheckTableConstraintContext: AlterSpecificationContext {
		public var name: UidContext!
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func CHECK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECK.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func CONSTRAINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
			open
			func ENFORCED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENFORCED.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAlterCheckTableConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAlterCheckTableConstraint(self)
			}
		}
	}
	public class AlterByDropConstraintCheckContext: AlterSpecificationContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func CONSTRAINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT.rawValue, 0)
			}
			open
			func CHECK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECK.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByDropConstraintCheck(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByDropConstraintCheck(self)
			}
		}
	}
	public class AlterByAddColumnsContext: AlterSpecificationContext {
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func columnDefinition() -> [ColumnDefinitionContext] {
				return getRuleContexts(ColumnDefinitionContext.self)
			}
			open
			func columnDefinition(_ i: Int) -> ColumnDefinitionContext? {
				return getRuleContext(ColumnDefinitionContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COLUMN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAddColumns(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAddColumns(self)
			}
		}
	}
	public class AlterByAlterIndexVisibilityContext: AlterSpecificationContext {
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func VISIBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VISIBLE.rawValue, 0)
			}
			open
			func INVISIBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INVISIBLE.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAlterIndexVisibility(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAlterIndexVisibility(self)
			}
		}
	}
	public class AlterByDropForeignKeyContext: AlterSpecificationContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func FOREIGN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOREIGN.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByDropForeignKey(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByDropForeignKey(self)
			}
		}
	}
	public class AlterByAddCheckTableConstraintContext: AlterSpecificationContext {
		public var name: UidContext!
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func CHECK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECK.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func CONSTRAINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
			open
			func ENFORCED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENFORCED.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAddCheckTableConstraint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAddCheckTableConstraint(self)
			}
		}
	}
	public class AlterPartitionContext: AlterSpecificationContext {
			open
			func alterPartitionSpecification() -> AlterPartitionSpecificationContext? {
				return getRuleContext(AlterPartitionSpecificationContext.self, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterPartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterPartition(self)
			}
		}
	}
	public class AlterByAddIndexContext: AlterSpecificationContext {
		public var indexFormat: Token!
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func indexType() -> IndexTypeContext? {
				return getRuleContext(IndexTypeContext.self, 0)
			}
			open
			func indexOption() -> [IndexOptionContext] {
				return getRuleContexts(IndexOptionContext.self)
			}
			open
			func indexOption(_ i: Int) -> IndexOptionContext? {
				return getRuleContext(IndexOptionContext.self, i)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAddIndex(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAddIndex(self)
			}
		}
	}
	public class AlterByDropColumnContext: AlterSpecificationContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func COLUMN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN.rawValue, 0)
			}
			open
			func RESTRICT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESTRICT.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByDropColumn(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByDropColumn(self)
			}
		}
	}
	public class AlterByChangeDefaultContext: AlterSpecificationContext {
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func defaultValue() -> DefaultValueContext? {
				return getRuleContext(DefaultValueContext.self, 0)
			}
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func COLUMN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByChangeDefault(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByChangeDefault(self)
			}
		}
	}
	public class AlterByForceContext: AlterSpecificationContext {
			open
			func FORCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FORCE.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByForce(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByForce(self)
			}
		}
	}
	public class AlterByAddSpecialIndexContext: AlterSpecificationContext {
		public var keyType: Token!
		public var indexFormat: Token!
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func FULLTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FULLTEXT.rawValue, 0)
			}
			open
			func SPATIAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SPATIAL.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func indexOption() -> [IndexOptionContext] {
				return getRuleContexts(IndexOptionContext.self)
			}
			open
			func indexOption(_ i: Int) -> IndexOptionContext? {
				return getRuleContext(IndexOptionContext.self, i)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAddSpecialIndex(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAddSpecialIndex(self)
			}
		}
	}
	public class AlterByModifyColumnContext: AlterSpecificationContext {
			open
			func MODIFY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MODIFY.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func columnDefinition() -> ColumnDefinitionContext? {
				return getRuleContext(ColumnDefinitionContext.self, 0)
			}
			open
			func COLUMN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN.rawValue, 0)
			}
			open
			func FIRST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIRST.rawValue, 0)
			}
			open
			func AFTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AFTER.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByModifyColumn(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByModifyColumn(self)
			}
		}
	}
	public class AlterByTableOptionContext: AlterSpecificationContext {
			open
			func tableOption() -> [TableOptionContext] {
				return getRuleContexts(TableOptionContext.self)
			}
			open
			func tableOption(_ i: Int) -> TableOptionContext? {
				return getRuleContext(TableOptionContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByTableOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByTableOption(self)
			}
		}
	}
	public class AlterByDropPrimaryKeyContext: AlterSpecificationContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func PRIMARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRIMARY.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByDropPrimaryKey(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByDropPrimaryKey(self)
			}
		}
	}
	public class AlterByLockContext: AlterSpecificationContext {
		public var lockType: Token!
			open
			func LOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCK.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func NONE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NONE.rawValue, 0)
			}
			open
			func SHARED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHARED.rawValue, 0)
			}
			open
			func EXCLUSIVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXCLUSIVE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByLock(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByLock(self)
			}
		}
	}
	public class AlterByDiscardTablespaceContext: AlterSpecificationContext {
			open
			func DISCARD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISCARD.rawValue, 0)
			}
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByDiscardTablespace(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByDiscardTablespace(self)
			}
		}
	}
	public class AlterByValidateContext: AlterSpecificationContext {
		public var validationFormat: Token!
			open
			func VALIDATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALIDATION.rawValue, 0)
			}
			open
			func WITHOUT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITHOUT.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByValidate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByValidate(self)
			}
		}
	}
	public class AlterByAddPrimaryKeyContext: AlterSpecificationContext {
		public var name: UidContext!
		public var index: UidContext!
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func PRIMARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRIMARY.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func CONSTRAINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT.rawValue, 0)
			}
			open
			func indexType() -> IndexTypeContext? {
				return getRuleContext(IndexTypeContext.self, 0)
			}
			open
			func indexOption() -> [IndexOptionContext] {
				return getRuleContexts(IndexOptionContext.self)
			}
			open
			func indexOption(_ i: Int) -> IndexOptionContext? {
				return getRuleContext(IndexOptionContext.self, i)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAddPrimaryKey(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAddPrimaryKey(self)
			}
		}
	}
	public class AlterByEnableKeysContext: AlterSpecificationContext {
			open
			func ENABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENABLE.rawValue, 0)
			}
			open
			func KEYS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEYS.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByEnableKeys(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByEnableKeys(self)
			}
		}
	}
	public class AlterBySetAlgorithmContext: AlterSpecificationContext {
		public var algType: Token!
			open
			func ALGORITHM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALGORITHM.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func INSTANT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSTANT.rawValue, 0)
			}
			open
			func INPLACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INPLACE.rawValue, 0)
			}
			open
			func COPY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COPY.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterBySetAlgorithm(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterBySetAlgorithm(self)
			}
		}
	}
	public class AlterByChangeColumnContext: AlterSpecificationContext {
		public var oldColumn: UidContext!
		public var newColumn: UidContext!
		public var afterColumn: UidContext!
			open
			func CHANGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHANGE.rawValue, 0)
			}
			open
			func columnDefinition() -> ColumnDefinitionContext? {
				return getRuleContext(ColumnDefinitionContext.self, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func COLUMN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN.rawValue, 0)
			}
			open
			func FIRST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIRST.rawValue, 0)
			}
			open
			func AFTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AFTER.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByChangeColumn(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByChangeColumn(self)
			}
		}
	}
	public class AlterByAddUniqueKeyContext: AlterSpecificationContext {
		public var name: UidContext!
		public var indexFormat: Token!
		public var indexName: UidContext!
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func UNIQUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNIQUE.rawValue, 0)
			}
			open
			func indexColumnNames() -> IndexColumnNamesContext? {
				return getRuleContext(IndexColumnNamesContext.self, 0)
			}
			open
			func CONSTRAINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT.rawValue, 0)
			}
			open
			func indexType() -> IndexTypeContext? {
				return getRuleContext(IndexTypeContext.self, 0)
			}
			open
			func indexOption() -> [IndexOptionContext] {
				return getRuleContexts(IndexOptionContext.self)
			}
			open
			func indexOption(_ i: Int) -> IndexOptionContext? {
				return getRuleContext(IndexOptionContext.self, i)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAddUniqueKey(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAddUniqueKey(self)
			}
		}
	}
	public class AlterByDropIndexContext: AlterSpecificationContext {
		public var indexFormat: Token!
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByDropIndex(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByDropIndex(self)
			}
		}
	}
	public class AlterByAddColumnContext: AlterSpecificationContext {
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func columnDefinition() -> ColumnDefinitionContext? {
				return getRuleContext(ColumnDefinitionContext.self, 0)
			}
			open
			func COLUMN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN.rawValue, 0)
			}
			open
			func FIRST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIRST.rawValue, 0)
			}
			open
			func AFTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AFTER.rawValue, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAddColumn(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAddColumn(self)
			}
		}
	}
	public class AlterByOrderContext: AlterSpecificationContext {
			open
			func ORDER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ORDER.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}

		public
		init(_ ctx: AlterSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByOrder(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByOrder(self)
			}
		}
	}
	@discardableResult
	 open func alterSpecification() throws -> AlterSpecificationContext {
		var _localctx: AlterSpecificationContext
		_localctx = AlterSpecificationContext(_ctx, getState())
		try enterRule(_localctx, 148, MySqlParser.RULE_alterSpecification)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(2877)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,369, _ctx)) {
		 	case 1:
		 		_localctx =  AlterByTableOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2526)
		 		try tableOption()
		 		setState(2533)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,311,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(2528)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 					setState(2527)
		 					try match(MySqlParser.Tokens.COMMA.rawValue)

		 				}

		 				setState(2530)
		 				try tableOption()

		 		 
		 			}
		 			setState(2535)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,311,_ctx)
		 		}

		 		break
		 	case 2:
		 		_localctx =  AlterByAddColumnContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2536)
		 		try match(MySqlParser.Tokens.ADD.rawValue)
		 		setState(2538)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COLUMN.rawValue) {
		 			setState(2537)
		 			try match(MySqlParser.Tokens.COLUMN.rawValue)

		 		}

		 		setState(2540)
		 		try uid()
		 		setState(2541)
		 		try columnDefinition()
		 		setState(2545)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .FIRST:
		 		 	setState(2542)
		 		 	try match(MySqlParser.Tokens.FIRST.rawValue)

		 			break

		 		case .AFTER:
		 		 	setState(2543)
		 		 	try match(MySqlParser.Tokens.AFTER.rawValue)
		 		 	setState(2544)
		 		 	try uid()

		 			break
		 		case .EOF:fallthrough
		 		case .ALTER:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .CALL:fallthrough
		 		case .CHANGE:fallthrough
		 		case .CHECK:fallthrough
		 		case .CREATE:fallthrough
		 		case .DELETE:fallthrough
		 		case .DESC:fallthrough
		 		case .DESCRIBE:fallthrough
		 		case .DROP:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .GET:fallthrough
		 		case .GRANT:fallthrough
		 		case .INSERT:fallthrough
		 		case .KILL:fallthrough
		 		case .LOAD:fallthrough
		 		case .LOCK:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PURGE:fallthrough
		 		case .RELEASE:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESIGNAL:fallthrough
		 		case .REVOKE:fallthrough
		 		case .SELECT:fallthrough
		 		case .SET:fallthrough
		 		case .SHOW:fallthrough
		 		case .SIGNAL:fallthrough
		 		case .TABLE:fallthrough
		 		case .UNLOCK:fallthrough
		 		case .UPDATE:fallthrough
		 		case .USE:fallthrough
		 		case .VALUES:fallthrough
		 		case .WITH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .CACHE:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .COMMIT:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DO:fallthrough
		 		case .FLUSH:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HELP:fallthrough
		 		case .INSTALL:fallthrough
		 		case .PREPARE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .RESET:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .START:fallthrough
		 		case .STOP:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .XA:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .MINUS:fallthrough
		 		case .LR_BRACKET:fallthrough
		 		case .COMMA:fallthrough
		 		case .SEMI:
		 			break
		 		default:
		 			break
		 		}

		 		break
		 	case 3:
		 		_localctx =  AlterByAddColumnsContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2547)
		 		try match(MySqlParser.Tokens.ADD.rawValue)
		 		setState(2549)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COLUMN.rawValue) {
		 			setState(2548)
		 			try match(MySqlParser.Tokens.COLUMN.rawValue)

		 		}

		 		setState(2551)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2552)
		 		try uid()
		 		setState(2553)
		 		try columnDefinition()
		 		setState(2560)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(2554)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(2555)
		 			try uid()
		 			setState(2556)
		 			try columnDefinition()


		 			setState(2562)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2563)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 4:
		 		_localctx =  AlterByAddIndexContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2565)
		 		try match(MySqlParser.Tokens.ADD.rawValue)
		 		setState(2566)
		 		_localctx.castdown(AlterByAddIndexContext.self).indexFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue)) {
		 			_localctx.castdown(AlterByAddIndexContext.self).indexFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2568)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(2567)
		 			try uid()

		 		}

		 		setState(2571)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.USING.rawValue) {
		 			setState(2570)
		 			try indexType()

		 		}

		 		setState(2573)
		 		try indexColumnNames()
		 		setState(2577)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,318,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(2574)
		 				try indexOption()

		 		 
		 			}
		 			setState(2579)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,318,_ctx)
		 		}

		 		break
		 	case 5:
		 		_localctx =  AlterByAddPrimaryKeyContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2580)
		 		try match(MySqlParser.Tokens.ADD.rawValue)
		 		setState(2585)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CONSTRAINT.rawValue) {
		 			setState(2581)
		 			try match(MySqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(2583)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,319,_ctx)) {
		 			case 1:
		 				setState(2582)
		 				try {
		 						let assignmentValue = try uid()
		 						_localctx.castdown(AlterByAddPrimaryKeyContext.self).name = assignmentValue
		 				     }()


		 				break
		 			default: break
		 			}

		 		}

		 		setState(2587)
		 		try match(MySqlParser.Tokens.PRIMARY.rawValue)
		 		setState(2588)
		 		try match(MySqlParser.Tokens.KEY.rawValue)
		 		setState(2590)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(2589)
		 			try {
		 					let assignmentValue = try uid()
		 					_localctx.castdown(AlterByAddPrimaryKeyContext.self).index = assignmentValue
		 			     }()


		 		}

		 		setState(2593)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.USING.rawValue) {
		 			setState(2592)
		 			try indexType()

		 		}

		 		setState(2595)
		 		try indexColumnNames()
		 		setState(2599)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,323,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(2596)
		 				try indexOption()

		 		 
		 			}
		 			setState(2601)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,323,_ctx)
		 		}

		 		break
		 	case 6:
		 		_localctx =  AlterByAddUniqueKeyContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2602)
		 		try match(MySqlParser.Tokens.ADD.rawValue)
		 		setState(2607)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CONSTRAINT.rawValue) {
		 			setState(2603)
		 			try match(MySqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(2605)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 				setState(2604)
		 				try {
		 						let assignmentValue = try uid()
		 						_localctx.castdown(AlterByAddUniqueKeyContext.self).name = assignmentValue
		 				     }()


		 			}


		 		}

		 		setState(2609)
		 		try match(MySqlParser.Tokens.UNIQUE.rawValue)
		 		setState(2611)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue) {
		 			setState(2610)
		 			_localctx.castdown(AlterByAddUniqueKeyContext.self).indexFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue)) {
		 				_localctx.castdown(AlterByAddUniqueKeyContext.self).indexFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(2614)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(2613)
		 			try {
		 					let assignmentValue = try uid()
		 					_localctx.castdown(AlterByAddUniqueKeyContext.self).indexName = assignmentValue
		 			     }()


		 		}

		 		setState(2617)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.USING.rawValue) {
		 			setState(2616)
		 			try indexType()

		 		}

		 		setState(2619)
		 		try indexColumnNames()
		 		setState(2623)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,329,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(2620)
		 				try indexOption()

		 		 
		 			}
		 			setState(2625)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,329,_ctx)
		 		}

		 		break
		 	case 7:
		 		_localctx =  AlterByAddSpecialIndexContext(_localctx);
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2626)
		 		try match(MySqlParser.Tokens.ADD.rawValue)
		 		setState(2627)
		 		_localctx.castdown(AlterByAddSpecialIndexContext.self).keyType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FULLTEXT.rawValue || _la == MySqlParser.Tokens.SPATIAL.rawValue)) {
		 			_localctx.castdown(AlterByAddSpecialIndexContext.self).keyType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2629)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue) {
		 			setState(2628)
		 			_localctx.castdown(AlterByAddSpecialIndexContext.self).indexFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue)) {
		 				_localctx.castdown(AlterByAddSpecialIndexContext.self).indexFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(2632)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(2631)
		 			try uid()

		 		}

		 		setState(2634)
		 		try indexColumnNames()
		 		setState(2638)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,332,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(2635)
		 				try indexOption()

		 		 
		 			}
		 			setState(2640)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,332,_ctx)
		 		}

		 		break
		 	case 8:
		 		_localctx =  AlterByAddForeignKeyContext(_localctx);
		 		try enterOuterAlt(_localctx, 8)
		 		setState(2641)
		 		try match(MySqlParser.Tokens.ADD.rawValue)
		 		setState(2646)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CONSTRAINT.rawValue) {
		 			setState(2642)
		 			try match(MySqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(2644)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 				setState(2643)
		 				try {
		 						let assignmentValue = try uid()
		 						_localctx.castdown(AlterByAddForeignKeyContext.self).name = assignmentValue
		 				     }()


		 			}


		 		}

		 		setState(2648)
		 		try match(MySqlParser.Tokens.FOREIGN.rawValue)
		 		setState(2649)
		 		try match(MySqlParser.Tokens.KEY.rawValue)
		 		setState(2651)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(2650)
		 			try {
		 					let assignmentValue = try uid()
		 					_localctx.castdown(AlterByAddForeignKeyContext.self).indexName = assignmentValue
		 			     }()


		 		}

		 		setState(2653)
		 		try indexColumnNames()
		 		setState(2654)
		 		try referenceDefinition()

		 		break
		 	case 9:
		 		_localctx =  AlterByAddCheckTableConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 9)
		 		setState(2656)
		 		try match(MySqlParser.Tokens.ADD.rawValue)
		 		setState(2661)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CONSTRAINT.rawValue) {
		 			setState(2657)
		 			try match(MySqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(2659)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 				setState(2658)
		 				try {
		 						let assignmentValue = try uid()
		 						_localctx.castdown(AlterByAddCheckTableConstraintContext.self).name = assignmentValue
		 				     }()


		 			}


		 		}

		 		setState(2663)
		 		try match(MySqlParser.Tokens.CHECK.rawValue)
		 		setState(2670)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,338, _ctx)) {
		 		case 1:
		 			setState(2664)
		 			try uid()

		 			break
		 		case 2:
		 			setState(2665)
		 			try stringLiteral()

		 			break
		 		case 3:
		 			setState(2666)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2667)
		 			try expression(0)
		 			setState(2668)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2673)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.NOT.rawValue) {
		 			setState(2672)
		 			try match(MySqlParser.Tokens.NOT.rawValue)

		 		}

		 		setState(2676)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.ENFORCED.rawValue) {
		 			setState(2675)
		 			try match(MySqlParser.Tokens.ENFORCED.rawValue)

		 		}


		 		break
		 	case 10:
		 		_localctx =  AlterByAlterCheckTableConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 10)
		 		setState(2678)
		 		try match(MySqlParser.Tokens.ALTER.rawValue)
		 		setState(2683)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CONSTRAINT.rawValue) {
		 			setState(2679)
		 			try match(MySqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(2681)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 				setState(2680)
		 				try {
		 						let assignmentValue = try uid()
		 						_localctx.castdown(AlterByAlterCheckTableConstraintContext.self).name = assignmentValue
		 				     }()


		 			}


		 		}

		 		setState(2685)
		 		try match(MySqlParser.Tokens.CHECK.rawValue)
		 		setState(2692)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,343, _ctx)) {
		 		case 1:
		 			setState(2686)
		 			try uid()

		 			break
		 		case 2:
		 			setState(2687)
		 			try stringLiteral()

		 			break
		 		case 3:
		 			setState(2688)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(2689)
		 			try expression(0)
		 			setState(2690)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(2695)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.NOT.rawValue) {
		 			setState(2694)
		 			try match(MySqlParser.Tokens.NOT.rawValue)

		 		}

		 		setState(2698)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.ENFORCED.rawValue) {
		 			setState(2697)
		 			try match(MySqlParser.Tokens.ENFORCED.rawValue)

		 		}


		 		break
		 	case 11:
		 		_localctx =  AlterByAddCheckTableConstraintContext(_localctx);
		 		try enterOuterAlt(_localctx, 11)
		 		setState(2700)
		 		try match(MySqlParser.Tokens.ADD.rawValue)
		 		setState(2705)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CONSTRAINT.rawValue) {
		 			setState(2701)
		 			try match(MySqlParser.Tokens.CONSTRAINT.rawValue)
		 			setState(2703)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 				setState(2702)
		 				try {
		 						let assignmentValue = try uid()
		 						_localctx.castdown(AlterByAddCheckTableConstraintContext.self).name = assignmentValue
		 				     }()


		 			}


		 		}

		 		setState(2707)
		 		try match(MySqlParser.Tokens.CHECK.rawValue)
		 		setState(2708)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2709)
		 		try expression(0)
		 		setState(2710)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 12:
		 		_localctx =  AlterBySetAlgorithmContext(_localctx);
		 		try enterOuterAlt(_localctx, 12)
		 		setState(2712)
		 		try match(MySqlParser.Tokens.ALGORITHM.rawValue)
		 		setState(2714)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(2713)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(2716)
		 		_localctx.castdown(AlterBySetAlgorithmContext.self).algType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.COPY.rawValue || _la == MySqlParser.Tokens.INPLACE.rawValue || _la == MySqlParser.Tokens.INSTANT.rawValue)) {
		 			_localctx.castdown(AlterBySetAlgorithmContext.self).algType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 13:
		 		_localctx =  AlterByChangeDefaultContext(_localctx);
		 		try enterOuterAlt(_localctx, 13)
		 		setState(2717)
		 		try match(MySqlParser.Tokens.ALTER.rawValue)
		 		setState(2719)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COLUMN.rawValue) {
		 			setState(2718)
		 			try match(MySqlParser.Tokens.COLUMN.rawValue)

		 		}

		 		setState(2721)
		 		try uid()
		 		setState(2727)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .SET:
		 			setState(2722)
		 			try match(MySqlParser.Tokens.SET.rawValue)
		 			setState(2723)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)
		 			setState(2724)
		 			try defaultValue()

		 			break

		 		case .DROP:
		 			setState(2725)
		 			try match(MySqlParser.Tokens.DROP.rawValue)
		 			setState(2726)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 14:
		 		_localctx =  AlterByChangeColumnContext(_localctx);
		 		try enterOuterAlt(_localctx, 14)
		 		setState(2729)
		 		try match(MySqlParser.Tokens.CHANGE.rawValue)
		 		setState(2731)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COLUMN.rawValue) {
		 			setState(2730)
		 			try match(MySqlParser.Tokens.COLUMN.rawValue)

		 		}

		 		setState(2733)
		 		try {
		 				let assignmentValue = try uid()
		 				_localctx.castdown(AlterByChangeColumnContext.self).oldColumn = assignmentValue
		 		     }()

		 		setState(2734)
		 		try {
		 				let assignmentValue = try uid()
		 				_localctx.castdown(AlterByChangeColumnContext.self).newColumn = assignmentValue
		 		     }()

		 		setState(2735)
		 		try columnDefinition()
		 		setState(2739)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .FIRST:
		 		 	setState(2736)
		 		 	try match(MySqlParser.Tokens.FIRST.rawValue)

		 			break

		 		case .AFTER:
		 		 	setState(2737)
		 		 	try match(MySqlParser.Tokens.AFTER.rawValue)
		 		 	setState(2738)
		 		 	try {
		 		 			let assignmentValue = try uid()
		 		 			_localctx.castdown(AlterByChangeColumnContext.self).afterColumn = assignmentValue
		 		 	     }()


		 			break
		 		case .EOF:fallthrough
		 		case .ALTER:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .CALL:fallthrough
		 		case .CHANGE:fallthrough
		 		case .CHECK:fallthrough
		 		case .CREATE:fallthrough
		 		case .DELETE:fallthrough
		 		case .DESC:fallthrough
		 		case .DESCRIBE:fallthrough
		 		case .DROP:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .GET:fallthrough
		 		case .GRANT:fallthrough
		 		case .INSERT:fallthrough
		 		case .KILL:fallthrough
		 		case .LOAD:fallthrough
		 		case .LOCK:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PURGE:fallthrough
		 		case .RELEASE:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESIGNAL:fallthrough
		 		case .REVOKE:fallthrough
		 		case .SELECT:fallthrough
		 		case .SET:fallthrough
		 		case .SHOW:fallthrough
		 		case .SIGNAL:fallthrough
		 		case .TABLE:fallthrough
		 		case .UNLOCK:fallthrough
		 		case .UPDATE:fallthrough
		 		case .USE:fallthrough
		 		case .VALUES:fallthrough
		 		case .WITH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .CACHE:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .COMMIT:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DO:fallthrough
		 		case .FLUSH:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HELP:fallthrough
		 		case .INSTALL:fallthrough
		 		case .PREPARE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .RESET:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .START:fallthrough
		 		case .STOP:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .XA:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .MINUS:fallthrough
		 		case .LR_BRACKET:fallthrough
		 		case .COMMA:fallthrough
		 		case .SEMI:
		 			break
		 		default:
		 			break
		 		}

		 		break
		 	case 15:
		 		_localctx =  AlterByRenameColumnContext(_localctx);
		 		try enterOuterAlt(_localctx, 15)
		 		setState(2741)
		 		try match(MySqlParser.Tokens.RENAME.rawValue)
		 		setState(2742)
		 		try match(MySqlParser.Tokens.COLUMN.rawValue)
		 		setState(2743)
		 		try {
		 				let assignmentValue = try uid()
		 				_localctx.castdown(AlterByRenameColumnContext.self).oldColumn = assignmentValue
		 		     }()

		 		setState(2744)
		 		try match(MySqlParser.Tokens.TO.rawValue)
		 		setState(2745)
		 		try {
		 				let assignmentValue = try uid()
		 				_localctx.castdown(AlterByRenameColumnContext.self).newColumn = assignmentValue
		 		     }()


		 		break
		 	case 16:
		 		_localctx =  AlterByLockContext(_localctx);
		 		try enterOuterAlt(_localctx, 16)
		 		setState(2747)
		 		try match(MySqlParser.Tokens.LOCK.rawValue)
		 		setState(2749)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(2748)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(2751)
		 		_localctx.castdown(AlterByLockContext.self).lockType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.EXCLUSIVE.rawValue || _la == MySqlParser.Tokens.NONE.rawValue || _la == MySqlParser.Tokens.SHARED.rawValue)) {
		 			_localctx.castdown(AlterByLockContext.self).lockType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 17:
		 		_localctx =  AlterByModifyColumnContext(_localctx);
		 		try enterOuterAlt(_localctx, 17)
		 		setState(2752)
		 		try match(MySqlParser.Tokens.MODIFY.rawValue)
		 		setState(2754)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COLUMN.rawValue) {
		 			setState(2753)
		 			try match(MySqlParser.Tokens.COLUMN.rawValue)

		 		}

		 		setState(2756)
		 		try uid()
		 		setState(2757)
		 		try columnDefinition()
		 		setState(2761)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .FIRST:
		 		 	setState(2758)
		 		 	try match(MySqlParser.Tokens.FIRST.rawValue)

		 			break

		 		case .AFTER:
		 		 	setState(2759)
		 		 	try match(MySqlParser.Tokens.AFTER.rawValue)
		 		 	setState(2760)
		 		 	try uid()

		 			break
		 		case .EOF:fallthrough
		 		case .ALTER:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .CALL:fallthrough
		 		case .CHANGE:fallthrough
		 		case .CHECK:fallthrough
		 		case .CREATE:fallthrough
		 		case .DELETE:fallthrough
		 		case .DESC:fallthrough
		 		case .DESCRIBE:fallthrough
		 		case .DROP:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .GET:fallthrough
		 		case .GRANT:fallthrough
		 		case .INSERT:fallthrough
		 		case .KILL:fallthrough
		 		case .LOAD:fallthrough
		 		case .LOCK:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .PARTITION:fallthrough
		 		case .PURGE:fallthrough
		 		case .RELEASE:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESIGNAL:fallthrough
		 		case .REVOKE:fallthrough
		 		case .SELECT:fallthrough
		 		case .SET:fallthrough
		 		case .SHOW:fallthrough
		 		case .SIGNAL:fallthrough
		 		case .TABLE:fallthrough
		 		case .UNLOCK:fallthrough
		 		case .UPDATE:fallthrough
		 		case .USE:fallthrough
		 		case .VALUES:fallthrough
		 		case .WITH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .CACHE:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .COMMIT:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DO:fallthrough
		 		case .FLUSH:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HELP:fallthrough
		 		case .INSTALL:fallthrough
		 		case .PREPARE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .RESET:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .START:fallthrough
		 		case .STOP:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .XA:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .MINUS:fallthrough
		 		case .LR_BRACKET:fallthrough
		 		case .COMMA:fallthrough
		 		case .SEMI:
		 			break
		 		default:
		 			break
		 		}

		 		break
		 	case 18:
		 		_localctx =  AlterByDropColumnContext(_localctx);
		 		try enterOuterAlt(_localctx, 18)
		 		setState(2763)
		 		try match(MySqlParser.Tokens.DROP.rawValue)
		 		setState(2765)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COLUMN.rawValue) {
		 			setState(2764)
		 			try match(MySqlParser.Tokens.COLUMN.rawValue)

		 		}

		 		setState(2767)
		 		try uid()
		 		setState(2769)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.RESTRICT.rawValue) {
		 			setState(2768)
		 			try match(MySqlParser.Tokens.RESTRICT.rawValue)

		 		}


		 		break
		 	case 19:
		 		_localctx =  AlterByDropConstraintCheckContext(_localctx);
		 		try enterOuterAlt(_localctx, 19)
		 		setState(2771)
		 		try match(MySqlParser.Tokens.DROP.rawValue)
		 		setState(2772)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.CHECK.rawValue || _la == MySqlParser.Tokens.CONSTRAINT.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2773)
		 		try uid()

		 		break
		 	case 20:
		 		_localctx =  AlterByDropPrimaryKeyContext(_localctx);
		 		try enterOuterAlt(_localctx, 20)
		 		setState(2774)
		 		try match(MySqlParser.Tokens.DROP.rawValue)
		 		setState(2775)
		 		try match(MySqlParser.Tokens.PRIMARY.rawValue)
		 		setState(2776)
		 		try match(MySqlParser.Tokens.KEY.rawValue)

		 		break
		 	case 21:
		 		_localctx =  AlterByDropIndexContext(_localctx);
		 		try enterOuterAlt(_localctx, 21)
		 		setState(2777)
		 		try match(MySqlParser.Tokens.DROP.rawValue)
		 		setState(2778)
		 		_localctx.castdown(AlterByDropIndexContext.self).indexFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue)) {
		 			_localctx.castdown(AlterByDropIndexContext.self).indexFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2779)
		 		try uid()

		 		break
		 	case 22:
		 		_localctx =  AlterByRenameIndexContext(_localctx);
		 		try enterOuterAlt(_localctx, 22)
		 		setState(2780)
		 		try match(MySqlParser.Tokens.RENAME.rawValue)
		 		setState(2781)
		 		_localctx.castdown(AlterByRenameIndexContext.self).indexFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue)) {
		 			_localctx.castdown(AlterByRenameIndexContext.self).indexFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2782)
		 		try uid()
		 		setState(2783)
		 		try match(MySqlParser.Tokens.TO.rawValue)
		 		setState(2784)
		 		try uid()

		 		break
		 	case 23:
		 		_localctx =  AlterByAlterColumnDefaultContext(_localctx);
		 		try enterOuterAlt(_localctx, 23)
		 		setState(2786)
		 		try match(MySqlParser.Tokens.ALTER.rawValue)
		 		setState(2788)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COLUMN.rawValue) {
		 			setState(2787)
		 			try match(MySqlParser.Tokens.COLUMN.rawValue)

		 		}

		 		setState(2790)
		 		try uid()
		 		setState(2804)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,360, _ctx)) {
		 		case 1:
		 			setState(2791)
		 			try match(MySqlParser.Tokens.SET.rawValue)
		 			setState(2792)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)
		 			setState(2798)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .START_NATIONAL_STRING_LITERAL:fallthrough
		 			case .STRING_LITERAL:fallthrough
		 			case .STRING_CHARSET_NAME:
		 				setState(2793)
		 				try stringLiteral()

		 				break

		 			case .LR_BRACKET:
		 				setState(2794)
		 				try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 				setState(2795)
		 				try expression(0)
		 				setState(2796)
		 				try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			break
		 		case 2:
		 			setState(2800)
		 			try match(MySqlParser.Tokens.SET.rawValue)
		 			setState(2801)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.INVISIBLE.rawValue || _la == MySqlParser.Tokens.VISIBLE.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		case 3:
		 			setState(2802)
		 			try match(MySqlParser.Tokens.DROP.rawValue)
		 			setState(2803)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 24:
		 		_localctx =  AlterByAlterIndexVisibilityContext(_localctx);
		 		try enterOuterAlt(_localctx, 24)
		 		setState(2806)
		 		try match(MySqlParser.Tokens.ALTER.rawValue)
		 		setState(2807)
		 		try match(MySqlParser.Tokens.INDEX.rawValue)
		 		setState(2808)
		 		try uid()
		 		setState(2809)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.INVISIBLE.rawValue || _la == MySqlParser.Tokens.VISIBLE.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 25:
		 		_localctx =  AlterByDropForeignKeyContext(_localctx);
		 		try enterOuterAlt(_localctx, 25)
		 		setState(2811)
		 		try match(MySqlParser.Tokens.DROP.rawValue)
		 		setState(2812)
		 		try match(MySqlParser.Tokens.FOREIGN.rawValue)
		 		setState(2813)
		 		try match(MySqlParser.Tokens.KEY.rawValue)
		 		setState(2814)
		 		try uid()

		 		break
		 	case 26:
		 		_localctx =  AlterByDisableKeysContext(_localctx);
		 		try enterOuterAlt(_localctx, 26)
		 		setState(2815)
		 		try match(MySqlParser.Tokens.DISABLE.rawValue)
		 		setState(2816)
		 		try match(MySqlParser.Tokens.KEYS.rawValue)

		 		break
		 	case 27:
		 		_localctx =  AlterByEnableKeysContext(_localctx);
		 		try enterOuterAlt(_localctx, 27)
		 		setState(2817)
		 		try match(MySqlParser.Tokens.ENABLE.rawValue)
		 		setState(2818)
		 		try match(MySqlParser.Tokens.KEYS.rawValue)

		 		break
		 	case 28:
		 		_localctx =  AlterByRenameContext(_localctx);
		 		try enterOuterAlt(_localctx, 28)
		 		setState(2819)
		 		try match(MySqlParser.Tokens.RENAME.rawValue)
		 		setState(2821)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.AS.rawValue || _la == MySqlParser.Tokens.TO.rawValue) {
		 			setState(2820)
		 			_localctx.castdown(AlterByRenameContext.self).renameFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.AS.rawValue || _la == MySqlParser.Tokens.TO.rawValue)) {
		 				_localctx.castdown(AlterByRenameContext.self).renameFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(2825)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,362, _ctx)) {
		 		case 1:
		 			setState(2823)
		 			try uid()

		 			break
		 		case 2:
		 			setState(2824)
		 			try fullId()

		 			break
		 		default: break
		 		}

		 		break
		 	case 29:
		 		_localctx =  AlterByOrderContext(_localctx);
		 		try enterOuterAlt(_localctx, 29)
		 		setState(2827)
		 		try match(MySqlParser.Tokens.ORDER.rawValue)
		 		setState(2828)
		 		try match(MySqlParser.Tokens.BY.rawValue)
		 		setState(2829)
		 		try uidList()

		 		break
		 	case 30:
		 		_localctx =  AlterByConvertCharsetContext(_localctx);
		 		try enterOuterAlt(_localctx, 30)
		 		setState(2830)
		 		try match(MySqlParser.Tokens.CONVERT.rawValue)
		 		setState(2831)
		 		try match(MySqlParser.Tokens.TO.rawValue)
		 		setState(2835)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .CHARSET:
		 			setState(2832)
		 			try match(MySqlParser.Tokens.CHARSET.rawValue)

		 			break

		 		case .CHARACTER:
		 			setState(2833)
		 			try match(MySqlParser.Tokens.CHARACTER.rawValue)
		 			setState(2834)
		 			try match(MySqlParser.Tokens.SET.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(2837)
		 		try charsetName()
		 		setState(2840)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COLLATE.rawValue) {
		 			setState(2838)
		 			try match(MySqlParser.Tokens.COLLATE.rawValue)
		 			setState(2839)
		 			try collationName()

		 		}


		 		break
		 	case 31:
		 		_localctx =  AlterByDefaultCharsetContext(_localctx);
		 		try enterOuterAlt(_localctx, 31)
		 		setState(2843)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DEFAULT.rawValue) {
		 			setState(2842)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 		}

		 		setState(2845)
		 		try match(MySqlParser.Tokens.CHARACTER.rawValue)
		 		setState(2846)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(2847)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(2848)
		 		try charsetName()
		 		setState(2852)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COLLATE.rawValue) {
		 			setState(2849)
		 			try match(MySqlParser.Tokens.COLLATE.rawValue)
		 			setState(2850)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 			setState(2851)
		 			try collationName()

		 		}


		 		break
		 	case 32:
		 		_localctx =  AlterByDiscardTablespaceContext(_localctx);
		 		try enterOuterAlt(_localctx, 32)
		 		setState(2854)
		 		try match(MySqlParser.Tokens.DISCARD.rawValue)
		 		setState(2855)
		 		try match(MySqlParser.Tokens.TABLESPACE.rawValue)

		 		break
		 	case 33:
		 		_localctx =  AlterByImportTablespaceContext(_localctx);
		 		try enterOuterAlt(_localctx, 33)
		 		setState(2856)
		 		try match(MySqlParser.Tokens.IMPORT.rawValue)
		 		setState(2857)
		 		try match(MySqlParser.Tokens.TABLESPACE.rawValue)

		 		break
		 	case 34:
		 		_localctx =  AlterByForceContext(_localctx);
		 		try enterOuterAlt(_localctx, 34)
		 		setState(2858)
		 		try match(MySqlParser.Tokens.FORCE.rawValue)

		 		break
		 	case 35:
		 		_localctx =  AlterByValidateContext(_localctx);
		 		try enterOuterAlt(_localctx, 35)
		 		setState(2859)
		 		_localctx.castdown(AlterByValidateContext.self).validationFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.WITH.rawValue || _la == MySqlParser.Tokens.WITHOUT.rawValue)) {
		 			_localctx.castdown(AlterByValidateContext.self).validationFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(2860)
		 		try match(MySqlParser.Tokens.VALIDATION.rawValue)

		 		break
		 	case 36:
		 		_localctx =  AlterByAddDefinitionsContext(_localctx);
		 		try enterOuterAlt(_localctx, 36)
		 		setState(2861)
		 		try match(MySqlParser.Tokens.ADD.rawValue)
		 		setState(2863)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COLUMN.rawValue) {
		 			setState(2862)
		 			try match(MySqlParser.Tokens.COLUMN.rawValue)

		 		}

		 		setState(2865)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2866)
		 		try createDefinition()
		 		setState(2871)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(2867)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(2868)
		 			try createDefinition()


		 			setState(2873)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2874)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 37:
		 		_localctx =  AlterPartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 37)
		 		setState(2876)
		 		try alterPartitionSpecification()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterPartitionSpecificationContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterPartitionSpecification
		}
	}
	public class AlterByImportPartitionContext: AlterPartitionSpecificationContext {
			open
			func IMPORT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IMPORT.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByImportPartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByImportPartition(self)
			}
		}
	}
	public class AlterByDropPartitionContext: AlterPartitionSpecificationContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByDropPartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByDropPartition(self)
			}
		}
	}
	public class AlterByDiscardPartitionContext: AlterPartitionSpecificationContext {
			open
			func DISCARD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISCARD.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByDiscardPartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByDiscardPartition(self)
			}
		}
	}
	public class AlterByAddPartitionContext: AlterPartitionSpecificationContext {
			open
			func ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADD.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func partitionDefinition() -> [PartitionDefinitionContext] {
				return getRuleContexts(PartitionDefinitionContext.self)
			}
			open
			func partitionDefinition(_ i: Int) -> PartitionDefinitionContext? {
				return getRuleContext(PartitionDefinitionContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAddPartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAddPartition(self)
			}
		}
	}
	public class AlterByRemovePartitioningContext: AlterPartitionSpecificationContext {
			open
			func REMOVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REMOVE.rawValue, 0)
			}
			open
			func PARTITIONING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITIONING.rawValue, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByRemovePartitioning(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByRemovePartitioning(self)
			}
		}
	}
	public class AlterByOptimizePartitionContext: AlterPartitionSpecificationContext {
			open
			func OPTIMIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTIMIZE.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByOptimizePartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByOptimizePartition(self)
			}
		}
	}
	public class AlterByCheckPartitionContext: AlterPartitionSpecificationContext {
			open
			func CHECK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECK.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByCheckPartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByCheckPartition(self)
			}
		}
	}
	public class AlterByCoalescePartitionContext: AlterPartitionSpecificationContext {
			open
			func COALESCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COALESCE.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByCoalescePartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByCoalescePartition(self)
			}
		}
	}
	public class AlterByReorganizePartitionContext: AlterPartitionSpecificationContext {
			open
			func REORGANIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REORGANIZE.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func INTO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTO.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func partitionDefinition() -> [PartitionDefinitionContext] {
				return getRuleContexts(PartitionDefinitionContext.self)
			}
			open
			func partitionDefinition(_ i: Int) -> PartitionDefinitionContext? {
				return getRuleContext(PartitionDefinitionContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByReorganizePartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByReorganizePartition(self)
			}
		}
	}
	public class AlterByAnalyzePartitionContext: AlterPartitionSpecificationContext {
			open
			func ANALYZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ANALYZE.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByAnalyzePartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByAnalyzePartition(self)
			}
		}
	}
	public class AlterByRebuildPartitionContext: AlterPartitionSpecificationContext {
			open
			func REBUILD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REBUILD.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByRebuildPartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByRebuildPartition(self)
			}
		}
	}
	public class AlterByUpgradePartitioningContext: AlterPartitionSpecificationContext {
			open
			func UPGRADE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPGRADE.rawValue, 0)
			}
			open
			func PARTITIONING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITIONING.rawValue, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByUpgradePartitioning(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByUpgradePartitioning(self)
			}
		}
	}
	public class AlterByTruncatePartitionContext: AlterPartitionSpecificationContext {
			open
			func TRUNCATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRUNCATE.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByTruncatePartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByTruncatePartition(self)
			}
		}
	}
	public class AlterByRepairPartitionContext: AlterPartitionSpecificationContext {
			open
			func REPAIR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPAIR.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByRepairPartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByRepairPartition(self)
			}
		}
	}
	public class AlterByExchangePartitionContext: AlterPartitionSpecificationContext {
		public var validationFormat: Token!
			open
			func EXCHANGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXCHANGE.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func WITH() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.WITH.rawValue)
			}
			open
			func WITH(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, i)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func VALIDATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALIDATION.rawValue, 0)
			}
			open
			func WITHOUT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITHOUT.rawValue, 0)
			}

		public
		init(_ ctx: AlterPartitionSpecificationContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterByExchangePartition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterByExchangePartition(self)
			}
		}
	}
	@discardableResult
	 open func alterPartitionSpecification() throws -> AlterPartitionSpecificationContext {
		var _localctx: AlterPartitionSpecificationContext
		_localctx = AlterPartitionSpecificationContext(_ctx, getState())
		try enterRule(_localctx, 150, MySqlParser.RULE_alterPartitionSpecification)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(2977)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ADD:
		 		_localctx =  AlterByAddPartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(2879)
		 		try match(MySqlParser.Tokens.ADD.rawValue)
		 		setState(2880)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2881)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2882)
		 		try partitionDefinition()
		 		setState(2887)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(2883)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(2884)
		 			try partitionDefinition()


		 			setState(2889)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2890)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break

		 	case .DROP:
		 		_localctx =  AlterByDropPartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(2892)
		 		try match(MySqlParser.Tokens.DROP.rawValue)
		 		setState(2893)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2894)
		 		try uidList()

		 		break

		 	case .DISCARD:
		 		_localctx =  AlterByDiscardPartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(2895)
		 		try match(MySqlParser.Tokens.DISCARD.rawValue)
		 		setState(2896)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2899)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ARRAY:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .BUCKETS:fallthrough
		 		case .CONDITION:fallthrough
		 		case .CURRENT:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DIAGNOSTICS:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENFORCED:fallthrough
		 		case .EXCEPT:fallthrough
		 		case .GROUP:fallthrough
		 		case .IF:fallthrough
		 		case .IGNORED:fallthrough
		 		case .INSERT:fallthrough
		 		case .LATERAL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OPTIONAL:fallthrough
		 		case .ORDER:fallthrough
		 		case .PRIMARY:fallthrough
		 		case .REPEAT:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SKIP_QUERY_REWRITE:fallthrough
		 		case .STACKED:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .BINARY:fallthrough
		 		case .TEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .JSON_ARRAY:fallthrough
		 		case .JSON_ARRAYAGG:fallthrough
		 		case .JSON_ARRAY_APPEND:fallthrough
		 		case .JSON_ARRAY_INSERT:fallthrough
		 		case .JSON_CONTAINS:fallthrough
		 		case .JSON_CONTAINS_PATH:fallthrough
		 		case .JSON_DEPTH:fallthrough
		 		case .JSON_EXTRACT:fallthrough
		 		case .JSON_INSERT:fallthrough
		 		case .JSON_KEYS:fallthrough
		 		case .JSON_LENGTH:fallthrough
		 		case .JSON_MERGE:fallthrough
		 		case .JSON_MERGE_PATCH:fallthrough
		 		case .JSON_MERGE_PRESERVE:fallthrough
		 		case .JSON_OBJECT:fallthrough
		 		case .JSON_OBJECTAGG:fallthrough
		 		case .JSON_OVERLAPS:fallthrough
		 		case .JSON_PRETTY:fallthrough
		 		case .JSON_QUOTE:fallthrough
		 		case .JSON_REMOVE:fallthrough
		 		case .JSON_REPLACE:fallthrough
		 		case .JSON_SCHEMA_VALID:fallthrough
		 		case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 		case .JSON_SEARCH:fallthrough
		 		case .JSON_SET:fallthrough
		 		case .JSON_STORAGE_FREE:fallthrough
		 		case .JSON_STORAGE_SIZE:fallthrough
		 		case .JSON_TABLE:fallthrough
		 		case .JSON_TYPE:fallthrough
		 		case .JSON_UNQUOTE:fallthrough
		 		case .JSON_VALID:fallthrough
		 		case .JSON_VALUE:fallthrough
		 		case .NESTED:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .PATH:fallthrough
		 		case .AVG:fallthrough
		 		case .BIT_AND:fallthrough
		 		case .BIT_OR:fallthrough
		 		case .BIT_XOR:fallthrough
		 		case .COUNT:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .GROUP_CONCAT:fallthrough
		 		case .LAG:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NTH_VALUE:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .RANK:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .STD:fallthrough
		 		case .STDDEV:fallthrough
		 		case .STDDEV_POP:fallthrough
		 		case .STDDEV_SAMP:fallthrough
		 		case .SUM:fallthrough
		 		case .VAR_POP:fallthrough
		 		case .VAR_SAMP:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .CURRENT_DATE:fallthrough
		 		case .CURRENT_TIME:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .LOCALTIME:fallthrough
		 		case .CURDATE:fallthrough
		 		case .CURTIME:fallthrough
		 		case .DATE_ADD:fallthrough
		 		case .DATE_SUB:fallthrough
		 		case .LOCALTIMESTAMP:fallthrough
		 		case .NOW:fallthrough
		 		case .POSITION:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .SUBSTRING:fallthrough
		 		case .SYSDATE:fallthrough
		 		case .TRIM:fallthrough
		 		case .UTC_DATE:fallthrough
		 		case .UTC_TIME:fallthrough
		 		case .UTC_TIMESTAMP:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .ACTION:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALGORITHM:fallthrough
		 		case .ANY:fallthrough
		 		case .AT:fallthrough
		 		case .AUTHORS:fallthrough
		 		case .AUTOCOMMIT:fallthrough
		 		case .AUTOEXTEND_SIZE:fallthrough
		 		case .AUTO_INCREMENT:fallthrough
		 		case .AVG_ROW_LENGTH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .BIT:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BTREE:fallthrough
		 		case .CACHE:fallthrough
		 		case .CASCADED:fallthrough
		 		case .CHAIN:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .PAGE_CHECKSUM:fallthrough
		 		case .CIPHER:fallthrough
		 		case .CLASS_ORIGIN:fallthrough
		 		case .CLIENT:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTERING:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CODE:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COLUMN_FORMAT:fallthrough
		 		case .COLUMN_NAME:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMPACT:fallthrough
		 		case .COMPLETION:fallthrough
		 		case .COMPRESSED:fallthrough
		 		case .COMPRESSION:fallthrough
		 		case .CONCURRENT:fallthrough
		 		case .CONNECT:fallthrough
		 		case .CONNECTION:fallthrough
		 		case .CONSISTENT:fallthrough
		 		case .CONSTRAINT_CATALOG:fallthrough
		 		case .CONSTRAINT_SCHEMA:fallthrough
		 		case .CONSTRAINT_NAME:fallthrough
		 		case .CONTAINS:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTRIBUTORS:fallthrough
		 		case .COPY:fallthrough
		 		case .CPU:fallthrough
		 		case .CURSOR_NAME:fallthrough
		 		case .DATA:fallthrough
		 		case .DATAFILE:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DEFAULT_AUTH:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DELAY_KEY_WRITE:fallthrough
		 		case .DES_KEY_FILE:fallthrough
		 		case .DIRECTORY:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISCARD:fallthrough
		 		case .DISK:fallthrough
		 		case .DO:fallthrough
		 		case .DUMPFILE:fallthrough
		 		case .DUPLICATE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .END:fallthrough
		 		case .ENDS:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ENGINES:fallthrough
		 		case .ERROR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVEN:fallthrough
		 		case .EVENT:fallthrough
		 		case .EVENTS:fallthrough
		 		case .EVERY:fallthrough
		 		case .EXCHANGE:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPIRE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .EXTENT_SIZE:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FAST:fallthrough
		 		case .FAULTS:fallthrough
		 		case .FIELDS:fallthrough
		 		case .FILE_BLOCK_SIZE:fallthrough
		 		case .FILTER:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIXED:fallthrough
		 		case .FLUSH:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FOUND:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GENERAL:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GRANTS:fallthrough
		 		case .GROUP_REPLICATION:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HASH:fallthrough
		 		case .HELP:fallthrough
		 		case .HISTORY:fallthrough
		 		case .HOST:fallthrough
		 		case .HOSTS:fallthrough
		 		case .IDENTIFIED:fallthrough
		 		case .IGNORE_SERVER_IDS:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INDEXES:fallthrough
		 		case .INITIAL_SIZE:fallthrough
		 		case .INPLACE:fallthrough
		 		case .INSERT_METHOD:fallthrough
		 		case .INSTALL:fallthrough
		 		case .INSTANCE:fallthrough
		 		case .INSTANT:fallthrough
		 		case .INVISIBLE:fallthrough
		 		case .INVOKER:fallthrough
		 		case .IO:fallthrough
		 		case .IO_THREAD:fallthrough
		 		case .IPC:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ISSUER:fallthrough
		 		case .JSON:fallthrough
		 		case .KEY_BLOCK_SIZE:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LEAVES:fallthrough
		 		case .LESS:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOGFILE:fallthrough
		 		case .LOGS:fallthrough
		 		case .MASTER:fallthrough
		 		case .MASTER_AUTO_POSITION:fallthrough
		 		case .MASTER_CONNECT_RETRY:fallthrough
		 		case .MASTER_DELAY:fallthrough
		 		case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 		case .MASTER_HOST:fallthrough
		 		case .MASTER_LOG_FILE:fallthrough
		 		case .MASTER_LOG_POS:fallthrough
		 		case .MASTER_PASSWORD:fallthrough
		 		case .MASTER_PORT:fallthrough
		 		case .MASTER_RETRY_COUNT:fallthrough
		 		case .MASTER_SSL:fallthrough
		 		case .MASTER_SSL_CA:fallthrough
		 		case .MASTER_SSL_CAPATH:fallthrough
		 		case .MASTER_SSL_CERT:fallthrough
		 		case .MASTER_SSL_CIPHER:fallthrough
		 		case .MASTER_SSL_CRL:fallthrough
		 		case .MASTER_SSL_CRLPATH:fallthrough
		 		case .MASTER_SSL_KEY:fallthrough
		 		case .MASTER_TLS_VERSION:fallthrough
		 		case .MASTER_USER:fallthrough
		 		case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 		case .MAX_QUERIES_PER_HOUR:fallthrough
		 		case .MAX_ROWS:fallthrough
		 		case .MAX_SIZE:fallthrough
		 		case .MAX_UPDATES_PER_HOUR:fallthrough
		 		case .MAX_USER_CONNECTIONS:fallthrough
		 		case .MEDIUM:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MESSAGE_TEXT:fallthrough
		 		case .MID:fallthrough
		 		case .MIGRATE:fallthrough
		 		case .MIN_ROWS:fallthrough
		 		case .MODE:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MUTEX:fallthrough
		 		case .MYSQL:fallthrough
		 		case .MYSQL_ERRNO:fallthrough
		 		case .NAME:fallthrough
		 		case .NAMES:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NEVER:fallthrough
		 		case .NEXT:fallthrough
		 		case .NO:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOWAIT:fallthrough
		 		case .NODEGROUP:fallthrough
		 		case .NONE:fallthrough
		 		case .ODBC:fallthrough
		 		case .OFFLINE:fallthrough
		 		case .OFFSET:fallthrough
		 		case .OF:fallthrough
		 		case .OJ:fallthrough
		 		case .OLD_PASSWORD:fallthrough
		 		case .ONE:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .OPTIMIZER_COSTS:fallthrough
		 		case .OPTIONS:fallthrough
		 		case .OWNER:fallthrough
		 		case .PACK_KEYS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PARSER:fallthrough
		 		case .PARTIAL:fallthrough
		 		case .PARTITIONING:fallthrough
		 		case .PARTITIONS:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PHASE:fallthrough
		 		case .PLUGIN:fallthrough
		 		case .PLUGIN_DIR:fallthrough
		 		case .PLUGINS:fallthrough
		 		case .PORT:fallthrough
		 		case .PRECEDES:fallthrough
		 		case .PREPARE:fallthrough
		 		case .PRESERVE:fallthrough
		 		case .PREV:fallthrough
		 		case .PROCESSLIST:fallthrough
		 		case .PROFILE:fallthrough
		 		case .PROFILES:fallthrough
		 		case .PROXY:fallthrough
		 		case .QUERY:fallthrough
		 		case .QUICK:fallthrough
		 		case .REBUILD:fallthrough
		 		case .RECOVER:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REDO_BUFFER_SIZE:fallthrough
		 		case .REDUNDANT:fallthrough
		 		case .RELAY:fallthrough
		 		case .RELAY_LOG_FILE:fallthrough
		 		case .RELAY_LOG_POS:fallthrough
		 		case .RELAYLOG:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REORGANIZE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .REPLICATE_DO_DB:fallthrough
		 		case .REPLICATE_DO_TABLE:fallthrough
		 		case .REPLICATE_IGNORE_DB:fallthrough
		 		case .REPLICATE_IGNORE_TABLE:fallthrough
		 		case .REPLICATE_REWRITE_DB:fallthrough
		 		case .REPLICATE_WILD_DO_TABLE:fallthrough
		 		case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 		case .REPLICATION:fallthrough
		 		case .RESET:fallthrough
		 		case .RESUME:fallthrough
		 		case .RETURNED_SQLSTATE:fallthrough
		 		case .RETURNING:fallthrough
		 		case .RETURNS:fallthrough
		 		case .REUSE:fallthrough
		 		case .ROLE:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROTATE:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_FORMAT:fallthrough
		 		case .RTREE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEDULE:fallthrough
		 		case .SECURITY:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION:fallthrough
		 		case .SHARE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SIGNED:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SLAVE:fallthrough
		 		case .SLOW:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOCKET:fallthrough
		 		case .SOME:fallthrough
		 		case .SONAME:fallthrough
		 		case .SOUNDS:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SQL_AFTER_GTIDS:fallthrough
		 		case .SQL_AFTER_MTS_GAPS:fallthrough
		 		case .SQL_BEFORE_GTIDS:fallthrough
		 		case .SQL_BUFFER_RESULT:fallthrough
		 		case .SQL_CACHE:fallthrough
		 		case .SQL_NO_CACHE:fallthrough
		 		case .SQL_THREAD:fallthrough
		 		case .START:fallthrough
		 		case .STARTS:fallthrough
		 		case .STATS_AUTO_RECALC:fallthrough
		 		case .STATS_PERSISTENT:fallthrough
		 		case .STATS_SAMPLE_PAGES:fallthrough
		 		case .STATUS:fallthrough
		 		case .STOP:fallthrough
		 		case .STORAGE:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBCLASS_ORIGIN:fallthrough
		 		case .SUBJECT:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBPARTITIONS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .SWAPS:fallthrough
		 		case .SWITCHES:fallthrough
		 		case .TABLE_NAME:fallthrough
		 		case .TABLESPACE:fallthrough
		 		case .TABLE_TYPE:fallthrough
		 		case .TEMPORARY:fallthrough
		 		case .TEMPTABLE:fallthrough
		 		case .THAN:fallthrough
		 		case .TRADITIONAL:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSACTIONAL:fallthrough
		 		case .TRIGGERS:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDEFINED:fallthrough
		 		case .UNDOFILE:fallthrough
		 		case .UNDO_BUFFER_SIZE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPGRADE:fallthrough
		 		case .USER:fallthrough
		 		case .USE_FRM:fallthrough
		 		case .USER_RESOURCES:fallthrough
		 		case .VALIDATION:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARIABLES:fallthrough
		 		case .VIEW:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .VISIBLE:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNINGS:fallthrough
		 		case .WITHOUT:fallthrough
		 		case .WORK:fallthrough
		 		case .WRAPPER:fallthrough
		 		case .X509:fallthrough
		 		case .XA:fallthrough
		 		case .XML:fallthrough
		 		case .EUR:fallthrough
		 		case .USA:fallthrough
		 		case .JIS:fallthrough
		 		case .ISO:fallthrough
		 		case .INTERNAL:fallthrough
		 		case .QUARTER:fallthrough
		 		case .MONTH:fallthrough
		 		case .DAY:fallthrough
		 		case .HOUR:fallthrough
		 		case .MINUTE:fallthrough
		 		case .WEEK:fallthrough
		 		case .SECOND:fallthrough
		 		case .MICROSECOND:fallthrough
		 		case .ADMIN:fallthrough
		 		case .AUDIT_ABORT_EXEMPT:fallthrough
		 		case .AUDIT_ADMIN:fallthrough
		 		case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 		case .BACKUP_ADMIN:fallthrough
		 		case .BINLOG_ADMIN:fallthrough
		 		case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 		case .CLONE_ADMIN:fallthrough
		 		case .CONNECTION_ADMIN:fallthrough
		 		case .ENCRYPTION_KEY_ADMIN:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .FILE:fallthrough
		 		case .FIREWALL_ADMIN:fallthrough
		 		case .FIREWALL_EXEMPT:fallthrough
		 		case .FIREWALL_USER:fallthrough
		 		case .GROUP_REPLICATION_ADMIN:fallthrough
		 		case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 		case .INVOKE:fallthrough
		 		case .LAMBDA:fallthrough
		 		case .NDB_STORED_USER:fallthrough
		 		case .PASSWORDLESS_USER_ADMIN:fallthrough
		 		case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .PROCESS:fallthrough
		 		case .RELOAD:fallthrough
		 		case .REPLICATION_APPLIER:fallthrough
		 		case .REPLICATION_SLAVE_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_USER:fallthrough
		 		case .ROLE_ADMIN:fallthrough
		 		case .ROUTINE:fallthrough
		 		case .S3:fallthrough
		 		case .SESSION_VARIABLES_ADMIN:fallthrough
		 		case .SET_USER_ID:fallthrough
		 		case .SHOW_ROUTINE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SUPER:fallthrough
		 		case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 		case .TABLES:fallthrough
		 		case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 		case .VERSION_TOKEN_ADMIN:fallthrough
		 		case .XA_RECOVER_ADMIN:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .ARCHIVE:fallthrough
		 		case .BLACKHOLE:fallthrough
		 		case .CSV:fallthrough
		 		case .FEDERATED:fallthrough
		 		case .INNODB:fallthrough
		 		case .MEMORY:fallthrough
		 		case .MRG_MYISAM:fallthrough
		 		case .MYISAM:fallthrough
		 		case .NDB:fallthrough
		 		case .NDBCLUSTER:fallthrough
		 		case .PERFORMANCE_SCHEMA:fallthrough
		 		case .TOKUDB:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:fallthrough
		 		case .ABS:fallthrough
		 		case .ACOS:fallthrough
		 		case .ADDDATE:fallthrough
		 		case .ADDTIME:fallthrough
		 		case .AES_DECRYPT:fallthrough
		 		case .AES_ENCRYPT:fallthrough
		 		case .AREA:fallthrough
		 		case .ASBINARY:fallthrough
		 		case .ASIN:fallthrough
		 		case .ASTEXT:fallthrough
		 		case .ASWKB:fallthrough
		 		case .ASWKT:fallthrough
		 		case .ASYMMETRIC_DECRYPT:fallthrough
		 		case .ASYMMETRIC_DERIVE:fallthrough
		 		case .ASYMMETRIC_ENCRYPT:fallthrough
		 		case .ASYMMETRIC_SIGN:fallthrough
		 		case .ASYMMETRIC_VERIFY:fallthrough
		 		case .ATAN:fallthrough
		 		case .ATAN2:fallthrough
		 		case .BENCHMARK:fallthrough
		 		case .BIN:fallthrough
		 		case .BIT_COUNT:fallthrough
		 		case .BIT_LENGTH:fallthrough
		 		case .BUFFER:fallthrough
		 		case .CATALOG_NAME:fallthrough
		 		case .CEIL:fallthrough
		 		case .CEILING:fallthrough
		 		case .CENTROID:fallthrough
		 		case .CHARACTER_LENGTH:fallthrough
		 		case .CHARSET:fallthrough
		 		case .CHAR_LENGTH:fallthrough
		 		case .COERCIBILITY:fallthrough
		 		case .COLLATION:fallthrough
		 		case .COMPRESS:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_WS:fallthrough
		 		case .CONNECTION_ID:fallthrough
		 		case .CONV:fallthrough
		 		case .CONVERT_TZ:fallthrough
		 		case .COS:fallthrough
		 		case .COT:fallthrough
		 		case .CRC32:fallthrough
		 		case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 		case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 		case .CREATE_DH_PARAMETERS:fallthrough
		 		case .CREATE_DIGEST:fallthrough
		 		case .CROSSES:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATE_FORMAT:fallthrough
		 		case .DAYNAME:fallthrough
		 		case .DAYOFMONTH:fallthrough
		 		case .DAYOFWEEK:fallthrough
		 		case .DAYOFYEAR:fallthrough
		 		case .DECODE:fallthrough
		 		case .DEGREES:fallthrough
		 		case .DES_DECRYPT:fallthrough
		 		case .DES_ENCRYPT:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISJOINT:fallthrough
		 		case .ELT:fallthrough
		 		case .ENCODE:fallthrough
		 		case .ENCRYPT:fallthrough
		 		case .ENDPOINT:fallthrough
		 		case .ENGINE_ATTRIBUTE:fallthrough
		 		case .ENVELOPE:fallthrough
		 		case .EQUALS:fallthrough
		 		case .EXP:fallthrough
		 		case .EXPORT_SET:fallthrough
		 		case .EXTERIORRING:fallthrough
		 		case .EXTRACTVALUE:fallthrough
		 		case .FIELD:fallthrough
		 		case .FIND_IN_SET:fallthrough
		 		case .FLOOR:fallthrough
		 		case .FORMAT:fallthrough
		 		case .FOUND_ROWS:fallthrough
		 		case .FROM_BASE64:fallthrough
		 		case .FROM_DAYS:fallthrough
		 		case .FROM_UNIXTIME:fallthrough
		 		case .GEOMCOLLFROMTEXT:fallthrough
		 		case .GEOMCOLLFROMWKB:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .GEOMETRYFROMTEXT:fallthrough
		 		case .GEOMETRYFROMWKB:fallthrough
		 		case .GEOMETRYN:fallthrough
		 		case .GEOMETRYTYPE:fallthrough
		 		case .GEOMFROMTEXT:fallthrough
		 		case .GEOMFROMWKB:fallthrough
		 		case .GET_FORMAT:fallthrough
		 		case .GET_LOCK:fallthrough
		 		case .GLENGTH:fallthrough
		 		case .GREATEST:fallthrough
		 		case .GTID_SUBSET:fallthrough
		 		case .GTID_SUBTRACT:fallthrough
		 		case .HEX:fallthrough
		 		case .IFNULL:fallthrough
		 		case .INET6_ATON:fallthrough
		 		case .INET6_NTOA:fallthrough
		 		case .INET_ATON:fallthrough
		 		case .INET_NTOA:fallthrough
		 		case .INSTR:fallthrough
		 		case .INTERIORRINGN:fallthrough
		 		case .INTERSECTS:fallthrough
		 		case .ISCLOSED:fallthrough
		 		case .ISEMPTY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .ISSIMPLE:fallthrough
		 		case .IS_FREE_LOCK:fallthrough
		 		case .IS_IPV4:fallthrough
		 		case .IS_IPV4_COMPAT:fallthrough
		 		case .IS_IPV4_MAPPED:fallthrough
		 		case .IS_IPV6:fallthrough
		 		case .IS_USED_LOCK:fallthrough
		 		case .LAST_INSERT_ID:fallthrough
		 		case .LCASE:fallthrough
		 		case .LEAST:fallthrough
		 		case .LENGTH:fallthrough
		 		case .LINEFROMTEXT:fallthrough
		 		case .LINEFROMWKB:fallthrough
		 		case .LINESTRINGFROMTEXT:fallthrough
		 		case .LINESTRINGFROMWKB:fallthrough
		 		case .LN:fallthrough
		 		case .LOAD_FILE:fallthrough
		 		case .LOCATE:fallthrough
		 		case .LOG:fallthrough
		 		case .LOG10:fallthrough
		 		case .LOG2:fallthrough
		 		case .LOWER:fallthrough
		 		case .LPAD:fallthrough
		 		case .LTRIM:fallthrough
		 		case .MAKEDATE:fallthrough
		 		case .MAKETIME:fallthrough
		 		case .MAKE_SET:fallthrough
		 		case .MASTER_POS_WAIT:fallthrough
		 		case .MBRCONTAINS:fallthrough
		 		case .MBRDISJOINT:fallthrough
		 		case .MBREQUAL:fallthrough
		 		case .MBRINTERSECTS:fallthrough
		 		case .MBROVERLAPS:fallthrough
		 		case .MBRTOUCHES:fallthrough
		 		case .MBRWITHIN:fallthrough
		 		case .MD5:fallthrough
		 		case .MLINEFROMTEXT:fallthrough
		 		case .MLINEFROMWKB:fallthrough
		 		case .MONTHNAME:fallthrough
		 		case .MPOINTFROMTEXT:fallthrough
		 		case .MPOINTFROMWKB:fallthrough
		 		case .MPOLYFROMTEXT:fallthrough
		 		case .MPOLYFROMWKB:fallthrough
		 		case .MULTILINESTRINGFROMTEXT:fallthrough
		 		case .MULTILINESTRINGFROMWKB:fallthrough
		 		case .MULTIPOINTFROMTEXT:fallthrough
		 		case .MULTIPOINTFROMWKB:fallthrough
		 		case .MULTIPOLYGONFROMTEXT:fallthrough
		 		case .MULTIPOLYGONFROMWKB:fallthrough
		 		case .NAME_CONST:fallthrough
		 		case .NULLIF:fallthrough
		 		case .NUMGEOMETRIES:fallthrough
		 		case .NUMINTERIORRINGS:fallthrough
		 		case .NUMPOINTS:fallthrough
		 		case .OCT:fallthrough
		 		case .OCTET_LENGTH:fallthrough
		 		case .ORD:fallthrough
		 		case .OVERLAPS:fallthrough
		 		case .PERIOD_ADD:fallthrough
		 		case .PERIOD_DIFF:fallthrough
		 		case .PI:fallthrough
		 		case .POINTFROMTEXT:fallthrough
		 		case .POINTFROMWKB:fallthrough
		 		case .POINTN:fallthrough
		 		case .POLYFROMTEXT:fallthrough
		 		case .POLYFROMWKB:fallthrough
		 		case .POLYGONFROMTEXT:fallthrough
		 		case .POLYGONFROMWKB:fallthrough
		 		case .POW:fallthrough
		 		case .POWER:fallthrough
		 		case .QUOTE:fallthrough
		 		case .RADIANS:fallthrough
		 		case .RAND:fallthrough
		 		case .RANDOM:fallthrough
		 		case .RANDOM_BYTES:fallthrough
		 		case .RELEASE_LOCK:fallthrough
		 		case .REVERSE:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_COUNT:fallthrough
		 		case .RPAD:fallthrough
		 		case .RTRIM:fallthrough
		 		case .SEC_TO_TIME:fallthrough
		 		case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SHA:fallthrough
		 		case .SHA1:fallthrough
		 		case .SHA2:fallthrough
		 		case .SCHEMA_NAME:fallthrough
		 		case .SIGN:fallthrough
		 		case .SIN:fallthrough
		 		case .SLEEP:fallthrough
		 		case .SOUNDEX:fallthrough
		 		case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 		case .SQRT:fallthrough
		 		case .SRID:fallthrough
		 		case .STARTPOINT:fallthrough
		 		case .STRCMP:fallthrough
		 		case .STR_TO_DATE:fallthrough
		 		case .ST_AREA:fallthrough
		 		case .ST_ASBINARY:fallthrough
		 		case .ST_ASTEXT:fallthrough
		 		case .ST_ASWKB:fallthrough
		 		case .ST_ASWKT:fallthrough
		 		case .ST_BUFFER:fallthrough
		 		case .ST_CENTROID:fallthrough
		 		case .ST_CONTAINS:fallthrough
		 		case .ST_CROSSES:fallthrough
		 		case .ST_DIFFERENCE:fallthrough
		 		case .ST_DIMENSION:fallthrough
		 		case .ST_DISJOINT:fallthrough
		 		case .ST_DISTANCE:fallthrough
		 		case .ST_ENDPOINT:fallthrough
		 		case .ST_ENVELOPE:fallthrough
		 		case .ST_EQUALS:fallthrough
		 		case .ST_EXTERIORRING:fallthrough
		 		case .ST_GEOMCOLLFROMTEXT:fallthrough
		 		case .ST_GEOMCOLLFROMTXT:fallthrough
		 		case .ST_GEOMCOLLFROMWKB:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .ST_GEOMETRYFROMTEXT:fallthrough
		 		case .ST_GEOMETRYFROMWKB:fallthrough
		 		case .ST_GEOMETRYN:fallthrough
		 		case .ST_GEOMETRYTYPE:fallthrough
		 		case .ST_GEOMFROMTEXT:fallthrough
		 		case .ST_GEOMFROMWKB:fallthrough
		 		case .ST_INTERIORRINGN:fallthrough
		 		case .ST_INTERSECTION:fallthrough
		 		case .ST_INTERSECTS:fallthrough
		 		case .ST_ISCLOSED:fallthrough
		 		case .ST_ISEMPTY:fallthrough
		 		case .ST_ISSIMPLE:fallthrough
		 		case .ST_LINEFROMTEXT:fallthrough
		 		case .ST_LINEFROMWKB:fallthrough
		 		case .ST_LINESTRINGFROMTEXT:fallthrough
		 		case .ST_LINESTRINGFROMWKB:fallthrough
		 		case .ST_NUMGEOMETRIES:fallthrough
		 		case .ST_NUMINTERIORRING:fallthrough
		 		case .ST_NUMINTERIORRINGS:fallthrough
		 		case .ST_NUMPOINTS:fallthrough
		 		case .ST_OVERLAPS:fallthrough
		 		case .ST_POINTFROMTEXT:fallthrough
		 		case .ST_POINTFROMWKB:fallthrough
		 		case .ST_POINTN:fallthrough
		 		case .ST_POLYFROMTEXT:fallthrough
		 		case .ST_POLYFROMWKB:fallthrough
		 		case .ST_POLYGONFROMTEXT:fallthrough
		 		case .ST_POLYGONFROMWKB:fallthrough
		 		case .ST_SRID:fallthrough
		 		case .ST_STARTPOINT:fallthrough
		 		case .ST_SYMDIFFERENCE:fallthrough
		 		case .ST_TOUCHES:fallthrough
		 		case .ST_UNION:fallthrough
		 		case .ST_WITHIN:fallthrough
		 		case .ST_X:fallthrough
		 		case .ST_Y:fallthrough
		 		case .SUBDATE:fallthrough
		 		case .SUBSTRING_INDEX:fallthrough
		 		case .SUBTIME:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TAN:fallthrough
		 		case .TIMEDIFF:fallthrough
		 		case .TIMESTAMPADD:fallthrough
		 		case .TIMESTAMPDIFF:fallthrough
		 		case .TIME_FORMAT:fallthrough
		 		case .TIME_TO_SEC:fallthrough
		 		case .TOUCHES:fallthrough
		 		case .TO_BASE64:fallthrough
		 		case .TO_DAYS:fallthrough
		 		case .TO_SECONDS:fallthrough
		 		case .TP_CONNECTION_ADMIN:fallthrough
		 		case .UCASE:fallthrough
		 		case .UNCOMPRESS:fallthrough
		 		case .UNCOMPRESSED_LENGTH:fallthrough
		 		case .UNHEX:fallthrough
		 		case .UNIX_TIMESTAMP:fallthrough
		 		case .UPDATEXML:fallthrough
		 		case .UPPER:fallthrough
		 		case .UUID:fallthrough
		 		case .UUID_SHORT:fallthrough
		 		case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 		case .VERSION:fallthrough
		 		case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 		case .WEEKDAY:fallthrough
		 		case .WEEKOFYEAR:fallthrough
		 		case .WEIGHT_STRING:fallthrough
		 		case .WITHIN:fallthrough
		 		case .YEARWEEK:fallthrough
		 		case .Y_FUNCTION:fallthrough
		 		case .X_FUNCTION:fallthrough
		 		case .MOD:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:fallthrough
		 		case .ID:
		 			setState(2897)
		 			try uidList()

		 			break

		 		case .ALL:
		 			setState(2898)
		 			try match(MySqlParser.Tokens.ALL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(2901)
		 		try match(MySqlParser.Tokens.TABLESPACE.rawValue)

		 		break

		 	case .IMPORT:
		 		_localctx =  AlterByImportPartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(2902)
		 		try match(MySqlParser.Tokens.IMPORT.rawValue)
		 		setState(2903)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2906)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ARRAY:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .BUCKETS:fallthrough
		 		case .CONDITION:fallthrough
		 		case .CURRENT:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DIAGNOSTICS:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENFORCED:fallthrough
		 		case .EXCEPT:fallthrough
		 		case .GROUP:fallthrough
		 		case .IF:fallthrough
		 		case .IGNORED:fallthrough
		 		case .INSERT:fallthrough
		 		case .LATERAL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OPTIONAL:fallthrough
		 		case .ORDER:fallthrough
		 		case .PRIMARY:fallthrough
		 		case .REPEAT:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SKIP_QUERY_REWRITE:fallthrough
		 		case .STACKED:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .BINARY:fallthrough
		 		case .TEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .JSON_ARRAY:fallthrough
		 		case .JSON_ARRAYAGG:fallthrough
		 		case .JSON_ARRAY_APPEND:fallthrough
		 		case .JSON_ARRAY_INSERT:fallthrough
		 		case .JSON_CONTAINS:fallthrough
		 		case .JSON_CONTAINS_PATH:fallthrough
		 		case .JSON_DEPTH:fallthrough
		 		case .JSON_EXTRACT:fallthrough
		 		case .JSON_INSERT:fallthrough
		 		case .JSON_KEYS:fallthrough
		 		case .JSON_LENGTH:fallthrough
		 		case .JSON_MERGE:fallthrough
		 		case .JSON_MERGE_PATCH:fallthrough
		 		case .JSON_MERGE_PRESERVE:fallthrough
		 		case .JSON_OBJECT:fallthrough
		 		case .JSON_OBJECTAGG:fallthrough
		 		case .JSON_OVERLAPS:fallthrough
		 		case .JSON_PRETTY:fallthrough
		 		case .JSON_QUOTE:fallthrough
		 		case .JSON_REMOVE:fallthrough
		 		case .JSON_REPLACE:fallthrough
		 		case .JSON_SCHEMA_VALID:fallthrough
		 		case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 		case .JSON_SEARCH:fallthrough
		 		case .JSON_SET:fallthrough
		 		case .JSON_STORAGE_FREE:fallthrough
		 		case .JSON_STORAGE_SIZE:fallthrough
		 		case .JSON_TABLE:fallthrough
		 		case .JSON_TYPE:fallthrough
		 		case .JSON_UNQUOTE:fallthrough
		 		case .JSON_VALID:fallthrough
		 		case .JSON_VALUE:fallthrough
		 		case .NESTED:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .PATH:fallthrough
		 		case .AVG:fallthrough
		 		case .BIT_AND:fallthrough
		 		case .BIT_OR:fallthrough
		 		case .BIT_XOR:fallthrough
		 		case .COUNT:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .GROUP_CONCAT:fallthrough
		 		case .LAG:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NTH_VALUE:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .RANK:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .STD:fallthrough
		 		case .STDDEV:fallthrough
		 		case .STDDEV_POP:fallthrough
		 		case .STDDEV_SAMP:fallthrough
		 		case .SUM:fallthrough
		 		case .VAR_POP:fallthrough
		 		case .VAR_SAMP:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .CURRENT_DATE:fallthrough
		 		case .CURRENT_TIME:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .LOCALTIME:fallthrough
		 		case .CURDATE:fallthrough
		 		case .CURTIME:fallthrough
		 		case .DATE_ADD:fallthrough
		 		case .DATE_SUB:fallthrough
		 		case .LOCALTIMESTAMP:fallthrough
		 		case .NOW:fallthrough
		 		case .POSITION:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .SUBSTRING:fallthrough
		 		case .SYSDATE:fallthrough
		 		case .TRIM:fallthrough
		 		case .UTC_DATE:fallthrough
		 		case .UTC_TIME:fallthrough
		 		case .UTC_TIMESTAMP:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .ACTION:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALGORITHM:fallthrough
		 		case .ANY:fallthrough
		 		case .AT:fallthrough
		 		case .AUTHORS:fallthrough
		 		case .AUTOCOMMIT:fallthrough
		 		case .AUTOEXTEND_SIZE:fallthrough
		 		case .AUTO_INCREMENT:fallthrough
		 		case .AVG_ROW_LENGTH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .BIT:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BTREE:fallthrough
		 		case .CACHE:fallthrough
		 		case .CASCADED:fallthrough
		 		case .CHAIN:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .PAGE_CHECKSUM:fallthrough
		 		case .CIPHER:fallthrough
		 		case .CLASS_ORIGIN:fallthrough
		 		case .CLIENT:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTERING:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CODE:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COLUMN_FORMAT:fallthrough
		 		case .COLUMN_NAME:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMPACT:fallthrough
		 		case .COMPLETION:fallthrough
		 		case .COMPRESSED:fallthrough
		 		case .COMPRESSION:fallthrough
		 		case .CONCURRENT:fallthrough
		 		case .CONNECT:fallthrough
		 		case .CONNECTION:fallthrough
		 		case .CONSISTENT:fallthrough
		 		case .CONSTRAINT_CATALOG:fallthrough
		 		case .CONSTRAINT_SCHEMA:fallthrough
		 		case .CONSTRAINT_NAME:fallthrough
		 		case .CONTAINS:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTRIBUTORS:fallthrough
		 		case .COPY:fallthrough
		 		case .CPU:fallthrough
		 		case .CURSOR_NAME:fallthrough
		 		case .DATA:fallthrough
		 		case .DATAFILE:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DEFAULT_AUTH:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DELAY_KEY_WRITE:fallthrough
		 		case .DES_KEY_FILE:fallthrough
		 		case .DIRECTORY:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISCARD:fallthrough
		 		case .DISK:fallthrough
		 		case .DO:fallthrough
		 		case .DUMPFILE:fallthrough
		 		case .DUPLICATE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .END:fallthrough
		 		case .ENDS:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ENGINES:fallthrough
		 		case .ERROR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVEN:fallthrough
		 		case .EVENT:fallthrough
		 		case .EVENTS:fallthrough
		 		case .EVERY:fallthrough
		 		case .EXCHANGE:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPIRE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .EXTENT_SIZE:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FAST:fallthrough
		 		case .FAULTS:fallthrough
		 		case .FIELDS:fallthrough
		 		case .FILE_BLOCK_SIZE:fallthrough
		 		case .FILTER:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIXED:fallthrough
		 		case .FLUSH:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FOUND:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GENERAL:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GRANTS:fallthrough
		 		case .GROUP_REPLICATION:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HASH:fallthrough
		 		case .HELP:fallthrough
		 		case .HISTORY:fallthrough
		 		case .HOST:fallthrough
		 		case .HOSTS:fallthrough
		 		case .IDENTIFIED:fallthrough
		 		case .IGNORE_SERVER_IDS:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INDEXES:fallthrough
		 		case .INITIAL_SIZE:fallthrough
		 		case .INPLACE:fallthrough
		 		case .INSERT_METHOD:fallthrough
		 		case .INSTALL:fallthrough
		 		case .INSTANCE:fallthrough
		 		case .INSTANT:fallthrough
		 		case .INVISIBLE:fallthrough
		 		case .INVOKER:fallthrough
		 		case .IO:fallthrough
		 		case .IO_THREAD:fallthrough
		 		case .IPC:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ISSUER:fallthrough
		 		case .JSON:fallthrough
		 		case .KEY_BLOCK_SIZE:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LEAVES:fallthrough
		 		case .LESS:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOGFILE:fallthrough
		 		case .LOGS:fallthrough
		 		case .MASTER:fallthrough
		 		case .MASTER_AUTO_POSITION:fallthrough
		 		case .MASTER_CONNECT_RETRY:fallthrough
		 		case .MASTER_DELAY:fallthrough
		 		case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 		case .MASTER_HOST:fallthrough
		 		case .MASTER_LOG_FILE:fallthrough
		 		case .MASTER_LOG_POS:fallthrough
		 		case .MASTER_PASSWORD:fallthrough
		 		case .MASTER_PORT:fallthrough
		 		case .MASTER_RETRY_COUNT:fallthrough
		 		case .MASTER_SSL:fallthrough
		 		case .MASTER_SSL_CA:fallthrough
		 		case .MASTER_SSL_CAPATH:fallthrough
		 		case .MASTER_SSL_CERT:fallthrough
		 		case .MASTER_SSL_CIPHER:fallthrough
		 		case .MASTER_SSL_CRL:fallthrough
		 		case .MASTER_SSL_CRLPATH:fallthrough
		 		case .MASTER_SSL_KEY:fallthrough
		 		case .MASTER_TLS_VERSION:fallthrough
		 		case .MASTER_USER:fallthrough
		 		case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 		case .MAX_QUERIES_PER_HOUR:fallthrough
		 		case .MAX_ROWS:fallthrough
		 		case .MAX_SIZE:fallthrough
		 		case .MAX_UPDATES_PER_HOUR:fallthrough
		 		case .MAX_USER_CONNECTIONS:fallthrough
		 		case .MEDIUM:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MESSAGE_TEXT:fallthrough
		 		case .MID:fallthrough
		 		case .MIGRATE:fallthrough
		 		case .MIN_ROWS:fallthrough
		 		case .MODE:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MUTEX:fallthrough
		 		case .MYSQL:fallthrough
		 		case .MYSQL_ERRNO:fallthrough
		 		case .NAME:fallthrough
		 		case .NAMES:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NEVER:fallthrough
		 		case .NEXT:fallthrough
		 		case .NO:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOWAIT:fallthrough
		 		case .NODEGROUP:fallthrough
		 		case .NONE:fallthrough
		 		case .ODBC:fallthrough
		 		case .OFFLINE:fallthrough
		 		case .OFFSET:fallthrough
		 		case .OF:fallthrough
		 		case .OJ:fallthrough
		 		case .OLD_PASSWORD:fallthrough
		 		case .ONE:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .OPTIMIZER_COSTS:fallthrough
		 		case .OPTIONS:fallthrough
		 		case .OWNER:fallthrough
		 		case .PACK_KEYS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PARSER:fallthrough
		 		case .PARTIAL:fallthrough
		 		case .PARTITIONING:fallthrough
		 		case .PARTITIONS:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PHASE:fallthrough
		 		case .PLUGIN:fallthrough
		 		case .PLUGIN_DIR:fallthrough
		 		case .PLUGINS:fallthrough
		 		case .PORT:fallthrough
		 		case .PRECEDES:fallthrough
		 		case .PREPARE:fallthrough
		 		case .PRESERVE:fallthrough
		 		case .PREV:fallthrough
		 		case .PROCESSLIST:fallthrough
		 		case .PROFILE:fallthrough
		 		case .PROFILES:fallthrough
		 		case .PROXY:fallthrough
		 		case .QUERY:fallthrough
		 		case .QUICK:fallthrough
		 		case .REBUILD:fallthrough
		 		case .RECOVER:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REDO_BUFFER_SIZE:fallthrough
		 		case .REDUNDANT:fallthrough
		 		case .RELAY:fallthrough
		 		case .RELAY_LOG_FILE:fallthrough
		 		case .RELAY_LOG_POS:fallthrough
		 		case .RELAYLOG:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REORGANIZE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .REPLICATE_DO_DB:fallthrough
		 		case .REPLICATE_DO_TABLE:fallthrough
		 		case .REPLICATE_IGNORE_DB:fallthrough
		 		case .REPLICATE_IGNORE_TABLE:fallthrough
		 		case .REPLICATE_REWRITE_DB:fallthrough
		 		case .REPLICATE_WILD_DO_TABLE:fallthrough
		 		case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 		case .REPLICATION:fallthrough
		 		case .RESET:fallthrough
		 		case .RESUME:fallthrough
		 		case .RETURNED_SQLSTATE:fallthrough
		 		case .RETURNING:fallthrough
		 		case .RETURNS:fallthrough
		 		case .REUSE:fallthrough
		 		case .ROLE:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROTATE:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_FORMAT:fallthrough
		 		case .RTREE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEDULE:fallthrough
		 		case .SECURITY:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION:fallthrough
		 		case .SHARE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SIGNED:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SLAVE:fallthrough
		 		case .SLOW:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOCKET:fallthrough
		 		case .SOME:fallthrough
		 		case .SONAME:fallthrough
		 		case .SOUNDS:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SQL_AFTER_GTIDS:fallthrough
		 		case .SQL_AFTER_MTS_GAPS:fallthrough
		 		case .SQL_BEFORE_GTIDS:fallthrough
		 		case .SQL_BUFFER_RESULT:fallthrough
		 		case .SQL_CACHE:fallthrough
		 		case .SQL_NO_CACHE:fallthrough
		 		case .SQL_THREAD:fallthrough
		 		case .START:fallthrough
		 		case .STARTS:fallthrough
		 		case .STATS_AUTO_RECALC:fallthrough
		 		case .STATS_PERSISTENT:fallthrough
		 		case .STATS_SAMPLE_PAGES:fallthrough
		 		case .STATUS:fallthrough
		 		case .STOP:fallthrough
		 		case .STORAGE:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBCLASS_ORIGIN:fallthrough
		 		case .SUBJECT:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBPARTITIONS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .SWAPS:fallthrough
		 		case .SWITCHES:fallthrough
		 		case .TABLE_NAME:fallthrough
		 		case .TABLESPACE:fallthrough
		 		case .TABLE_TYPE:fallthrough
		 		case .TEMPORARY:fallthrough
		 		case .TEMPTABLE:fallthrough
		 		case .THAN:fallthrough
		 		case .TRADITIONAL:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSACTIONAL:fallthrough
		 		case .TRIGGERS:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDEFINED:fallthrough
		 		case .UNDOFILE:fallthrough
		 		case .UNDO_BUFFER_SIZE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPGRADE:fallthrough
		 		case .USER:fallthrough
		 		case .USE_FRM:fallthrough
		 		case .USER_RESOURCES:fallthrough
		 		case .VALIDATION:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARIABLES:fallthrough
		 		case .VIEW:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .VISIBLE:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNINGS:fallthrough
		 		case .WITHOUT:fallthrough
		 		case .WORK:fallthrough
		 		case .WRAPPER:fallthrough
		 		case .X509:fallthrough
		 		case .XA:fallthrough
		 		case .XML:fallthrough
		 		case .EUR:fallthrough
		 		case .USA:fallthrough
		 		case .JIS:fallthrough
		 		case .ISO:fallthrough
		 		case .INTERNAL:fallthrough
		 		case .QUARTER:fallthrough
		 		case .MONTH:fallthrough
		 		case .DAY:fallthrough
		 		case .HOUR:fallthrough
		 		case .MINUTE:fallthrough
		 		case .WEEK:fallthrough
		 		case .SECOND:fallthrough
		 		case .MICROSECOND:fallthrough
		 		case .ADMIN:fallthrough
		 		case .AUDIT_ABORT_EXEMPT:fallthrough
		 		case .AUDIT_ADMIN:fallthrough
		 		case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 		case .BACKUP_ADMIN:fallthrough
		 		case .BINLOG_ADMIN:fallthrough
		 		case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 		case .CLONE_ADMIN:fallthrough
		 		case .CONNECTION_ADMIN:fallthrough
		 		case .ENCRYPTION_KEY_ADMIN:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .FILE:fallthrough
		 		case .FIREWALL_ADMIN:fallthrough
		 		case .FIREWALL_EXEMPT:fallthrough
		 		case .FIREWALL_USER:fallthrough
		 		case .GROUP_REPLICATION_ADMIN:fallthrough
		 		case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 		case .INVOKE:fallthrough
		 		case .LAMBDA:fallthrough
		 		case .NDB_STORED_USER:fallthrough
		 		case .PASSWORDLESS_USER_ADMIN:fallthrough
		 		case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .PROCESS:fallthrough
		 		case .RELOAD:fallthrough
		 		case .REPLICATION_APPLIER:fallthrough
		 		case .REPLICATION_SLAVE_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_USER:fallthrough
		 		case .ROLE_ADMIN:fallthrough
		 		case .ROUTINE:fallthrough
		 		case .S3:fallthrough
		 		case .SESSION_VARIABLES_ADMIN:fallthrough
		 		case .SET_USER_ID:fallthrough
		 		case .SHOW_ROUTINE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SUPER:fallthrough
		 		case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 		case .TABLES:fallthrough
		 		case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 		case .VERSION_TOKEN_ADMIN:fallthrough
		 		case .XA_RECOVER_ADMIN:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .ARCHIVE:fallthrough
		 		case .BLACKHOLE:fallthrough
		 		case .CSV:fallthrough
		 		case .FEDERATED:fallthrough
		 		case .INNODB:fallthrough
		 		case .MEMORY:fallthrough
		 		case .MRG_MYISAM:fallthrough
		 		case .MYISAM:fallthrough
		 		case .NDB:fallthrough
		 		case .NDBCLUSTER:fallthrough
		 		case .PERFORMANCE_SCHEMA:fallthrough
		 		case .TOKUDB:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:fallthrough
		 		case .ABS:fallthrough
		 		case .ACOS:fallthrough
		 		case .ADDDATE:fallthrough
		 		case .ADDTIME:fallthrough
		 		case .AES_DECRYPT:fallthrough
		 		case .AES_ENCRYPT:fallthrough
		 		case .AREA:fallthrough
		 		case .ASBINARY:fallthrough
		 		case .ASIN:fallthrough
		 		case .ASTEXT:fallthrough
		 		case .ASWKB:fallthrough
		 		case .ASWKT:fallthrough
		 		case .ASYMMETRIC_DECRYPT:fallthrough
		 		case .ASYMMETRIC_DERIVE:fallthrough
		 		case .ASYMMETRIC_ENCRYPT:fallthrough
		 		case .ASYMMETRIC_SIGN:fallthrough
		 		case .ASYMMETRIC_VERIFY:fallthrough
		 		case .ATAN:fallthrough
		 		case .ATAN2:fallthrough
		 		case .BENCHMARK:fallthrough
		 		case .BIN:fallthrough
		 		case .BIT_COUNT:fallthrough
		 		case .BIT_LENGTH:fallthrough
		 		case .BUFFER:fallthrough
		 		case .CATALOG_NAME:fallthrough
		 		case .CEIL:fallthrough
		 		case .CEILING:fallthrough
		 		case .CENTROID:fallthrough
		 		case .CHARACTER_LENGTH:fallthrough
		 		case .CHARSET:fallthrough
		 		case .CHAR_LENGTH:fallthrough
		 		case .COERCIBILITY:fallthrough
		 		case .COLLATION:fallthrough
		 		case .COMPRESS:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_WS:fallthrough
		 		case .CONNECTION_ID:fallthrough
		 		case .CONV:fallthrough
		 		case .CONVERT_TZ:fallthrough
		 		case .COS:fallthrough
		 		case .COT:fallthrough
		 		case .CRC32:fallthrough
		 		case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 		case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 		case .CREATE_DH_PARAMETERS:fallthrough
		 		case .CREATE_DIGEST:fallthrough
		 		case .CROSSES:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATE_FORMAT:fallthrough
		 		case .DAYNAME:fallthrough
		 		case .DAYOFMONTH:fallthrough
		 		case .DAYOFWEEK:fallthrough
		 		case .DAYOFYEAR:fallthrough
		 		case .DECODE:fallthrough
		 		case .DEGREES:fallthrough
		 		case .DES_DECRYPT:fallthrough
		 		case .DES_ENCRYPT:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISJOINT:fallthrough
		 		case .ELT:fallthrough
		 		case .ENCODE:fallthrough
		 		case .ENCRYPT:fallthrough
		 		case .ENDPOINT:fallthrough
		 		case .ENGINE_ATTRIBUTE:fallthrough
		 		case .ENVELOPE:fallthrough
		 		case .EQUALS:fallthrough
		 		case .EXP:fallthrough
		 		case .EXPORT_SET:fallthrough
		 		case .EXTERIORRING:fallthrough
		 		case .EXTRACTVALUE:fallthrough
		 		case .FIELD:fallthrough
		 		case .FIND_IN_SET:fallthrough
		 		case .FLOOR:fallthrough
		 		case .FORMAT:fallthrough
		 		case .FOUND_ROWS:fallthrough
		 		case .FROM_BASE64:fallthrough
		 		case .FROM_DAYS:fallthrough
		 		case .FROM_UNIXTIME:fallthrough
		 		case .GEOMCOLLFROMTEXT:fallthrough
		 		case .GEOMCOLLFROMWKB:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .GEOMETRYFROMTEXT:fallthrough
		 		case .GEOMETRYFROMWKB:fallthrough
		 		case .GEOMETRYN:fallthrough
		 		case .GEOMETRYTYPE:fallthrough
		 		case .GEOMFROMTEXT:fallthrough
		 		case .GEOMFROMWKB:fallthrough
		 		case .GET_FORMAT:fallthrough
		 		case .GET_LOCK:fallthrough
		 		case .GLENGTH:fallthrough
		 		case .GREATEST:fallthrough
		 		case .GTID_SUBSET:fallthrough
		 		case .GTID_SUBTRACT:fallthrough
		 		case .HEX:fallthrough
		 		case .IFNULL:fallthrough
		 		case .INET6_ATON:fallthrough
		 		case .INET6_NTOA:fallthrough
		 		case .INET_ATON:fallthrough
		 		case .INET_NTOA:fallthrough
		 		case .INSTR:fallthrough
		 		case .INTERIORRINGN:fallthrough
		 		case .INTERSECTS:fallthrough
		 		case .ISCLOSED:fallthrough
		 		case .ISEMPTY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .ISSIMPLE:fallthrough
		 		case .IS_FREE_LOCK:fallthrough
		 		case .IS_IPV4:fallthrough
		 		case .IS_IPV4_COMPAT:fallthrough
		 		case .IS_IPV4_MAPPED:fallthrough
		 		case .IS_IPV6:fallthrough
		 		case .IS_USED_LOCK:fallthrough
		 		case .LAST_INSERT_ID:fallthrough
		 		case .LCASE:fallthrough
		 		case .LEAST:fallthrough
		 		case .LENGTH:fallthrough
		 		case .LINEFROMTEXT:fallthrough
		 		case .LINEFROMWKB:fallthrough
		 		case .LINESTRINGFROMTEXT:fallthrough
		 		case .LINESTRINGFROMWKB:fallthrough
		 		case .LN:fallthrough
		 		case .LOAD_FILE:fallthrough
		 		case .LOCATE:fallthrough
		 		case .LOG:fallthrough
		 		case .LOG10:fallthrough
		 		case .LOG2:fallthrough
		 		case .LOWER:fallthrough
		 		case .LPAD:fallthrough
		 		case .LTRIM:fallthrough
		 		case .MAKEDATE:fallthrough
		 		case .MAKETIME:fallthrough
		 		case .MAKE_SET:fallthrough
		 		case .MASTER_POS_WAIT:fallthrough
		 		case .MBRCONTAINS:fallthrough
		 		case .MBRDISJOINT:fallthrough
		 		case .MBREQUAL:fallthrough
		 		case .MBRINTERSECTS:fallthrough
		 		case .MBROVERLAPS:fallthrough
		 		case .MBRTOUCHES:fallthrough
		 		case .MBRWITHIN:fallthrough
		 		case .MD5:fallthrough
		 		case .MLINEFROMTEXT:fallthrough
		 		case .MLINEFROMWKB:fallthrough
		 		case .MONTHNAME:fallthrough
		 		case .MPOINTFROMTEXT:fallthrough
		 		case .MPOINTFROMWKB:fallthrough
		 		case .MPOLYFROMTEXT:fallthrough
		 		case .MPOLYFROMWKB:fallthrough
		 		case .MULTILINESTRINGFROMTEXT:fallthrough
		 		case .MULTILINESTRINGFROMWKB:fallthrough
		 		case .MULTIPOINTFROMTEXT:fallthrough
		 		case .MULTIPOINTFROMWKB:fallthrough
		 		case .MULTIPOLYGONFROMTEXT:fallthrough
		 		case .MULTIPOLYGONFROMWKB:fallthrough
		 		case .NAME_CONST:fallthrough
		 		case .NULLIF:fallthrough
		 		case .NUMGEOMETRIES:fallthrough
		 		case .NUMINTERIORRINGS:fallthrough
		 		case .NUMPOINTS:fallthrough
		 		case .OCT:fallthrough
		 		case .OCTET_LENGTH:fallthrough
		 		case .ORD:fallthrough
		 		case .OVERLAPS:fallthrough
		 		case .PERIOD_ADD:fallthrough
		 		case .PERIOD_DIFF:fallthrough
		 		case .PI:fallthrough
		 		case .POINTFROMTEXT:fallthrough
		 		case .POINTFROMWKB:fallthrough
		 		case .POINTN:fallthrough
		 		case .POLYFROMTEXT:fallthrough
		 		case .POLYFROMWKB:fallthrough
		 		case .POLYGONFROMTEXT:fallthrough
		 		case .POLYGONFROMWKB:fallthrough
		 		case .POW:fallthrough
		 		case .POWER:fallthrough
		 		case .QUOTE:fallthrough
		 		case .RADIANS:fallthrough
		 		case .RAND:fallthrough
		 		case .RANDOM:fallthrough
		 		case .RANDOM_BYTES:fallthrough
		 		case .RELEASE_LOCK:fallthrough
		 		case .REVERSE:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_COUNT:fallthrough
		 		case .RPAD:fallthrough
		 		case .RTRIM:fallthrough
		 		case .SEC_TO_TIME:fallthrough
		 		case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SHA:fallthrough
		 		case .SHA1:fallthrough
		 		case .SHA2:fallthrough
		 		case .SCHEMA_NAME:fallthrough
		 		case .SIGN:fallthrough
		 		case .SIN:fallthrough
		 		case .SLEEP:fallthrough
		 		case .SOUNDEX:fallthrough
		 		case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 		case .SQRT:fallthrough
		 		case .SRID:fallthrough
		 		case .STARTPOINT:fallthrough
		 		case .STRCMP:fallthrough
		 		case .STR_TO_DATE:fallthrough
		 		case .ST_AREA:fallthrough
		 		case .ST_ASBINARY:fallthrough
		 		case .ST_ASTEXT:fallthrough
		 		case .ST_ASWKB:fallthrough
		 		case .ST_ASWKT:fallthrough
		 		case .ST_BUFFER:fallthrough
		 		case .ST_CENTROID:fallthrough
		 		case .ST_CONTAINS:fallthrough
		 		case .ST_CROSSES:fallthrough
		 		case .ST_DIFFERENCE:fallthrough
		 		case .ST_DIMENSION:fallthrough
		 		case .ST_DISJOINT:fallthrough
		 		case .ST_DISTANCE:fallthrough
		 		case .ST_ENDPOINT:fallthrough
		 		case .ST_ENVELOPE:fallthrough
		 		case .ST_EQUALS:fallthrough
		 		case .ST_EXTERIORRING:fallthrough
		 		case .ST_GEOMCOLLFROMTEXT:fallthrough
		 		case .ST_GEOMCOLLFROMTXT:fallthrough
		 		case .ST_GEOMCOLLFROMWKB:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .ST_GEOMETRYFROMTEXT:fallthrough
		 		case .ST_GEOMETRYFROMWKB:fallthrough
		 		case .ST_GEOMETRYN:fallthrough
		 		case .ST_GEOMETRYTYPE:fallthrough
		 		case .ST_GEOMFROMTEXT:fallthrough
		 		case .ST_GEOMFROMWKB:fallthrough
		 		case .ST_INTERIORRINGN:fallthrough
		 		case .ST_INTERSECTION:fallthrough
		 		case .ST_INTERSECTS:fallthrough
		 		case .ST_ISCLOSED:fallthrough
		 		case .ST_ISEMPTY:fallthrough
		 		case .ST_ISSIMPLE:fallthrough
		 		case .ST_LINEFROMTEXT:fallthrough
		 		case .ST_LINEFROMWKB:fallthrough
		 		case .ST_LINESTRINGFROMTEXT:fallthrough
		 		case .ST_LINESTRINGFROMWKB:fallthrough
		 		case .ST_NUMGEOMETRIES:fallthrough
		 		case .ST_NUMINTERIORRING:fallthrough
		 		case .ST_NUMINTERIORRINGS:fallthrough
		 		case .ST_NUMPOINTS:fallthrough
		 		case .ST_OVERLAPS:fallthrough
		 		case .ST_POINTFROMTEXT:fallthrough
		 		case .ST_POINTFROMWKB:fallthrough
		 		case .ST_POINTN:fallthrough
		 		case .ST_POLYFROMTEXT:fallthrough
		 		case .ST_POLYFROMWKB:fallthrough
		 		case .ST_POLYGONFROMTEXT:fallthrough
		 		case .ST_POLYGONFROMWKB:fallthrough
		 		case .ST_SRID:fallthrough
		 		case .ST_STARTPOINT:fallthrough
		 		case .ST_SYMDIFFERENCE:fallthrough
		 		case .ST_TOUCHES:fallthrough
		 		case .ST_UNION:fallthrough
		 		case .ST_WITHIN:fallthrough
		 		case .ST_X:fallthrough
		 		case .ST_Y:fallthrough
		 		case .SUBDATE:fallthrough
		 		case .SUBSTRING_INDEX:fallthrough
		 		case .SUBTIME:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TAN:fallthrough
		 		case .TIMEDIFF:fallthrough
		 		case .TIMESTAMPADD:fallthrough
		 		case .TIMESTAMPDIFF:fallthrough
		 		case .TIME_FORMAT:fallthrough
		 		case .TIME_TO_SEC:fallthrough
		 		case .TOUCHES:fallthrough
		 		case .TO_BASE64:fallthrough
		 		case .TO_DAYS:fallthrough
		 		case .TO_SECONDS:fallthrough
		 		case .TP_CONNECTION_ADMIN:fallthrough
		 		case .UCASE:fallthrough
		 		case .UNCOMPRESS:fallthrough
		 		case .UNCOMPRESSED_LENGTH:fallthrough
		 		case .UNHEX:fallthrough
		 		case .UNIX_TIMESTAMP:fallthrough
		 		case .UPDATEXML:fallthrough
		 		case .UPPER:fallthrough
		 		case .UUID:fallthrough
		 		case .UUID_SHORT:fallthrough
		 		case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 		case .VERSION:fallthrough
		 		case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 		case .WEEKDAY:fallthrough
		 		case .WEEKOFYEAR:fallthrough
		 		case .WEIGHT_STRING:fallthrough
		 		case .WITHIN:fallthrough
		 		case .YEARWEEK:fallthrough
		 		case .Y_FUNCTION:fallthrough
		 		case .X_FUNCTION:fallthrough
		 		case .MOD:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:fallthrough
		 		case .ID:
		 			setState(2904)
		 			try uidList()

		 			break

		 		case .ALL:
		 			setState(2905)
		 			try match(MySqlParser.Tokens.ALL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(2908)
		 		try match(MySqlParser.Tokens.TABLESPACE.rawValue)

		 		break

		 	case .TRUNCATE:
		 		_localctx =  AlterByTruncatePartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(2909)
		 		try match(MySqlParser.Tokens.TRUNCATE.rawValue)
		 		setState(2910)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2913)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ARRAY:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .BUCKETS:fallthrough
		 		case .CONDITION:fallthrough
		 		case .CURRENT:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DIAGNOSTICS:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENFORCED:fallthrough
		 		case .EXCEPT:fallthrough
		 		case .GROUP:fallthrough
		 		case .IF:fallthrough
		 		case .IGNORED:fallthrough
		 		case .INSERT:fallthrough
		 		case .LATERAL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OPTIONAL:fallthrough
		 		case .ORDER:fallthrough
		 		case .PRIMARY:fallthrough
		 		case .REPEAT:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SKIP_QUERY_REWRITE:fallthrough
		 		case .STACKED:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .BINARY:fallthrough
		 		case .TEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .JSON_ARRAY:fallthrough
		 		case .JSON_ARRAYAGG:fallthrough
		 		case .JSON_ARRAY_APPEND:fallthrough
		 		case .JSON_ARRAY_INSERT:fallthrough
		 		case .JSON_CONTAINS:fallthrough
		 		case .JSON_CONTAINS_PATH:fallthrough
		 		case .JSON_DEPTH:fallthrough
		 		case .JSON_EXTRACT:fallthrough
		 		case .JSON_INSERT:fallthrough
		 		case .JSON_KEYS:fallthrough
		 		case .JSON_LENGTH:fallthrough
		 		case .JSON_MERGE:fallthrough
		 		case .JSON_MERGE_PATCH:fallthrough
		 		case .JSON_MERGE_PRESERVE:fallthrough
		 		case .JSON_OBJECT:fallthrough
		 		case .JSON_OBJECTAGG:fallthrough
		 		case .JSON_OVERLAPS:fallthrough
		 		case .JSON_PRETTY:fallthrough
		 		case .JSON_QUOTE:fallthrough
		 		case .JSON_REMOVE:fallthrough
		 		case .JSON_REPLACE:fallthrough
		 		case .JSON_SCHEMA_VALID:fallthrough
		 		case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 		case .JSON_SEARCH:fallthrough
		 		case .JSON_SET:fallthrough
		 		case .JSON_STORAGE_FREE:fallthrough
		 		case .JSON_STORAGE_SIZE:fallthrough
		 		case .JSON_TABLE:fallthrough
		 		case .JSON_TYPE:fallthrough
		 		case .JSON_UNQUOTE:fallthrough
		 		case .JSON_VALID:fallthrough
		 		case .JSON_VALUE:fallthrough
		 		case .NESTED:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .PATH:fallthrough
		 		case .AVG:fallthrough
		 		case .BIT_AND:fallthrough
		 		case .BIT_OR:fallthrough
		 		case .BIT_XOR:fallthrough
		 		case .COUNT:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .GROUP_CONCAT:fallthrough
		 		case .LAG:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NTH_VALUE:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .RANK:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .STD:fallthrough
		 		case .STDDEV:fallthrough
		 		case .STDDEV_POP:fallthrough
		 		case .STDDEV_SAMP:fallthrough
		 		case .SUM:fallthrough
		 		case .VAR_POP:fallthrough
		 		case .VAR_SAMP:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .CURRENT_DATE:fallthrough
		 		case .CURRENT_TIME:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .LOCALTIME:fallthrough
		 		case .CURDATE:fallthrough
		 		case .CURTIME:fallthrough
		 		case .DATE_ADD:fallthrough
		 		case .DATE_SUB:fallthrough
		 		case .LOCALTIMESTAMP:fallthrough
		 		case .NOW:fallthrough
		 		case .POSITION:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .SUBSTRING:fallthrough
		 		case .SYSDATE:fallthrough
		 		case .TRIM:fallthrough
		 		case .UTC_DATE:fallthrough
		 		case .UTC_TIME:fallthrough
		 		case .UTC_TIMESTAMP:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .ACTION:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALGORITHM:fallthrough
		 		case .ANY:fallthrough
		 		case .AT:fallthrough
		 		case .AUTHORS:fallthrough
		 		case .AUTOCOMMIT:fallthrough
		 		case .AUTOEXTEND_SIZE:fallthrough
		 		case .AUTO_INCREMENT:fallthrough
		 		case .AVG_ROW_LENGTH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .BIT:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BTREE:fallthrough
		 		case .CACHE:fallthrough
		 		case .CASCADED:fallthrough
		 		case .CHAIN:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .PAGE_CHECKSUM:fallthrough
		 		case .CIPHER:fallthrough
		 		case .CLASS_ORIGIN:fallthrough
		 		case .CLIENT:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTERING:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CODE:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COLUMN_FORMAT:fallthrough
		 		case .COLUMN_NAME:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMPACT:fallthrough
		 		case .COMPLETION:fallthrough
		 		case .COMPRESSED:fallthrough
		 		case .COMPRESSION:fallthrough
		 		case .CONCURRENT:fallthrough
		 		case .CONNECT:fallthrough
		 		case .CONNECTION:fallthrough
		 		case .CONSISTENT:fallthrough
		 		case .CONSTRAINT_CATALOG:fallthrough
		 		case .CONSTRAINT_SCHEMA:fallthrough
		 		case .CONSTRAINT_NAME:fallthrough
		 		case .CONTAINS:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTRIBUTORS:fallthrough
		 		case .COPY:fallthrough
		 		case .CPU:fallthrough
		 		case .CURSOR_NAME:fallthrough
		 		case .DATA:fallthrough
		 		case .DATAFILE:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DEFAULT_AUTH:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DELAY_KEY_WRITE:fallthrough
		 		case .DES_KEY_FILE:fallthrough
		 		case .DIRECTORY:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISCARD:fallthrough
		 		case .DISK:fallthrough
		 		case .DO:fallthrough
		 		case .DUMPFILE:fallthrough
		 		case .DUPLICATE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .END:fallthrough
		 		case .ENDS:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ENGINES:fallthrough
		 		case .ERROR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVEN:fallthrough
		 		case .EVENT:fallthrough
		 		case .EVENTS:fallthrough
		 		case .EVERY:fallthrough
		 		case .EXCHANGE:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPIRE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .EXTENT_SIZE:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FAST:fallthrough
		 		case .FAULTS:fallthrough
		 		case .FIELDS:fallthrough
		 		case .FILE_BLOCK_SIZE:fallthrough
		 		case .FILTER:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIXED:fallthrough
		 		case .FLUSH:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FOUND:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GENERAL:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GRANTS:fallthrough
		 		case .GROUP_REPLICATION:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HASH:fallthrough
		 		case .HELP:fallthrough
		 		case .HISTORY:fallthrough
		 		case .HOST:fallthrough
		 		case .HOSTS:fallthrough
		 		case .IDENTIFIED:fallthrough
		 		case .IGNORE_SERVER_IDS:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INDEXES:fallthrough
		 		case .INITIAL_SIZE:fallthrough
		 		case .INPLACE:fallthrough
		 		case .INSERT_METHOD:fallthrough
		 		case .INSTALL:fallthrough
		 		case .INSTANCE:fallthrough
		 		case .INSTANT:fallthrough
		 		case .INVISIBLE:fallthrough
		 		case .INVOKER:fallthrough
		 		case .IO:fallthrough
		 		case .IO_THREAD:fallthrough
		 		case .IPC:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ISSUER:fallthrough
		 		case .JSON:fallthrough
		 		case .KEY_BLOCK_SIZE:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LEAVES:fallthrough
		 		case .LESS:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOGFILE:fallthrough
		 		case .LOGS:fallthrough
		 		case .MASTER:fallthrough
		 		case .MASTER_AUTO_POSITION:fallthrough
		 		case .MASTER_CONNECT_RETRY:fallthrough
		 		case .MASTER_DELAY:fallthrough
		 		case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 		case .MASTER_HOST:fallthrough
		 		case .MASTER_LOG_FILE:fallthrough
		 		case .MASTER_LOG_POS:fallthrough
		 		case .MASTER_PASSWORD:fallthrough
		 		case .MASTER_PORT:fallthrough
		 		case .MASTER_RETRY_COUNT:fallthrough
		 		case .MASTER_SSL:fallthrough
		 		case .MASTER_SSL_CA:fallthrough
		 		case .MASTER_SSL_CAPATH:fallthrough
		 		case .MASTER_SSL_CERT:fallthrough
		 		case .MASTER_SSL_CIPHER:fallthrough
		 		case .MASTER_SSL_CRL:fallthrough
		 		case .MASTER_SSL_CRLPATH:fallthrough
		 		case .MASTER_SSL_KEY:fallthrough
		 		case .MASTER_TLS_VERSION:fallthrough
		 		case .MASTER_USER:fallthrough
		 		case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 		case .MAX_QUERIES_PER_HOUR:fallthrough
		 		case .MAX_ROWS:fallthrough
		 		case .MAX_SIZE:fallthrough
		 		case .MAX_UPDATES_PER_HOUR:fallthrough
		 		case .MAX_USER_CONNECTIONS:fallthrough
		 		case .MEDIUM:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MESSAGE_TEXT:fallthrough
		 		case .MID:fallthrough
		 		case .MIGRATE:fallthrough
		 		case .MIN_ROWS:fallthrough
		 		case .MODE:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MUTEX:fallthrough
		 		case .MYSQL:fallthrough
		 		case .MYSQL_ERRNO:fallthrough
		 		case .NAME:fallthrough
		 		case .NAMES:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NEVER:fallthrough
		 		case .NEXT:fallthrough
		 		case .NO:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOWAIT:fallthrough
		 		case .NODEGROUP:fallthrough
		 		case .NONE:fallthrough
		 		case .ODBC:fallthrough
		 		case .OFFLINE:fallthrough
		 		case .OFFSET:fallthrough
		 		case .OF:fallthrough
		 		case .OJ:fallthrough
		 		case .OLD_PASSWORD:fallthrough
		 		case .ONE:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .OPTIMIZER_COSTS:fallthrough
		 		case .OPTIONS:fallthrough
		 		case .OWNER:fallthrough
		 		case .PACK_KEYS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PARSER:fallthrough
		 		case .PARTIAL:fallthrough
		 		case .PARTITIONING:fallthrough
		 		case .PARTITIONS:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PHASE:fallthrough
		 		case .PLUGIN:fallthrough
		 		case .PLUGIN_DIR:fallthrough
		 		case .PLUGINS:fallthrough
		 		case .PORT:fallthrough
		 		case .PRECEDES:fallthrough
		 		case .PREPARE:fallthrough
		 		case .PRESERVE:fallthrough
		 		case .PREV:fallthrough
		 		case .PROCESSLIST:fallthrough
		 		case .PROFILE:fallthrough
		 		case .PROFILES:fallthrough
		 		case .PROXY:fallthrough
		 		case .QUERY:fallthrough
		 		case .QUICK:fallthrough
		 		case .REBUILD:fallthrough
		 		case .RECOVER:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REDO_BUFFER_SIZE:fallthrough
		 		case .REDUNDANT:fallthrough
		 		case .RELAY:fallthrough
		 		case .RELAY_LOG_FILE:fallthrough
		 		case .RELAY_LOG_POS:fallthrough
		 		case .RELAYLOG:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REORGANIZE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .REPLICATE_DO_DB:fallthrough
		 		case .REPLICATE_DO_TABLE:fallthrough
		 		case .REPLICATE_IGNORE_DB:fallthrough
		 		case .REPLICATE_IGNORE_TABLE:fallthrough
		 		case .REPLICATE_REWRITE_DB:fallthrough
		 		case .REPLICATE_WILD_DO_TABLE:fallthrough
		 		case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 		case .REPLICATION:fallthrough
		 		case .RESET:fallthrough
		 		case .RESUME:fallthrough
		 		case .RETURNED_SQLSTATE:fallthrough
		 		case .RETURNING:fallthrough
		 		case .RETURNS:fallthrough
		 		case .REUSE:fallthrough
		 		case .ROLE:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROTATE:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_FORMAT:fallthrough
		 		case .RTREE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEDULE:fallthrough
		 		case .SECURITY:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION:fallthrough
		 		case .SHARE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SIGNED:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SLAVE:fallthrough
		 		case .SLOW:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOCKET:fallthrough
		 		case .SOME:fallthrough
		 		case .SONAME:fallthrough
		 		case .SOUNDS:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SQL_AFTER_GTIDS:fallthrough
		 		case .SQL_AFTER_MTS_GAPS:fallthrough
		 		case .SQL_BEFORE_GTIDS:fallthrough
		 		case .SQL_BUFFER_RESULT:fallthrough
		 		case .SQL_CACHE:fallthrough
		 		case .SQL_NO_CACHE:fallthrough
		 		case .SQL_THREAD:fallthrough
		 		case .START:fallthrough
		 		case .STARTS:fallthrough
		 		case .STATS_AUTO_RECALC:fallthrough
		 		case .STATS_PERSISTENT:fallthrough
		 		case .STATS_SAMPLE_PAGES:fallthrough
		 		case .STATUS:fallthrough
		 		case .STOP:fallthrough
		 		case .STORAGE:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBCLASS_ORIGIN:fallthrough
		 		case .SUBJECT:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBPARTITIONS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .SWAPS:fallthrough
		 		case .SWITCHES:fallthrough
		 		case .TABLE_NAME:fallthrough
		 		case .TABLESPACE:fallthrough
		 		case .TABLE_TYPE:fallthrough
		 		case .TEMPORARY:fallthrough
		 		case .TEMPTABLE:fallthrough
		 		case .THAN:fallthrough
		 		case .TRADITIONAL:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSACTIONAL:fallthrough
		 		case .TRIGGERS:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDEFINED:fallthrough
		 		case .UNDOFILE:fallthrough
		 		case .UNDO_BUFFER_SIZE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPGRADE:fallthrough
		 		case .USER:fallthrough
		 		case .USE_FRM:fallthrough
		 		case .USER_RESOURCES:fallthrough
		 		case .VALIDATION:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARIABLES:fallthrough
		 		case .VIEW:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .VISIBLE:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNINGS:fallthrough
		 		case .WITHOUT:fallthrough
		 		case .WORK:fallthrough
		 		case .WRAPPER:fallthrough
		 		case .X509:fallthrough
		 		case .XA:fallthrough
		 		case .XML:fallthrough
		 		case .EUR:fallthrough
		 		case .USA:fallthrough
		 		case .JIS:fallthrough
		 		case .ISO:fallthrough
		 		case .INTERNAL:fallthrough
		 		case .QUARTER:fallthrough
		 		case .MONTH:fallthrough
		 		case .DAY:fallthrough
		 		case .HOUR:fallthrough
		 		case .MINUTE:fallthrough
		 		case .WEEK:fallthrough
		 		case .SECOND:fallthrough
		 		case .MICROSECOND:fallthrough
		 		case .ADMIN:fallthrough
		 		case .AUDIT_ABORT_EXEMPT:fallthrough
		 		case .AUDIT_ADMIN:fallthrough
		 		case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 		case .BACKUP_ADMIN:fallthrough
		 		case .BINLOG_ADMIN:fallthrough
		 		case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 		case .CLONE_ADMIN:fallthrough
		 		case .CONNECTION_ADMIN:fallthrough
		 		case .ENCRYPTION_KEY_ADMIN:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .FILE:fallthrough
		 		case .FIREWALL_ADMIN:fallthrough
		 		case .FIREWALL_EXEMPT:fallthrough
		 		case .FIREWALL_USER:fallthrough
		 		case .GROUP_REPLICATION_ADMIN:fallthrough
		 		case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 		case .INVOKE:fallthrough
		 		case .LAMBDA:fallthrough
		 		case .NDB_STORED_USER:fallthrough
		 		case .PASSWORDLESS_USER_ADMIN:fallthrough
		 		case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .PROCESS:fallthrough
		 		case .RELOAD:fallthrough
		 		case .REPLICATION_APPLIER:fallthrough
		 		case .REPLICATION_SLAVE_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_USER:fallthrough
		 		case .ROLE_ADMIN:fallthrough
		 		case .ROUTINE:fallthrough
		 		case .S3:fallthrough
		 		case .SESSION_VARIABLES_ADMIN:fallthrough
		 		case .SET_USER_ID:fallthrough
		 		case .SHOW_ROUTINE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SUPER:fallthrough
		 		case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 		case .TABLES:fallthrough
		 		case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 		case .VERSION_TOKEN_ADMIN:fallthrough
		 		case .XA_RECOVER_ADMIN:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .ARCHIVE:fallthrough
		 		case .BLACKHOLE:fallthrough
		 		case .CSV:fallthrough
		 		case .FEDERATED:fallthrough
		 		case .INNODB:fallthrough
		 		case .MEMORY:fallthrough
		 		case .MRG_MYISAM:fallthrough
		 		case .MYISAM:fallthrough
		 		case .NDB:fallthrough
		 		case .NDBCLUSTER:fallthrough
		 		case .PERFORMANCE_SCHEMA:fallthrough
		 		case .TOKUDB:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:fallthrough
		 		case .ABS:fallthrough
		 		case .ACOS:fallthrough
		 		case .ADDDATE:fallthrough
		 		case .ADDTIME:fallthrough
		 		case .AES_DECRYPT:fallthrough
		 		case .AES_ENCRYPT:fallthrough
		 		case .AREA:fallthrough
		 		case .ASBINARY:fallthrough
		 		case .ASIN:fallthrough
		 		case .ASTEXT:fallthrough
		 		case .ASWKB:fallthrough
		 		case .ASWKT:fallthrough
		 		case .ASYMMETRIC_DECRYPT:fallthrough
		 		case .ASYMMETRIC_DERIVE:fallthrough
		 		case .ASYMMETRIC_ENCRYPT:fallthrough
		 		case .ASYMMETRIC_SIGN:fallthrough
		 		case .ASYMMETRIC_VERIFY:fallthrough
		 		case .ATAN:fallthrough
		 		case .ATAN2:fallthrough
		 		case .BENCHMARK:fallthrough
		 		case .BIN:fallthrough
		 		case .BIT_COUNT:fallthrough
		 		case .BIT_LENGTH:fallthrough
		 		case .BUFFER:fallthrough
		 		case .CATALOG_NAME:fallthrough
		 		case .CEIL:fallthrough
		 		case .CEILING:fallthrough
		 		case .CENTROID:fallthrough
		 		case .CHARACTER_LENGTH:fallthrough
		 		case .CHARSET:fallthrough
		 		case .CHAR_LENGTH:fallthrough
		 		case .COERCIBILITY:fallthrough
		 		case .COLLATION:fallthrough
		 		case .COMPRESS:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_WS:fallthrough
		 		case .CONNECTION_ID:fallthrough
		 		case .CONV:fallthrough
		 		case .CONVERT_TZ:fallthrough
		 		case .COS:fallthrough
		 		case .COT:fallthrough
		 		case .CRC32:fallthrough
		 		case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 		case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 		case .CREATE_DH_PARAMETERS:fallthrough
		 		case .CREATE_DIGEST:fallthrough
		 		case .CROSSES:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATE_FORMAT:fallthrough
		 		case .DAYNAME:fallthrough
		 		case .DAYOFMONTH:fallthrough
		 		case .DAYOFWEEK:fallthrough
		 		case .DAYOFYEAR:fallthrough
		 		case .DECODE:fallthrough
		 		case .DEGREES:fallthrough
		 		case .DES_DECRYPT:fallthrough
		 		case .DES_ENCRYPT:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISJOINT:fallthrough
		 		case .ELT:fallthrough
		 		case .ENCODE:fallthrough
		 		case .ENCRYPT:fallthrough
		 		case .ENDPOINT:fallthrough
		 		case .ENGINE_ATTRIBUTE:fallthrough
		 		case .ENVELOPE:fallthrough
		 		case .EQUALS:fallthrough
		 		case .EXP:fallthrough
		 		case .EXPORT_SET:fallthrough
		 		case .EXTERIORRING:fallthrough
		 		case .EXTRACTVALUE:fallthrough
		 		case .FIELD:fallthrough
		 		case .FIND_IN_SET:fallthrough
		 		case .FLOOR:fallthrough
		 		case .FORMAT:fallthrough
		 		case .FOUND_ROWS:fallthrough
		 		case .FROM_BASE64:fallthrough
		 		case .FROM_DAYS:fallthrough
		 		case .FROM_UNIXTIME:fallthrough
		 		case .GEOMCOLLFROMTEXT:fallthrough
		 		case .GEOMCOLLFROMWKB:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .GEOMETRYFROMTEXT:fallthrough
		 		case .GEOMETRYFROMWKB:fallthrough
		 		case .GEOMETRYN:fallthrough
		 		case .GEOMETRYTYPE:fallthrough
		 		case .GEOMFROMTEXT:fallthrough
		 		case .GEOMFROMWKB:fallthrough
		 		case .GET_FORMAT:fallthrough
		 		case .GET_LOCK:fallthrough
		 		case .GLENGTH:fallthrough
		 		case .GREATEST:fallthrough
		 		case .GTID_SUBSET:fallthrough
		 		case .GTID_SUBTRACT:fallthrough
		 		case .HEX:fallthrough
		 		case .IFNULL:fallthrough
		 		case .INET6_ATON:fallthrough
		 		case .INET6_NTOA:fallthrough
		 		case .INET_ATON:fallthrough
		 		case .INET_NTOA:fallthrough
		 		case .INSTR:fallthrough
		 		case .INTERIORRINGN:fallthrough
		 		case .INTERSECTS:fallthrough
		 		case .ISCLOSED:fallthrough
		 		case .ISEMPTY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .ISSIMPLE:fallthrough
		 		case .IS_FREE_LOCK:fallthrough
		 		case .IS_IPV4:fallthrough
		 		case .IS_IPV4_COMPAT:fallthrough
		 		case .IS_IPV4_MAPPED:fallthrough
		 		case .IS_IPV6:fallthrough
		 		case .IS_USED_LOCK:fallthrough
		 		case .LAST_INSERT_ID:fallthrough
		 		case .LCASE:fallthrough
		 		case .LEAST:fallthrough
		 		case .LENGTH:fallthrough
		 		case .LINEFROMTEXT:fallthrough
		 		case .LINEFROMWKB:fallthrough
		 		case .LINESTRINGFROMTEXT:fallthrough
		 		case .LINESTRINGFROMWKB:fallthrough
		 		case .LN:fallthrough
		 		case .LOAD_FILE:fallthrough
		 		case .LOCATE:fallthrough
		 		case .LOG:fallthrough
		 		case .LOG10:fallthrough
		 		case .LOG2:fallthrough
		 		case .LOWER:fallthrough
		 		case .LPAD:fallthrough
		 		case .LTRIM:fallthrough
		 		case .MAKEDATE:fallthrough
		 		case .MAKETIME:fallthrough
		 		case .MAKE_SET:fallthrough
		 		case .MASTER_POS_WAIT:fallthrough
		 		case .MBRCONTAINS:fallthrough
		 		case .MBRDISJOINT:fallthrough
		 		case .MBREQUAL:fallthrough
		 		case .MBRINTERSECTS:fallthrough
		 		case .MBROVERLAPS:fallthrough
		 		case .MBRTOUCHES:fallthrough
		 		case .MBRWITHIN:fallthrough
		 		case .MD5:fallthrough
		 		case .MLINEFROMTEXT:fallthrough
		 		case .MLINEFROMWKB:fallthrough
		 		case .MONTHNAME:fallthrough
		 		case .MPOINTFROMTEXT:fallthrough
		 		case .MPOINTFROMWKB:fallthrough
		 		case .MPOLYFROMTEXT:fallthrough
		 		case .MPOLYFROMWKB:fallthrough
		 		case .MULTILINESTRINGFROMTEXT:fallthrough
		 		case .MULTILINESTRINGFROMWKB:fallthrough
		 		case .MULTIPOINTFROMTEXT:fallthrough
		 		case .MULTIPOINTFROMWKB:fallthrough
		 		case .MULTIPOLYGONFROMTEXT:fallthrough
		 		case .MULTIPOLYGONFROMWKB:fallthrough
		 		case .NAME_CONST:fallthrough
		 		case .NULLIF:fallthrough
		 		case .NUMGEOMETRIES:fallthrough
		 		case .NUMINTERIORRINGS:fallthrough
		 		case .NUMPOINTS:fallthrough
		 		case .OCT:fallthrough
		 		case .OCTET_LENGTH:fallthrough
		 		case .ORD:fallthrough
		 		case .OVERLAPS:fallthrough
		 		case .PERIOD_ADD:fallthrough
		 		case .PERIOD_DIFF:fallthrough
		 		case .PI:fallthrough
		 		case .POINTFROMTEXT:fallthrough
		 		case .POINTFROMWKB:fallthrough
		 		case .POINTN:fallthrough
		 		case .POLYFROMTEXT:fallthrough
		 		case .POLYFROMWKB:fallthrough
		 		case .POLYGONFROMTEXT:fallthrough
		 		case .POLYGONFROMWKB:fallthrough
		 		case .POW:fallthrough
		 		case .POWER:fallthrough
		 		case .QUOTE:fallthrough
		 		case .RADIANS:fallthrough
		 		case .RAND:fallthrough
		 		case .RANDOM:fallthrough
		 		case .RANDOM_BYTES:fallthrough
		 		case .RELEASE_LOCK:fallthrough
		 		case .REVERSE:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_COUNT:fallthrough
		 		case .RPAD:fallthrough
		 		case .RTRIM:fallthrough
		 		case .SEC_TO_TIME:fallthrough
		 		case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SHA:fallthrough
		 		case .SHA1:fallthrough
		 		case .SHA2:fallthrough
		 		case .SCHEMA_NAME:fallthrough
		 		case .SIGN:fallthrough
		 		case .SIN:fallthrough
		 		case .SLEEP:fallthrough
		 		case .SOUNDEX:fallthrough
		 		case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 		case .SQRT:fallthrough
		 		case .SRID:fallthrough
		 		case .STARTPOINT:fallthrough
		 		case .STRCMP:fallthrough
		 		case .STR_TO_DATE:fallthrough
		 		case .ST_AREA:fallthrough
		 		case .ST_ASBINARY:fallthrough
		 		case .ST_ASTEXT:fallthrough
		 		case .ST_ASWKB:fallthrough
		 		case .ST_ASWKT:fallthrough
		 		case .ST_BUFFER:fallthrough
		 		case .ST_CENTROID:fallthrough
		 		case .ST_CONTAINS:fallthrough
		 		case .ST_CROSSES:fallthrough
		 		case .ST_DIFFERENCE:fallthrough
		 		case .ST_DIMENSION:fallthrough
		 		case .ST_DISJOINT:fallthrough
		 		case .ST_DISTANCE:fallthrough
		 		case .ST_ENDPOINT:fallthrough
		 		case .ST_ENVELOPE:fallthrough
		 		case .ST_EQUALS:fallthrough
		 		case .ST_EXTERIORRING:fallthrough
		 		case .ST_GEOMCOLLFROMTEXT:fallthrough
		 		case .ST_GEOMCOLLFROMTXT:fallthrough
		 		case .ST_GEOMCOLLFROMWKB:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .ST_GEOMETRYFROMTEXT:fallthrough
		 		case .ST_GEOMETRYFROMWKB:fallthrough
		 		case .ST_GEOMETRYN:fallthrough
		 		case .ST_GEOMETRYTYPE:fallthrough
		 		case .ST_GEOMFROMTEXT:fallthrough
		 		case .ST_GEOMFROMWKB:fallthrough
		 		case .ST_INTERIORRINGN:fallthrough
		 		case .ST_INTERSECTION:fallthrough
		 		case .ST_INTERSECTS:fallthrough
		 		case .ST_ISCLOSED:fallthrough
		 		case .ST_ISEMPTY:fallthrough
		 		case .ST_ISSIMPLE:fallthrough
		 		case .ST_LINEFROMTEXT:fallthrough
		 		case .ST_LINEFROMWKB:fallthrough
		 		case .ST_LINESTRINGFROMTEXT:fallthrough
		 		case .ST_LINESTRINGFROMWKB:fallthrough
		 		case .ST_NUMGEOMETRIES:fallthrough
		 		case .ST_NUMINTERIORRING:fallthrough
		 		case .ST_NUMINTERIORRINGS:fallthrough
		 		case .ST_NUMPOINTS:fallthrough
		 		case .ST_OVERLAPS:fallthrough
		 		case .ST_POINTFROMTEXT:fallthrough
		 		case .ST_POINTFROMWKB:fallthrough
		 		case .ST_POINTN:fallthrough
		 		case .ST_POLYFROMTEXT:fallthrough
		 		case .ST_POLYFROMWKB:fallthrough
		 		case .ST_POLYGONFROMTEXT:fallthrough
		 		case .ST_POLYGONFROMWKB:fallthrough
		 		case .ST_SRID:fallthrough
		 		case .ST_STARTPOINT:fallthrough
		 		case .ST_SYMDIFFERENCE:fallthrough
		 		case .ST_TOUCHES:fallthrough
		 		case .ST_UNION:fallthrough
		 		case .ST_WITHIN:fallthrough
		 		case .ST_X:fallthrough
		 		case .ST_Y:fallthrough
		 		case .SUBDATE:fallthrough
		 		case .SUBSTRING_INDEX:fallthrough
		 		case .SUBTIME:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TAN:fallthrough
		 		case .TIMEDIFF:fallthrough
		 		case .TIMESTAMPADD:fallthrough
		 		case .TIMESTAMPDIFF:fallthrough
		 		case .TIME_FORMAT:fallthrough
		 		case .TIME_TO_SEC:fallthrough
		 		case .TOUCHES:fallthrough
		 		case .TO_BASE64:fallthrough
		 		case .TO_DAYS:fallthrough
		 		case .TO_SECONDS:fallthrough
		 		case .TP_CONNECTION_ADMIN:fallthrough
		 		case .UCASE:fallthrough
		 		case .UNCOMPRESS:fallthrough
		 		case .UNCOMPRESSED_LENGTH:fallthrough
		 		case .UNHEX:fallthrough
		 		case .UNIX_TIMESTAMP:fallthrough
		 		case .UPDATEXML:fallthrough
		 		case .UPPER:fallthrough
		 		case .UUID:fallthrough
		 		case .UUID_SHORT:fallthrough
		 		case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 		case .VERSION:fallthrough
		 		case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 		case .WEEKDAY:fallthrough
		 		case .WEEKOFYEAR:fallthrough
		 		case .WEIGHT_STRING:fallthrough
		 		case .WITHIN:fallthrough
		 		case .YEARWEEK:fallthrough
		 		case .Y_FUNCTION:fallthrough
		 		case .X_FUNCTION:fallthrough
		 		case .MOD:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:fallthrough
		 		case .ID:
		 			setState(2911)
		 			try uidList()

		 			break

		 		case .ALL:
		 			setState(2912)
		 			try match(MySqlParser.Tokens.ALL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .COALESCE:
		 		_localctx =  AlterByCoalescePartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(2915)
		 		try match(MySqlParser.Tokens.COALESCE.rawValue)
		 		setState(2916)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2917)
		 		try decimalLiteral()

		 		break

		 	case .REORGANIZE:
		 		_localctx =  AlterByReorganizePartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 7)
		 		setState(2918)
		 		try match(MySqlParser.Tokens.REORGANIZE.rawValue)
		 		setState(2919)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2920)
		 		try uidList()
		 		setState(2921)
		 		try match(MySqlParser.Tokens.INTO.rawValue)
		 		setState(2922)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(2923)
		 		try partitionDefinition()
		 		setState(2928)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(2924)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(2925)
		 			try partitionDefinition()


		 			setState(2930)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(2931)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break

		 	case .EXCHANGE:
		 		_localctx =  AlterByExchangePartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 8)
		 		setState(2933)
		 		try match(MySqlParser.Tokens.EXCHANGE.rawValue)
		 		setState(2934)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2935)
		 		try uid()
		 		setState(2936)
		 		try match(MySqlParser.Tokens.WITH.rawValue)
		 		setState(2937)
		 		try match(MySqlParser.Tokens.TABLE.rawValue)
		 		setState(2938)
		 		try tableName()
		 		setState(2941)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,375,_ctx)) {
		 		case 1:
		 			setState(2939)
		 			_localctx.castdown(AlterByExchangePartitionContext.self).validationFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.WITH.rawValue || _la == MySqlParser.Tokens.WITHOUT.rawValue)) {
		 				_localctx.castdown(AlterByExchangePartitionContext.self).validationFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(2940)
		 			try match(MySqlParser.Tokens.VALIDATION.rawValue)

		 			break
		 		default: break
		 		}

		 		break

		 	case .ANALYZE:
		 		_localctx =  AlterByAnalyzePartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 9)
		 		setState(2943)
		 		try match(MySqlParser.Tokens.ANALYZE.rawValue)
		 		setState(2944)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2947)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ARRAY:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .BUCKETS:fallthrough
		 		case .CONDITION:fallthrough
		 		case .CURRENT:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DIAGNOSTICS:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENFORCED:fallthrough
		 		case .EXCEPT:fallthrough
		 		case .GROUP:fallthrough
		 		case .IF:fallthrough
		 		case .IGNORED:fallthrough
		 		case .INSERT:fallthrough
		 		case .LATERAL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OPTIONAL:fallthrough
		 		case .ORDER:fallthrough
		 		case .PRIMARY:fallthrough
		 		case .REPEAT:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SKIP_QUERY_REWRITE:fallthrough
		 		case .STACKED:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .BINARY:fallthrough
		 		case .TEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .JSON_ARRAY:fallthrough
		 		case .JSON_ARRAYAGG:fallthrough
		 		case .JSON_ARRAY_APPEND:fallthrough
		 		case .JSON_ARRAY_INSERT:fallthrough
		 		case .JSON_CONTAINS:fallthrough
		 		case .JSON_CONTAINS_PATH:fallthrough
		 		case .JSON_DEPTH:fallthrough
		 		case .JSON_EXTRACT:fallthrough
		 		case .JSON_INSERT:fallthrough
		 		case .JSON_KEYS:fallthrough
		 		case .JSON_LENGTH:fallthrough
		 		case .JSON_MERGE:fallthrough
		 		case .JSON_MERGE_PATCH:fallthrough
		 		case .JSON_MERGE_PRESERVE:fallthrough
		 		case .JSON_OBJECT:fallthrough
		 		case .JSON_OBJECTAGG:fallthrough
		 		case .JSON_OVERLAPS:fallthrough
		 		case .JSON_PRETTY:fallthrough
		 		case .JSON_QUOTE:fallthrough
		 		case .JSON_REMOVE:fallthrough
		 		case .JSON_REPLACE:fallthrough
		 		case .JSON_SCHEMA_VALID:fallthrough
		 		case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 		case .JSON_SEARCH:fallthrough
		 		case .JSON_SET:fallthrough
		 		case .JSON_STORAGE_FREE:fallthrough
		 		case .JSON_STORAGE_SIZE:fallthrough
		 		case .JSON_TABLE:fallthrough
		 		case .JSON_TYPE:fallthrough
		 		case .JSON_UNQUOTE:fallthrough
		 		case .JSON_VALID:fallthrough
		 		case .JSON_VALUE:fallthrough
		 		case .NESTED:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .PATH:fallthrough
		 		case .AVG:fallthrough
		 		case .BIT_AND:fallthrough
		 		case .BIT_OR:fallthrough
		 		case .BIT_XOR:fallthrough
		 		case .COUNT:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .GROUP_CONCAT:fallthrough
		 		case .LAG:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NTH_VALUE:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .RANK:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .STD:fallthrough
		 		case .STDDEV:fallthrough
		 		case .STDDEV_POP:fallthrough
		 		case .STDDEV_SAMP:fallthrough
		 		case .SUM:fallthrough
		 		case .VAR_POP:fallthrough
		 		case .VAR_SAMP:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .CURRENT_DATE:fallthrough
		 		case .CURRENT_TIME:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .LOCALTIME:fallthrough
		 		case .CURDATE:fallthrough
		 		case .CURTIME:fallthrough
		 		case .DATE_ADD:fallthrough
		 		case .DATE_SUB:fallthrough
		 		case .LOCALTIMESTAMP:fallthrough
		 		case .NOW:fallthrough
		 		case .POSITION:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .SUBSTRING:fallthrough
		 		case .SYSDATE:fallthrough
		 		case .TRIM:fallthrough
		 		case .UTC_DATE:fallthrough
		 		case .UTC_TIME:fallthrough
		 		case .UTC_TIMESTAMP:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .ACTION:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALGORITHM:fallthrough
		 		case .ANY:fallthrough
		 		case .AT:fallthrough
		 		case .AUTHORS:fallthrough
		 		case .AUTOCOMMIT:fallthrough
		 		case .AUTOEXTEND_SIZE:fallthrough
		 		case .AUTO_INCREMENT:fallthrough
		 		case .AVG_ROW_LENGTH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .BIT:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BTREE:fallthrough
		 		case .CACHE:fallthrough
		 		case .CASCADED:fallthrough
		 		case .CHAIN:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .PAGE_CHECKSUM:fallthrough
		 		case .CIPHER:fallthrough
		 		case .CLASS_ORIGIN:fallthrough
		 		case .CLIENT:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTERING:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CODE:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COLUMN_FORMAT:fallthrough
		 		case .COLUMN_NAME:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMPACT:fallthrough
		 		case .COMPLETION:fallthrough
		 		case .COMPRESSED:fallthrough
		 		case .COMPRESSION:fallthrough
		 		case .CONCURRENT:fallthrough
		 		case .CONNECT:fallthrough
		 		case .CONNECTION:fallthrough
		 		case .CONSISTENT:fallthrough
		 		case .CONSTRAINT_CATALOG:fallthrough
		 		case .CONSTRAINT_SCHEMA:fallthrough
		 		case .CONSTRAINT_NAME:fallthrough
		 		case .CONTAINS:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTRIBUTORS:fallthrough
		 		case .COPY:fallthrough
		 		case .CPU:fallthrough
		 		case .CURSOR_NAME:fallthrough
		 		case .DATA:fallthrough
		 		case .DATAFILE:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DEFAULT_AUTH:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DELAY_KEY_WRITE:fallthrough
		 		case .DES_KEY_FILE:fallthrough
		 		case .DIRECTORY:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISCARD:fallthrough
		 		case .DISK:fallthrough
		 		case .DO:fallthrough
		 		case .DUMPFILE:fallthrough
		 		case .DUPLICATE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .END:fallthrough
		 		case .ENDS:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ENGINES:fallthrough
		 		case .ERROR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVEN:fallthrough
		 		case .EVENT:fallthrough
		 		case .EVENTS:fallthrough
		 		case .EVERY:fallthrough
		 		case .EXCHANGE:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPIRE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .EXTENT_SIZE:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FAST:fallthrough
		 		case .FAULTS:fallthrough
		 		case .FIELDS:fallthrough
		 		case .FILE_BLOCK_SIZE:fallthrough
		 		case .FILTER:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIXED:fallthrough
		 		case .FLUSH:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FOUND:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GENERAL:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GRANTS:fallthrough
		 		case .GROUP_REPLICATION:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HASH:fallthrough
		 		case .HELP:fallthrough
		 		case .HISTORY:fallthrough
		 		case .HOST:fallthrough
		 		case .HOSTS:fallthrough
		 		case .IDENTIFIED:fallthrough
		 		case .IGNORE_SERVER_IDS:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INDEXES:fallthrough
		 		case .INITIAL_SIZE:fallthrough
		 		case .INPLACE:fallthrough
		 		case .INSERT_METHOD:fallthrough
		 		case .INSTALL:fallthrough
		 		case .INSTANCE:fallthrough
		 		case .INSTANT:fallthrough
		 		case .INVISIBLE:fallthrough
		 		case .INVOKER:fallthrough
		 		case .IO:fallthrough
		 		case .IO_THREAD:fallthrough
		 		case .IPC:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ISSUER:fallthrough
		 		case .JSON:fallthrough
		 		case .KEY_BLOCK_SIZE:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LEAVES:fallthrough
		 		case .LESS:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOGFILE:fallthrough
		 		case .LOGS:fallthrough
		 		case .MASTER:fallthrough
		 		case .MASTER_AUTO_POSITION:fallthrough
		 		case .MASTER_CONNECT_RETRY:fallthrough
		 		case .MASTER_DELAY:fallthrough
		 		case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 		case .MASTER_HOST:fallthrough
		 		case .MASTER_LOG_FILE:fallthrough
		 		case .MASTER_LOG_POS:fallthrough
		 		case .MASTER_PASSWORD:fallthrough
		 		case .MASTER_PORT:fallthrough
		 		case .MASTER_RETRY_COUNT:fallthrough
		 		case .MASTER_SSL:fallthrough
		 		case .MASTER_SSL_CA:fallthrough
		 		case .MASTER_SSL_CAPATH:fallthrough
		 		case .MASTER_SSL_CERT:fallthrough
		 		case .MASTER_SSL_CIPHER:fallthrough
		 		case .MASTER_SSL_CRL:fallthrough
		 		case .MASTER_SSL_CRLPATH:fallthrough
		 		case .MASTER_SSL_KEY:fallthrough
		 		case .MASTER_TLS_VERSION:fallthrough
		 		case .MASTER_USER:fallthrough
		 		case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 		case .MAX_QUERIES_PER_HOUR:fallthrough
		 		case .MAX_ROWS:fallthrough
		 		case .MAX_SIZE:fallthrough
		 		case .MAX_UPDATES_PER_HOUR:fallthrough
		 		case .MAX_USER_CONNECTIONS:fallthrough
		 		case .MEDIUM:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MESSAGE_TEXT:fallthrough
		 		case .MID:fallthrough
		 		case .MIGRATE:fallthrough
		 		case .MIN_ROWS:fallthrough
		 		case .MODE:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MUTEX:fallthrough
		 		case .MYSQL:fallthrough
		 		case .MYSQL_ERRNO:fallthrough
		 		case .NAME:fallthrough
		 		case .NAMES:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NEVER:fallthrough
		 		case .NEXT:fallthrough
		 		case .NO:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOWAIT:fallthrough
		 		case .NODEGROUP:fallthrough
		 		case .NONE:fallthrough
		 		case .ODBC:fallthrough
		 		case .OFFLINE:fallthrough
		 		case .OFFSET:fallthrough
		 		case .OF:fallthrough
		 		case .OJ:fallthrough
		 		case .OLD_PASSWORD:fallthrough
		 		case .ONE:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .OPTIMIZER_COSTS:fallthrough
		 		case .OPTIONS:fallthrough
		 		case .OWNER:fallthrough
		 		case .PACK_KEYS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PARSER:fallthrough
		 		case .PARTIAL:fallthrough
		 		case .PARTITIONING:fallthrough
		 		case .PARTITIONS:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PHASE:fallthrough
		 		case .PLUGIN:fallthrough
		 		case .PLUGIN_DIR:fallthrough
		 		case .PLUGINS:fallthrough
		 		case .PORT:fallthrough
		 		case .PRECEDES:fallthrough
		 		case .PREPARE:fallthrough
		 		case .PRESERVE:fallthrough
		 		case .PREV:fallthrough
		 		case .PROCESSLIST:fallthrough
		 		case .PROFILE:fallthrough
		 		case .PROFILES:fallthrough
		 		case .PROXY:fallthrough
		 		case .QUERY:fallthrough
		 		case .QUICK:fallthrough
		 		case .REBUILD:fallthrough
		 		case .RECOVER:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REDO_BUFFER_SIZE:fallthrough
		 		case .REDUNDANT:fallthrough
		 		case .RELAY:fallthrough
		 		case .RELAY_LOG_FILE:fallthrough
		 		case .RELAY_LOG_POS:fallthrough
		 		case .RELAYLOG:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REORGANIZE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .REPLICATE_DO_DB:fallthrough
		 		case .REPLICATE_DO_TABLE:fallthrough
		 		case .REPLICATE_IGNORE_DB:fallthrough
		 		case .REPLICATE_IGNORE_TABLE:fallthrough
		 		case .REPLICATE_REWRITE_DB:fallthrough
		 		case .REPLICATE_WILD_DO_TABLE:fallthrough
		 		case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 		case .REPLICATION:fallthrough
		 		case .RESET:fallthrough
		 		case .RESUME:fallthrough
		 		case .RETURNED_SQLSTATE:fallthrough
		 		case .RETURNING:fallthrough
		 		case .RETURNS:fallthrough
		 		case .REUSE:fallthrough
		 		case .ROLE:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROTATE:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_FORMAT:fallthrough
		 		case .RTREE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEDULE:fallthrough
		 		case .SECURITY:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION:fallthrough
		 		case .SHARE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SIGNED:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SLAVE:fallthrough
		 		case .SLOW:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOCKET:fallthrough
		 		case .SOME:fallthrough
		 		case .SONAME:fallthrough
		 		case .SOUNDS:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SQL_AFTER_GTIDS:fallthrough
		 		case .SQL_AFTER_MTS_GAPS:fallthrough
		 		case .SQL_BEFORE_GTIDS:fallthrough
		 		case .SQL_BUFFER_RESULT:fallthrough
		 		case .SQL_CACHE:fallthrough
		 		case .SQL_NO_CACHE:fallthrough
		 		case .SQL_THREAD:fallthrough
		 		case .START:fallthrough
		 		case .STARTS:fallthrough
		 		case .STATS_AUTO_RECALC:fallthrough
		 		case .STATS_PERSISTENT:fallthrough
		 		case .STATS_SAMPLE_PAGES:fallthrough
		 		case .STATUS:fallthrough
		 		case .STOP:fallthrough
		 		case .STORAGE:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBCLASS_ORIGIN:fallthrough
		 		case .SUBJECT:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBPARTITIONS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .SWAPS:fallthrough
		 		case .SWITCHES:fallthrough
		 		case .TABLE_NAME:fallthrough
		 		case .TABLESPACE:fallthrough
		 		case .TABLE_TYPE:fallthrough
		 		case .TEMPORARY:fallthrough
		 		case .TEMPTABLE:fallthrough
		 		case .THAN:fallthrough
		 		case .TRADITIONAL:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSACTIONAL:fallthrough
		 		case .TRIGGERS:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDEFINED:fallthrough
		 		case .UNDOFILE:fallthrough
		 		case .UNDO_BUFFER_SIZE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPGRADE:fallthrough
		 		case .USER:fallthrough
		 		case .USE_FRM:fallthrough
		 		case .USER_RESOURCES:fallthrough
		 		case .VALIDATION:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARIABLES:fallthrough
		 		case .VIEW:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .VISIBLE:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNINGS:fallthrough
		 		case .WITHOUT:fallthrough
		 		case .WORK:fallthrough
		 		case .WRAPPER:fallthrough
		 		case .X509:fallthrough
		 		case .XA:fallthrough
		 		case .XML:fallthrough
		 		case .EUR:fallthrough
		 		case .USA:fallthrough
		 		case .JIS:fallthrough
		 		case .ISO:fallthrough
		 		case .INTERNAL:fallthrough
		 		case .QUARTER:fallthrough
		 		case .MONTH:fallthrough
		 		case .DAY:fallthrough
		 		case .HOUR:fallthrough
		 		case .MINUTE:fallthrough
		 		case .WEEK:fallthrough
		 		case .SECOND:fallthrough
		 		case .MICROSECOND:fallthrough
		 		case .ADMIN:fallthrough
		 		case .AUDIT_ABORT_EXEMPT:fallthrough
		 		case .AUDIT_ADMIN:fallthrough
		 		case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 		case .BACKUP_ADMIN:fallthrough
		 		case .BINLOG_ADMIN:fallthrough
		 		case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 		case .CLONE_ADMIN:fallthrough
		 		case .CONNECTION_ADMIN:fallthrough
		 		case .ENCRYPTION_KEY_ADMIN:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .FILE:fallthrough
		 		case .FIREWALL_ADMIN:fallthrough
		 		case .FIREWALL_EXEMPT:fallthrough
		 		case .FIREWALL_USER:fallthrough
		 		case .GROUP_REPLICATION_ADMIN:fallthrough
		 		case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 		case .INVOKE:fallthrough
		 		case .LAMBDA:fallthrough
		 		case .NDB_STORED_USER:fallthrough
		 		case .PASSWORDLESS_USER_ADMIN:fallthrough
		 		case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .PROCESS:fallthrough
		 		case .RELOAD:fallthrough
		 		case .REPLICATION_APPLIER:fallthrough
		 		case .REPLICATION_SLAVE_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_USER:fallthrough
		 		case .ROLE_ADMIN:fallthrough
		 		case .ROUTINE:fallthrough
		 		case .S3:fallthrough
		 		case .SESSION_VARIABLES_ADMIN:fallthrough
		 		case .SET_USER_ID:fallthrough
		 		case .SHOW_ROUTINE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SUPER:fallthrough
		 		case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 		case .TABLES:fallthrough
		 		case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 		case .VERSION_TOKEN_ADMIN:fallthrough
		 		case .XA_RECOVER_ADMIN:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .ARCHIVE:fallthrough
		 		case .BLACKHOLE:fallthrough
		 		case .CSV:fallthrough
		 		case .FEDERATED:fallthrough
		 		case .INNODB:fallthrough
		 		case .MEMORY:fallthrough
		 		case .MRG_MYISAM:fallthrough
		 		case .MYISAM:fallthrough
		 		case .NDB:fallthrough
		 		case .NDBCLUSTER:fallthrough
		 		case .PERFORMANCE_SCHEMA:fallthrough
		 		case .TOKUDB:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:fallthrough
		 		case .ABS:fallthrough
		 		case .ACOS:fallthrough
		 		case .ADDDATE:fallthrough
		 		case .ADDTIME:fallthrough
		 		case .AES_DECRYPT:fallthrough
		 		case .AES_ENCRYPT:fallthrough
		 		case .AREA:fallthrough
		 		case .ASBINARY:fallthrough
		 		case .ASIN:fallthrough
		 		case .ASTEXT:fallthrough
		 		case .ASWKB:fallthrough
		 		case .ASWKT:fallthrough
		 		case .ASYMMETRIC_DECRYPT:fallthrough
		 		case .ASYMMETRIC_DERIVE:fallthrough
		 		case .ASYMMETRIC_ENCRYPT:fallthrough
		 		case .ASYMMETRIC_SIGN:fallthrough
		 		case .ASYMMETRIC_VERIFY:fallthrough
		 		case .ATAN:fallthrough
		 		case .ATAN2:fallthrough
		 		case .BENCHMARK:fallthrough
		 		case .BIN:fallthrough
		 		case .BIT_COUNT:fallthrough
		 		case .BIT_LENGTH:fallthrough
		 		case .BUFFER:fallthrough
		 		case .CATALOG_NAME:fallthrough
		 		case .CEIL:fallthrough
		 		case .CEILING:fallthrough
		 		case .CENTROID:fallthrough
		 		case .CHARACTER_LENGTH:fallthrough
		 		case .CHARSET:fallthrough
		 		case .CHAR_LENGTH:fallthrough
		 		case .COERCIBILITY:fallthrough
		 		case .COLLATION:fallthrough
		 		case .COMPRESS:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_WS:fallthrough
		 		case .CONNECTION_ID:fallthrough
		 		case .CONV:fallthrough
		 		case .CONVERT_TZ:fallthrough
		 		case .COS:fallthrough
		 		case .COT:fallthrough
		 		case .CRC32:fallthrough
		 		case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 		case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 		case .CREATE_DH_PARAMETERS:fallthrough
		 		case .CREATE_DIGEST:fallthrough
		 		case .CROSSES:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATE_FORMAT:fallthrough
		 		case .DAYNAME:fallthrough
		 		case .DAYOFMONTH:fallthrough
		 		case .DAYOFWEEK:fallthrough
		 		case .DAYOFYEAR:fallthrough
		 		case .DECODE:fallthrough
		 		case .DEGREES:fallthrough
		 		case .DES_DECRYPT:fallthrough
		 		case .DES_ENCRYPT:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISJOINT:fallthrough
		 		case .ELT:fallthrough
		 		case .ENCODE:fallthrough
		 		case .ENCRYPT:fallthrough
		 		case .ENDPOINT:fallthrough
		 		case .ENGINE_ATTRIBUTE:fallthrough
		 		case .ENVELOPE:fallthrough
		 		case .EQUALS:fallthrough
		 		case .EXP:fallthrough
		 		case .EXPORT_SET:fallthrough
		 		case .EXTERIORRING:fallthrough
		 		case .EXTRACTVALUE:fallthrough
		 		case .FIELD:fallthrough
		 		case .FIND_IN_SET:fallthrough
		 		case .FLOOR:fallthrough
		 		case .FORMAT:fallthrough
		 		case .FOUND_ROWS:fallthrough
		 		case .FROM_BASE64:fallthrough
		 		case .FROM_DAYS:fallthrough
		 		case .FROM_UNIXTIME:fallthrough
		 		case .GEOMCOLLFROMTEXT:fallthrough
		 		case .GEOMCOLLFROMWKB:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .GEOMETRYFROMTEXT:fallthrough
		 		case .GEOMETRYFROMWKB:fallthrough
		 		case .GEOMETRYN:fallthrough
		 		case .GEOMETRYTYPE:fallthrough
		 		case .GEOMFROMTEXT:fallthrough
		 		case .GEOMFROMWKB:fallthrough
		 		case .GET_FORMAT:fallthrough
		 		case .GET_LOCK:fallthrough
		 		case .GLENGTH:fallthrough
		 		case .GREATEST:fallthrough
		 		case .GTID_SUBSET:fallthrough
		 		case .GTID_SUBTRACT:fallthrough
		 		case .HEX:fallthrough
		 		case .IFNULL:fallthrough
		 		case .INET6_ATON:fallthrough
		 		case .INET6_NTOA:fallthrough
		 		case .INET_ATON:fallthrough
		 		case .INET_NTOA:fallthrough
		 		case .INSTR:fallthrough
		 		case .INTERIORRINGN:fallthrough
		 		case .INTERSECTS:fallthrough
		 		case .ISCLOSED:fallthrough
		 		case .ISEMPTY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .ISSIMPLE:fallthrough
		 		case .IS_FREE_LOCK:fallthrough
		 		case .IS_IPV4:fallthrough
		 		case .IS_IPV4_COMPAT:fallthrough
		 		case .IS_IPV4_MAPPED:fallthrough
		 		case .IS_IPV6:fallthrough
		 		case .IS_USED_LOCK:fallthrough
		 		case .LAST_INSERT_ID:fallthrough
		 		case .LCASE:fallthrough
		 		case .LEAST:fallthrough
		 		case .LENGTH:fallthrough
		 		case .LINEFROMTEXT:fallthrough
		 		case .LINEFROMWKB:fallthrough
		 		case .LINESTRINGFROMTEXT:fallthrough
		 		case .LINESTRINGFROMWKB:fallthrough
		 		case .LN:fallthrough
		 		case .LOAD_FILE:fallthrough
		 		case .LOCATE:fallthrough
		 		case .LOG:fallthrough
		 		case .LOG10:fallthrough
		 		case .LOG2:fallthrough
		 		case .LOWER:fallthrough
		 		case .LPAD:fallthrough
		 		case .LTRIM:fallthrough
		 		case .MAKEDATE:fallthrough
		 		case .MAKETIME:fallthrough
		 		case .MAKE_SET:fallthrough
		 		case .MASTER_POS_WAIT:fallthrough
		 		case .MBRCONTAINS:fallthrough
		 		case .MBRDISJOINT:fallthrough
		 		case .MBREQUAL:fallthrough
		 		case .MBRINTERSECTS:fallthrough
		 		case .MBROVERLAPS:fallthrough
		 		case .MBRTOUCHES:fallthrough
		 		case .MBRWITHIN:fallthrough
		 		case .MD5:fallthrough
		 		case .MLINEFROMTEXT:fallthrough
		 		case .MLINEFROMWKB:fallthrough
		 		case .MONTHNAME:fallthrough
		 		case .MPOINTFROMTEXT:fallthrough
		 		case .MPOINTFROMWKB:fallthrough
		 		case .MPOLYFROMTEXT:fallthrough
		 		case .MPOLYFROMWKB:fallthrough
		 		case .MULTILINESTRINGFROMTEXT:fallthrough
		 		case .MULTILINESTRINGFROMWKB:fallthrough
		 		case .MULTIPOINTFROMTEXT:fallthrough
		 		case .MULTIPOINTFROMWKB:fallthrough
		 		case .MULTIPOLYGONFROMTEXT:fallthrough
		 		case .MULTIPOLYGONFROMWKB:fallthrough
		 		case .NAME_CONST:fallthrough
		 		case .NULLIF:fallthrough
		 		case .NUMGEOMETRIES:fallthrough
		 		case .NUMINTERIORRINGS:fallthrough
		 		case .NUMPOINTS:fallthrough
		 		case .OCT:fallthrough
		 		case .OCTET_LENGTH:fallthrough
		 		case .ORD:fallthrough
		 		case .OVERLAPS:fallthrough
		 		case .PERIOD_ADD:fallthrough
		 		case .PERIOD_DIFF:fallthrough
		 		case .PI:fallthrough
		 		case .POINTFROMTEXT:fallthrough
		 		case .POINTFROMWKB:fallthrough
		 		case .POINTN:fallthrough
		 		case .POLYFROMTEXT:fallthrough
		 		case .POLYFROMWKB:fallthrough
		 		case .POLYGONFROMTEXT:fallthrough
		 		case .POLYGONFROMWKB:fallthrough
		 		case .POW:fallthrough
		 		case .POWER:fallthrough
		 		case .QUOTE:fallthrough
		 		case .RADIANS:fallthrough
		 		case .RAND:fallthrough
		 		case .RANDOM:fallthrough
		 		case .RANDOM_BYTES:fallthrough
		 		case .RELEASE_LOCK:fallthrough
		 		case .REVERSE:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_COUNT:fallthrough
		 		case .RPAD:fallthrough
		 		case .RTRIM:fallthrough
		 		case .SEC_TO_TIME:fallthrough
		 		case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SHA:fallthrough
		 		case .SHA1:fallthrough
		 		case .SHA2:fallthrough
		 		case .SCHEMA_NAME:fallthrough
		 		case .SIGN:fallthrough
		 		case .SIN:fallthrough
		 		case .SLEEP:fallthrough
		 		case .SOUNDEX:fallthrough
		 		case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 		case .SQRT:fallthrough
		 		case .SRID:fallthrough
		 		case .STARTPOINT:fallthrough
		 		case .STRCMP:fallthrough
		 		case .STR_TO_DATE:fallthrough
		 		case .ST_AREA:fallthrough
		 		case .ST_ASBINARY:fallthrough
		 		case .ST_ASTEXT:fallthrough
		 		case .ST_ASWKB:fallthrough
		 		case .ST_ASWKT:fallthrough
		 		case .ST_BUFFER:fallthrough
		 		case .ST_CENTROID:fallthrough
		 		case .ST_CONTAINS:fallthrough
		 		case .ST_CROSSES:fallthrough
		 		case .ST_DIFFERENCE:fallthrough
		 		case .ST_DIMENSION:fallthrough
		 		case .ST_DISJOINT:fallthrough
		 		case .ST_DISTANCE:fallthrough
		 		case .ST_ENDPOINT:fallthrough
		 		case .ST_ENVELOPE:fallthrough
		 		case .ST_EQUALS:fallthrough
		 		case .ST_EXTERIORRING:fallthrough
		 		case .ST_GEOMCOLLFROMTEXT:fallthrough
		 		case .ST_GEOMCOLLFROMTXT:fallthrough
		 		case .ST_GEOMCOLLFROMWKB:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .ST_GEOMETRYFROMTEXT:fallthrough
		 		case .ST_GEOMETRYFROMWKB:fallthrough
		 		case .ST_GEOMETRYN:fallthrough
		 		case .ST_GEOMETRYTYPE:fallthrough
		 		case .ST_GEOMFROMTEXT:fallthrough
		 		case .ST_GEOMFROMWKB:fallthrough
		 		case .ST_INTERIORRINGN:fallthrough
		 		case .ST_INTERSECTION:fallthrough
		 		case .ST_INTERSECTS:fallthrough
		 		case .ST_ISCLOSED:fallthrough
		 		case .ST_ISEMPTY:fallthrough
		 		case .ST_ISSIMPLE:fallthrough
		 		case .ST_LINEFROMTEXT:fallthrough
		 		case .ST_LINEFROMWKB:fallthrough
		 		case .ST_LINESTRINGFROMTEXT:fallthrough
		 		case .ST_LINESTRINGFROMWKB:fallthrough
		 		case .ST_NUMGEOMETRIES:fallthrough
		 		case .ST_NUMINTERIORRING:fallthrough
		 		case .ST_NUMINTERIORRINGS:fallthrough
		 		case .ST_NUMPOINTS:fallthrough
		 		case .ST_OVERLAPS:fallthrough
		 		case .ST_POINTFROMTEXT:fallthrough
		 		case .ST_POINTFROMWKB:fallthrough
		 		case .ST_POINTN:fallthrough
		 		case .ST_POLYFROMTEXT:fallthrough
		 		case .ST_POLYFROMWKB:fallthrough
		 		case .ST_POLYGONFROMTEXT:fallthrough
		 		case .ST_POLYGONFROMWKB:fallthrough
		 		case .ST_SRID:fallthrough
		 		case .ST_STARTPOINT:fallthrough
		 		case .ST_SYMDIFFERENCE:fallthrough
		 		case .ST_TOUCHES:fallthrough
		 		case .ST_UNION:fallthrough
		 		case .ST_WITHIN:fallthrough
		 		case .ST_X:fallthrough
		 		case .ST_Y:fallthrough
		 		case .SUBDATE:fallthrough
		 		case .SUBSTRING_INDEX:fallthrough
		 		case .SUBTIME:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TAN:fallthrough
		 		case .TIMEDIFF:fallthrough
		 		case .TIMESTAMPADD:fallthrough
		 		case .TIMESTAMPDIFF:fallthrough
		 		case .TIME_FORMAT:fallthrough
		 		case .TIME_TO_SEC:fallthrough
		 		case .TOUCHES:fallthrough
		 		case .TO_BASE64:fallthrough
		 		case .TO_DAYS:fallthrough
		 		case .TO_SECONDS:fallthrough
		 		case .TP_CONNECTION_ADMIN:fallthrough
		 		case .UCASE:fallthrough
		 		case .UNCOMPRESS:fallthrough
		 		case .UNCOMPRESSED_LENGTH:fallthrough
		 		case .UNHEX:fallthrough
		 		case .UNIX_TIMESTAMP:fallthrough
		 		case .UPDATEXML:fallthrough
		 		case .UPPER:fallthrough
		 		case .UUID:fallthrough
		 		case .UUID_SHORT:fallthrough
		 		case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 		case .VERSION:fallthrough
		 		case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 		case .WEEKDAY:fallthrough
		 		case .WEEKOFYEAR:fallthrough
		 		case .WEIGHT_STRING:fallthrough
		 		case .WITHIN:fallthrough
		 		case .YEARWEEK:fallthrough
		 		case .Y_FUNCTION:fallthrough
		 		case .X_FUNCTION:fallthrough
		 		case .MOD:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:fallthrough
		 		case .ID:
		 			setState(2945)
		 			try uidList()

		 			break

		 		case .ALL:
		 			setState(2946)
		 			try match(MySqlParser.Tokens.ALL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .CHECK:
		 		_localctx =  AlterByCheckPartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 10)
		 		setState(2949)
		 		try match(MySqlParser.Tokens.CHECK.rawValue)
		 		setState(2950)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2953)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ARRAY:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .BUCKETS:fallthrough
		 		case .CONDITION:fallthrough
		 		case .CURRENT:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DIAGNOSTICS:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENFORCED:fallthrough
		 		case .EXCEPT:fallthrough
		 		case .GROUP:fallthrough
		 		case .IF:fallthrough
		 		case .IGNORED:fallthrough
		 		case .INSERT:fallthrough
		 		case .LATERAL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OPTIONAL:fallthrough
		 		case .ORDER:fallthrough
		 		case .PRIMARY:fallthrough
		 		case .REPEAT:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SKIP_QUERY_REWRITE:fallthrough
		 		case .STACKED:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .BINARY:fallthrough
		 		case .TEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .JSON_ARRAY:fallthrough
		 		case .JSON_ARRAYAGG:fallthrough
		 		case .JSON_ARRAY_APPEND:fallthrough
		 		case .JSON_ARRAY_INSERT:fallthrough
		 		case .JSON_CONTAINS:fallthrough
		 		case .JSON_CONTAINS_PATH:fallthrough
		 		case .JSON_DEPTH:fallthrough
		 		case .JSON_EXTRACT:fallthrough
		 		case .JSON_INSERT:fallthrough
		 		case .JSON_KEYS:fallthrough
		 		case .JSON_LENGTH:fallthrough
		 		case .JSON_MERGE:fallthrough
		 		case .JSON_MERGE_PATCH:fallthrough
		 		case .JSON_MERGE_PRESERVE:fallthrough
		 		case .JSON_OBJECT:fallthrough
		 		case .JSON_OBJECTAGG:fallthrough
		 		case .JSON_OVERLAPS:fallthrough
		 		case .JSON_PRETTY:fallthrough
		 		case .JSON_QUOTE:fallthrough
		 		case .JSON_REMOVE:fallthrough
		 		case .JSON_REPLACE:fallthrough
		 		case .JSON_SCHEMA_VALID:fallthrough
		 		case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 		case .JSON_SEARCH:fallthrough
		 		case .JSON_SET:fallthrough
		 		case .JSON_STORAGE_FREE:fallthrough
		 		case .JSON_STORAGE_SIZE:fallthrough
		 		case .JSON_TABLE:fallthrough
		 		case .JSON_TYPE:fallthrough
		 		case .JSON_UNQUOTE:fallthrough
		 		case .JSON_VALID:fallthrough
		 		case .JSON_VALUE:fallthrough
		 		case .NESTED:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .PATH:fallthrough
		 		case .AVG:fallthrough
		 		case .BIT_AND:fallthrough
		 		case .BIT_OR:fallthrough
		 		case .BIT_XOR:fallthrough
		 		case .COUNT:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .GROUP_CONCAT:fallthrough
		 		case .LAG:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NTH_VALUE:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .RANK:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .STD:fallthrough
		 		case .STDDEV:fallthrough
		 		case .STDDEV_POP:fallthrough
		 		case .STDDEV_SAMP:fallthrough
		 		case .SUM:fallthrough
		 		case .VAR_POP:fallthrough
		 		case .VAR_SAMP:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .CURRENT_DATE:fallthrough
		 		case .CURRENT_TIME:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .LOCALTIME:fallthrough
		 		case .CURDATE:fallthrough
		 		case .CURTIME:fallthrough
		 		case .DATE_ADD:fallthrough
		 		case .DATE_SUB:fallthrough
		 		case .LOCALTIMESTAMP:fallthrough
		 		case .NOW:fallthrough
		 		case .POSITION:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .SUBSTRING:fallthrough
		 		case .SYSDATE:fallthrough
		 		case .TRIM:fallthrough
		 		case .UTC_DATE:fallthrough
		 		case .UTC_TIME:fallthrough
		 		case .UTC_TIMESTAMP:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .ACTION:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALGORITHM:fallthrough
		 		case .ANY:fallthrough
		 		case .AT:fallthrough
		 		case .AUTHORS:fallthrough
		 		case .AUTOCOMMIT:fallthrough
		 		case .AUTOEXTEND_SIZE:fallthrough
		 		case .AUTO_INCREMENT:fallthrough
		 		case .AVG_ROW_LENGTH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .BIT:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BTREE:fallthrough
		 		case .CACHE:fallthrough
		 		case .CASCADED:fallthrough
		 		case .CHAIN:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .PAGE_CHECKSUM:fallthrough
		 		case .CIPHER:fallthrough
		 		case .CLASS_ORIGIN:fallthrough
		 		case .CLIENT:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTERING:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CODE:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COLUMN_FORMAT:fallthrough
		 		case .COLUMN_NAME:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMPACT:fallthrough
		 		case .COMPLETION:fallthrough
		 		case .COMPRESSED:fallthrough
		 		case .COMPRESSION:fallthrough
		 		case .CONCURRENT:fallthrough
		 		case .CONNECT:fallthrough
		 		case .CONNECTION:fallthrough
		 		case .CONSISTENT:fallthrough
		 		case .CONSTRAINT_CATALOG:fallthrough
		 		case .CONSTRAINT_SCHEMA:fallthrough
		 		case .CONSTRAINT_NAME:fallthrough
		 		case .CONTAINS:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTRIBUTORS:fallthrough
		 		case .COPY:fallthrough
		 		case .CPU:fallthrough
		 		case .CURSOR_NAME:fallthrough
		 		case .DATA:fallthrough
		 		case .DATAFILE:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DEFAULT_AUTH:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DELAY_KEY_WRITE:fallthrough
		 		case .DES_KEY_FILE:fallthrough
		 		case .DIRECTORY:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISCARD:fallthrough
		 		case .DISK:fallthrough
		 		case .DO:fallthrough
		 		case .DUMPFILE:fallthrough
		 		case .DUPLICATE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .END:fallthrough
		 		case .ENDS:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ENGINES:fallthrough
		 		case .ERROR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVEN:fallthrough
		 		case .EVENT:fallthrough
		 		case .EVENTS:fallthrough
		 		case .EVERY:fallthrough
		 		case .EXCHANGE:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPIRE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .EXTENT_SIZE:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FAST:fallthrough
		 		case .FAULTS:fallthrough
		 		case .FIELDS:fallthrough
		 		case .FILE_BLOCK_SIZE:fallthrough
		 		case .FILTER:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIXED:fallthrough
		 		case .FLUSH:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FOUND:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GENERAL:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GRANTS:fallthrough
		 		case .GROUP_REPLICATION:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HASH:fallthrough
		 		case .HELP:fallthrough
		 		case .HISTORY:fallthrough
		 		case .HOST:fallthrough
		 		case .HOSTS:fallthrough
		 		case .IDENTIFIED:fallthrough
		 		case .IGNORE_SERVER_IDS:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INDEXES:fallthrough
		 		case .INITIAL_SIZE:fallthrough
		 		case .INPLACE:fallthrough
		 		case .INSERT_METHOD:fallthrough
		 		case .INSTALL:fallthrough
		 		case .INSTANCE:fallthrough
		 		case .INSTANT:fallthrough
		 		case .INVISIBLE:fallthrough
		 		case .INVOKER:fallthrough
		 		case .IO:fallthrough
		 		case .IO_THREAD:fallthrough
		 		case .IPC:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ISSUER:fallthrough
		 		case .JSON:fallthrough
		 		case .KEY_BLOCK_SIZE:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LEAVES:fallthrough
		 		case .LESS:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOGFILE:fallthrough
		 		case .LOGS:fallthrough
		 		case .MASTER:fallthrough
		 		case .MASTER_AUTO_POSITION:fallthrough
		 		case .MASTER_CONNECT_RETRY:fallthrough
		 		case .MASTER_DELAY:fallthrough
		 		case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 		case .MASTER_HOST:fallthrough
		 		case .MASTER_LOG_FILE:fallthrough
		 		case .MASTER_LOG_POS:fallthrough
		 		case .MASTER_PASSWORD:fallthrough
		 		case .MASTER_PORT:fallthrough
		 		case .MASTER_RETRY_COUNT:fallthrough
		 		case .MASTER_SSL:fallthrough
		 		case .MASTER_SSL_CA:fallthrough
		 		case .MASTER_SSL_CAPATH:fallthrough
		 		case .MASTER_SSL_CERT:fallthrough
		 		case .MASTER_SSL_CIPHER:fallthrough
		 		case .MASTER_SSL_CRL:fallthrough
		 		case .MASTER_SSL_CRLPATH:fallthrough
		 		case .MASTER_SSL_KEY:fallthrough
		 		case .MASTER_TLS_VERSION:fallthrough
		 		case .MASTER_USER:fallthrough
		 		case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 		case .MAX_QUERIES_PER_HOUR:fallthrough
		 		case .MAX_ROWS:fallthrough
		 		case .MAX_SIZE:fallthrough
		 		case .MAX_UPDATES_PER_HOUR:fallthrough
		 		case .MAX_USER_CONNECTIONS:fallthrough
		 		case .MEDIUM:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MESSAGE_TEXT:fallthrough
		 		case .MID:fallthrough
		 		case .MIGRATE:fallthrough
		 		case .MIN_ROWS:fallthrough
		 		case .MODE:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MUTEX:fallthrough
		 		case .MYSQL:fallthrough
		 		case .MYSQL_ERRNO:fallthrough
		 		case .NAME:fallthrough
		 		case .NAMES:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NEVER:fallthrough
		 		case .NEXT:fallthrough
		 		case .NO:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOWAIT:fallthrough
		 		case .NODEGROUP:fallthrough
		 		case .NONE:fallthrough
		 		case .ODBC:fallthrough
		 		case .OFFLINE:fallthrough
		 		case .OFFSET:fallthrough
		 		case .OF:fallthrough
		 		case .OJ:fallthrough
		 		case .OLD_PASSWORD:fallthrough
		 		case .ONE:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .OPTIMIZER_COSTS:fallthrough
		 		case .OPTIONS:fallthrough
		 		case .OWNER:fallthrough
		 		case .PACK_KEYS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PARSER:fallthrough
		 		case .PARTIAL:fallthrough
		 		case .PARTITIONING:fallthrough
		 		case .PARTITIONS:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PHASE:fallthrough
		 		case .PLUGIN:fallthrough
		 		case .PLUGIN_DIR:fallthrough
		 		case .PLUGINS:fallthrough
		 		case .PORT:fallthrough
		 		case .PRECEDES:fallthrough
		 		case .PREPARE:fallthrough
		 		case .PRESERVE:fallthrough
		 		case .PREV:fallthrough
		 		case .PROCESSLIST:fallthrough
		 		case .PROFILE:fallthrough
		 		case .PROFILES:fallthrough
		 		case .PROXY:fallthrough
		 		case .QUERY:fallthrough
		 		case .QUICK:fallthrough
		 		case .REBUILD:fallthrough
		 		case .RECOVER:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REDO_BUFFER_SIZE:fallthrough
		 		case .REDUNDANT:fallthrough
		 		case .RELAY:fallthrough
		 		case .RELAY_LOG_FILE:fallthrough
		 		case .RELAY_LOG_POS:fallthrough
		 		case .RELAYLOG:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REORGANIZE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .REPLICATE_DO_DB:fallthrough
		 		case .REPLICATE_DO_TABLE:fallthrough
		 		case .REPLICATE_IGNORE_DB:fallthrough
		 		case .REPLICATE_IGNORE_TABLE:fallthrough
		 		case .REPLICATE_REWRITE_DB:fallthrough
		 		case .REPLICATE_WILD_DO_TABLE:fallthrough
		 		case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 		case .REPLICATION:fallthrough
		 		case .RESET:fallthrough
		 		case .RESUME:fallthrough
		 		case .RETURNED_SQLSTATE:fallthrough
		 		case .RETURNING:fallthrough
		 		case .RETURNS:fallthrough
		 		case .REUSE:fallthrough
		 		case .ROLE:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROTATE:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_FORMAT:fallthrough
		 		case .RTREE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEDULE:fallthrough
		 		case .SECURITY:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION:fallthrough
		 		case .SHARE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SIGNED:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SLAVE:fallthrough
		 		case .SLOW:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOCKET:fallthrough
		 		case .SOME:fallthrough
		 		case .SONAME:fallthrough
		 		case .SOUNDS:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SQL_AFTER_GTIDS:fallthrough
		 		case .SQL_AFTER_MTS_GAPS:fallthrough
		 		case .SQL_BEFORE_GTIDS:fallthrough
		 		case .SQL_BUFFER_RESULT:fallthrough
		 		case .SQL_CACHE:fallthrough
		 		case .SQL_NO_CACHE:fallthrough
		 		case .SQL_THREAD:fallthrough
		 		case .START:fallthrough
		 		case .STARTS:fallthrough
		 		case .STATS_AUTO_RECALC:fallthrough
		 		case .STATS_PERSISTENT:fallthrough
		 		case .STATS_SAMPLE_PAGES:fallthrough
		 		case .STATUS:fallthrough
		 		case .STOP:fallthrough
		 		case .STORAGE:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBCLASS_ORIGIN:fallthrough
		 		case .SUBJECT:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBPARTITIONS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .SWAPS:fallthrough
		 		case .SWITCHES:fallthrough
		 		case .TABLE_NAME:fallthrough
		 		case .TABLESPACE:fallthrough
		 		case .TABLE_TYPE:fallthrough
		 		case .TEMPORARY:fallthrough
		 		case .TEMPTABLE:fallthrough
		 		case .THAN:fallthrough
		 		case .TRADITIONAL:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSACTIONAL:fallthrough
		 		case .TRIGGERS:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDEFINED:fallthrough
		 		case .UNDOFILE:fallthrough
		 		case .UNDO_BUFFER_SIZE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPGRADE:fallthrough
		 		case .USER:fallthrough
		 		case .USE_FRM:fallthrough
		 		case .USER_RESOURCES:fallthrough
		 		case .VALIDATION:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARIABLES:fallthrough
		 		case .VIEW:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .VISIBLE:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNINGS:fallthrough
		 		case .WITHOUT:fallthrough
		 		case .WORK:fallthrough
		 		case .WRAPPER:fallthrough
		 		case .X509:fallthrough
		 		case .XA:fallthrough
		 		case .XML:fallthrough
		 		case .EUR:fallthrough
		 		case .USA:fallthrough
		 		case .JIS:fallthrough
		 		case .ISO:fallthrough
		 		case .INTERNAL:fallthrough
		 		case .QUARTER:fallthrough
		 		case .MONTH:fallthrough
		 		case .DAY:fallthrough
		 		case .HOUR:fallthrough
		 		case .MINUTE:fallthrough
		 		case .WEEK:fallthrough
		 		case .SECOND:fallthrough
		 		case .MICROSECOND:fallthrough
		 		case .ADMIN:fallthrough
		 		case .AUDIT_ABORT_EXEMPT:fallthrough
		 		case .AUDIT_ADMIN:fallthrough
		 		case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 		case .BACKUP_ADMIN:fallthrough
		 		case .BINLOG_ADMIN:fallthrough
		 		case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 		case .CLONE_ADMIN:fallthrough
		 		case .CONNECTION_ADMIN:fallthrough
		 		case .ENCRYPTION_KEY_ADMIN:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .FILE:fallthrough
		 		case .FIREWALL_ADMIN:fallthrough
		 		case .FIREWALL_EXEMPT:fallthrough
		 		case .FIREWALL_USER:fallthrough
		 		case .GROUP_REPLICATION_ADMIN:fallthrough
		 		case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 		case .INVOKE:fallthrough
		 		case .LAMBDA:fallthrough
		 		case .NDB_STORED_USER:fallthrough
		 		case .PASSWORDLESS_USER_ADMIN:fallthrough
		 		case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .PROCESS:fallthrough
		 		case .RELOAD:fallthrough
		 		case .REPLICATION_APPLIER:fallthrough
		 		case .REPLICATION_SLAVE_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_USER:fallthrough
		 		case .ROLE_ADMIN:fallthrough
		 		case .ROUTINE:fallthrough
		 		case .S3:fallthrough
		 		case .SESSION_VARIABLES_ADMIN:fallthrough
		 		case .SET_USER_ID:fallthrough
		 		case .SHOW_ROUTINE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SUPER:fallthrough
		 		case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 		case .TABLES:fallthrough
		 		case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 		case .VERSION_TOKEN_ADMIN:fallthrough
		 		case .XA_RECOVER_ADMIN:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .ARCHIVE:fallthrough
		 		case .BLACKHOLE:fallthrough
		 		case .CSV:fallthrough
		 		case .FEDERATED:fallthrough
		 		case .INNODB:fallthrough
		 		case .MEMORY:fallthrough
		 		case .MRG_MYISAM:fallthrough
		 		case .MYISAM:fallthrough
		 		case .NDB:fallthrough
		 		case .NDBCLUSTER:fallthrough
		 		case .PERFORMANCE_SCHEMA:fallthrough
		 		case .TOKUDB:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:fallthrough
		 		case .ABS:fallthrough
		 		case .ACOS:fallthrough
		 		case .ADDDATE:fallthrough
		 		case .ADDTIME:fallthrough
		 		case .AES_DECRYPT:fallthrough
		 		case .AES_ENCRYPT:fallthrough
		 		case .AREA:fallthrough
		 		case .ASBINARY:fallthrough
		 		case .ASIN:fallthrough
		 		case .ASTEXT:fallthrough
		 		case .ASWKB:fallthrough
		 		case .ASWKT:fallthrough
		 		case .ASYMMETRIC_DECRYPT:fallthrough
		 		case .ASYMMETRIC_DERIVE:fallthrough
		 		case .ASYMMETRIC_ENCRYPT:fallthrough
		 		case .ASYMMETRIC_SIGN:fallthrough
		 		case .ASYMMETRIC_VERIFY:fallthrough
		 		case .ATAN:fallthrough
		 		case .ATAN2:fallthrough
		 		case .BENCHMARK:fallthrough
		 		case .BIN:fallthrough
		 		case .BIT_COUNT:fallthrough
		 		case .BIT_LENGTH:fallthrough
		 		case .BUFFER:fallthrough
		 		case .CATALOG_NAME:fallthrough
		 		case .CEIL:fallthrough
		 		case .CEILING:fallthrough
		 		case .CENTROID:fallthrough
		 		case .CHARACTER_LENGTH:fallthrough
		 		case .CHARSET:fallthrough
		 		case .CHAR_LENGTH:fallthrough
		 		case .COERCIBILITY:fallthrough
		 		case .COLLATION:fallthrough
		 		case .COMPRESS:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_WS:fallthrough
		 		case .CONNECTION_ID:fallthrough
		 		case .CONV:fallthrough
		 		case .CONVERT_TZ:fallthrough
		 		case .COS:fallthrough
		 		case .COT:fallthrough
		 		case .CRC32:fallthrough
		 		case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 		case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 		case .CREATE_DH_PARAMETERS:fallthrough
		 		case .CREATE_DIGEST:fallthrough
		 		case .CROSSES:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATE_FORMAT:fallthrough
		 		case .DAYNAME:fallthrough
		 		case .DAYOFMONTH:fallthrough
		 		case .DAYOFWEEK:fallthrough
		 		case .DAYOFYEAR:fallthrough
		 		case .DECODE:fallthrough
		 		case .DEGREES:fallthrough
		 		case .DES_DECRYPT:fallthrough
		 		case .DES_ENCRYPT:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISJOINT:fallthrough
		 		case .ELT:fallthrough
		 		case .ENCODE:fallthrough
		 		case .ENCRYPT:fallthrough
		 		case .ENDPOINT:fallthrough
		 		case .ENGINE_ATTRIBUTE:fallthrough
		 		case .ENVELOPE:fallthrough
		 		case .EQUALS:fallthrough
		 		case .EXP:fallthrough
		 		case .EXPORT_SET:fallthrough
		 		case .EXTERIORRING:fallthrough
		 		case .EXTRACTVALUE:fallthrough
		 		case .FIELD:fallthrough
		 		case .FIND_IN_SET:fallthrough
		 		case .FLOOR:fallthrough
		 		case .FORMAT:fallthrough
		 		case .FOUND_ROWS:fallthrough
		 		case .FROM_BASE64:fallthrough
		 		case .FROM_DAYS:fallthrough
		 		case .FROM_UNIXTIME:fallthrough
		 		case .GEOMCOLLFROMTEXT:fallthrough
		 		case .GEOMCOLLFROMWKB:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .GEOMETRYFROMTEXT:fallthrough
		 		case .GEOMETRYFROMWKB:fallthrough
		 		case .GEOMETRYN:fallthrough
		 		case .GEOMETRYTYPE:fallthrough
		 		case .GEOMFROMTEXT:fallthrough
		 		case .GEOMFROMWKB:fallthrough
		 		case .GET_FORMAT:fallthrough
		 		case .GET_LOCK:fallthrough
		 		case .GLENGTH:fallthrough
		 		case .GREATEST:fallthrough
		 		case .GTID_SUBSET:fallthrough
		 		case .GTID_SUBTRACT:fallthrough
		 		case .HEX:fallthrough
		 		case .IFNULL:fallthrough
		 		case .INET6_ATON:fallthrough
		 		case .INET6_NTOA:fallthrough
		 		case .INET_ATON:fallthrough
		 		case .INET_NTOA:fallthrough
		 		case .INSTR:fallthrough
		 		case .INTERIORRINGN:fallthrough
		 		case .INTERSECTS:fallthrough
		 		case .ISCLOSED:fallthrough
		 		case .ISEMPTY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .ISSIMPLE:fallthrough
		 		case .IS_FREE_LOCK:fallthrough
		 		case .IS_IPV4:fallthrough
		 		case .IS_IPV4_COMPAT:fallthrough
		 		case .IS_IPV4_MAPPED:fallthrough
		 		case .IS_IPV6:fallthrough
		 		case .IS_USED_LOCK:fallthrough
		 		case .LAST_INSERT_ID:fallthrough
		 		case .LCASE:fallthrough
		 		case .LEAST:fallthrough
		 		case .LENGTH:fallthrough
		 		case .LINEFROMTEXT:fallthrough
		 		case .LINEFROMWKB:fallthrough
		 		case .LINESTRINGFROMTEXT:fallthrough
		 		case .LINESTRINGFROMWKB:fallthrough
		 		case .LN:fallthrough
		 		case .LOAD_FILE:fallthrough
		 		case .LOCATE:fallthrough
		 		case .LOG:fallthrough
		 		case .LOG10:fallthrough
		 		case .LOG2:fallthrough
		 		case .LOWER:fallthrough
		 		case .LPAD:fallthrough
		 		case .LTRIM:fallthrough
		 		case .MAKEDATE:fallthrough
		 		case .MAKETIME:fallthrough
		 		case .MAKE_SET:fallthrough
		 		case .MASTER_POS_WAIT:fallthrough
		 		case .MBRCONTAINS:fallthrough
		 		case .MBRDISJOINT:fallthrough
		 		case .MBREQUAL:fallthrough
		 		case .MBRINTERSECTS:fallthrough
		 		case .MBROVERLAPS:fallthrough
		 		case .MBRTOUCHES:fallthrough
		 		case .MBRWITHIN:fallthrough
		 		case .MD5:fallthrough
		 		case .MLINEFROMTEXT:fallthrough
		 		case .MLINEFROMWKB:fallthrough
		 		case .MONTHNAME:fallthrough
		 		case .MPOINTFROMTEXT:fallthrough
		 		case .MPOINTFROMWKB:fallthrough
		 		case .MPOLYFROMTEXT:fallthrough
		 		case .MPOLYFROMWKB:fallthrough
		 		case .MULTILINESTRINGFROMTEXT:fallthrough
		 		case .MULTILINESTRINGFROMWKB:fallthrough
		 		case .MULTIPOINTFROMTEXT:fallthrough
		 		case .MULTIPOINTFROMWKB:fallthrough
		 		case .MULTIPOLYGONFROMTEXT:fallthrough
		 		case .MULTIPOLYGONFROMWKB:fallthrough
		 		case .NAME_CONST:fallthrough
		 		case .NULLIF:fallthrough
		 		case .NUMGEOMETRIES:fallthrough
		 		case .NUMINTERIORRINGS:fallthrough
		 		case .NUMPOINTS:fallthrough
		 		case .OCT:fallthrough
		 		case .OCTET_LENGTH:fallthrough
		 		case .ORD:fallthrough
		 		case .OVERLAPS:fallthrough
		 		case .PERIOD_ADD:fallthrough
		 		case .PERIOD_DIFF:fallthrough
		 		case .PI:fallthrough
		 		case .POINTFROMTEXT:fallthrough
		 		case .POINTFROMWKB:fallthrough
		 		case .POINTN:fallthrough
		 		case .POLYFROMTEXT:fallthrough
		 		case .POLYFROMWKB:fallthrough
		 		case .POLYGONFROMTEXT:fallthrough
		 		case .POLYGONFROMWKB:fallthrough
		 		case .POW:fallthrough
		 		case .POWER:fallthrough
		 		case .QUOTE:fallthrough
		 		case .RADIANS:fallthrough
		 		case .RAND:fallthrough
		 		case .RANDOM:fallthrough
		 		case .RANDOM_BYTES:fallthrough
		 		case .RELEASE_LOCK:fallthrough
		 		case .REVERSE:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_COUNT:fallthrough
		 		case .RPAD:fallthrough
		 		case .RTRIM:fallthrough
		 		case .SEC_TO_TIME:fallthrough
		 		case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SHA:fallthrough
		 		case .SHA1:fallthrough
		 		case .SHA2:fallthrough
		 		case .SCHEMA_NAME:fallthrough
		 		case .SIGN:fallthrough
		 		case .SIN:fallthrough
		 		case .SLEEP:fallthrough
		 		case .SOUNDEX:fallthrough
		 		case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 		case .SQRT:fallthrough
		 		case .SRID:fallthrough
		 		case .STARTPOINT:fallthrough
		 		case .STRCMP:fallthrough
		 		case .STR_TO_DATE:fallthrough
		 		case .ST_AREA:fallthrough
		 		case .ST_ASBINARY:fallthrough
		 		case .ST_ASTEXT:fallthrough
		 		case .ST_ASWKB:fallthrough
		 		case .ST_ASWKT:fallthrough
		 		case .ST_BUFFER:fallthrough
		 		case .ST_CENTROID:fallthrough
		 		case .ST_CONTAINS:fallthrough
		 		case .ST_CROSSES:fallthrough
		 		case .ST_DIFFERENCE:fallthrough
		 		case .ST_DIMENSION:fallthrough
		 		case .ST_DISJOINT:fallthrough
		 		case .ST_DISTANCE:fallthrough
		 		case .ST_ENDPOINT:fallthrough
		 		case .ST_ENVELOPE:fallthrough
		 		case .ST_EQUALS:fallthrough
		 		case .ST_EXTERIORRING:fallthrough
		 		case .ST_GEOMCOLLFROMTEXT:fallthrough
		 		case .ST_GEOMCOLLFROMTXT:fallthrough
		 		case .ST_GEOMCOLLFROMWKB:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .ST_GEOMETRYFROMTEXT:fallthrough
		 		case .ST_GEOMETRYFROMWKB:fallthrough
		 		case .ST_GEOMETRYN:fallthrough
		 		case .ST_GEOMETRYTYPE:fallthrough
		 		case .ST_GEOMFROMTEXT:fallthrough
		 		case .ST_GEOMFROMWKB:fallthrough
		 		case .ST_INTERIORRINGN:fallthrough
		 		case .ST_INTERSECTION:fallthrough
		 		case .ST_INTERSECTS:fallthrough
		 		case .ST_ISCLOSED:fallthrough
		 		case .ST_ISEMPTY:fallthrough
		 		case .ST_ISSIMPLE:fallthrough
		 		case .ST_LINEFROMTEXT:fallthrough
		 		case .ST_LINEFROMWKB:fallthrough
		 		case .ST_LINESTRINGFROMTEXT:fallthrough
		 		case .ST_LINESTRINGFROMWKB:fallthrough
		 		case .ST_NUMGEOMETRIES:fallthrough
		 		case .ST_NUMINTERIORRING:fallthrough
		 		case .ST_NUMINTERIORRINGS:fallthrough
		 		case .ST_NUMPOINTS:fallthrough
		 		case .ST_OVERLAPS:fallthrough
		 		case .ST_POINTFROMTEXT:fallthrough
		 		case .ST_POINTFROMWKB:fallthrough
		 		case .ST_POINTN:fallthrough
		 		case .ST_POLYFROMTEXT:fallthrough
		 		case .ST_POLYFROMWKB:fallthrough
		 		case .ST_POLYGONFROMTEXT:fallthrough
		 		case .ST_POLYGONFROMWKB:fallthrough
		 		case .ST_SRID:fallthrough
		 		case .ST_STARTPOINT:fallthrough
		 		case .ST_SYMDIFFERENCE:fallthrough
		 		case .ST_TOUCHES:fallthrough
		 		case .ST_UNION:fallthrough
		 		case .ST_WITHIN:fallthrough
		 		case .ST_X:fallthrough
		 		case .ST_Y:fallthrough
		 		case .SUBDATE:fallthrough
		 		case .SUBSTRING_INDEX:fallthrough
		 		case .SUBTIME:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TAN:fallthrough
		 		case .TIMEDIFF:fallthrough
		 		case .TIMESTAMPADD:fallthrough
		 		case .TIMESTAMPDIFF:fallthrough
		 		case .TIME_FORMAT:fallthrough
		 		case .TIME_TO_SEC:fallthrough
		 		case .TOUCHES:fallthrough
		 		case .TO_BASE64:fallthrough
		 		case .TO_DAYS:fallthrough
		 		case .TO_SECONDS:fallthrough
		 		case .TP_CONNECTION_ADMIN:fallthrough
		 		case .UCASE:fallthrough
		 		case .UNCOMPRESS:fallthrough
		 		case .UNCOMPRESSED_LENGTH:fallthrough
		 		case .UNHEX:fallthrough
		 		case .UNIX_TIMESTAMP:fallthrough
		 		case .UPDATEXML:fallthrough
		 		case .UPPER:fallthrough
		 		case .UUID:fallthrough
		 		case .UUID_SHORT:fallthrough
		 		case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 		case .VERSION:fallthrough
		 		case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 		case .WEEKDAY:fallthrough
		 		case .WEEKOFYEAR:fallthrough
		 		case .WEIGHT_STRING:fallthrough
		 		case .WITHIN:fallthrough
		 		case .YEARWEEK:fallthrough
		 		case .Y_FUNCTION:fallthrough
		 		case .X_FUNCTION:fallthrough
		 		case .MOD:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:fallthrough
		 		case .ID:
		 			setState(2951)
		 			try uidList()

		 			break

		 		case .ALL:
		 			setState(2952)
		 			try match(MySqlParser.Tokens.ALL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .OPTIMIZE:
		 		_localctx =  AlterByOptimizePartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 11)
		 		setState(2955)
		 		try match(MySqlParser.Tokens.OPTIMIZE.rawValue)
		 		setState(2956)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2959)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ARRAY:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .BUCKETS:fallthrough
		 		case .CONDITION:fallthrough
		 		case .CURRENT:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DIAGNOSTICS:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENFORCED:fallthrough
		 		case .EXCEPT:fallthrough
		 		case .GROUP:fallthrough
		 		case .IF:fallthrough
		 		case .IGNORED:fallthrough
		 		case .INSERT:fallthrough
		 		case .LATERAL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OPTIONAL:fallthrough
		 		case .ORDER:fallthrough
		 		case .PRIMARY:fallthrough
		 		case .REPEAT:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SKIP_QUERY_REWRITE:fallthrough
		 		case .STACKED:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .BINARY:fallthrough
		 		case .TEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .JSON_ARRAY:fallthrough
		 		case .JSON_ARRAYAGG:fallthrough
		 		case .JSON_ARRAY_APPEND:fallthrough
		 		case .JSON_ARRAY_INSERT:fallthrough
		 		case .JSON_CONTAINS:fallthrough
		 		case .JSON_CONTAINS_PATH:fallthrough
		 		case .JSON_DEPTH:fallthrough
		 		case .JSON_EXTRACT:fallthrough
		 		case .JSON_INSERT:fallthrough
		 		case .JSON_KEYS:fallthrough
		 		case .JSON_LENGTH:fallthrough
		 		case .JSON_MERGE:fallthrough
		 		case .JSON_MERGE_PATCH:fallthrough
		 		case .JSON_MERGE_PRESERVE:fallthrough
		 		case .JSON_OBJECT:fallthrough
		 		case .JSON_OBJECTAGG:fallthrough
		 		case .JSON_OVERLAPS:fallthrough
		 		case .JSON_PRETTY:fallthrough
		 		case .JSON_QUOTE:fallthrough
		 		case .JSON_REMOVE:fallthrough
		 		case .JSON_REPLACE:fallthrough
		 		case .JSON_SCHEMA_VALID:fallthrough
		 		case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 		case .JSON_SEARCH:fallthrough
		 		case .JSON_SET:fallthrough
		 		case .JSON_STORAGE_FREE:fallthrough
		 		case .JSON_STORAGE_SIZE:fallthrough
		 		case .JSON_TABLE:fallthrough
		 		case .JSON_TYPE:fallthrough
		 		case .JSON_UNQUOTE:fallthrough
		 		case .JSON_VALID:fallthrough
		 		case .JSON_VALUE:fallthrough
		 		case .NESTED:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .PATH:fallthrough
		 		case .AVG:fallthrough
		 		case .BIT_AND:fallthrough
		 		case .BIT_OR:fallthrough
		 		case .BIT_XOR:fallthrough
		 		case .COUNT:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .GROUP_CONCAT:fallthrough
		 		case .LAG:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NTH_VALUE:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .RANK:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .STD:fallthrough
		 		case .STDDEV:fallthrough
		 		case .STDDEV_POP:fallthrough
		 		case .STDDEV_SAMP:fallthrough
		 		case .SUM:fallthrough
		 		case .VAR_POP:fallthrough
		 		case .VAR_SAMP:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .CURRENT_DATE:fallthrough
		 		case .CURRENT_TIME:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .LOCALTIME:fallthrough
		 		case .CURDATE:fallthrough
		 		case .CURTIME:fallthrough
		 		case .DATE_ADD:fallthrough
		 		case .DATE_SUB:fallthrough
		 		case .LOCALTIMESTAMP:fallthrough
		 		case .NOW:fallthrough
		 		case .POSITION:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .SUBSTRING:fallthrough
		 		case .SYSDATE:fallthrough
		 		case .TRIM:fallthrough
		 		case .UTC_DATE:fallthrough
		 		case .UTC_TIME:fallthrough
		 		case .UTC_TIMESTAMP:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .ACTION:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALGORITHM:fallthrough
		 		case .ANY:fallthrough
		 		case .AT:fallthrough
		 		case .AUTHORS:fallthrough
		 		case .AUTOCOMMIT:fallthrough
		 		case .AUTOEXTEND_SIZE:fallthrough
		 		case .AUTO_INCREMENT:fallthrough
		 		case .AVG_ROW_LENGTH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .BIT:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BTREE:fallthrough
		 		case .CACHE:fallthrough
		 		case .CASCADED:fallthrough
		 		case .CHAIN:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .PAGE_CHECKSUM:fallthrough
		 		case .CIPHER:fallthrough
		 		case .CLASS_ORIGIN:fallthrough
		 		case .CLIENT:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTERING:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CODE:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COLUMN_FORMAT:fallthrough
		 		case .COLUMN_NAME:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMPACT:fallthrough
		 		case .COMPLETION:fallthrough
		 		case .COMPRESSED:fallthrough
		 		case .COMPRESSION:fallthrough
		 		case .CONCURRENT:fallthrough
		 		case .CONNECT:fallthrough
		 		case .CONNECTION:fallthrough
		 		case .CONSISTENT:fallthrough
		 		case .CONSTRAINT_CATALOG:fallthrough
		 		case .CONSTRAINT_SCHEMA:fallthrough
		 		case .CONSTRAINT_NAME:fallthrough
		 		case .CONTAINS:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTRIBUTORS:fallthrough
		 		case .COPY:fallthrough
		 		case .CPU:fallthrough
		 		case .CURSOR_NAME:fallthrough
		 		case .DATA:fallthrough
		 		case .DATAFILE:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DEFAULT_AUTH:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DELAY_KEY_WRITE:fallthrough
		 		case .DES_KEY_FILE:fallthrough
		 		case .DIRECTORY:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISCARD:fallthrough
		 		case .DISK:fallthrough
		 		case .DO:fallthrough
		 		case .DUMPFILE:fallthrough
		 		case .DUPLICATE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .END:fallthrough
		 		case .ENDS:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ENGINES:fallthrough
		 		case .ERROR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVEN:fallthrough
		 		case .EVENT:fallthrough
		 		case .EVENTS:fallthrough
		 		case .EVERY:fallthrough
		 		case .EXCHANGE:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPIRE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .EXTENT_SIZE:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FAST:fallthrough
		 		case .FAULTS:fallthrough
		 		case .FIELDS:fallthrough
		 		case .FILE_BLOCK_SIZE:fallthrough
		 		case .FILTER:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIXED:fallthrough
		 		case .FLUSH:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FOUND:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GENERAL:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GRANTS:fallthrough
		 		case .GROUP_REPLICATION:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HASH:fallthrough
		 		case .HELP:fallthrough
		 		case .HISTORY:fallthrough
		 		case .HOST:fallthrough
		 		case .HOSTS:fallthrough
		 		case .IDENTIFIED:fallthrough
		 		case .IGNORE_SERVER_IDS:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INDEXES:fallthrough
		 		case .INITIAL_SIZE:fallthrough
		 		case .INPLACE:fallthrough
		 		case .INSERT_METHOD:fallthrough
		 		case .INSTALL:fallthrough
		 		case .INSTANCE:fallthrough
		 		case .INSTANT:fallthrough
		 		case .INVISIBLE:fallthrough
		 		case .INVOKER:fallthrough
		 		case .IO:fallthrough
		 		case .IO_THREAD:fallthrough
		 		case .IPC:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ISSUER:fallthrough
		 		case .JSON:fallthrough
		 		case .KEY_BLOCK_SIZE:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LEAVES:fallthrough
		 		case .LESS:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOGFILE:fallthrough
		 		case .LOGS:fallthrough
		 		case .MASTER:fallthrough
		 		case .MASTER_AUTO_POSITION:fallthrough
		 		case .MASTER_CONNECT_RETRY:fallthrough
		 		case .MASTER_DELAY:fallthrough
		 		case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 		case .MASTER_HOST:fallthrough
		 		case .MASTER_LOG_FILE:fallthrough
		 		case .MASTER_LOG_POS:fallthrough
		 		case .MASTER_PASSWORD:fallthrough
		 		case .MASTER_PORT:fallthrough
		 		case .MASTER_RETRY_COUNT:fallthrough
		 		case .MASTER_SSL:fallthrough
		 		case .MASTER_SSL_CA:fallthrough
		 		case .MASTER_SSL_CAPATH:fallthrough
		 		case .MASTER_SSL_CERT:fallthrough
		 		case .MASTER_SSL_CIPHER:fallthrough
		 		case .MASTER_SSL_CRL:fallthrough
		 		case .MASTER_SSL_CRLPATH:fallthrough
		 		case .MASTER_SSL_KEY:fallthrough
		 		case .MASTER_TLS_VERSION:fallthrough
		 		case .MASTER_USER:fallthrough
		 		case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 		case .MAX_QUERIES_PER_HOUR:fallthrough
		 		case .MAX_ROWS:fallthrough
		 		case .MAX_SIZE:fallthrough
		 		case .MAX_UPDATES_PER_HOUR:fallthrough
		 		case .MAX_USER_CONNECTIONS:fallthrough
		 		case .MEDIUM:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MESSAGE_TEXT:fallthrough
		 		case .MID:fallthrough
		 		case .MIGRATE:fallthrough
		 		case .MIN_ROWS:fallthrough
		 		case .MODE:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MUTEX:fallthrough
		 		case .MYSQL:fallthrough
		 		case .MYSQL_ERRNO:fallthrough
		 		case .NAME:fallthrough
		 		case .NAMES:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NEVER:fallthrough
		 		case .NEXT:fallthrough
		 		case .NO:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOWAIT:fallthrough
		 		case .NODEGROUP:fallthrough
		 		case .NONE:fallthrough
		 		case .ODBC:fallthrough
		 		case .OFFLINE:fallthrough
		 		case .OFFSET:fallthrough
		 		case .OF:fallthrough
		 		case .OJ:fallthrough
		 		case .OLD_PASSWORD:fallthrough
		 		case .ONE:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .OPTIMIZER_COSTS:fallthrough
		 		case .OPTIONS:fallthrough
		 		case .OWNER:fallthrough
		 		case .PACK_KEYS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PARSER:fallthrough
		 		case .PARTIAL:fallthrough
		 		case .PARTITIONING:fallthrough
		 		case .PARTITIONS:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PHASE:fallthrough
		 		case .PLUGIN:fallthrough
		 		case .PLUGIN_DIR:fallthrough
		 		case .PLUGINS:fallthrough
		 		case .PORT:fallthrough
		 		case .PRECEDES:fallthrough
		 		case .PREPARE:fallthrough
		 		case .PRESERVE:fallthrough
		 		case .PREV:fallthrough
		 		case .PROCESSLIST:fallthrough
		 		case .PROFILE:fallthrough
		 		case .PROFILES:fallthrough
		 		case .PROXY:fallthrough
		 		case .QUERY:fallthrough
		 		case .QUICK:fallthrough
		 		case .REBUILD:fallthrough
		 		case .RECOVER:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REDO_BUFFER_SIZE:fallthrough
		 		case .REDUNDANT:fallthrough
		 		case .RELAY:fallthrough
		 		case .RELAY_LOG_FILE:fallthrough
		 		case .RELAY_LOG_POS:fallthrough
		 		case .RELAYLOG:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REORGANIZE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .REPLICATE_DO_DB:fallthrough
		 		case .REPLICATE_DO_TABLE:fallthrough
		 		case .REPLICATE_IGNORE_DB:fallthrough
		 		case .REPLICATE_IGNORE_TABLE:fallthrough
		 		case .REPLICATE_REWRITE_DB:fallthrough
		 		case .REPLICATE_WILD_DO_TABLE:fallthrough
		 		case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 		case .REPLICATION:fallthrough
		 		case .RESET:fallthrough
		 		case .RESUME:fallthrough
		 		case .RETURNED_SQLSTATE:fallthrough
		 		case .RETURNING:fallthrough
		 		case .RETURNS:fallthrough
		 		case .REUSE:fallthrough
		 		case .ROLE:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROTATE:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_FORMAT:fallthrough
		 		case .RTREE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEDULE:fallthrough
		 		case .SECURITY:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION:fallthrough
		 		case .SHARE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SIGNED:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SLAVE:fallthrough
		 		case .SLOW:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOCKET:fallthrough
		 		case .SOME:fallthrough
		 		case .SONAME:fallthrough
		 		case .SOUNDS:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SQL_AFTER_GTIDS:fallthrough
		 		case .SQL_AFTER_MTS_GAPS:fallthrough
		 		case .SQL_BEFORE_GTIDS:fallthrough
		 		case .SQL_BUFFER_RESULT:fallthrough
		 		case .SQL_CACHE:fallthrough
		 		case .SQL_NO_CACHE:fallthrough
		 		case .SQL_THREAD:fallthrough
		 		case .START:fallthrough
		 		case .STARTS:fallthrough
		 		case .STATS_AUTO_RECALC:fallthrough
		 		case .STATS_PERSISTENT:fallthrough
		 		case .STATS_SAMPLE_PAGES:fallthrough
		 		case .STATUS:fallthrough
		 		case .STOP:fallthrough
		 		case .STORAGE:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBCLASS_ORIGIN:fallthrough
		 		case .SUBJECT:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBPARTITIONS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .SWAPS:fallthrough
		 		case .SWITCHES:fallthrough
		 		case .TABLE_NAME:fallthrough
		 		case .TABLESPACE:fallthrough
		 		case .TABLE_TYPE:fallthrough
		 		case .TEMPORARY:fallthrough
		 		case .TEMPTABLE:fallthrough
		 		case .THAN:fallthrough
		 		case .TRADITIONAL:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSACTIONAL:fallthrough
		 		case .TRIGGERS:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDEFINED:fallthrough
		 		case .UNDOFILE:fallthrough
		 		case .UNDO_BUFFER_SIZE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPGRADE:fallthrough
		 		case .USER:fallthrough
		 		case .USE_FRM:fallthrough
		 		case .USER_RESOURCES:fallthrough
		 		case .VALIDATION:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARIABLES:fallthrough
		 		case .VIEW:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .VISIBLE:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNINGS:fallthrough
		 		case .WITHOUT:fallthrough
		 		case .WORK:fallthrough
		 		case .WRAPPER:fallthrough
		 		case .X509:fallthrough
		 		case .XA:fallthrough
		 		case .XML:fallthrough
		 		case .EUR:fallthrough
		 		case .USA:fallthrough
		 		case .JIS:fallthrough
		 		case .ISO:fallthrough
		 		case .INTERNAL:fallthrough
		 		case .QUARTER:fallthrough
		 		case .MONTH:fallthrough
		 		case .DAY:fallthrough
		 		case .HOUR:fallthrough
		 		case .MINUTE:fallthrough
		 		case .WEEK:fallthrough
		 		case .SECOND:fallthrough
		 		case .MICROSECOND:fallthrough
		 		case .ADMIN:fallthrough
		 		case .AUDIT_ABORT_EXEMPT:fallthrough
		 		case .AUDIT_ADMIN:fallthrough
		 		case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 		case .BACKUP_ADMIN:fallthrough
		 		case .BINLOG_ADMIN:fallthrough
		 		case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 		case .CLONE_ADMIN:fallthrough
		 		case .CONNECTION_ADMIN:fallthrough
		 		case .ENCRYPTION_KEY_ADMIN:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .FILE:fallthrough
		 		case .FIREWALL_ADMIN:fallthrough
		 		case .FIREWALL_EXEMPT:fallthrough
		 		case .FIREWALL_USER:fallthrough
		 		case .GROUP_REPLICATION_ADMIN:fallthrough
		 		case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 		case .INVOKE:fallthrough
		 		case .LAMBDA:fallthrough
		 		case .NDB_STORED_USER:fallthrough
		 		case .PASSWORDLESS_USER_ADMIN:fallthrough
		 		case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .PROCESS:fallthrough
		 		case .RELOAD:fallthrough
		 		case .REPLICATION_APPLIER:fallthrough
		 		case .REPLICATION_SLAVE_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_USER:fallthrough
		 		case .ROLE_ADMIN:fallthrough
		 		case .ROUTINE:fallthrough
		 		case .S3:fallthrough
		 		case .SESSION_VARIABLES_ADMIN:fallthrough
		 		case .SET_USER_ID:fallthrough
		 		case .SHOW_ROUTINE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SUPER:fallthrough
		 		case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 		case .TABLES:fallthrough
		 		case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 		case .VERSION_TOKEN_ADMIN:fallthrough
		 		case .XA_RECOVER_ADMIN:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .ARCHIVE:fallthrough
		 		case .BLACKHOLE:fallthrough
		 		case .CSV:fallthrough
		 		case .FEDERATED:fallthrough
		 		case .INNODB:fallthrough
		 		case .MEMORY:fallthrough
		 		case .MRG_MYISAM:fallthrough
		 		case .MYISAM:fallthrough
		 		case .NDB:fallthrough
		 		case .NDBCLUSTER:fallthrough
		 		case .PERFORMANCE_SCHEMA:fallthrough
		 		case .TOKUDB:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:fallthrough
		 		case .ABS:fallthrough
		 		case .ACOS:fallthrough
		 		case .ADDDATE:fallthrough
		 		case .ADDTIME:fallthrough
		 		case .AES_DECRYPT:fallthrough
		 		case .AES_ENCRYPT:fallthrough
		 		case .AREA:fallthrough
		 		case .ASBINARY:fallthrough
		 		case .ASIN:fallthrough
		 		case .ASTEXT:fallthrough
		 		case .ASWKB:fallthrough
		 		case .ASWKT:fallthrough
		 		case .ASYMMETRIC_DECRYPT:fallthrough
		 		case .ASYMMETRIC_DERIVE:fallthrough
		 		case .ASYMMETRIC_ENCRYPT:fallthrough
		 		case .ASYMMETRIC_SIGN:fallthrough
		 		case .ASYMMETRIC_VERIFY:fallthrough
		 		case .ATAN:fallthrough
		 		case .ATAN2:fallthrough
		 		case .BENCHMARK:fallthrough
		 		case .BIN:fallthrough
		 		case .BIT_COUNT:fallthrough
		 		case .BIT_LENGTH:fallthrough
		 		case .BUFFER:fallthrough
		 		case .CATALOG_NAME:fallthrough
		 		case .CEIL:fallthrough
		 		case .CEILING:fallthrough
		 		case .CENTROID:fallthrough
		 		case .CHARACTER_LENGTH:fallthrough
		 		case .CHARSET:fallthrough
		 		case .CHAR_LENGTH:fallthrough
		 		case .COERCIBILITY:fallthrough
		 		case .COLLATION:fallthrough
		 		case .COMPRESS:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_WS:fallthrough
		 		case .CONNECTION_ID:fallthrough
		 		case .CONV:fallthrough
		 		case .CONVERT_TZ:fallthrough
		 		case .COS:fallthrough
		 		case .COT:fallthrough
		 		case .CRC32:fallthrough
		 		case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 		case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 		case .CREATE_DH_PARAMETERS:fallthrough
		 		case .CREATE_DIGEST:fallthrough
		 		case .CROSSES:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATE_FORMAT:fallthrough
		 		case .DAYNAME:fallthrough
		 		case .DAYOFMONTH:fallthrough
		 		case .DAYOFWEEK:fallthrough
		 		case .DAYOFYEAR:fallthrough
		 		case .DECODE:fallthrough
		 		case .DEGREES:fallthrough
		 		case .DES_DECRYPT:fallthrough
		 		case .DES_ENCRYPT:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISJOINT:fallthrough
		 		case .ELT:fallthrough
		 		case .ENCODE:fallthrough
		 		case .ENCRYPT:fallthrough
		 		case .ENDPOINT:fallthrough
		 		case .ENGINE_ATTRIBUTE:fallthrough
		 		case .ENVELOPE:fallthrough
		 		case .EQUALS:fallthrough
		 		case .EXP:fallthrough
		 		case .EXPORT_SET:fallthrough
		 		case .EXTERIORRING:fallthrough
		 		case .EXTRACTVALUE:fallthrough
		 		case .FIELD:fallthrough
		 		case .FIND_IN_SET:fallthrough
		 		case .FLOOR:fallthrough
		 		case .FORMAT:fallthrough
		 		case .FOUND_ROWS:fallthrough
		 		case .FROM_BASE64:fallthrough
		 		case .FROM_DAYS:fallthrough
		 		case .FROM_UNIXTIME:fallthrough
		 		case .GEOMCOLLFROMTEXT:fallthrough
		 		case .GEOMCOLLFROMWKB:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .GEOMETRYFROMTEXT:fallthrough
		 		case .GEOMETRYFROMWKB:fallthrough
		 		case .GEOMETRYN:fallthrough
		 		case .GEOMETRYTYPE:fallthrough
		 		case .GEOMFROMTEXT:fallthrough
		 		case .GEOMFROMWKB:fallthrough
		 		case .GET_FORMAT:fallthrough
		 		case .GET_LOCK:fallthrough
		 		case .GLENGTH:fallthrough
		 		case .GREATEST:fallthrough
		 		case .GTID_SUBSET:fallthrough
		 		case .GTID_SUBTRACT:fallthrough
		 		case .HEX:fallthrough
		 		case .IFNULL:fallthrough
		 		case .INET6_ATON:fallthrough
		 		case .INET6_NTOA:fallthrough
		 		case .INET_ATON:fallthrough
		 		case .INET_NTOA:fallthrough
		 		case .INSTR:fallthrough
		 		case .INTERIORRINGN:fallthrough
		 		case .INTERSECTS:fallthrough
		 		case .ISCLOSED:fallthrough
		 		case .ISEMPTY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .ISSIMPLE:fallthrough
		 		case .IS_FREE_LOCK:fallthrough
		 		case .IS_IPV4:fallthrough
		 		case .IS_IPV4_COMPAT:fallthrough
		 		case .IS_IPV4_MAPPED:fallthrough
		 		case .IS_IPV6:fallthrough
		 		case .IS_USED_LOCK:fallthrough
		 		case .LAST_INSERT_ID:fallthrough
		 		case .LCASE:fallthrough
		 		case .LEAST:fallthrough
		 		case .LENGTH:fallthrough
		 		case .LINEFROMTEXT:fallthrough
		 		case .LINEFROMWKB:fallthrough
		 		case .LINESTRINGFROMTEXT:fallthrough
		 		case .LINESTRINGFROMWKB:fallthrough
		 		case .LN:fallthrough
		 		case .LOAD_FILE:fallthrough
		 		case .LOCATE:fallthrough
		 		case .LOG:fallthrough
		 		case .LOG10:fallthrough
		 		case .LOG2:fallthrough
		 		case .LOWER:fallthrough
		 		case .LPAD:fallthrough
		 		case .LTRIM:fallthrough
		 		case .MAKEDATE:fallthrough
		 		case .MAKETIME:fallthrough
		 		case .MAKE_SET:fallthrough
		 		case .MASTER_POS_WAIT:fallthrough
		 		case .MBRCONTAINS:fallthrough
		 		case .MBRDISJOINT:fallthrough
		 		case .MBREQUAL:fallthrough
		 		case .MBRINTERSECTS:fallthrough
		 		case .MBROVERLAPS:fallthrough
		 		case .MBRTOUCHES:fallthrough
		 		case .MBRWITHIN:fallthrough
		 		case .MD5:fallthrough
		 		case .MLINEFROMTEXT:fallthrough
		 		case .MLINEFROMWKB:fallthrough
		 		case .MONTHNAME:fallthrough
		 		case .MPOINTFROMTEXT:fallthrough
		 		case .MPOINTFROMWKB:fallthrough
		 		case .MPOLYFROMTEXT:fallthrough
		 		case .MPOLYFROMWKB:fallthrough
		 		case .MULTILINESTRINGFROMTEXT:fallthrough
		 		case .MULTILINESTRINGFROMWKB:fallthrough
		 		case .MULTIPOINTFROMTEXT:fallthrough
		 		case .MULTIPOINTFROMWKB:fallthrough
		 		case .MULTIPOLYGONFROMTEXT:fallthrough
		 		case .MULTIPOLYGONFROMWKB:fallthrough
		 		case .NAME_CONST:fallthrough
		 		case .NULLIF:fallthrough
		 		case .NUMGEOMETRIES:fallthrough
		 		case .NUMINTERIORRINGS:fallthrough
		 		case .NUMPOINTS:fallthrough
		 		case .OCT:fallthrough
		 		case .OCTET_LENGTH:fallthrough
		 		case .ORD:fallthrough
		 		case .OVERLAPS:fallthrough
		 		case .PERIOD_ADD:fallthrough
		 		case .PERIOD_DIFF:fallthrough
		 		case .PI:fallthrough
		 		case .POINTFROMTEXT:fallthrough
		 		case .POINTFROMWKB:fallthrough
		 		case .POINTN:fallthrough
		 		case .POLYFROMTEXT:fallthrough
		 		case .POLYFROMWKB:fallthrough
		 		case .POLYGONFROMTEXT:fallthrough
		 		case .POLYGONFROMWKB:fallthrough
		 		case .POW:fallthrough
		 		case .POWER:fallthrough
		 		case .QUOTE:fallthrough
		 		case .RADIANS:fallthrough
		 		case .RAND:fallthrough
		 		case .RANDOM:fallthrough
		 		case .RANDOM_BYTES:fallthrough
		 		case .RELEASE_LOCK:fallthrough
		 		case .REVERSE:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_COUNT:fallthrough
		 		case .RPAD:fallthrough
		 		case .RTRIM:fallthrough
		 		case .SEC_TO_TIME:fallthrough
		 		case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SHA:fallthrough
		 		case .SHA1:fallthrough
		 		case .SHA2:fallthrough
		 		case .SCHEMA_NAME:fallthrough
		 		case .SIGN:fallthrough
		 		case .SIN:fallthrough
		 		case .SLEEP:fallthrough
		 		case .SOUNDEX:fallthrough
		 		case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 		case .SQRT:fallthrough
		 		case .SRID:fallthrough
		 		case .STARTPOINT:fallthrough
		 		case .STRCMP:fallthrough
		 		case .STR_TO_DATE:fallthrough
		 		case .ST_AREA:fallthrough
		 		case .ST_ASBINARY:fallthrough
		 		case .ST_ASTEXT:fallthrough
		 		case .ST_ASWKB:fallthrough
		 		case .ST_ASWKT:fallthrough
		 		case .ST_BUFFER:fallthrough
		 		case .ST_CENTROID:fallthrough
		 		case .ST_CONTAINS:fallthrough
		 		case .ST_CROSSES:fallthrough
		 		case .ST_DIFFERENCE:fallthrough
		 		case .ST_DIMENSION:fallthrough
		 		case .ST_DISJOINT:fallthrough
		 		case .ST_DISTANCE:fallthrough
		 		case .ST_ENDPOINT:fallthrough
		 		case .ST_ENVELOPE:fallthrough
		 		case .ST_EQUALS:fallthrough
		 		case .ST_EXTERIORRING:fallthrough
		 		case .ST_GEOMCOLLFROMTEXT:fallthrough
		 		case .ST_GEOMCOLLFROMTXT:fallthrough
		 		case .ST_GEOMCOLLFROMWKB:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .ST_GEOMETRYFROMTEXT:fallthrough
		 		case .ST_GEOMETRYFROMWKB:fallthrough
		 		case .ST_GEOMETRYN:fallthrough
		 		case .ST_GEOMETRYTYPE:fallthrough
		 		case .ST_GEOMFROMTEXT:fallthrough
		 		case .ST_GEOMFROMWKB:fallthrough
		 		case .ST_INTERIORRINGN:fallthrough
		 		case .ST_INTERSECTION:fallthrough
		 		case .ST_INTERSECTS:fallthrough
		 		case .ST_ISCLOSED:fallthrough
		 		case .ST_ISEMPTY:fallthrough
		 		case .ST_ISSIMPLE:fallthrough
		 		case .ST_LINEFROMTEXT:fallthrough
		 		case .ST_LINEFROMWKB:fallthrough
		 		case .ST_LINESTRINGFROMTEXT:fallthrough
		 		case .ST_LINESTRINGFROMWKB:fallthrough
		 		case .ST_NUMGEOMETRIES:fallthrough
		 		case .ST_NUMINTERIORRING:fallthrough
		 		case .ST_NUMINTERIORRINGS:fallthrough
		 		case .ST_NUMPOINTS:fallthrough
		 		case .ST_OVERLAPS:fallthrough
		 		case .ST_POINTFROMTEXT:fallthrough
		 		case .ST_POINTFROMWKB:fallthrough
		 		case .ST_POINTN:fallthrough
		 		case .ST_POLYFROMTEXT:fallthrough
		 		case .ST_POLYFROMWKB:fallthrough
		 		case .ST_POLYGONFROMTEXT:fallthrough
		 		case .ST_POLYGONFROMWKB:fallthrough
		 		case .ST_SRID:fallthrough
		 		case .ST_STARTPOINT:fallthrough
		 		case .ST_SYMDIFFERENCE:fallthrough
		 		case .ST_TOUCHES:fallthrough
		 		case .ST_UNION:fallthrough
		 		case .ST_WITHIN:fallthrough
		 		case .ST_X:fallthrough
		 		case .ST_Y:fallthrough
		 		case .SUBDATE:fallthrough
		 		case .SUBSTRING_INDEX:fallthrough
		 		case .SUBTIME:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TAN:fallthrough
		 		case .TIMEDIFF:fallthrough
		 		case .TIMESTAMPADD:fallthrough
		 		case .TIMESTAMPDIFF:fallthrough
		 		case .TIME_FORMAT:fallthrough
		 		case .TIME_TO_SEC:fallthrough
		 		case .TOUCHES:fallthrough
		 		case .TO_BASE64:fallthrough
		 		case .TO_DAYS:fallthrough
		 		case .TO_SECONDS:fallthrough
		 		case .TP_CONNECTION_ADMIN:fallthrough
		 		case .UCASE:fallthrough
		 		case .UNCOMPRESS:fallthrough
		 		case .UNCOMPRESSED_LENGTH:fallthrough
		 		case .UNHEX:fallthrough
		 		case .UNIX_TIMESTAMP:fallthrough
		 		case .UPDATEXML:fallthrough
		 		case .UPPER:fallthrough
		 		case .UUID:fallthrough
		 		case .UUID_SHORT:fallthrough
		 		case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 		case .VERSION:fallthrough
		 		case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 		case .WEEKDAY:fallthrough
		 		case .WEEKOFYEAR:fallthrough
		 		case .WEIGHT_STRING:fallthrough
		 		case .WITHIN:fallthrough
		 		case .YEARWEEK:fallthrough
		 		case .Y_FUNCTION:fallthrough
		 		case .X_FUNCTION:fallthrough
		 		case .MOD:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:fallthrough
		 		case .ID:
		 			setState(2957)
		 			try uidList()

		 			break

		 		case .ALL:
		 			setState(2958)
		 			try match(MySqlParser.Tokens.ALL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .REBUILD:
		 		_localctx =  AlterByRebuildPartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 12)
		 		setState(2961)
		 		try match(MySqlParser.Tokens.REBUILD.rawValue)
		 		setState(2962)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2965)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ARRAY:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .BUCKETS:fallthrough
		 		case .CONDITION:fallthrough
		 		case .CURRENT:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DIAGNOSTICS:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENFORCED:fallthrough
		 		case .EXCEPT:fallthrough
		 		case .GROUP:fallthrough
		 		case .IF:fallthrough
		 		case .IGNORED:fallthrough
		 		case .INSERT:fallthrough
		 		case .LATERAL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OPTIONAL:fallthrough
		 		case .ORDER:fallthrough
		 		case .PRIMARY:fallthrough
		 		case .REPEAT:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SKIP_QUERY_REWRITE:fallthrough
		 		case .STACKED:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .BINARY:fallthrough
		 		case .TEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .JSON_ARRAY:fallthrough
		 		case .JSON_ARRAYAGG:fallthrough
		 		case .JSON_ARRAY_APPEND:fallthrough
		 		case .JSON_ARRAY_INSERT:fallthrough
		 		case .JSON_CONTAINS:fallthrough
		 		case .JSON_CONTAINS_PATH:fallthrough
		 		case .JSON_DEPTH:fallthrough
		 		case .JSON_EXTRACT:fallthrough
		 		case .JSON_INSERT:fallthrough
		 		case .JSON_KEYS:fallthrough
		 		case .JSON_LENGTH:fallthrough
		 		case .JSON_MERGE:fallthrough
		 		case .JSON_MERGE_PATCH:fallthrough
		 		case .JSON_MERGE_PRESERVE:fallthrough
		 		case .JSON_OBJECT:fallthrough
		 		case .JSON_OBJECTAGG:fallthrough
		 		case .JSON_OVERLAPS:fallthrough
		 		case .JSON_PRETTY:fallthrough
		 		case .JSON_QUOTE:fallthrough
		 		case .JSON_REMOVE:fallthrough
		 		case .JSON_REPLACE:fallthrough
		 		case .JSON_SCHEMA_VALID:fallthrough
		 		case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 		case .JSON_SEARCH:fallthrough
		 		case .JSON_SET:fallthrough
		 		case .JSON_STORAGE_FREE:fallthrough
		 		case .JSON_STORAGE_SIZE:fallthrough
		 		case .JSON_TABLE:fallthrough
		 		case .JSON_TYPE:fallthrough
		 		case .JSON_UNQUOTE:fallthrough
		 		case .JSON_VALID:fallthrough
		 		case .JSON_VALUE:fallthrough
		 		case .NESTED:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .PATH:fallthrough
		 		case .AVG:fallthrough
		 		case .BIT_AND:fallthrough
		 		case .BIT_OR:fallthrough
		 		case .BIT_XOR:fallthrough
		 		case .COUNT:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .GROUP_CONCAT:fallthrough
		 		case .LAG:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NTH_VALUE:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .RANK:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .STD:fallthrough
		 		case .STDDEV:fallthrough
		 		case .STDDEV_POP:fallthrough
		 		case .STDDEV_SAMP:fallthrough
		 		case .SUM:fallthrough
		 		case .VAR_POP:fallthrough
		 		case .VAR_SAMP:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .CURRENT_DATE:fallthrough
		 		case .CURRENT_TIME:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .LOCALTIME:fallthrough
		 		case .CURDATE:fallthrough
		 		case .CURTIME:fallthrough
		 		case .DATE_ADD:fallthrough
		 		case .DATE_SUB:fallthrough
		 		case .LOCALTIMESTAMP:fallthrough
		 		case .NOW:fallthrough
		 		case .POSITION:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .SUBSTRING:fallthrough
		 		case .SYSDATE:fallthrough
		 		case .TRIM:fallthrough
		 		case .UTC_DATE:fallthrough
		 		case .UTC_TIME:fallthrough
		 		case .UTC_TIMESTAMP:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .ACTION:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALGORITHM:fallthrough
		 		case .ANY:fallthrough
		 		case .AT:fallthrough
		 		case .AUTHORS:fallthrough
		 		case .AUTOCOMMIT:fallthrough
		 		case .AUTOEXTEND_SIZE:fallthrough
		 		case .AUTO_INCREMENT:fallthrough
		 		case .AVG_ROW_LENGTH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .BIT:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BTREE:fallthrough
		 		case .CACHE:fallthrough
		 		case .CASCADED:fallthrough
		 		case .CHAIN:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .PAGE_CHECKSUM:fallthrough
		 		case .CIPHER:fallthrough
		 		case .CLASS_ORIGIN:fallthrough
		 		case .CLIENT:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTERING:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CODE:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COLUMN_FORMAT:fallthrough
		 		case .COLUMN_NAME:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMPACT:fallthrough
		 		case .COMPLETION:fallthrough
		 		case .COMPRESSED:fallthrough
		 		case .COMPRESSION:fallthrough
		 		case .CONCURRENT:fallthrough
		 		case .CONNECT:fallthrough
		 		case .CONNECTION:fallthrough
		 		case .CONSISTENT:fallthrough
		 		case .CONSTRAINT_CATALOG:fallthrough
		 		case .CONSTRAINT_SCHEMA:fallthrough
		 		case .CONSTRAINT_NAME:fallthrough
		 		case .CONTAINS:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTRIBUTORS:fallthrough
		 		case .COPY:fallthrough
		 		case .CPU:fallthrough
		 		case .CURSOR_NAME:fallthrough
		 		case .DATA:fallthrough
		 		case .DATAFILE:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DEFAULT_AUTH:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DELAY_KEY_WRITE:fallthrough
		 		case .DES_KEY_FILE:fallthrough
		 		case .DIRECTORY:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISCARD:fallthrough
		 		case .DISK:fallthrough
		 		case .DO:fallthrough
		 		case .DUMPFILE:fallthrough
		 		case .DUPLICATE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .END:fallthrough
		 		case .ENDS:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ENGINES:fallthrough
		 		case .ERROR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVEN:fallthrough
		 		case .EVENT:fallthrough
		 		case .EVENTS:fallthrough
		 		case .EVERY:fallthrough
		 		case .EXCHANGE:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPIRE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .EXTENT_SIZE:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FAST:fallthrough
		 		case .FAULTS:fallthrough
		 		case .FIELDS:fallthrough
		 		case .FILE_BLOCK_SIZE:fallthrough
		 		case .FILTER:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIXED:fallthrough
		 		case .FLUSH:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FOUND:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GENERAL:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GRANTS:fallthrough
		 		case .GROUP_REPLICATION:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HASH:fallthrough
		 		case .HELP:fallthrough
		 		case .HISTORY:fallthrough
		 		case .HOST:fallthrough
		 		case .HOSTS:fallthrough
		 		case .IDENTIFIED:fallthrough
		 		case .IGNORE_SERVER_IDS:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INDEXES:fallthrough
		 		case .INITIAL_SIZE:fallthrough
		 		case .INPLACE:fallthrough
		 		case .INSERT_METHOD:fallthrough
		 		case .INSTALL:fallthrough
		 		case .INSTANCE:fallthrough
		 		case .INSTANT:fallthrough
		 		case .INVISIBLE:fallthrough
		 		case .INVOKER:fallthrough
		 		case .IO:fallthrough
		 		case .IO_THREAD:fallthrough
		 		case .IPC:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ISSUER:fallthrough
		 		case .JSON:fallthrough
		 		case .KEY_BLOCK_SIZE:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LEAVES:fallthrough
		 		case .LESS:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOGFILE:fallthrough
		 		case .LOGS:fallthrough
		 		case .MASTER:fallthrough
		 		case .MASTER_AUTO_POSITION:fallthrough
		 		case .MASTER_CONNECT_RETRY:fallthrough
		 		case .MASTER_DELAY:fallthrough
		 		case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 		case .MASTER_HOST:fallthrough
		 		case .MASTER_LOG_FILE:fallthrough
		 		case .MASTER_LOG_POS:fallthrough
		 		case .MASTER_PASSWORD:fallthrough
		 		case .MASTER_PORT:fallthrough
		 		case .MASTER_RETRY_COUNT:fallthrough
		 		case .MASTER_SSL:fallthrough
		 		case .MASTER_SSL_CA:fallthrough
		 		case .MASTER_SSL_CAPATH:fallthrough
		 		case .MASTER_SSL_CERT:fallthrough
		 		case .MASTER_SSL_CIPHER:fallthrough
		 		case .MASTER_SSL_CRL:fallthrough
		 		case .MASTER_SSL_CRLPATH:fallthrough
		 		case .MASTER_SSL_KEY:fallthrough
		 		case .MASTER_TLS_VERSION:fallthrough
		 		case .MASTER_USER:fallthrough
		 		case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 		case .MAX_QUERIES_PER_HOUR:fallthrough
		 		case .MAX_ROWS:fallthrough
		 		case .MAX_SIZE:fallthrough
		 		case .MAX_UPDATES_PER_HOUR:fallthrough
		 		case .MAX_USER_CONNECTIONS:fallthrough
		 		case .MEDIUM:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MESSAGE_TEXT:fallthrough
		 		case .MID:fallthrough
		 		case .MIGRATE:fallthrough
		 		case .MIN_ROWS:fallthrough
		 		case .MODE:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MUTEX:fallthrough
		 		case .MYSQL:fallthrough
		 		case .MYSQL_ERRNO:fallthrough
		 		case .NAME:fallthrough
		 		case .NAMES:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NEVER:fallthrough
		 		case .NEXT:fallthrough
		 		case .NO:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOWAIT:fallthrough
		 		case .NODEGROUP:fallthrough
		 		case .NONE:fallthrough
		 		case .ODBC:fallthrough
		 		case .OFFLINE:fallthrough
		 		case .OFFSET:fallthrough
		 		case .OF:fallthrough
		 		case .OJ:fallthrough
		 		case .OLD_PASSWORD:fallthrough
		 		case .ONE:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .OPTIMIZER_COSTS:fallthrough
		 		case .OPTIONS:fallthrough
		 		case .OWNER:fallthrough
		 		case .PACK_KEYS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PARSER:fallthrough
		 		case .PARTIAL:fallthrough
		 		case .PARTITIONING:fallthrough
		 		case .PARTITIONS:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PHASE:fallthrough
		 		case .PLUGIN:fallthrough
		 		case .PLUGIN_DIR:fallthrough
		 		case .PLUGINS:fallthrough
		 		case .PORT:fallthrough
		 		case .PRECEDES:fallthrough
		 		case .PREPARE:fallthrough
		 		case .PRESERVE:fallthrough
		 		case .PREV:fallthrough
		 		case .PROCESSLIST:fallthrough
		 		case .PROFILE:fallthrough
		 		case .PROFILES:fallthrough
		 		case .PROXY:fallthrough
		 		case .QUERY:fallthrough
		 		case .QUICK:fallthrough
		 		case .REBUILD:fallthrough
		 		case .RECOVER:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REDO_BUFFER_SIZE:fallthrough
		 		case .REDUNDANT:fallthrough
		 		case .RELAY:fallthrough
		 		case .RELAY_LOG_FILE:fallthrough
		 		case .RELAY_LOG_POS:fallthrough
		 		case .RELAYLOG:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REORGANIZE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .REPLICATE_DO_DB:fallthrough
		 		case .REPLICATE_DO_TABLE:fallthrough
		 		case .REPLICATE_IGNORE_DB:fallthrough
		 		case .REPLICATE_IGNORE_TABLE:fallthrough
		 		case .REPLICATE_REWRITE_DB:fallthrough
		 		case .REPLICATE_WILD_DO_TABLE:fallthrough
		 		case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 		case .REPLICATION:fallthrough
		 		case .RESET:fallthrough
		 		case .RESUME:fallthrough
		 		case .RETURNED_SQLSTATE:fallthrough
		 		case .RETURNING:fallthrough
		 		case .RETURNS:fallthrough
		 		case .REUSE:fallthrough
		 		case .ROLE:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROTATE:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_FORMAT:fallthrough
		 		case .RTREE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEDULE:fallthrough
		 		case .SECURITY:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION:fallthrough
		 		case .SHARE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SIGNED:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SLAVE:fallthrough
		 		case .SLOW:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOCKET:fallthrough
		 		case .SOME:fallthrough
		 		case .SONAME:fallthrough
		 		case .SOUNDS:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SQL_AFTER_GTIDS:fallthrough
		 		case .SQL_AFTER_MTS_GAPS:fallthrough
		 		case .SQL_BEFORE_GTIDS:fallthrough
		 		case .SQL_BUFFER_RESULT:fallthrough
		 		case .SQL_CACHE:fallthrough
		 		case .SQL_NO_CACHE:fallthrough
		 		case .SQL_THREAD:fallthrough
		 		case .START:fallthrough
		 		case .STARTS:fallthrough
		 		case .STATS_AUTO_RECALC:fallthrough
		 		case .STATS_PERSISTENT:fallthrough
		 		case .STATS_SAMPLE_PAGES:fallthrough
		 		case .STATUS:fallthrough
		 		case .STOP:fallthrough
		 		case .STORAGE:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBCLASS_ORIGIN:fallthrough
		 		case .SUBJECT:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBPARTITIONS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .SWAPS:fallthrough
		 		case .SWITCHES:fallthrough
		 		case .TABLE_NAME:fallthrough
		 		case .TABLESPACE:fallthrough
		 		case .TABLE_TYPE:fallthrough
		 		case .TEMPORARY:fallthrough
		 		case .TEMPTABLE:fallthrough
		 		case .THAN:fallthrough
		 		case .TRADITIONAL:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSACTIONAL:fallthrough
		 		case .TRIGGERS:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDEFINED:fallthrough
		 		case .UNDOFILE:fallthrough
		 		case .UNDO_BUFFER_SIZE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPGRADE:fallthrough
		 		case .USER:fallthrough
		 		case .USE_FRM:fallthrough
		 		case .USER_RESOURCES:fallthrough
		 		case .VALIDATION:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARIABLES:fallthrough
		 		case .VIEW:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .VISIBLE:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNINGS:fallthrough
		 		case .WITHOUT:fallthrough
		 		case .WORK:fallthrough
		 		case .WRAPPER:fallthrough
		 		case .X509:fallthrough
		 		case .XA:fallthrough
		 		case .XML:fallthrough
		 		case .EUR:fallthrough
		 		case .USA:fallthrough
		 		case .JIS:fallthrough
		 		case .ISO:fallthrough
		 		case .INTERNAL:fallthrough
		 		case .QUARTER:fallthrough
		 		case .MONTH:fallthrough
		 		case .DAY:fallthrough
		 		case .HOUR:fallthrough
		 		case .MINUTE:fallthrough
		 		case .WEEK:fallthrough
		 		case .SECOND:fallthrough
		 		case .MICROSECOND:fallthrough
		 		case .ADMIN:fallthrough
		 		case .AUDIT_ABORT_EXEMPT:fallthrough
		 		case .AUDIT_ADMIN:fallthrough
		 		case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 		case .BACKUP_ADMIN:fallthrough
		 		case .BINLOG_ADMIN:fallthrough
		 		case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 		case .CLONE_ADMIN:fallthrough
		 		case .CONNECTION_ADMIN:fallthrough
		 		case .ENCRYPTION_KEY_ADMIN:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .FILE:fallthrough
		 		case .FIREWALL_ADMIN:fallthrough
		 		case .FIREWALL_EXEMPT:fallthrough
		 		case .FIREWALL_USER:fallthrough
		 		case .GROUP_REPLICATION_ADMIN:fallthrough
		 		case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 		case .INVOKE:fallthrough
		 		case .LAMBDA:fallthrough
		 		case .NDB_STORED_USER:fallthrough
		 		case .PASSWORDLESS_USER_ADMIN:fallthrough
		 		case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .PROCESS:fallthrough
		 		case .RELOAD:fallthrough
		 		case .REPLICATION_APPLIER:fallthrough
		 		case .REPLICATION_SLAVE_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_USER:fallthrough
		 		case .ROLE_ADMIN:fallthrough
		 		case .ROUTINE:fallthrough
		 		case .S3:fallthrough
		 		case .SESSION_VARIABLES_ADMIN:fallthrough
		 		case .SET_USER_ID:fallthrough
		 		case .SHOW_ROUTINE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SUPER:fallthrough
		 		case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 		case .TABLES:fallthrough
		 		case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 		case .VERSION_TOKEN_ADMIN:fallthrough
		 		case .XA_RECOVER_ADMIN:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .ARCHIVE:fallthrough
		 		case .BLACKHOLE:fallthrough
		 		case .CSV:fallthrough
		 		case .FEDERATED:fallthrough
		 		case .INNODB:fallthrough
		 		case .MEMORY:fallthrough
		 		case .MRG_MYISAM:fallthrough
		 		case .MYISAM:fallthrough
		 		case .NDB:fallthrough
		 		case .NDBCLUSTER:fallthrough
		 		case .PERFORMANCE_SCHEMA:fallthrough
		 		case .TOKUDB:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:fallthrough
		 		case .ABS:fallthrough
		 		case .ACOS:fallthrough
		 		case .ADDDATE:fallthrough
		 		case .ADDTIME:fallthrough
		 		case .AES_DECRYPT:fallthrough
		 		case .AES_ENCRYPT:fallthrough
		 		case .AREA:fallthrough
		 		case .ASBINARY:fallthrough
		 		case .ASIN:fallthrough
		 		case .ASTEXT:fallthrough
		 		case .ASWKB:fallthrough
		 		case .ASWKT:fallthrough
		 		case .ASYMMETRIC_DECRYPT:fallthrough
		 		case .ASYMMETRIC_DERIVE:fallthrough
		 		case .ASYMMETRIC_ENCRYPT:fallthrough
		 		case .ASYMMETRIC_SIGN:fallthrough
		 		case .ASYMMETRIC_VERIFY:fallthrough
		 		case .ATAN:fallthrough
		 		case .ATAN2:fallthrough
		 		case .BENCHMARK:fallthrough
		 		case .BIN:fallthrough
		 		case .BIT_COUNT:fallthrough
		 		case .BIT_LENGTH:fallthrough
		 		case .BUFFER:fallthrough
		 		case .CATALOG_NAME:fallthrough
		 		case .CEIL:fallthrough
		 		case .CEILING:fallthrough
		 		case .CENTROID:fallthrough
		 		case .CHARACTER_LENGTH:fallthrough
		 		case .CHARSET:fallthrough
		 		case .CHAR_LENGTH:fallthrough
		 		case .COERCIBILITY:fallthrough
		 		case .COLLATION:fallthrough
		 		case .COMPRESS:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_WS:fallthrough
		 		case .CONNECTION_ID:fallthrough
		 		case .CONV:fallthrough
		 		case .CONVERT_TZ:fallthrough
		 		case .COS:fallthrough
		 		case .COT:fallthrough
		 		case .CRC32:fallthrough
		 		case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 		case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 		case .CREATE_DH_PARAMETERS:fallthrough
		 		case .CREATE_DIGEST:fallthrough
		 		case .CROSSES:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATE_FORMAT:fallthrough
		 		case .DAYNAME:fallthrough
		 		case .DAYOFMONTH:fallthrough
		 		case .DAYOFWEEK:fallthrough
		 		case .DAYOFYEAR:fallthrough
		 		case .DECODE:fallthrough
		 		case .DEGREES:fallthrough
		 		case .DES_DECRYPT:fallthrough
		 		case .DES_ENCRYPT:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISJOINT:fallthrough
		 		case .ELT:fallthrough
		 		case .ENCODE:fallthrough
		 		case .ENCRYPT:fallthrough
		 		case .ENDPOINT:fallthrough
		 		case .ENGINE_ATTRIBUTE:fallthrough
		 		case .ENVELOPE:fallthrough
		 		case .EQUALS:fallthrough
		 		case .EXP:fallthrough
		 		case .EXPORT_SET:fallthrough
		 		case .EXTERIORRING:fallthrough
		 		case .EXTRACTVALUE:fallthrough
		 		case .FIELD:fallthrough
		 		case .FIND_IN_SET:fallthrough
		 		case .FLOOR:fallthrough
		 		case .FORMAT:fallthrough
		 		case .FOUND_ROWS:fallthrough
		 		case .FROM_BASE64:fallthrough
		 		case .FROM_DAYS:fallthrough
		 		case .FROM_UNIXTIME:fallthrough
		 		case .GEOMCOLLFROMTEXT:fallthrough
		 		case .GEOMCOLLFROMWKB:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .GEOMETRYFROMTEXT:fallthrough
		 		case .GEOMETRYFROMWKB:fallthrough
		 		case .GEOMETRYN:fallthrough
		 		case .GEOMETRYTYPE:fallthrough
		 		case .GEOMFROMTEXT:fallthrough
		 		case .GEOMFROMWKB:fallthrough
		 		case .GET_FORMAT:fallthrough
		 		case .GET_LOCK:fallthrough
		 		case .GLENGTH:fallthrough
		 		case .GREATEST:fallthrough
		 		case .GTID_SUBSET:fallthrough
		 		case .GTID_SUBTRACT:fallthrough
		 		case .HEX:fallthrough
		 		case .IFNULL:fallthrough
		 		case .INET6_ATON:fallthrough
		 		case .INET6_NTOA:fallthrough
		 		case .INET_ATON:fallthrough
		 		case .INET_NTOA:fallthrough
		 		case .INSTR:fallthrough
		 		case .INTERIORRINGN:fallthrough
		 		case .INTERSECTS:fallthrough
		 		case .ISCLOSED:fallthrough
		 		case .ISEMPTY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .ISSIMPLE:fallthrough
		 		case .IS_FREE_LOCK:fallthrough
		 		case .IS_IPV4:fallthrough
		 		case .IS_IPV4_COMPAT:fallthrough
		 		case .IS_IPV4_MAPPED:fallthrough
		 		case .IS_IPV6:fallthrough
		 		case .IS_USED_LOCK:fallthrough
		 		case .LAST_INSERT_ID:fallthrough
		 		case .LCASE:fallthrough
		 		case .LEAST:fallthrough
		 		case .LENGTH:fallthrough
		 		case .LINEFROMTEXT:fallthrough
		 		case .LINEFROMWKB:fallthrough
		 		case .LINESTRINGFROMTEXT:fallthrough
		 		case .LINESTRINGFROMWKB:fallthrough
		 		case .LN:fallthrough
		 		case .LOAD_FILE:fallthrough
		 		case .LOCATE:fallthrough
		 		case .LOG:fallthrough
		 		case .LOG10:fallthrough
		 		case .LOG2:fallthrough
		 		case .LOWER:fallthrough
		 		case .LPAD:fallthrough
		 		case .LTRIM:fallthrough
		 		case .MAKEDATE:fallthrough
		 		case .MAKETIME:fallthrough
		 		case .MAKE_SET:fallthrough
		 		case .MASTER_POS_WAIT:fallthrough
		 		case .MBRCONTAINS:fallthrough
		 		case .MBRDISJOINT:fallthrough
		 		case .MBREQUAL:fallthrough
		 		case .MBRINTERSECTS:fallthrough
		 		case .MBROVERLAPS:fallthrough
		 		case .MBRTOUCHES:fallthrough
		 		case .MBRWITHIN:fallthrough
		 		case .MD5:fallthrough
		 		case .MLINEFROMTEXT:fallthrough
		 		case .MLINEFROMWKB:fallthrough
		 		case .MONTHNAME:fallthrough
		 		case .MPOINTFROMTEXT:fallthrough
		 		case .MPOINTFROMWKB:fallthrough
		 		case .MPOLYFROMTEXT:fallthrough
		 		case .MPOLYFROMWKB:fallthrough
		 		case .MULTILINESTRINGFROMTEXT:fallthrough
		 		case .MULTILINESTRINGFROMWKB:fallthrough
		 		case .MULTIPOINTFROMTEXT:fallthrough
		 		case .MULTIPOINTFROMWKB:fallthrough
		 		case .MULTIPOLYGONFROMTEXT:fallthrough
		 		case .MULTIPOLYGONFROMWKB:fallthrough
		 		case .NAME_CONST:fallthrough
		 		case .NULLIF:fallthrough
		 		case .NUMGEOMETRIES:fallthrough
		 		case .NUMINTERIORRINGS:fallthrough
		 		case .NUMPOINTS:fallthrough
		 		case .OCT:fallthrough
		 		case .OCTET_LENGTH:fallthrough
		 		case .ORD:fallthrough
		 		case .OVERLAPS:fallthrough
		 		case .PERIOD_ADD:fallthrough
		 		case .PERIOD_DIFF:fallthrough
		 		case .PI:fallthrough
		 		case .POINTFROMTEXT:fallthrough
		 		case .POINTFROMWKB:fallthrough
		 		case .POINTN:fallthrough
		 		case .POLYFROMTEXT:fallthrough
		 		case .POLYFROMWKB:fallthrough
		 		case .POLYGONFROMTEXT:fallthrough
		 		case .POLYGONFROMWKB:fallthrough
		 		case .POW:fallthrough
		 		case .POWER:fallthrough
		 		case .QUOTE:fallthrough
		 		case .RADIANS:fallthrough
		 		case .RAND:fallthrough
		 		case .RANDOM:fallthrough
		 		case .RANDOM_BYTES:fallthrough
		 		case .RELEASE_LOCK:fallthrough
		 		case .REVERSE:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_COUNT:fallthrough
		 		case .RPAD:fallthrough
		 		case .RTRIM:fallthrough
		 		case .SEC_TO_TIME:fallthrough
		 		case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SHA:fallthrough
		 		case .SHA1:fallthrough
		 		case .SHA2:fallthrough
		 		case .SCHEMA_NAME:fallthrough
		 		case .SIGN:fallthrough
		 		case .SIN:fallthrough
		 		case .SLEEP:fallthrough
		 		case .SOUNDEX:fallthrough
		 		case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 		case .SQRT:fallthrough
		 		case .SRID:fallthrough
		 		case .STARTPOINT:fallthrough
		 		case .STRCMP:fallthrough
		 		case .STR_TO_DATE:fallthrough
		 		case .ST_AREA:fallthrough
		 		case .ST_ASBINARY:fallthrough
		 		case .ST_ASTEXT:fallthrough
		 		case .ST_ASWKB:fallthrough
		 		case .ST_ASWKT:fallthrough
		 		case .ST_BUFFER:fallthrough
		 		case .ST_CENTROID:fallthrough
		 		case .ST_CONTAINS:fallthrough
		 		case .ST_CROSSES:fallthrough
		 		case .ST_DIFFERENCE:fallthrough
		 		case .ST_DIMENSION:fallthrough
		 		case .ST_DISJOINT:fallthrough
		 		case .ST_DISTANCE:fallthrough
		 		case .ST_ENDPOINT:fallthrough
		 		case .ST_ENVELOPE:fallthrough
		 		case .ST_EQUALS:fallthrough
		 		case .ST_EXTERIORRING:fallthrough
		 		case .ST_GEOMCOLLFROMTEXT:fallthrough
		 		case .ST_GEOMCOLLFROMTXT:fallthrough
		 		case .ST_GEOMCOLLFROMWKB:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .ST_GEOMETRYFROMTEXT:fallthrough
		 		case .ST_GEOMETRYFROMWKB:fallthrough
		 		case .ST_GEOMETRYN:fallthrough
		 		case .ST_GEOMETRYTYPE:fallthrough
		 		case .ST_GEOMFROMTEXT:fallthrough
		 		case .ST_GEOMFROMWKB:fallthrough
		 		case .ST_INTERIORRINGN:fallthrough
		 		case .ST_INTERSECTION:fallthrough
		 		case .ST_INTERSECTS:fallthrough
		 		case .ST_ISCLOSED:fallthrough
		 		case .ST_ISEMPTY:fallthrough
		 		case .ST_ISSIMPLE:fallthrough
		 		case .ST_LINEFROMTEXT:fallthrough
		 		case .ST_LINEFROMWKB:fallthrough
		 		case .ST_LINESTRINGFROMTEXT:fallthrough
		 		case .ST_LINESTRINGFROMWKB:fallthrough
		 		case .ST_NUMGEOMETRIES:fallthrough
		 		case .ST_NUMINTERIORRING:fallthrough
		 		case .ST_NUMINTERIORRINGS:fallthrough
		 		case .ST_NUMPOINTS:fallthrough
		 		case .ST_OVERLAPS:fallthrough
		 		case .ST_POINTFROMTEXT:fallthrough
		 		case .ST_POINTFROMWKB:fallthrough
		 		case .ST_POINTN:fallthrough
		 		case .ST_POLYFROMTEXT:fallthrough
		 		case .ST_POLYFROMWKB:fallthrough
		 		case .ST_POLYGONFROMTEXT:fallthrough
		 		case .ST_POLYGONFROMWKB:fallthrough
		 		case .ST_SRID:fallthrough
		 		case .ST_STARTPOINT:fallthrough
		 		case .ST_SYMDIFFERENCE:fallthrough
		 		case .ST_TOUCHES:fallthrough
		 		case .ST_UNION:fallthrough
		 		case .ST_WITHIN:fallthrough
		 		case .ST_X:fallthrough
		 		case .ST_Y:fallthrough
		 		case .SUBDATE:fallthrough
		 		case .SUBSTRING_INDEX:fallthrough
		 		case .SUBTIME:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TAN:fallthrough
		 		case .TIMEDIFF:fallthrough
		 		case .TIMESTAMPADD:fallthrough
		 		case .TIMESTAMPDIFF:fallthrough
		 		case .TIME_FORMAT:fallthrough
		 		case .TIME_TO_SEC:fallthrough
		 		case .TOUCHES:fallthrough
		 		case .TO_BASE64:fallthrough
		 		case .TO_DAYS:fallthrough
		 		case .TO_SECONDS:fallthrough
		 		case .TP_CONNECTION_ADMIN:fallthrough
		 		case .UCASE:fallthrough
		 		case .UNCOMPRESS:fallthrough
		 		case .UNCOMPRESSED_LENGTH:fallthrough
		 		case .UNHEX:fallthrough
		 		case .UNIX_TIMESTAMP:fallthrough
		 		case .UPDATEXML:fallthrough
		 		case .UPPER:fallthrough
		 		case .UUID:fallthrough
		 		case .UUID_SHORT:fallthrough
		 		case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 		case .VERSION:fallthrough
		 		case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 		case .WEEKDAY:fallthrough
		 		case .WEEKOFYEAR:fallthrough
		 		case .WEIGHT_STRING:fallthrough
		 		case .WITHIN:fallthrough
		 		case .YEARWEEK:fallthrough
		 		case .Y_FUNCTION:fallthrough
		 		case .X_FUNCTION:fallthrough
		 		case .MOD:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:fallthrough
		 		case .ID:
		 			setState(2963)
		 			try uidList()

		 			break

		 		case .ALL:
		 			setState(2964)
		 			try match(MySqlParser.Tokens.ALL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .REPAIR:
		 		_localctx =  AlterByRepairPartitionContext(_localctx);
		 		try enterOuterAlt(_localctx, 13)
		 		setState(2967)
		 		try match(MySqlParser.Tokens.REPAIR.rawValue)
		 		setState(2968)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(2971)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ARRAY:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .BUCKETS:fallthrough
		 		case .CONDITION:fallthrough
		 		case .CURRENT:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DIAGNOSTICS:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENFORCED:fallthrough
		 		case .EXCEPT:fallthrough
		 		case .GROUP:fallthrough
		 		case .IF:fallthrough
		 		case .IGNORED:fallthrough
		 		case .INSERT:fallthrough
		 		case .LATERAL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OPTIONAL:fallthrough
		 		case .ORDER:fallthrough
		 		case .PRIMARY:fallthrough
		 		case .REPEAT:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SKIP_QUERY_REWRITE:fallthrough
		 		case .STACKED:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .BINARY:fallthrough
		 		case .TEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .JSON_ARRAY:fallthrough
		 		case .JSON_ARRAYAGG:fallthrough
		 		case .JSON_ARRAY_APPEND:fallthrough
		 		case .JSON_ARRAY_INSERT:fallthrough
		 		case .JSON_CONTAINS:fallthrough
		 		case .JSON_CONTAINS_PATH:fallthrough
		 		case .JSON_DEPTH:fallthrough
		 		case .JSON_EXTRACT:fallthrough
		 		case .JSON_INSERT:fallthrough
		 		case .JSON_KEYS:fallthrough
		 		case .JSON_LENGTH:fallthrough
		 		case .JSON_MERGE:fallthrough
		 		case .JSON_MERGE_PATCH:fallthrough
		 		case .JSON_MERGE_PRESERVE:fallthrough
		 		case .JSON_OBJECT:fallthrough
		 		case .JSON_OBJECTAGG:fallthrough
		 		case .JSON_OVERLAPS:fallthrough
		 		case .JSON_PRETTY:fallthrough
		 		case .JSON_QUOTE:fallthrough
		 		case .JSON_REMOVE:fallthrough
		 		case .JSON_REPLACE:fallthrough
		 		case .JSON_SCHEMA_VALID:fallthrough
		 		case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 		case .JSON_SEARCH:fallthrough
		 		case .JSON_SET:fallthrough
		 		case .JSON_STORAGE_FREE:fallthrough
		 		case .JSON_STORAGE_SIZE:fallthrough
		 		case .JSON_TABLE:fallthrough
		 		case .JSON_TYPE:fallthrough
		 		case .JSON_UNQUOTE:fallthrough
		 		case .JSON_VALID:fallthrough
		 		case .JSON_VALUE:fallthrough
		 		case .NESTED:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .PATH:fallthrough
		 		case .AVG:fallthrough
		 		case .BIT_AND:fallthrough
		 		case .BIT_OR:fallthrough
		 		case .BIT_XOR:fallthrough
		 		case .COUNT:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .GROUP_CONCAT:fallthrough
		 		case .LAG:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NTH_VALUE:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .RANK:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .STD:fallthrough
		 		case .STDDEV:fallthrough
		 		case .STDDEV_POP:fallthrough
		 		case .STDDEV_SAMP:fallthrough
		 		case .SUM:fallthrough
		 		case .VAR_POP:fallthrough
		 		case .VAR_SAMP:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .CURRENT_DATE:fallthrough
		 		case .CURRENT_TIME:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .LOCALTIME:fallthrough
		 		case .CURDATE:fallthrough
		 		case .CURTIME:fallthrough
		 		case .DATE_ADD:fallthrough
		 		case .DATE_SUB:fallthrough
		 		case .LOCALTIMESTAMP:fallthrough
		 		case .NOW:fallthrough
		 		case .POSITION:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .SUBSTRING:fallthrough
		 		case .SYSDATE:fallthrough
		 		case .TRIM:fallthrough
		 		case .UTC_DATE:fallthrough
		 		case .UTC_TIME:fallthrough
		 		case .UTC_TIMESTAMP:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .ACTION:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALGORITHM:fallthrough
		 		case .ANY:fallthrough
		 		case .AT:fallthrough
		 		case .AUTHORS:fallthrough
		 		case .AUTOCOMMIT:fallthrough
		 		case .AUTOEXTEND_SIZE:fallthrough
		 		case .AUTO_INCREMENT:fallthrough
		 		case .AVG_ROW_LENGTH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .BIT:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BTREE:fallthrough
		 		case .CACHE:fallthrough
		 		case .CASCADED:fallthrough
		 		case .CHAIN:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .PAGE_CHECKSUM:fallthrough
		 		case .CIPHER:fallthrough
		 		case .CLASS_ORIGIN:fallthrough
		 		case .CLIENT:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTERING:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CODE:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COLUMN_FORMAT:fallthrough
		 		case .COLUMN_NAME:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMPACT:fallthrough
		 		case .COMPLETION:fallthrough
		 		case .COMPRESSED:fallthrough
		 		case .COMPRESSION:fallthrough
		 		case .CONCURRENT:fallthrough
		 		case .CONNECT:fallthrough
		 		case .CONNECTION:fallthrough
		 		case .CONSISTENT:fallthrough
		 		case .CONSTRAINT_CATALOG:fallthrough
		 		case .CONSTRAINT_SCHEMA:fallthrough
		 		case .CONSTRAINT_NAME:fallthrough
		 		case .CONTAINS:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTRIBUTORS:fallthrough
		 		case .COPY:fallthrough
		 		case .CPU:fallthrough
		 		case .CURSOR_NAME:fallthrough
		 		case .DATA:fallthrough
		 		case .DATAFILE:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DEFAULT_AUTH:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DELAY_KEY_WRITE:fallthrough
		 		case .DES_KEY_FILE:fallthrough
		 		case .DIRECTORY:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISCARD:fallthrough
		 		case .DISK:fallthrough
		 		case .DO:fallthrough
		 		case .DUMPFILE:fallthrough
		 		case .DUPLICATE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .END:fallthrough
		 		case .ENDS:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ENGINES:fallthrough
		 		case .ERROR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVEN:fallthrough
		 		case .EVENT:fallthrough
		 		case .EVENTS:fallthrough
		 		case .EVERY:fallthrough
		 		case .EXCHANGE:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPIRE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .EXTENT_SIZE:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FAST:fallthrough
		 		case .FAULTS:fallthrough
		 		case .FIELDS:fallthrough
		 		case .FILE_BLOCK_SIZE:fallthrough
		 		case .FILTER:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIXED:fallthrough
		 		case .FLUSH:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FOUND:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GENERAL:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GRANTS:fallthrough
		 		case .GROUP_REPLICATION:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HASH:fallthrough
		 		case .HELP:fallthrough
		 		case .HISTORY:fallthrough
		 		case .HOST:fallthrough
		 		case .HOSTS:fallthrough
		 		case .IDENTIFIED:fallthrough
		 		case .IGNORE_SERVER_IDS:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INDEXES:fallthrough
		 		case .INITIAL_SIZE:fallthrough
		 		case .INPLACE:fallthrough
		 		case .INSERT_METHOD:fallthrough
		 		case .INSTALL:fallthrough
		 		case .INSTANCE:fallthrough
		 		case .INSTANT:fallthrough
		 		case .INVISIBLE:fallthrough
		 		case .INVOKER:fallthrough
		 		case .IO:fallthrough
		 		case .IO_THREAD:fallthrough
		 		case .IPC:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ISSUER:fallthrough
		 		case .JSON:fallthrough
		 		case .KEY_BLOCK_SIZE:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LEAVES:fallthrough
		 		case .LESS:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOGFILE:fallthrough
		 		case .LOGS:fallthrough
		 		case .MASTER:fallthrough
		 		case .MASTER_AUTO_POSITION:fallthrough
		 		case .MASTER_CONNECT_RETRY:fallthrough
		 		case .MASTER_DELAY:fallthrough
		 		case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 		case .MASTER_HOST:fallthrough
		 		case .MASTER_LOG_FILE:fallthrough
		 		case .MASTER_LOG_POS:fallthrough
		 		case .MASTER_PASSWORD:fallthrough
		 		case .MASTER_PORT:fallthrough
		 		case .MASTER_RETRY_COUNT:fallthrough
		 		case .MASTER_SSL:fallthrough
		 		case .MASTER_SSL_CA:fallthrough
		 		case .MASTER_SSL_CAPATH:fallthrough
		 		case .MASTER_SSL_CERT:fallthrough
		 		case .MASTER_SSL_CIPHER:fallthrough
		 		case .MASTER_SSL_CRL:fallthrough
		 		case .MASTER_SSL_CRLPATH:fallthrough
		 		case .MASTER_SSL_KEY:fallthrough
		 		case .MASTER_TLS_VERSION:fallthrough
		 		case .MASTER_USER:fallthrough
		 		case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 		case .MAX_QUERIES_PER_HOUR:fallthrough
		 		case .MAX_ROWS:fallthrough
		 		case .MAX_SIZE:fallthrough
		 		case .MAX_UPDATES_PER_HOUR:fallthrough
		 		case .MAX_USER_CONNECTIONS:fallthrough
		 		case .MEDIUM:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MESSAGE_TEXT:fallthrough
		 		case .MID:fallthrough
		 		case .MIGRATE:fallthrough
		 		case .MIN_ROWS:fallthrough
		 		case .MODE:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MUTEX:fallthrough
		 		case .MYSQL:fallthrough
		 		case .MYSQL_ERRNO:fallthrough
		 		case .NAME:fallthrough
		 		case .NAMES:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NEVER:fallthrough
		 		case .NEXT:fallthrough
		 		case .NO:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOWAIT:fallthrough
		 		case .NODEGROUP:fallthrough
		 		case .NONE:fallthrough
		 		case .ODBC:fallthrough
		 		case .OFFLINE:fallthrough
		 		case .OFFSET:fallthrough
		 		case .OF:fallthrough
		 		case .OJ:fallthrough
		 		case .OLD_PASSWORD:fallthrough
		 		case .ONE:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .OPTIMIZER_COSTS:fallthrough
		 		case .OPTIONS:fallthrough
		 		case .OWNER:fallthrough
		 		case .PACK_KEYS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PARSER:fallthrough
		 		case .PARTIAL:fallthrough
		 		case .PARTITIONING:fallthrough
		 		case .PARTITIONS:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PHASE:fallthrough
		 		case .PLUGIN:fallthrough
		 		case .PLUGIN_DIR:fallthrough
		 		case .PLUGINS:fallthrough
		 		case .PORT:fallthrough
		 		case .PRECEDES:fallthrough
		 		case .PREPARE:fallthrough
		 		case .PRESERVE:fallthrough
		 		case .PREV:fallthrough
		 		case .PROCESSLIST:fallthrough
		 		case .PROFILE:fallthrough
		 		case .PROFILES:fallthrough
		 		case .PROXY:fallthrough
		 		case .QUERY:fallthrough
		 		case .QUICK:fallthrough
		 		case .REBUILD:fallthrough
		 		case .RECOVER:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REDO_BUFFER_SIZE:fallthrough
		 		case .REDUNDANT:fallthrough
		 		case .RELAY:fallthrough
		 		case .RELAY_LOG_FILE:fallthrough
		 		case .RELAY_LOG_POS:fallthrough
		 		case .RELAYLOG:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REORGANIZE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .REPLICATE_DO_DB:fallthrough
		 		case .REPLICATE_DO_TABLE:fallthrough
		 		case .REPLICATE_IGNORE_DB:fallthrough
		 		case .REPLICATE_IGNORE_TABLE:fallthrough
		 		case .REPLICATE_REWRITE_DB:fallthrough
		 		case .REPLICATE_WILD_DO_TABLE:fallthrough
		 		case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 		case .REPLICATION:fallthrough
		 		case .RESET:fallthrough
		 		case .RESUME:fallthrough
		 		case .RETURNED_SQLSTATE:fallthrough
		 		case .RETURNING:fallthrough
		 		case .RETURNS:fallthrough
		 		case .REUSE:fallthrough
		 		case .ROLE:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROTATE:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_FORMAT:fallthrough
		 		case .RTREE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEDULE:fallthrough
		 		case .SECURITY:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION:fallthrough
		 		case .SHARE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SIGNED:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SLAVE:fallthrough
		 		case .SLOW:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOCKET:fallthrough
		 		case .SOME:fallthrough
		 		case .SONAME:fallthrough
		 		case .SOUNDS:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SQL_AFTER_GTIDS:fallthrough
		 		case .SQL_AFTER_MTS_GAPS:fallthrough
		 		case .SQL_BEFORE_GTIDS:fallthrough
		 		case .SQL_BUFFER_RESULT:fallthrough
		 		case .SQL_CACHE:fallthrough
		 		case .SQL_NO_CACHE:fallthrough
		 		case .SQL_THREAD:fallthrough
		 		case .START:fallthrough
		 		case .STARTS:fallthrough
		 		case .STATS_AUTO_RECALC:fallthrough
		 		case .STATS_PERSISTENT:fallthrough
		 		case .STATS_SAMPLE_PAGES:fallthrough
		 		case .STATUS:fallthrough
		 		case .STOP:fallthrough
		 		case .STORAGE:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBCLASS_ORIGIN:fallthrough
		 		case .SUBJECT:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBPARTITIONS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .SWAPS:fallthrough
		 		case .SWITCHES:fallthrough
		 		case .TABLE_NAME:fallthrough
		 		case .TABLESPACE:fallthrough
		 		case .TABLE_TYPE:fallthrough
		 		case .TEMPORARY:fallthrough
		 		case .TEMPTABLE:fallthrough
		 		case .THAN:fallthrough
		 		case .TRADITIONAL:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSACTIONAL:fallthrough
		 		case .TRIGGERS:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDEFINED:fallthrough
		 		case .UNDOFILE:fallthrough
		 		case .UNDO_BUFFER_SIZE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPGRADE:fallthrough
		 		case .USER:fallthrough
		 		case .USE_FRM:fallthrough
		 		case .USER_RESOURCES:fallthrough
		 		case .VALIDATION:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARIABLES:fallthrough
		 		case .VIEW:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .VISIBLE:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNINGS:fallthrough
		 		case .WITHOUT:fallthrough
		 		case .WORK:fallthrough
		 		case .WRAPPER:fallthrough
		 		case .X509:fallthrough
		 		case .XA:fallthrough
		 		case .XML:fallthrough
		 		case .EUR:fallthrough
		 		case .USA:fallthrough
		 		case .JIS:fallthrough
		 		case .ISO:fallthrough
		 		case .INTERNAL:fallthrough
		 		case .QUARTER:fallthrough
		 		case .MONTH:fallthrough
		 		case .DAY:fallthrough
		 		case .HOUR:fallthrough
		 		case .MINUTE:fallthrough
		 		case .WEEK:fallthrough
		 		case .SECOND:fallthrough
		 		case .MICROSECOND:fallthrough
		 		case .ADMIN:fallthrough
		 		case .AUDIT_ABORT_EXEMPT:fallthrough
		 		case .AUDIT_ADMIN:fallthrough
		 		case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 		case .BACKUP_ADMIN:fallthrough
		 		case .BINLOG_ADMIN:fallthrough
		 		case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 		case .CLONE_ADMIN:fallthrough
		 		case .CONNECTION_ADMIN:fallthrough
		 		case .ENCRYPTION_KEY_ADMIN:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .FILE:fallthrough
		 		case .FIREWALL_ADMIN:fallthrough
		 		case .FIREWALL_EXEMPT:fallthrough
		 		case .FIREWALL_USER:fallthrough
		 		case .GROUP_REPLICATION_ADMIN:fallthrough
		 		case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 		case .INVOKE:fallthrough
		 		case .LAMBDA:fallthrough
		 		case .NDB_STORED_USER:fallthrough
		 		case .PASSWORDLESS_USER_ADMIN:fallthrough
		 		case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .PROCESS:fallthrough
		 		case .RELOAD:fallthrough
		 		case .REPLICATION_APPLIER:fallthrough
		 		case .REPLICATION_SLAVE_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_USER:fallthrough
		 		case .ROLE_ADMIN:fallthrough
		 		case .ROUTINE:fallthrough
		 		case .S3:fallthrough
		 		case .SESSION_VARIABLES_ADMIN:fallthrough
		 		case .SET_USER_ID:fallthrough
		 		case .SHOW_ROUTINE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SUPER:fallthrough
		 		case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 		case .TABLES:fallthrough
		 		case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 		case .VERSION_TOKEN_ADMIN:fallthrough
		 		case .XA_RECOVER_ADMIN:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .ARCHIVE:fallthrough
		 		case .BLACKHOLE:fallthrough
		 		case .CSV:fallthrough
		 		case .FEDERATED:fallthrough
		 		case .INNODB:fallthrough
		 		case .MEMORY:fallthrough
		 		case .MRG_MYISAM:fallthrough
		 		case .MYISAM:fallthrough
		 		case .NDB:fallthrough
		 		case .NDBCLUSTER:fallthrough
		 		case .PERFORMANCE_SCHEMA:fallthrough
		 		case .TOKUDB:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:fallthrough
		 		case .ABS:fallthrough
		 		case .ACOS:fallthrough
		 		case .ADDDATE:fallthrough
		 		case .ADDTIME:fallthrough
		 		case .AES_DECRYPT:fallthrough
		 		case .AES_ENCRYPT:fallthrough
		 		case .AREA:fallthrough
		 		case .ASBINARY:fallthrough
		 		case .ASIN:fallthrough
		 		case .ASTEXT:fallthrough
		 		case .ASWKB:fallthrough
		 		case .ASWKT:fallthrough
		 		case .ASYMMETRIC_DECRYPT:fallthrough
		 		case .ASYMMETRIC_DERIVE:fallthrough
		 		case .ASYMMETRIC_ENCRYPT:fallthrough
		 		case .ASYMMETRIC_SIGN:fallthrough
		 		case .ASYMMETRIC_VERIFY:fallthrough
		 		case .ATAN:fallthrough
		 		case .ATAN2:fallthrough
		 		case .BENCHMARK:fallthrough
		 		case .BIN:fallthrough
		 		case .BIT_COUNT:fallthrough
		 		case .BIT_LENGTH:fallthrough
		 		case .BUFFER:fallthrough
		 		case .CATALOG_NAME:fallthrough
		 		case .CEIL:fallthrough
		 		case .CEILING:fallthrough
		 		case .CENTROID:fallthrough
		 		case .CHARACTER_LENGTH:fallthrough
		 		case .CHARSET:fallthrough
		 		case .CHAR_LENGTH:fallthrough
		 		case .COERCIBILITY:fallthrough
		 		case .COLLATION:fallthrough
		 		case .COMPRESS:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_WS:fallthrough
		 		case .CONNECTION_ID:fallthrough
		 		case .CONV:fallthrough
		 		case .CONVERT_TZ:fallthrough
		 		case .COS:fallthrough
		 		case .COT:fallthrough
		 		case .CRC32:fallthrough
		 		case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 		case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 		case .CREATE_DH_PARAMETERS:fallthrough
		 		case .CREATE_DIGEST:fallthrough
		 		case .CROSSES:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATE_FORMAT:fallthrough
		 		case .DAYNAME:fallthrough
		 		case .DAYOFMONTH:fallthrough
		 		case .DAYOFWEEK:fallthrough
		 		case .DAYOFYEAR:fallthrough
		 		case .DECODE:fallthrough
		 		case .DEGREES:fallthrough
		 		case .DES_DECRYPT:fallthrough
		 		case .DES_ENCRYPT:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISJOINT:fallthrough
		 		case .ELT:fallthrough
		 		case .ENCODE:fallthrough
		 		case .ENCRYPT:fallthrough
		 		case .ENDPOINT:fallthrough
		 		case .ENGINE_ATTRIBUTE:fallthrough
		 		case .ENVELOPE:fallthrough
		 		case .EQUALS:fallthrough
		 		case .EXP:fallthrough
		 		case .EXPORT_SET:fallthrough
		 		case .EXTERIORRING:fallthrough
		 		case .EXTRACTVALUE:fallthrough
		 		case .FIELD:fallthrough
		 		case .FIND_IN_SET:fallthrough
		 		case .FLOOR:fallthrough
		 		case .FORMAT:fallthrough
		 		case .FOUND_ROWS:fallthrough
		 		case .FROM_BASE64:fallthrough
		 		case .FROM_DAYS:fallthrough
		 		case .FROM_UNIXTIME:fallthrough
		 		case .GEOMCOLLFROMTEXT:fallthrough
		 		case .GEOMCOLLFROMWKB:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .GEOMETRYFROMTEXT:fallthrough
		 		case .GEOMETRYFROMWKB:fallthrough
		 		case .GEOMETRYN:fallthrough
		 		case .GEOMETRYTYPE:fallthrough
		 		case .GEOMFROMTEXT:fallthrough
		 		case .GEOMFROMWKB:fallthrough
		 		case .GET_FORMAT:fallthrough
		 		case .GET_LOCK:fallthrough
		 		case .GLENGTH:fallthrough
		 		case .GREATEST:fallthrough
		 		case .GTID_SUBSET:fallthrough
		 		case .GTID_SUBTRACT:fallthrough
		 		case .HEX:fallthrough
		 		case .IFNULL:fallthrough
		 		case .INET6_ATON:fallthrough
		 		case .INET6_NTOA:fallthrough
		 		case .INET_ATON:fallthrough
		 		case .INET_NTOA:fallthrough
		 		case .INSTR:fallthrough
		 		case .INTERIORRINGN:fallthrough
		 		case .INTERSECTS:fallthrough
		 		case .ISCLOSED:fallthrough
		 		case .ISEMPTY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .ISSIMPLE:fallthrough
		 		case .IS_FREE_LOCK:fallthrough
		 		case .IS_IPV4:fallthrough
		 		case .IS_IPV4_COMPAT:fallthrough
		 		case .IS_IPV4_MAPPED:fallthrough
		 		case .IS_IPV6:fallthrough
		 		case .IS_USED_LOCK:fallthrough
		 		case .LAST_INSERT_ID:fallthrough
		 		case .LCASE:fallthrough
		 		case .LEAST:fallthrough
		 		case .LENGTH:fallthrough
		 		case .LINEFROMTEXT:fallthrough
		 		case .LINEFROMWKB:fallthrough
		 		case .LINESTRINGFROMTEXT:fallthrough
		 		case .LINESTRINGFROMWKB:fallthrough
		 		case .LN:fallthrough
		 		case .LOAD_FILE:fallthrough
		 		case .LOCATE:fallthrough
		 		case .LOG:fallthrough
		 		case .LOG10:fallthrough
		 		case .LOG2:fallthrough
		 		case .LOWER:fallthrough
		 		case .LPAD:fallthrough
		 		case .LTRIM:fallthrough
		 		case .MAKEDATE:fallthrough
		 		case .MAKETIME:fallthrough
		 		case .MAKE_SET:fallthrough
		 		case .MASTER_POS_WAIT:fallthrough
		 		case .MBRCONTAINS:fallthrough
		 		case .MBRDISJOINT:fallthrough
		 		case .MBREQUAL:fallthrough
		 		case .MBRINTERSECTS:fallthrough
		 		case .MBROVERLAPS:fallthrough
		 		case .MBRTOUCHES:fallthrough
		 		case .MBRWITHIN:fallthrough
		 		case .MD5:fallthrough
		 		case .MLINEFROMTEXT:fallthrough
		 		case .MLINEFROMWKB:fallthrough
		 		case .MONTHNAME:fallthrough
		 		case .MPOINTFROMTEXT:fallthrough
		 		case .MPOINTFROMWKB:fallthrough
		 		case .MPOLYFROMTEXT:fallthrough
		 		case .MPOLYFROMWKB:fallthrough
		 		case .MULTILINESTRINGFROMTEXT:fallthrough
		 		case .MULTILINESTRINGFROMWKB:fallthrough
		 		case .MULTIPOINTFROMTEXT:fallthrough
		 		case .MULTIPOINTFROMWKB:fallthrough
		 		case .MULTIPOLYGONFROMTEXT:fallthrough
		 		case .MULTIPOLYGONFROMWKB:fallthrough
		 		case .NAME_CONST:fallthrough
		 		case .NULLIF:fallthrough
		 		case .NUMGEOMETRIES:fallthrough
		 		case .NUMINTERIORRINGS:fallthrough
		 		case .NUMPOINTS:fallthrough
		 		case .OCT:fallthrough
		 		case .OCTET_LENGTH:fallthrough
		 		case .ORD:fallthrough
		 		case .OVERLAPS:fallthrough
		 		case .PERIOD_ADD:fallthrough
		 		case .PERIOD_DIFF:fallthrough
		 		case .PI:fallthrough
		 		case .POINTFROMTEXT:fallthrough
		 		case .POINTFROMWKB:fallthrough
		 		case .POINTN:fallthrough
		 		case .POLYFROMTEXT:fallthrough
		 		case .POLYFROMWKB:fallthrough
		 		case .POLYGONFROMTEXT:fallthrough
		 		case .POLYGONFROMWKB:fallthrough
		 		case .POW:fallthrough
		 		case .POWER:fallthrough
		 		case .QUOTE:fallthrough
		 		case .RADIANS:fallthrough
		 		case .RAND:fallthrough
		 		case .RANDOM:fallthrough
		 		case .RANDOM_BYTES:fallthrough
		 		case .RELEASE_LOCK:fallthrough
		 		case .REVERSE:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_COUNT:fallthrough
		 		case .RPAD:fallthrough
		 		case .RTRIM:fallthrough
		 		case .SEC_TO_TIME:fallthrough
		 		case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SHA:fallthrough
		 		case .SHA1:fallthrough
		 		case .SHA2:fallthrough
		 		case .SCHEMA_NAME:fallthrough
		 		case .SIGN:fallthrough
		 		case .SIN:fallthrough
		 		case .SLEEP:fallthrough
		 		case .SOUNDEX:fallthrough
		 		case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 		case .SQRT:fallthrough
		 		case .SRID:fallthrough
		 		case .STARTPOINT:fallthrough
		 		case .STRCMP:fallthrough
		 		case .STR_TO_DATE:fallthrough
		 		case .ST_AREA:fallthrough
		 		case .ST_ASBINARY:fallthrough
		 		case .ST_ASTEXT:fallthrough
		 		case .ST_ASWKB:fallthrough
		 		case .ST_ASWKT:fallthrough
		 		case .ST_BUFFER:fallthrough
		 		case .ST_CENTROID:fallthrough
		 		case .ST_CONTAINS:fallthrough
		 		case .ST_CROSSES:fallthrough
		 		case .ST_DIFFERENCE:fallthrough
		 		case .ST_DIMENSION:fallthrough
		 		case .ST_DISJOINT:fallthrough
		 		case .ST_DISTANCE:fallthrough
		 		case .ST_ENDPOINT:fallthrough
		 		case .ST_ENVELOPE:fallthrough
		 		case .ST_EQUALS:fallthrough
		 		case .ST_EXTERIORRING:fallthrough
		 		case .ST_GEOMCOLLFROMTEXT:fallthrough
		 		case .ST_GEOMCOLLFROMTXT:fallthrough
		 		case .ST_GEOMCOLLFROMWKB:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .ST_GEOMETRYFROMTEXT:fallthrough
		 		case .ST_GEOMETRYFROMWKB:fallthrough
		 		case .ST_GEOMETRYN:fallthrough
		 		case .ST_GEOMETRYTYPE:fallthrough
		 		case .ST_GEOMFROMTEXT:fallthrough
		 		case .ST_GEOMFROMWKB:fallthrough
		 		case .ST_INTERIORRINGN:fallthrough
		 		case .ST_INTERSECTION:fallthrough
		 		case .ST_INTERSECTS:fallthrough
		 		case .ST_ISCLOSED:fallthrough
		 		case .ST_ISEMPTY:fallthrough
		 		case .ST_ISSIMPLE:fallthrough
		 		case .ST_LINEFROMTEXT:fallthrough
		 		case .ST_LINEFROMWKB:fallthrough
		 		case .ST_LINESTRINGFROMTEXT:fallthrough
		 		case .ST_LINESTRINGFROMWKB:fallthrough
		 		case .ST_NUMGEOMETRIES:fallthrough
		 		case .ST_NUMINTERIORRING:fallthrough
		 		case .ST_NUMINTERIORRINGS:fallthrough
		 		case .ST_NUMPOINTS:fallthrough
		 		case .ST_OVERLAPS:fallthrough
		 		case .ST_POINTFROMTEXT:fallthrough
		 		case .ST_POINTFROMWKB:fallthrough
		 		case .ST_POINTN:fallthrough
		 		case .ST_POLYFROMTEXT:fallthrough
		 		case .ST_POLYFROMWKB:fallthrough
		 		case .ST_POLYGONFROMTEXT:fallthrough
		 		case .ST_POLYGONFROMWKB:fallthrough
		 		case .ST_SRID:fallthrough
		 		case .ST_STARTPOINT:fallthrough
		 		case .ST_SYMDIFFERENCE:fallthrough
		 		case .ST_TOUCHES:fallthrough
		 		case .ST_UNION:fallthrough
		 		case .ST_WITHIN:fallthrough
		 		case .ST_X:fallthrough
		 		case .ST_Y:fallthrough
		 		case .SUBDATE:fallthrough
		 		case .SUBSTRING_INDEX:fallthrough
		 		case .SUBTIME:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TAN:fallthrough
		 		case .TIMEDIFF:fallthrough
		 		case .TIMESTAMPADD:fallthrough
		 		case .TIMESTAMPDIFF:fallthrough
		 		case .TIME_FORMAT:fallthrough
		 		case .TIME_TO_SEC:fallthrough
		 		case .TOUCHES:fallthrough
		 		case .TO_BASE64:fallthrough
		 		case .TO_DAYS:fallthrough
		 		case .TO_SECONDS:fallthrough
		 		case .TP_CONNECTION_ADMIN:fallthrough
		 		case .UCASE:fallthrough
		 		case .UNCOMPRESS:fallthrough
		 		case .UNCOMPRESSED_LENGTH:fallthrough
		 		case .UNHEX:fallthrough
		 		case .UNIX_TIMESTAMP:fallthrough
		 		case .UPDATEXML:fallthrough
		 		case .UPPER:fallthrough
		 		case .UUID:fallthrough
		 		case .UUID_SHORT:fallthrough
		 		case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 		case .VERSION:fallthrough
		 		case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 		case .WEEKDAY:fallthrough
		 		case .WEEKOFYEAR:fallthrough
		 		case .WEIGHT_STRING:fallthrough
		 		case .WITHIN:fallthrough
		 		case .YEARWEEK:fallthrough
		 		case .Y_FUNCTION:fallthrough
		 		case .X_FUNCTION:fallthrough
		 		case .MOD:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:fallthrough
		 		case .ID:
		 			setState(2969)
		 			try uidList()

		 			break

		 		case .ALL:
		 			setState(2970)
		 			try match(MySqlParser.Tokens.ALL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .REMOVE:
		 		_localctx =  AlterByRemovePartitioningContext(_localctx);
		 		try enterOuterAlt(_localctx, 14)
		 		setState(2973)
		 		try match(MySqlParser.Tokens.REMOVE.rawValue)
		 		setState(2974)
		 		try match(MySqlParser.Tokens.PARTITIONING.rawValue)

		 		break

		 	case .UPGRADE:
		 		_localctx =  AlterByUpgradePartitioningContext(_localctx);
		 		try enterOuterAlt(_localctx, 15)
		 		setState(2975)
		 		try match(MySqlParser.Tokens.UPGRADE.rawValue)
		 		setState(2976)
		 		try match(MySqlParser.Tokens.PARTITIONING.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropDatabaseContext: ParserRuleContext {
		open var dbFormat: Token!
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func DATABASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATABASE.rawValue, 0)
			}
			open
			func SCHEMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEMA.rawValue, 0)
			}
			open
			func ifExists() -> IfExistsContext? {
				return getRuleContext(IfExistsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropDatabase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropDatabase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropDatabase(self)
			}
		}
	}
	@discardableResult
	 open func dropDatabase() throws -> DropDatabaseContext {
		var _localctx: DropDatabaseContext
		_localctx = DropDatabaseContext(_ctx, getState())
		try enterRule(_localctx, 152, MySqlParser.RULE_dropDatabase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2979)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(2980)
		 	_localctx.castdown(DropDatabaseContext.self).dbFormat = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.DATABASE.rawValue || _la == MySqlParser.Tokens.SCHEMA.rawValue)) {
		 		_localctx.castdown(DropDatabaseContext.self).dbFormat = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(2982)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,382,_ctx)) {
		 	case 1:
		 		setState(2981)
		 		try ifExists()

		 		break
		 	default: break
		 	}
		 	setState(2984)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropEventContext: ParserRuleContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func EVENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVENT.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func ifExists() -> IfExistsContext? {
				return getRuleContext(IfExistsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropEvent
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropEvent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropEvent(self)
			}
		}
	}
	@discardableResult
	 open func dropEvent() throws -> DropEventContext {
		var _localctx: DropEventContext
		_localctx = DropEventContext(_ctx, getState())
		try enterRule(_localctx, 154, MySqlParser.RULE_dropEvent)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2986)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(2987)
		 	try match(MySqlParser.Tokens.EVENT.rawValue)
		 	setState(2989)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,383,_ctx)) {
		 	case 1:
		 		setState(2988)
		 		try ifExists()

		 		break
		 	default: break
		 	}
		 	setState(2991)
		 	try fullId()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropIndexContext: ParserRuleContext {
		open var intimeAction: Token!
		open var algType: Token!
		open var lockType: Token!
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func ALGORITHM() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ALGORITHM.rawValue)
			}
			open
			func ALGORITHM(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALGORITHM.rawValue, i)
			}
			open
			func LOCK() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LOCK.rawValue)
			}
			open
			func LOCK(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCK.rawValue, i)
			}
			open
			func ONLINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONLINE.rawValue, 0)
			}
			open
			func OFFLINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OFFLINE.rawValue, 0)
			}
			open
			func DEFAULT() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.DEFAULT.rawValue)
			}
			open
			func DEFAULT(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, i)
			}
			open
			func INPLACE() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.INPLACE.rawValue)
			}
			open
			func INPLACE(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INPLACE.rawValue, i)
			}
			open
			func COPY() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COPY.rawValue)
			}
			open
			func COPY(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COPY.rawValue, i)
			}
			open
			func NONE() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.NONE.rawValue)
			}
			open
			func NONE(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NONE.rawValue, i)
			}
			open
			func SHARED() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.SHARED.rawValue)
			}
			open
			func SHARED(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHARED.rawValue, i)
			}
			open
			func EXCLUSIVE() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EXCLUSIVE.rawValue)
			}
			open
			func EXCLUSIVE(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXCLUSIVE.rawValue, i)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropIndex
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropIndex(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropIndex(self)
			}
		}
	}
	@discardableResult
	 open func dropIndex() throws -> DropIndexContext {
		var _localctx: DropIndexContext
		_localctx = DropIndexContext(_ctx, getState())
		try enterRule(_localctx, 156, MySqlParser.RULE_dropIndex)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(2993)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(2994)
		 	try match(MySqlParser.Tokens.INDEX.rawValue)
		 	setState(2996)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,384,_ctx)) {
		 	case 1:
		 		setState(2995)
		 		_localctx.castdown(DropIndexContext.self).intimeAction = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.OFFLINE.rawValue || _la == MySqlParser.Tokens.ONLINE.rawValue)) {
		 			_localctx.castdown(DropIndexContext.self).intimeAction = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(2998)
		 	try uid()
		 	setState(2999)
		 	try match(MySqlParser.Tokens.ON.rawValue)
		 	setState(3000)
		 	try tableName()
		 	setState(3013)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,388,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3011)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .ALGORITHM:
		 				setState(3001)
		 				try match(MySqlParser.Tokens.ALGORITHM.rawValue)
		 				setState(3003)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 					setState(3002)
		 					try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 				}

		 				setState(3005)
		 				_localctx.castdown(DropIndexContext.self).algType = try _input.LT(1)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.COPY.rawValue || _la == MySqlParser.Tokens.INPLACE.rawValue)) {
		 					_localctx.castdown(DropIndexContext.self).algType = try _errHandler.recoverInline(self) as Token
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 				break

		 			case .LOCK:
		 				setState(3006)
		 				try match(MySqlParser.Tokens.LOCK.rawValue)
		 				setState(3008)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 					setState(3007)
		 					try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 				}

		 				setState(3010)
		 				_localctx.castdown(DropIndexContext.self).lockType = try _input.LT(1)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.EXCLUSIVE.rawValue || _la == MySqlParser.Tokens.NONE.rawValue || _la == MySqlParser.Tokens.SHARED.rawValue)) {
		 					_localctx.castdown(DropIndexContext.self).lockType = try _errHandler.recoverInline(self) as Token
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 	 
		 		}
		 		setState(3015)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,388,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropLogfileGroupContext: ParserRuleContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func LOGFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOGFILE.rawValue, 0)
			}
			open
			func GROUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func engineName() -> EngineNameContext? {
				return getRuleContext(EngineNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropLogfileGroup
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropLogfileGroup(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropLogfileGroup(self)
			}
		}
	}
	@discardableResult
	 open func dropLogfileGroup() throws -> DropLogfileGroupContext {
		var _localctx: DropLogfileGroupContext
		_localctx = DropLogfileGroupContext(_ctx, getState())
		try enterRule(_localctx, 158, MySqlParser.RULE_dropLogfileGroup)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3016)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(3017)
		 	try match(MySqlParser.Tokens.LOGFILE.rawValue)
		 	setState(3018)
		 	try match(MySqlParser.Tokens.GROUP.rawValue)
		 	setState(3019)
		 	try uid()
		 	setState(3020)
		 	try match(MySqlParser.Tokens.ENGINE.rawValue)
		 	setState(3021)
		 	try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 	setState(3022)
		 	try engineName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropProcedureContext: ParserRuleContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCEDURE.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func ifExists() -> IfExistsContext? {
				return getRuleContext(IfExistsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropProcedure
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropProcedure(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropProcedure(self)
			}
		}
	}
	@discardableResult
	 open func dropProcedure() throws -> DropProcedureContext {
		var _localctx: DropProcedureContext
		_localctx = DropProcedureContext(_ctx, getState())
		try enterRule(_localctx, 160, MySqlParser.RULE_dropProcedure)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3024)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(3025)
		 	try match(MySqlParser.Tokens.PROCEDURE.rawValue)
		 	setState(3027)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,389,_ctx)) {
		 	case 1:
		 		setState(3026)
		 		try ifExists()

		 		break
		 	default: break
		 	}
		 	setState(3029)
		 	try fullId()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropFunctionContext: ParserRuleContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FUNCTION.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func ifExists() -> IfExistsContext? {
				return getRuleContext(IfExistsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropFunction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropFunction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropFunction(self)
			}
		}
	}
	@discardableResult
	 open func dropFunction() throws -> DropFunctionContext {
		var _localctx: DropFunctionContext
		_localctx = DropFunctionContext(_ctx, getState())
		try enterRule(_localctx, 162, MySqlParser.RULE_dropFunction)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3031)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(3032)
		 	try match(MySqlParser.Tokens.FUNCTION.rawValue)
		 	setState(3034)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,390,_ctx)) {
		 	case 1:
		 		setState(3033)
		 		try ifExists()

		 		break
		 	default: break
		 	}
		 	setState(3036)
		 	try fullId()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropServerContext: ParserRuleContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func SERVER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SERVER.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func ifExists() -> IfExistsContext? {
				return getRuleContext(IfExistsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropServer
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropServer(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropServer(self)
			}
		}
	}
	@discardableResult
	 open func dropServer() throws -> DropServerContext {
		var _localctx: DropServerContext
		_localctx = DropServerContext(_ctx, getState())
		try enterRule(_localctx, 164, MySqlParser.RULE_dropServer)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3038)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(3039)
		 	try match(MySqlParser.Tokens.SERVER.rawValue)
		 	setState(3041)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,391,_ctx)) {
		 	case 1:
		 		setState(3040)
		 		try ifExists()

		 		break
		 	default: break
		 	}
		 	setState(3043)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropTableContext: ParserRuleContext {
		open var dropType: Token!
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tables() -> TablesContext? {
				return getRuleContext(TablesContext.self, 0)
			}
			open
			func TEMPORARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TEMPORARY.rawValue, 0)
			}
			open
			func ifExists() -> IfExistsContext? {
				return getRuleContext(IfExistsContext.self, 0)
			}
			open
			func RESTRICT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESTRICT.rawValue, 0)
			}
			open
			func CASCADE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CASCADE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropTable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropTable(self)
			}
		}
	}
	@discardableResult
	 open func dropTable() throws -> DropTableContext {
		var _localctx: DropTableContext
		_localctx = DropTableContext(_ctx, getState())
		try enterRule(_localctx, 166, MySqlParser.RULE_dropTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3045)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(3047)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.TEMPORARY.rawValue) {
		 		setState(3046)
		 		try match(MySqlParser.Tokens.TEMPORARY.rawValue)

		 	}

		 	setState(3049)
		 	try match(MySqlParser.Tokens.TABLE.rawValue)
		 	setState(3051)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,393,_ctx)) {
		 	case 1:
		 		setState(3050)
		 		try ifExists()

		 		break
		 	default: break
		 	}
		 	setState(3053)
		 	try tables()
		 	setState(3055)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.CASCADE.rawValue || _la == MySqlParser.Tokens.RESTRICT.rawValue) {
		 		setState(3054)
		 		_localctx.castdown(DropTableContext.self).dropType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.CASCADE.rawValue || _la == MySqlParser.Tokens.RESTRICT.rawValue)) {
		 			_localctx.castdown(DropTableContext.self).dropType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropTablespaceContext: ParserRuleContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func engineName() -> EngineNameContext? {
				return getRuleContext(EngineNameContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropTablespace
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropTablespace(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropTablespace(self)
			}
		}
	}
	@discardableResult
	 open func dropTablespace() throws -> DropTablespaceContext {
		var _localctx: DropTablespaceContext
		_localctx = DropTablespaceContext(_ctx, getState())
		try enterRule(_localctx, 168, MySqlParser.RULE_dropTablespace)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3057)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(3058)
		 	try match(MySqlParser.Tokens.TABLESPACE.rawValue)
		 	setState(3059)
		 	try uid()
		 	setState(3065)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ENGINE.rawValue) {
		 		setState(3060)
		 		try match(MySqlParser.Tokens.ENGINE.rawValue)
		 		setState(3062)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue) {
		 			setState(3061)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		}

		 		setState(3064)
		 		try engineName()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropTriggerContext: ParserRuleContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func TRIGGER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRIGGER.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func ifExists() -> IfExistsContext? {
				return getRuleContext(IfExistsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropTrigger
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropTrigger(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropTrigger(self)
			}
		}
	}
	@discardableResult
	 open func dropTrigger() throws -> DropTriggerContext {
		var _localctx: DropTriggerContext
		_localctx = DropTriggerContext(_ctx, getState())
		try enterRule(_localctx, 170, MySqlParser.RULE_dropTrigger)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3067)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(3068)
		 	try match(MySqlParser.Tokens.TRIGGER.rawValue)
		 	setState(3070)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,397,_ctx)) {
		 	case 1:
		 		setState(3069)
		 		try ifExists()

		 		break
		 	default: break
		 	}
		 	setState(3072)
		 	try fullId()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropViewContext: ParserRuleContext {
		open var dropType: Token!
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func VIEW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VIEW.rawValue, 0)
			}
			open
			func fullId() -> [FullIdContext] {
				return getRuleContexts(FullIdContext.self)
			}
			open
			func fullId(_ i: Int) -> FullIdContext? {
				return getRuleContext(FullIdContext.self, i)
			}
			open
			func ifExists() -> IfExistsContext? {
				return getRuleContext(IfExistsContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func RESTRICT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESTRICT.rawValue, 0)
			}
			open
			func CASCADE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CASCADE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropView
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropView(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropView(self)
			}
		}
	}
	@discardableResult
	 open func dropView() throws -> DropViewContext {
		var _localctx: DropViewContext
		_localctx = DropViewContext(_ctx, getState())
		try enterRule(_localctx, 172, MySqlParser.RULE_dropView)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3074)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(3075)
		 	try match(MySqlParser.Tokens.VIEW.rawValue)
		 	setState(3077)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,398,_ctx)) {
		 	case 1:
		 		setState(3076)
		 		try ifExists()

		 		break
		 	default: break
		 	}
		 	setState(3079)
		 	try fullId()
		 	setState(3084)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(3080)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(3081)
		 		try fullId()


		 		setState(3086)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3088)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.CASCADE.rawValue || _la == MySqlParser.Tokens.RESTRICT.rawValue) {
		 		setState(3087)
		 		_localctx.castdown(DropViewContext.self).dropType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.CASCADE.rawValue || _la == MySqlParser.Tokens.RESTRICT.rawValue)) {
		 			_localctx.castdown(DropViewContext.self).dropType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropRoleContext: ParserRuleContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func ROLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLE.rawValue, 0)
			}
			open
			func roleName() -> [RoleNameContext] {
				return getRuleContexts(RoleNameContext.self)
			}
			open
			func roleName(_ i: Int) -> RoleNameContext? {
				return getRuleContext(RoleNameContext.self, i)
			}
			open
			func ifExists() -> IfExistsContext? {
				return getRuleContext(IfExistsContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropRole
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropRole(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropRole(self)
			}
		}
	}
	@discardableResult
	 open func dropRole() throws -> DropRoleContext {
		var _localctx: DropRoleContext
		_localctx = DropRoleContext(_ctx, getState())
		try enterRule(_localctx, 174, MySqlParser.RULE_dropRole)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3090)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(3091)
		 	try match(MySqlParser.Tokens.ROLE.rawValue)
		 	setState(3093)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,401,_ctx)) {
		 	case 1:
		 		setState(3092)
		 		try ifExists()

		 		break
		 	default: break
		 	}
		 	setState(3095)
		 	try roleName()
		 	setState(3100)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(3096)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(3097)
		 		try roleName()


		 		setState(3102)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetRoleContext: ParserRuleContext {
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func ROLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLE.rawValue, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func NONE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NONE.rawValue, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func roleName() -> [RoleNameContext] {
				return getRuleContexts(RoleNameContext.self)
			}
			open
			func roleName(_ i: Int) -> RoleNameContext? {
				return getRuleContext(RoleNameContext.self, i)
			}
			open
			func userName() -> [UserNameContext] {
				return getRuleContexts(UserNameContext.self)
			}
			open
			func userName(_ i: Int) -> UserNameContext? {
				return getRuleContext(UserNameContext.self, i)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func roleOption() -> RoleOptionContext? {
				return getRuleContext(RoleOptionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_setRole
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSetRole(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSetRole(self)
			}
		}
	}
	@discardableResult
	 open func setRole() throws -> SetRoleContext {
		var _localctx: SetRoleContext
		_localctx = SetRoleContext(_ctx, getState())
		try enterRule(_localctx, 176, MySqlParser.RULE_setRole)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3136)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,408, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3103)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(3104)
		 		try match(MySqlParser.Tokens.DEFAULT.rawValue)
		 		setState(3105)
		 		try match(MySqlParser.Tokens.ROLE.rawValue)
		 		setState(3116)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,404, _ctx)) {
		 		case 1:
		 			setState(3106)
		 			try match(MySqlParser.Tokens.NONE.rawValue)

		 			break
		 		case 2:
		 			setState(3107)
		 			try match(MySqlParser.Tokens.ALL.rawValue)

		 			break
		 		case 3:
		 			setState(3108)
		 			try roleName()
		 			setState(3113)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 				setState(3109)
		 				try match(MySqlParser.Tokens.COMMA.rawValue)
		 				setState(3110)
		 				try roleName()


		 				setState(3115)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}

		 			break
		 		default: break
		 		}
		 		setState(3118)
		 		try match(MySqlParser.Tokens.TO.rawValue)
		 		setState(3121)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,405, _ctx)) {
		 		case 1:
		 			setState(3119)
		 			try userName()

		 			break
		 		case 2:
		 			setState(3120)
		 			try uid()

		 			break
		 		default: break
		 		}
		 		setState(3130)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(3123)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3126)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,406, _ctx)) {
		 			case 1:
		 				setState(3124)
		 				try userName()

		 				break
		 			case 2:
		 				setState(3125)
		 				try uid()

		 				break
		 			default: break
		 			}


		 			setState(3132)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3133)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(3134)
		 		try match(MySqlParser.Tokens.ROLE.rawValue)
		 		setState(3135)
		 		try roleOption()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RenameTableContext: ParserRuleContext {
			open
			func RENAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RENAME.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func renameTableClause() -> [RenameTableClauseContext] {
				return getRuleContexts(RenameTableClauseContext.self)
			}
			open
			func renameTableClause(_ i: Int) -> RenameTableClauseContext? {
				return getRuleContext(RenameTableClauseContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_renameTable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRenameTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRenameTable(self)
			}
		}
	}
	@discardableResult
	 open func renameTable() throws -> RenameTableContext {
		var _localctx: RenameTableContext
		_localctx = RenameTableContext(_ctx, getState())
		try enterRule(_localctx, 178, MySqlParser.RULE_renameTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3138)
		 	try match(MySqlParser.Tokens.RENAME.rawValue)
		 	setState(3139)
		 	try match(MySqlParser.Tokens.TABLE.rawValue)
		 	setState(3140)
		 	try renameTableClause()
		 	setState(3145)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(3141)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(3142)
		 		try renameTableClause()


		 		setState(3147)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RenameTableClauseContext: ParserRuleContext {
			open
			func tableName() -> [TableNameContext] {
				return getRuleContexts(TableNameContext.self)
			}
			open
			func tableName(_ i: Int) -> TableNameContext? {
				return getRuleContext(TableNameContext.self, i)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_renameTableClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRenameTableClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRenameTableClause(self)
			}
		}
	}
	@discardableResult
	 open func renameTableClause() throws -> RenameTableClauseContext {
		var _localctx: RenameTableClauseContext
		_localctx = RenameTableClauseContext(_ctx, getState())
		try enterRule(_localctx, 180, MySqlParser.RULE_renameTableClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3148)
		 	try tableName()
		 	setState(3149)
		 	try match(MySqlParser.Tokens.TO.rawValue)
		 	setState(3150)
		 	try tableName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TruncateTableContext: ParserRuleContext {
			open
			func TRUNCATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRUNCATE.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_truncateTable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTruncateTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTruncateTable(self)
			}
		}
	}
	@discardableResult
	 open func truncateTable() throws -> TruncateTableContext {
		var _localctx: TruncateTableContext
		_localctx = TruncateTableContext(_ctx, getState())
		try enterRule(_localctx, 182, MySqlParser.RULE_truncateTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3152)
		 	try match(MySqlParser.Tokens.TRUNCATE.rawValue)
		 	setState(3154)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.TABLE.rawValue) {
		 		setState(3153)
		 		try match(MySqlParser.Tokens.TABLE.rawValue)

		 	}

		 	setState(3156)
		 	try tableName()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CallStatementContext: ParserRuleContext {
			open
			func CALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CALL.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func constants() -> ConstantsContext? {
				return getRuleContext(ConstantsContext.self, 0)
			}
			open
			func expressions() -> ExpressionsContext? {
				return getRuleContext(ExpressionsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_callStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCallStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCallStatement(self)
			}
		}
	}
	@discardableResult
	 open func callStatement() throws -> CallStatementContext {
		var _localctx: CallStatementContext
		_localctx = CallStatementContext(_ctx, getState())
		try enterRule(_localctx, 184, MySqlParser.RULE_callStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3158)
		 	try match(MySqlParser.Tokens.CALL.rawValue)
		 	setState(3159)
		 	try fullId()
		 	setState(3166)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,412,_ctx)) {
		 	case 1:
		 		setState(3160)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3163)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,411,_ctx)) {
		 		case 1:
		 			setState(3161)
		 			try constants()

		 			break
		 		case 2:
		 			setState(3162)
		 			try expressions()

		 			break
		 		default: break
		 		}
		 		setState(3165)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DeleteStatementContext: ParserRuleContext {
			open
			func singleDeleteStatement() -> SingleDeleteStatementContext? {
				return getRuleContext(SingleDeleteStatementContext.self, 0)
			}
			open
			func multipleDeleteStatement() -> MultipleDeleteStatementContext? {
				return getRuleContext(MultipleDeleteStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_deleteStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDeleteStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDeleteStatement(self)
			}
		}
	}
	@discardableResult
	 open func deleteStatement() throws -> DeleteStatementContext {
		var _localctx: DeleteStatementContext
		_localctx = DeleteStatementContext(_ctx, getState())
		try enterRule(_localctx, 186, MySqlParser.RULE_deleteStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3170)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,413, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3168)
		 		try singleDeleteStatement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3169)
		 		try multipleDeleteStatement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DoStatementContext: ParserRuleContext {
			open
			func DO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DO.rawValue, 0)
			}
			open
			func expressions() -> ExpressionsContext? {
				return getRuleContext(ExpressionsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_doStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDoStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDoStatement(self)
			}
		}
	}
	@discardableResult
	 open func doStatement() throws -> DoStatementContext {
		var _localctx: DoStatementContext
		_localctx = DoStatementContext(_ctx, getState())
		try enterRule(_localctx, 188, MySqlParser.RULE_doStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3172)
		 	try match(MySqlParser.Tokens.DO.rawValue)
		 	setState(3173)
		 	try expressions()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HandlerStatementContext: ParserRuleContext {
			open
			func handlerOpenStatement() -> HandlerOpenStatementContext? {
				return getRuleContext(HandlerOpenStatementContext.self, 0)
			}
			open
			func handlerReadIndexStatement() -> HandlerReadIndexStatementContext? {
				return getRuleContext(HandlerReadIndexStatementContext.self, 0)
			}
			open
			func handlerReadStatement() -> HandlerReadStatementContext? {
				return getRuleContext(HandlerReadStatementContext.self, 0)
			}
			open
			func handlerCloseStatement() -> HandlerCloseStatementContext? {
				return getRuleContext(HandlerCloseStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_handlerStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHandlerStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHandlerStatement(self)
			}
		}
	}
	@discardableResult
	 open func handlerStatement() throws -> HandlerStatementContext {
		var _localctx: HandlerStatementContext
		_localctx = HandlerStatementContext(_ctx, getState())
		try enterRule(_localctx, 190, MySqlParser.RULE_handlerStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3179)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,414, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3175)
		 		try handlerOpenStatement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3176)
		 		try handlerReadIndexStatement()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3177)
		 		try handlerReadStatement()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3178)
		 		try handlerCloseStatement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InsertStatementContext: ParserRuleContext {
		open var priority: Token!
		open var partitions: UidListContext!
		open var columns: FullColumnNameListContext!
		open var setFirst: UpdatedElementContext!
		open var _updatedElement: UpdatedElementContext!
		open var setElements: [UpdatedElementContext] = [UpdatedElementContext]()
		open var duplicatedFirst: UpdatedElementContext!
		open var duplicatedElements: [UpdatedElementContext] = [UpdatedElementContext]()
			open
			func INSERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSERT.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func insertStatementValue() -> InsertStatementValueContext? {
				return getRuleContext(InsertStatementValueContext.self, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func IGNORE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE.rawValue, 0)
			}
			open
			func INTO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTO.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func updatedElement() -> [UpdatedElementContext] {
				return getRuleContexts(UpdatedElementContext.self)
			}
			open
			func updatedElement(_ i: Int) -> UpdatedElementContext? {
				return getRuleContext(UpdatedElementContext.self, i)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func DUPLICATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DUPLICATE.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func UPDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPDATE.rawValue, 0)
			}
			open
			func LOW_PRIORITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOW_PRIORITY.rawValue, 0)
			}
			open
			func DELAYED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DELAYED.rawValue, 0)
			}
			open
			func HIGH_PRIORITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HIGH_PRIORITY.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
			open
			func fullColumnNameList() -> FullColumnNameListContext? {
				return getRuleContext(FullColumnNameListContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_insertStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterInsertStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitInsertStatement(self)
			}
		}
	}
	@discardableResult
	 open func insertStatement() throws -> InsertStatementContext {
		var _localctx: InsertStatementContext
		_localctx = InsertStatementContext(_ctx, getState())
		try enterRule(_localctx, 192, MySqlParser.RULE_insertStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3181)
		 	try match(MySqlParser.Tokens.INSERT.rawValue)
		 	setState(3183)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64((_la - 43)) & ~0x3f) == 0 && ((Int64(1) << (_la - 43)) & -9223372032559808511) != 0)) {
		 		setState(3182)
		 		_localctx.castdown(InsertStatementContext.self).priority = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 43)) & ~0x3f) == 0 && ((Int64(1) << (_la - 43)) & -9223372032559808511) != 0))) {
		 			_localctx.castdown(InsertStatementContext.self).priority = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3186)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IGNORE.rawValue) {
		 		setState(3185)
		 		try match(MySqlParser.Tokens.IGNORE.rawValue)

		 	}

		 	setState(3189)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.INTO.rawValue) {
		 		setState(3188)
		 		try match(MySqlParser.Tokens.INTO.rawValue)

		 	}

		 	setState(3191)
		 	try tableName()
		 	setState(3198)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.PARTITION.rawValue) {
		 		setState(3192)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(3193)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3195)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(3194)
		 			try {
		 					let assignmentValue = try uidList()
		 					_localctx.castdown(InsertStatementContext.self).partitions = assignmentValue
		 			     }()


		 		}

		 		setState(3197)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(3223)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SELECT:fallthrough
		 	case .VALUES:fallthrough
		 	case .VALUE:fallthrough
		 	case .LR_BRACKET:
		 		setState(3205)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,421,_ctx)) {
		 		case 1:
		 			setState(3200)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(3202)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,420,_ctx)) {
		 			case 1:
		 				setState(3201)
		 				try {
		 						let assignmentValue = try fullColumnNameList()
		 						_localctx.castdown(InsertStatementContext.self).columns = assignmentValue
		 				     }()


		 				break
		 			default: break
		 			}
		 			setState(3204)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(3207)
		 		try insertStatementValue()
		 		setState(3212)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,423,_ctx)) {
		 		case 1:
		 			setState(3209)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.AS.rawValue) {
		 				setState(3208)
		 				try match(MySqlParser.Tokens.AS.rawValue)

		 			}

		 			setState(3211)
		 			try uid()

		 			break
		 		default: break
		 		}

		 		break

		 	case .SET:
		 		setState(3214)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(3215)
		 		try {
		 				let assignmentValue = try updatedElement()
		 				_localctx.castdown(InsertStatementContext.self).setFirst = assignmentValue
		 		     }()

		 		setState(3220)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(3216)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3217)
		 			try {
		 					let assignmentValue = try updatedElement()
		 					_localctx.castdown(InsertStatementContext.self)._updatedElement = assignmentValue
		 			     }()

		 			_localctx.castdown(InsertStatementContext.self).setElements.append(_localctx.castdown(InsertStatementContext.self)._updatedElement)


		 			setState(3222)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3237)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ON.rawValue) {
		 		setState(3225)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(3226)
		 		try match(MySqlParser.Tokens.DUPLICATE.rawValue)
		 		setState(3227)
		 		try match(MySqlParser.Tokens.KEY.rawValue)
		 		setState(3228)
		 		try match(MySqlParser.Tokens.UPDATE.rawValue)
		 		setState(3229)
		 		try {
		 				let assignmentValue = try updatedElement()
		 				_localctx.castdown(InsertStatementContext.self).duplicatedFirst = assignmentValue
		 		     }()

		 		setState(3234)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(3230)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3231)
		 			try {
		 					let assignmentValue = try updatedElement()
		 					_localctx.castdown(InsertStatementContext.self)._updatedElement = assignmentValue
		 			     }()

		 			_localctx.castdown(InsertStatementContext.self).duplicatedElements.append(_localctx.castdown(InsertStatementContext.self)._updatedElement)


		 			setState(3236)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LoadDataStatementContext: ParserRuleContext {
		open var priority: Token!
		open var filename: Token!
		open var violation: Token!
		open var charset: CharsetNameContext!
		open var fieldsFormat: Token!
		open var linesFormat: Token!
			open
			func LOAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOAD.rawValue, 0)
			}
			open
			func DATA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATA.rawValue, 0)
			}
			open
			func INFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INFILE.rawValue, 0)
			}
			open
			func INTO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTO.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func SET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.SET.rawValue)
			}
			open
			func SET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, i)
			}
			open
			func LINES() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LINES.rawValue)
			}
			open
			func LINES(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINES.rawValue, i)
			}
			open
			func IGNORE() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.IGNORE.rawValue)
			}
			open
			func IGNORE(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE.rawValue, i)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func assignmentField() -> [AssignmentFieldContext] {
				return getRuleContexts(AssignmentFieldContext.self)
			}
			open
			func assignmentField(_ i: Int) -> AssignmentFieldContext? {
				return getRuleContext(AssignmentFieldContext.self, i)
			}
			open
			func updatedElement() -> [UpdatedElementContext] {
				return getRuleContexts(UpdatedElementContext.self)
			}
			open
			func updatedElement(_ i: Int) -> UpdatedElementContext? {
				return getRuleContext(UpdatedElementContext.self, i)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func LOW_PRIORITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOW_PRIORITY.rawValue, 0)
			}
			open
			func CONCURRENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONCURRENT.rawValue, 0)
			}
			open
			func REPLACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLACE.rawValue, 0)
			}
			open
			func FIELDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIELDS.rawValue, 0)
			}
			open
			func COLUMNS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMNS.rawValue, 0)
			}
			open
			func ROWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROWS.rawValue, 0)
			}
			open
			func selectFieldsInto() -> [SelectFieldsIntoContext] {
				return getRuleContexts(SelectFieldsIntoContext.self)
			}
			open
			func selectFieldsInto(_ i: Int) -> SelectFieldsIntoContext? {
				return getRuleContext(SelectFieldsIntoContext.self, i)
			}
			open
			func selectLinesInto() -> [SelectLinesIntoContext] {
				return getRuleContexts(SelectLinesIntoContext.self)
			}
			open
			func selectLinesInto(_ i: Int) -> SelectLinesIntoContext? {
				return getRuleContext(SelectLinesIntoContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_loadDataStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLoadDataStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLoadDataStatement(self)
			}
		}
	}
	@discardableResult
	 open func loadDataStatement() throws -> LoadDataStatementContext {
		var _localctx: LoadDataStatementContext
		_localctx = LoadDataStatementContext(_ctx, getState())
		try enterRule(_localctx, 194, MySqlParser.RULE_loadDataStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3239)
		 	try match(MySqlParser.Tokens.LOAD.rawValue)
		 	setState(3240)
		 	try match(MySqlParser.Tokens.DATA.rawValue)
		 	setState(3242)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LOW_PRIORITY.rawValue || _la == MySqlParser.Tokens.CONCURRENT.rawValue) {
		 		setState(3241)
		 		_localctx.castdown(LoadDataStatementContext.self).priority = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.LOW_PRIORITY.rawValue || _la == MySqlParser.Tokens.CONCURRENT.rawValue)) {
		 			_localctx.castdown(LoadDataStatementContext.self).priority = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3245)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LOCAL.rawValue) {
		 		setState(3244)
		 		try match(MySqlParser.Tokens.LOCAL.rawValue)

		 	}

		 	setState(3247)
		 	try match(MySqlParser.Tokens.INFILE.rawValue)
		 	setState(3248)
		 	try {
		 			let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 			_localctx.castdown(LoadDataStatementContext.self).filename = assignmentValue
		 	     }()

		 	setState(3250)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IGNORE.rawValue || _la == MySqlParser.Tokens.REPLACE.rawValue) {
		 		setState(3249)
		 		_localctx.castdown(LoadDataStatementContext.self).violation = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.IGNORE.rawValue || _la == MySqlParser.Tokens.REPLACE.rawValue)) {
		 			_localctx.castdown(LoadDataStatementContext.self).violation = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3252)
		 	try match(MySqlParser.Tokens.INTO.rawValue)
		 	setState(3253)
		 	try match(MySqlParser.Tokens.TABLE.rawValue)
		 	setState(3254)
		 	try tableName()
		 	setState(3260)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.PARTITION.rawValue) {
		 		setState(3255)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(3256)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3257)
		 		try uidList()
		 		setState(3258)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(3265)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.CHARACTER.rawValue) {
		 		setState(3262)
		 		try match(MySqlParser.Tokens.CHARACTER.rawValue)
		 		setState(3263)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(3264)
		 		try {
		 				let assignmentValue = try charsetName()
		 				_localctx.castdown(LoadDataStatementContext.self).charset = assignmentValue
		 		     }()


		 	}

		 	setState(3273)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.COLUMNS.rawValue || _la == MySqlParser.Tokens.FIELDS.rawValue) {
		 		setState(3267)
		 		_localctx.castdown(LoadDataStatementContext.self).fieldsFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.COLUMNS.rawValue || _la == MySqlParser.Tokens.FIELDS.rawValue)) {
		 			_localctx.castdown(LoadDataStatementContext.self).fieldsFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3269) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(3268)
		 			try selectFieldsInto()


		 			setState(3271); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (_la == MySqlParser.Tokens.ENCLOSED.rawValue || _la == MySqlParser.Tokens.ESCAPED.rawValue || _la == MySqlParser.Tokens.OPTIONALLY.rawValue || _la == MySqlParser.Tokens.TERMINATED.rawValue)

		 	}

		 	setState(3281)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LINES.rawValue) {
		 		setState(3275)
		 		try match(MySqlParser.Tokens.LINES.rawValue)
		 		setState(3277) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(3276)
		 			try selectLinesInto()


		 			setState(3279); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (_la == MySqlParser.Tokens.STARTING.rawValue || _la == MySqlParser.Tokens.TERMINATED.rawValue)

		 	}

		 	setState(3287)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IGNORE.rawValue) {
		 		setState(3283)
		 		try match(MySqlParser.Tokens.IGNORE.rawValue)
		 		setState(3284)
		 		try decimalLiteral()
		 		setState(3285)
		 		_localctx.castdown(LoadDataStatementContext.self).linesFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.LINES.rawValue || _la == MySqlParser.Tokens.ROWS.rawValue)) {
		 			_localctx.castdown(LoadDataStatementContext.self).linesFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3300)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,439,_ctx)) {
		 	case 1:
		 		setState(3289)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3290)
		 		try assignmentField()
		 		setState(3295)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(3291)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3292)
		 			try assignmentField()


		 			setState(3297)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3298)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(3311)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,441,_ctx)) {
		 	case 1:
		 		setState(3302)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(3303)
		 		try updatedElement()
		 		setState(3308)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(3304)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3305)
		 			try updatedElement()


		 			setState(3310)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LoadXmlStatementContext: ParserRuleContext {
		open var priority: Token!
		open var filename: Token!
		open var violation: Token!
		open var charset: CharsetNameContext!
		open var tag: Token!
		open var linesFormat: Token!
			open
			func LOAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOAD.rawValue, 0)
			}
			open
			func XML() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XML.rawValue, 0)
			}
			open
			func INFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INFILE.rawValue, 0)
			}
			open
			func INTO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTO.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func STRING_LITERAL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.STRING_LITERAL.rawValue)
			}
			open
			func STRING_LITERAL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, i)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL.rawValue, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func SET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.SET.rawValue)
			}
			open
			func SET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, i)
			}
			open
			func ROWS() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ROWS.rawValue)
			}
			open
			func ROWS(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROWS.rawValue, i)
			}
			open
			func IDENTIFIED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IDENTIFIED.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func LESS_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LESS_SYMBOL.rawValue, 0)
			}
			open
			func GREATER_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GREATER_SYMBOL.rawValue, 0)
			}
			open
			func IGNORE() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.IGNORE.rawValue)
			}
			open
			func IGNORE(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE.rawValue, i)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func assignmentField() -> [AssignmentFieldContext] {
				return getRuleContexts(AssignmentFieldContext.self)
			}
			open
			func assignmentField(_ i: Int) -> AssignmentFieldContext? {
				return getRuleContext(AssignmentFieldContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func updatedElement() -> [UpdatedElementContext] {
				return getRuleContexts(UpdatedElementContext.self)
			}
			open
			func updatedElement(_ i: Int) -> UpdatedElementContext? {
				return getRuleContext(UpdatedElementContext.self, i)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func LOW_PRIORITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOW_PRIORITY.rawValue, 0)
			}
			open
			func CONCURRENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONCURRENT.rawValue, 0)
			}
			open
			func REPLACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLACE.rawValue, 0)
			}
			open
			func LINES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINES.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_loadXmlStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLoadXmlStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLoadXmlStatement(self)
			}
		}
	}
	@discardableResult
	 open func loadXmlStatement() throws -> LoadXmlStatementContext {
		var _localctx: LoadXmlStatementContext
		_localctx = LoadXmlStatementContext(_ctx, getState())
		try enterRule(_localctx, 196, MySqlParser.RULE_loadXmlStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3313)
		 	try match(MySqlParser.Tokens.LOAD.rawValue)
		 	setState(3314)
		 	try match(MySqlParser.Tokens.XML.rawValue)
		 	setState(3316)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LOW_PRIORITY.rawValue || _la == MySqlParser.Tokens.CONCURRENT.rawValue) {
		 		setState(3315)
		 		_localctx.castdown(LoadXmlStatementContext.self).priority = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.LOW_PRIORITY.rawValue || _la == MySqlParser.Tokens.CONCURRENT.rawValue)) {
		 			_localctx.castdown(LoadXmlStatementContext.self).priority = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3319)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LOCAL.rawValue) {
		 		setState(3318)
		 		try match(MySqlParser.Tokens.LOCAL.rawValue)

		 	}

		 	setState(3321)
		 	try match(MySqlParser.Tokens.INFILE.rawValue)
		 	setState(3322)
		 	try {
		 			let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 			_localctx.castdown(LoadXmlStatementContext.self).filename = assignmentValue
		 	     }()

		 	setState(3324)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IGNORE.rawValue || _la == MySqlParser.Tokens.REPLACE.rawValue) {
		 		setState(3323)
		 		_localctx.castdown(LoadXmlStatementContext.self).violation = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.IGNORE.rawValue || _la == MySqlParser.Tokens.REPLACE.rawValue)) {
		 			_localctx.castdown(LoadXmlStatementContext.self).violation = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3326)
		 	try match(MySqlParser.Tokens.INTO.rawValue)
		 	setState(3327)
		 	try match(MySqlParser.Tokens.TABLE.rawValue)
		 	setState(3328)
		 	try tableName()
		 	setState(3332)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.CHARACTER.rawValue) {
		 		setState(3329)
		 		try match(MySqlParser.Tokens.CHARACTER.rawValue)
		 		setState(3330)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(3331)
		 		try {
		 				let assignmentValue = try charsetName()
		 				_localctx.castdown(LoadXmlStatementContext.self).charset = assignmentValue
		 		     }()


		 	}

		 	setState(3340)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ROWS.rawValue) {
		 		setState(3334)
		 		try match(MySqlParser.Tokens.ROWS.rawValue)
		 		setState(3335)
		 		try match(MySqlParser.Tokens.IDENTIFIED.rawValue)
		 		setState(3336)
		 		try match(MySqlParser.Tokens.BY.rawValue)
		 		setState(3337)
		 		try match(MySqlParser.Tokens.LESS_SYMBOL.rawValue)
		 		setState(3338)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(LoadXmlStatementContext.self).tag = assignmentValue
		 		     }()

		 		setState(3339)
		 		try match(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)

		 	}

		 	setState(3346)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IGNORE.rawValue) {
		 		setState(3342)
		 		try match(MySqlParser.Tokens.IGNORE.rawValue)
		 		setState(3343)
		 		try decimalLiteral()
		 		setState(3344)
		 		_localctx.castdown(LoadXmlStatementContext.self).linesFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.LINES.rawValue || _la == MySqlParser.Tokens.ROWS.rawValue)) {
		 			_localctx.castdown(LoadXmlStatementContext.self).linesFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3359)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,449,_ctx)) {
		 	case 1:
		 		setState(3348)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3349)
		 		try assignmentField()
		 		setState(3354)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(3350)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3351)
		 			try assignmentField()


		 			setState(3356)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3357)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(3370)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,451,_ctx)) {
		 	case 1:
		 		setState(3361)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(3362)
		 		try updatedElement()
		 		setState(3367)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(3363)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3364)
		 			try updatedElement()


		 			setState(3369)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReplaceStatementContext: ParserRuleContext {
		open var priority: Token!
		open var partitions: UidListContext!
		open var columns: UidListContext!
		open var setFirst: UpdatedElementContext!
		open var _updatedElement: UpdatedElementContext!
		open var setElements: [UpdatedElementContext] = [UpdatedElementContext]()
			open
			func REPLACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLACE.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func insertStatementValue() -> InsertStatementValueContext? {
				return getRuleContext(InsertStatementValueContext.self, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func INTO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTO.rawValue, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func updatedElement() -> [UpdatedElementContext] {
				return getRuleContexts(UpdatedElementContext.self)
			}
			open
			func updatedElement(_ i: Int) -> UpdatedElementContext? {
				return getRuleContext(UpdatedElementContext.self, i)
			}
			open
			func uidList() -> [UidListContext] {
				return getRuleContexts(UidListContext.self)
			}
			open
			func uidList(_ i: Int) -> UidListContext? {
				return getRuleContext(UidListContext.self, i)
			}
			open
			func LOW_PRIORITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOW_PRIORITY.rawValue, 0)
			}
			open
			func DELAYED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DELAYED.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_replaceStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterReplaceStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitReplaceStatement(self)
			}
		}
	}
	@discardableResult
	 open func replaceStatement() throws -> ReplaceStatementContext {
		var _localctx: ReplaceStatementContext
		_localctx = ReplaceStatementContext(_ctx, getState())
		try enterRule(_localctx, 198, MySqlParser.RULE_replaceStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3372)
		 	try match(MySqlParser.Tokens.REPLACE.rawValue)
		 	setState(3374)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.DELAYED.rawValue || _la == MySqlParser.Tokens.LOW_PRIORITY.rawValue) {
		 		setState(3373)
		 		_localctx.castdown(ReplaceStatementContext.self).priority = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DELAYED.rawValue || _la == MySqlParser.Tokens.LOW_PRIORITY.rawValue)) {
		 			_localctx.castdown(ReplaceStatementContext.self).priority = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3377)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.INTO.rawValue) {
		 		setState(3376)
		 		try match(MySqlParser.Tokens.INTO.rawValue)

		 	}

		 	setState(3379)
		 	try tableName()
		 	setState(3385)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.PARTITION.rawValue) {
		 		setState(3380)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(3381)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3382)
		 		try {
		 				let assignmentValue = try uidList()
		 				_localctx.castdown(ReplaceStatementContext.self).partitions = assignmentValue
		 		     }()

		 		setState(3383)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(3403)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SELECT:fallthrough
		 	case .VALUES:fallthrough
		 	case .VALUE:fallthrough
		 	case .LR_BRACKET:
		 		setState(3391)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,455,_ctx)) {
		 		case 1:
		 			setState(3387)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(3388)
		 			try {
		 					let assignmentValue = try uidList()
		 					_localctx.castdown(ReplaceStatementContext.self).columns = assignmentValue
		 			     }()

		 			setState(3389)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(3393)
		 		try insertStatementValue()

		 		break

		 	case .SET:
		 		setState(3394)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(3395)
		 		try {
		 				let assignmentValue = try updatedElement()
		 				_localctx.castdown(ReplaceStatementContext.self).setFirst = assignmentValue
		 		     }()

		 		setState(3400)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(3396)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3397)
		 			try {
		 					let assignmentValue = try updatedElement()
		 					_localctx.castdown(ReplaceStatementContext.self)._updatedElement = assignmentValue
		 			     }()

		 			_localctx.castdown(ReplaceStatementContext.self).setElements.append(_localctx.castdown(ReplaceStatementContext.self)._updatedElement)


		 			setState(3402)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SelectStatementContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_selectStatement
		}
	}
	public class UnionSelectContext: SelectStatementContext {
		public var unionType: Token!
			open
			func querySpecificationNointo() -> QuerySpecificationNointoContext? {
				return getRuleContext(QuerySpecificationNointoContext.self, 0)
			}
			open
			func queryExpressionNointo() -> QueryExpressionNointoContext? {
				return getRuleContext(QueryExpressionNointoContext.self, 0)
			}
			open
			func unionStatement() -> [UnionStatementContext] {
				return getRuleContexts(UnionStatementContext.self)
			}
			open
			func unionStatement(_ i: Int) -> UnionStatementContext? {
				return getRuleContext(UnionStatementContext.self, i)
			}
			open
			func UNION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNION.rawValue, 0)
			}
			open
			func orderByClause() -> OrderByClauseContext? {
				return getRuleContext(OrderByClauseContext.self, 0)
			}
			open
			func limitClause() -> LimitClauseContext? {
				return getRuleContext(LimitClauseContext.self, 0)
			}
			open
			func lockClause() -> LockClauseContext? {
				return getRuleContext(LockClauseContext.self, 0)
			}
			open
			func querySpecification() -> QuerySpecificationContext? {
				return getRuleContext(QuerySpecificationContext.self, 0)
			}
			open
			func queryExpression() -> QueryExpressionContext? {
				return getRuleContext(QueryExpressionContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func DISTINCT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISTINCT.rawValue, 0)
			}

		public
		init(_ ctx: SelectStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUnionSelect(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUnionSelect(self)
			}
		}
	}
	public class UnionParenthesisSelectContext: SelectStatementContext {
		public var unionType: Token!
			open
			func queryExpressionNointo() -> QueryExpressionNointoContext? {
				return getRuleContext(QueryExpressionNointoContext.self, 0)
			}
			open
			func unionParenthesis() -> [UnionParenthesisContext] {
				return getRuleContexts(UnionParenthesisContext.self)
			}
			open
			func unionParenthesis(_ i: Int) -> UnionParenthesisContext? {
				return getRuleContext(UnionParenthesisContext.self, i)
			}
			open
			func UNION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNION.rawValue, 0)
			}
			open
			func queryExpression() -> QueryExpressionContext? {
				return getRuleContext(QueryExpressionContext.self, 0)
			}
			open
			func orderByClause() -> OrderByClauseContext? {
				return getRuleContext(OrderByClauseContext.self, 0)
			}
			open
			func limitClause() -> LimitClauseContext? {
				return getRuleContext(LimitClauseContext.self, 0)
			}
			open
			func lockClause() -> LockClauseContext? {
				return getRuleContext(LockClauseContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func DISTINCT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISTINCT.rawValue, 0)
			}

		public
		init(_ ctx: SelectStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUnionParenthesisSelect(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUnionParenthesisSelect(self)
			}
		}
	}
	public class SimpleSelectContext: SelectStatementContext {
			open
			func querySpecification() -> QuerySpecificationContext? {
				return getRuleContext(QuerySpecificationContext.self, 0)
			}
			open
			func lockClause() -> LockClauseContext? {
				return getRuleContext(LockClauseContext.self, 0)
			}

		public
		init(_ ctx: SelectStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSimpleSelect(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSimpleSelect(self)
			}
		}
	}
	public class ParenthesisSelectContext: SelectStatementContext {
			open
			func queryExpression() -> QueryExpressionContext? {
				return getRuleContext(QueryExpressionContext.self, 0)
			}
			open
			func lockClause() -> LockClauseContext? {
				return getRuleContext(LockClauseContext.self, 0)
			}

		public
		init(_ ctx: SelectStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterParenthesisSelect(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitParenthesisSelect(self)
			}
		}
	}
	public class WithLateralStatementContext: SelectStatementContext {
			open
			func querySpecificationNointo() -> QuerySpecificationNointoContext? {
				return getRuleContext(QuerySpecificationNointoContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func lateralStatement() -> [LateralStatementContext] {
				return getRuleContexts(LateralStatementContext.self)
			}
			open
			func lateralStatement(_ i: Int) -> LateralStatementContext? {
				return getRuleContext(LateralStatementContext.self, i)
			}

		public
		init(_ ctx: SelectStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterWithLateralStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitWithLateralStatement(self)
			}
		}
	}
	@discardableResult
	 open func selectStatement() throws -> SelectStatementContext {
		var _localctx: SelectStatementContext
		_localctx = SelectStatementContext(_ctx, getState())
		try enterRule(_localctx, 200, MySqlParser.RULE_selectStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(3470)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,475, _ctx)) {
		 	case 1:
		 		_localctx =  SimpleSelectContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3405)
		 		try querySpecification()
		 		setState(3407)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,458,_ctx)) {
		 		case 1:
		 			setState(3406)
		 			try lockClause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		_localctx =  ParenthesisSelectContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3409)
		 		try queryExpression()
		 		setState(3411)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,459,_ctx)) {
		 		case 1:
		 			setState(3410)
		 			try lockClause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		_localctx =  UnionSelectContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3415)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .SELECT:
		 			setState(3413)
		 			try querySpecificationNointo()

		 			break

		 		case .LR_BRACKET:
		 			setState(3414)
		 			try queryExpressionNointo()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(3418); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(3417)
		 				try unionStatement()


		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(3420); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,461,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 		setState(3430)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.UNION.rawValue) {
		 			setState(3422)
		 			try match(MySqlParser.Tokens.UNION.rawValue)
		 			setState(3424)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.ALL.rawValue || _la == MySqlParser.Tokens.DISTINCT.rawValue) {
		 				setState(3423)
		 				_localctx.castdown(UnionSelectContext.self).unionType = try _input.LT(1)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.ALL.rawValue || _la == MySqlParser.Tokens.DISTINCT.rawValue)) {
		 					_localctx.castdown(UnionSelectContext.self).unionType = try _errHandler.recoverInline(self) as Token
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 			}

		 			setState(3428)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .SELECT:
		 				setState(3426)
		 				try querySpecification()

		 				break

		 			case .LR_BRACKET:
		 				setState(3427)
		 				try queryExpression()

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 		}

		 		setState(3433)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,465,_ctx)) {
		 		case 1:
		 			setState(3432)
		 			try orderByClause()

		 			break
		 		default: break
		 		}
		 		setState(3436)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LIMIT.rawValue) {
		 			setState(3435)
		 			try limitClause()

		 		}

		 		setState(3439)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,467,_ctx)) {
		 		case 1:
		 			setState(3438)
		 			try lockClause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		_localctx =  UnionParenthesisSelectContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3441)
		 		try queryExpressionNointo()
		 		setState(3443); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(3442)
		 				try unionParenthesis()


		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(3445); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,468,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 		setState(3452)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.UNION.rawValue) {
		 			setState(3447)
		 			try match(MySqlParser.Tokens.UNION.rawValue)
		 			setState(3449)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.ALL.rawValue || _la == MySqlParser.Tokens.DISTINCT.rawValue) {
		 				setState(3448)
		 				_localctx.castdown(UnionParenthesisSelectContext.self).unionType = try _input.LT(1)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.ALL.rawValue || _la == MySqlParser.Tokens.DISTINCT.rawValue)) {
		 					_localctx.castdown(UnionParenthesisSelectContext.self).unionType = try _errHandler.recoverInline(self) as Token
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 			}

		 			setState(3451)
		 			try queryExpression()

		 		}

		 		setState(3455)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,471,_ctx)) {
		 		case 1:
		 			setState(3454)
		 			try orderByClause()

		 			break
		 		default: break
		 		}
		 		setState(3458)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LIMIT.rawValue) {
		 			setState(3457)
		 			try limitClause()

		 		}

		 		setState(3461)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,473,_ctx)) {
		 		case 1:
		 			setState(3460)
		 			try lockClause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 5:
		 		_localctx =  WithLateralStatementContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(3463)
		 		try querySpecificationNointo()
		 		setState(3466) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(3464)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3465)
		 			try lateralStatement()


		 			setState(3468); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (_la == MySqlParser.Tokens.COMMA.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UpdateStatementContext: ParserRuleContext {
			open
			func singleUpdateStatement() -> SingleUpdateStatementContext? {
				return getRuleContext(SingleUpdateStatementContext.self, 0)
			}
			open
			func multipleUpdateStatement() -> MultipleUpdateStatementContext? {
				return getRuleContext(MultipleUpdateStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_updateStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUpdateStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUpdateStatement(self)
			}
		}
	}
	@discardableResult
	 open func updateStatement() throws -> UpdateStatementContext {
		var _localctx: UpdateStatementContext
		_localctx = UpdateStatementContext(_ctx, getState())
		try enterRule(_localctx, 202, MySqlParser.RULE_updateStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3474)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,476, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3472)
		 		try singleUpdateStatement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3473)
		 		try multipleUpdateStatement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ValuesStatementContext: ParserRuleContext {
			open
			func VALUES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUES.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func expressionsWithDefaults() -> [ExpressionsWithDefaultsContext] {
				return getRuleContexts(ExpressionsWithDefaultsContext.self)
			}
			open
			func expressionsWithDefaults(_ i: Int) -> ExpressionsWithDefaultsContext? {
				return getRuleContext(ExpressionsWithDefaultsContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_valuesStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterValuesStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitValuesStatement(self)
			}
		}
	}
	@discardableResult
	 open func valuesStatement() throws -> ValuesStatementContext {
		var _localctx: ValuesStatementContext
		_localctx = ValuesStatementContext(_ctx, getState())
		try enterRule(_localctx, 204, MySqlParser.RULE_valuesStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3476)
		 	try match(MySqlParser.Tokens.VALUES.rawValue)
		 	setState(3477)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(3479)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,477,_ctx)) {
		 	case 1:
		 		setState(3478)
		 		try expressionsWithDefaults()

		 		break
		 	default: break
		 	}
		 	setState(3481)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(3490)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(3482)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(3483)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3485)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,478,_ctx)) {
		 		case 1:
		 			setState(3484)
		 			try expressionsWithDefaults()

		 			break
		 		default: break
		 		}
		 		setState(3487)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)


		 		setState(3492)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InsertStatementValueContext: ParserRuleContext {
		open var insertFormat: Token!
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func VALUES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUES.rawValue, 0)
			}
			open
			func VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUE.rawValue, 0)
			}
			open
			func expressionsWithDefaults() -> [ExpressionsWithDefaultsContext] {
				return getRuleContexts(ExpressionsWithDefaultsContext.self)
			}
			open
			func expressionsWithDefaults(_ i: Int) -> ExpressionsWithDefaultsContext? {
				return getRuleContext(ExpressionsWithDefaultsContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_insertStatementValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterInsertStatementValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitInsertStatementValue(self)
			}
		}
	}
	@discardableResult
	 open func insertStatementValue() throws -> InsertStatementValueContext {
		var _localctx: InsertStatementValueContext
		_localctx = InsertStatementValueContext(_ctx, getState())
		try enterRule(_localctx, 206, MySqlParser.RULE_insertStatementValue)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3511)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SELECT:fallthrough
		 	case .LR_BRACKET:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3493)
		 		try selectStatement()

		 		break
		 	case .VALUES:fallthrough
		 	case .VALUE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3494)
		 		_localctx.castdown(InsertStatementValueContext.self).insertFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.VALUES.rawValue || _la == MySqlParser.Tokens.VALUE.rawValue)) {
		 			_localctx.castdown(InsertStatementValueContext.self).insertFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3495)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3497)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,480,_ctx)) {
		 		case 1:
		 			setState(3496)
		 			try expressionsWithDefaults()

		 			break
		 		default: break
		 		}
		 		setState(3499)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(3508)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(3500)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3501)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(3503)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,481,_ctx)) {
		 			case 1:
		 				setState(3502)
		 				try expressionsWithDefaults()

		 				break
		 			default: break
		 			}
		 			setState(3505)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)


		 			setState(3510)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UpdatedElementContext: ParserRuleContext {
			open
			func fullColumnName() -> FullColumnNameContext? {
				return getRuleContext(FullColumnNameContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_updatedElement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUpdatedElement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUpdatedElement(self)
			}
		}
	}
	@discardableResult
	 open func updatedElement() throws -> UpdatedElementContext {
		var _localctx: UpdatedElementContext
		_localctx = UpdatedElementContext(_ctx, getState())
		try enterRule(_localctx, 208, MySqlParser.RULE_updatedElement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3513)
		 	try fullColumnName()
		 	setState(3514)
		 	try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 	setState(3517)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,484, _ctx)) {
		 	case 1:
		 		setState(3515)
		 		try expression(0)

		 		break
		 	case 2:
		 		setState(3516)
		 		try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AssignmentFieldContext: ParserRuleContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func LOCAL_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL_ID.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_assignmentField
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAssignmentField(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAssignmentField(self)
			}
		}
	}
	@discardableResult
	 open func assignmentField() throws -> AssignmentFieldContext {
		var _localctx: AssignmentFieldContext
		_localctx = AssignmentFieldContext(_ctx, getState())
		try enterRule(_localctx, 210, MySqlParser.RULE_assignmentField)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3521)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ARRAY:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .BUCKETS:fallthrough
		 	case .CONDITION:fallthrough
		 	case .CURRENT:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DIAGNOSTICS:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENFORCED:fallthrough
		 	case .EXCEPT:fallthrough
		 	case .GROUP:fallthrough
		 	case .IF:fallthrough
		 	case .IGNORED:fallthrough
		 	case .INSERT:fallthrough
		 	case .LATERAL:fallthrough
		 	case .LEFT:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OPTIONAL:fallthrough
		 	case .ORDER:fallthrough
		 	case .PRIMARY:fallthrough
		 	case .REPEAT:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SKIP_QUERY_REWRITE:fallthrough
		 	case .STACKED:fallthrough
		 	case .DATE:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .DATETIME:fallthrough
		 	case .YEAR:fallthrough
		 	case .BINARY:fallthrough
		 	case .TEXT:fallthrough
		 	case .ENUM:fallthrough
		 	case .SERIAL:fallthrough
		 	case .JSON_ARRAY:fallthrough
		 	case .JSON_ARRAYAGG:fallthrough
		 	case .JSON_ARRAY_APPEND:fallthrough
		 	case .JSON_ARRAY_INSERT:fallthrough
		 	case .JSON_CONTAINS:fallthrough
		 	case .JSON_CONTAINS_PATH:fallthrough
		 	case .JSON_DEPTH:fallthrough
		 	case .JSON_EXTRACT:fallthrough
		 	case .JSON_INSERT:fallthrough
		 	case .JSON_KEYS:fallthrough
		 	case .JSON_LENGTH:fallthrough
		 	case .JSON_MERGE:fallthrough
		 	case .JSON_MERGE_PATCH:fallthrough
		 	case .JSON_MERGE_PRESERVE:fallthrough
		 	case .JSON_OBJECT:fallthrough
		 	case .JSON_OBJECTAGG:fallthrough
		 	case .JSON_OVERLAPS:fallthrough
		 	case .JSON_PRETTY:fallthrough
		 	case .JSON_QUOTE:fallthrough
		 	case .JSON_REMOVE:fallthrough
		 	case .JSON_REPLACE:fallthrough
		 	case .JSON_SCHEMA_VALID:fallthrough
		 	case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 	case .JSON_SEARCH:fallthrough
		 	case .JSON_SET:fallthrough
		 	case .JSON_STORAGE_FREE:fallthrough
		 	case .JSON_STORAGE_SIZE:fallthrough
		 	case .JSON_TABLE:fallthrough
		 	case .JSON_TYPE:fallthrough
		 	case .JSON_UNQUOTE:fallthrough
		 	case .JSON_VALID:fallthrough
		 	case .JSON_VALUE:fallthrough
		 	case .NESTED:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .PATH:fallthrough
		 	case .AVG:fallthrough
		 	case .BIT_AND:fallthrough
		 	case .BIT_OR:fallthrough
		 	case .BIT_XOR:fallthrough
		 	case .COUNT:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .GROUP_CONCAT:fallthrough
		 	case .LAG:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NTH_VALUE:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .STD:fallthrough
		 	case .STDDEV:fallthrough
		 	case .STDDEV_POP:fallthrough
		 	case .STDDEV_SAMP:fallthrough
		 	case .SUM:fallthrough
		 	case .VAR_POP:fallthrough
		 	case .VAR_SAMP:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .CURRENT_DATE:fallthrough
		 	case .CURRENT_TIME:fallthrough
		 	case .CURRENT_TIMESTAMP:fallthrough
		 	case .LOCALTIME:fallthrough
		 	case .CURDATE:fallthrough
		 	case .CURTIME:fallthrough
		 	case .DATE_ADD:fallthrough
		 	case .DATE_SUB:fallthrough
		 	case .LOCALTIMESTAMP:fallthrough
		 	case .NOW:fallthrough
		 	case .POSITION:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .SUBSTRING:fallthrough
		 	case .SYSDATE:fallthrough
		 	case .TRIM:fallthrough
		 	case .UTC_DATE:fallthrough
		 	case .UTC_TIME:fallthrough
		 	case .UTC_TIMESTAMP:fallthrough
		 	case .ACCOUNT:fallthrough
		 	case .ACTION:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALGORITHM:fallthrough
		 	case .ANY:fallthrough
		 	case .AT:fallthrough
		 	case .AUTHORS:fallthrough
		 	case .AUTOCOMMIT:fallthrough
		 	case .AUTOEXTEND_SIZE:fallthrough
		 	case .AUTO_INCREMENT:fallthrough
		 	case .AVG_ROW_LENGTH:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BINLOG:fallthrough
		 	case .BIT:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BOOL:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BTREE:fallthrough
		 	case .CACHE:fallthrough
		 	case .CASCADED:fallthrough
		 	case .CHAIN:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CHECKSUM:fallthrough
		 	case .PAGE_CHECKSUM:fallthrough
		 	case .CIPHER:fallthrough
		 	case .CLASS_ORIGIN:fallthrough
		 	case .CLIENT:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTERING:fallthrough
		 	case .COALESCE:fallthrough
		 	case .CODE:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COLUMN_FORMAT:fallthrough
		 	case .COLUMN_NAME:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMPACT:fallthrough
		 	case .COMPLETION:fallthrough
		 	case .COMPRESSED:fallthrough
		 	case .COMPRESSION:fallthrough
		 	case .CONCURRENT:fallthrough
		 	case .CONNECT:fallthrough
		 	case .CONNECTION:fallthrough
		 	case .CONSISTENT:fallthrough
		 	case .CONSTRAINT_CATALOG:fallthrough
		 	case .CONSTRAINT_SCHEMA:fallthrough
		 	case .CONSTRAINT_NAME:fallthrough
		 	case .CONTAINS:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTRIBUTORS:fallthrough
		 	case .COPY:fallthrough
		 	case .CPU:fallthrough
		 	case .CURSOR_NAME:fallthrough
		 	case .DATA:fallthrough
		 	case .DATAFILE:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DEFAULT_AUTH:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DELAY_KEY_WRITE:fallthrough
		 	case .DES_KEY_FILE:fallthrough
		 	case .DIRECTORY:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISCARD:fallthrough
		 	case .DISK:fallthrough
		 	case .DO:fallthrough
		 	case .DUMPFILE:fallthrough
		 	case .DUPLICATE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .END:fallthrough
		 	case .ENDS:fallthrough
		 	case .ENGINE:fallthrough
		 	case .ENGINES:fallthrough
		 	case .ERROR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVEN:fallthrough
		 	case .EVENT:fallthrough
		 	case .EVENTS:fallthrough
		 	case .EVERY:fallthrough
		 	case .EXCHANGE:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPIRE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .EXTENT_SIZE:fallthrough
		 	case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 	case .FAST:fallthrough
		 	case .FAULTS:fallthrough
		 	case .FIELDS:fallthrough
		 	case .FILE_BLOCK_SIZE:fallthrough
		 	case .FILTER:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIXED:fallthrough
		 	case .FLUSH:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FOUND:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GENERAL:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GRANTS:fallthrough
		 	case .GROUP_REPLICATION:fallthrough
		 	case .HANDLER:fallthrough
		 	case .HASH:fallthrough
		 	case .HELP:fallthrough
		 	case .HISTORY:fallthrough
		 	case .HOST:fallthrough
		 	case .HOSTS:fallthrough
		 	case .IDENTIFIED:fallthrough
		 	case .IGNORE_SERVER_IDS:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INDEXES:fallthrough
		 	case .INITIAL_SIZE:fallthrough
		 	case .INPLACE:fallthrough
		 	case .INSERT_METHOD:fallthrough
		 	case .INSTALL:fallthrough
		 	case .INSTANCE:fallthrough
		 	case .INSTANT:fallthrough
		 	case .INVISIBLE:fallthrough
		 	case .INVOKER:fallthrough
		 	case .IO:fallthrough
		 	case .IO_THREAD:fallthrough
		 	case .IPC:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ISSUER:fallthrough
		 	case .JSON:fallthrough
		 	case .KEY_BLOCK_SIZE:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LEAVES:fallthrough
		 	case .LESS:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOGFILE:fallthrough
		 	case .LOGS:fallthrough
		 	case .MASTER:fallthrough
		 	case .MASTER_AUTO_POSITION:fallthrough
		 	case .MASTER_CONNECT_RETRY:fallthrough
		 	case .MASTER_DELAY:fallthrough
		 	case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 	case .MASTER_HOST:fallthrough
		 	case .MASTER_LOG_FILE:fallthrough
		 	case .MASTER_LOG_POS:fallthrough
		 	case .MASTER_PASSWORD:fallthrough
		 	case .MASTER_PORT:fallthrough
		 	case .MASTER_RETRY_COUNT:fallthrough
		 	case .MASTER_SSL:fallthrough
		 	case .MASTER_SSL_CA:fallthrough
		 	case .MASTER_SSL_CAPATH:fallthrough
		 	case .MASTER_SSL_CERT:fallthrough
		 	case .MASTER_SSL_CIPHER:fallthrough
		 	case .MASTER_SSL_CRL:fallthrough
		 	case .MASTER_SSL_CRLPATH:fallthrough
		 	case .MASTER_SSL_KEY:fallthrough
		 	case .MASTER_TLS_VERSION:fallthrough
		 	case .MASTER_USER:fallthrough
		 	case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 	case .MAX_QUERIES_PER_HOUR:fallthrough
		 	case .MAX_ROWS:fallthrough
		 	case .MAX_SIZE:fallthrough
		 	case .MAX_UPDATES_PER_HOUR:fallthrough
		 	case .MAX_USER_CONNECTIONS:fallthrough
		 	case .MEDIUM:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MESSAGE_TEXT:fallthrough
		 	case .MID:fallthrough
		 	case .MIGRATE:fallthrough
		 	case .MIN_ROWS:fallthrough
		 	case .MODE:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MUTEX:fallthrough
		 	case .MYSQL:fallthrough
		 	case .MYSQL_ERRNO:fallthrough
		 	case .NAME:fallthrough
		 	case .NAMES:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NEVER:fallthrough
		 	case .NEXT:fallthrough
		 	case .NO:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOWAIT:fallthrough
		 	case .NODEGROUP:fallthrough
		 	case .NONE:fallthrough
		 	case .ODBC:fallthrough
		 	case .OFFLINE:fallthrough
		 	case .OFFSET:fallthrough
		 	case .OF:fallthrough
		 	case .OJ:fallthrough
		 	case .OLD_PASSWORD:fallthrough
		 	case .ONE:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .OPTIMIZER_COSTS:fallthrough
		 	case .OPTIONS:fallthrough
		 	case .OWNER:fallthrough
		 	case .PACK_KEYS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PARSER:fallthrough
		 	case .PARTIAL:fallthrough
		 	case .PARTITIONING:fallthrough
		 	case .PARTITIONS:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PASSWORD_LOCK_TIME:fallthrough
		 	case .PHASE:fallthrough
		 	case .PLUGIN:fallthrough
		 	case .PLUGIN_DIR:fallthrough
		 	case .PLUGINS:fallthrough
		 	case .PORT:fallthrough
		 	case .PRECEDES:fallthrough
		 	case .PREPARE:fallthrough
		 	case .PRESERVE:fallthrough
		 	case .PREV:fallthrough
		 	case .PROCESSLIST:fallthrough
		 	case .PROFILE:fallthrough
		 	case .PROFILES:fallthrough
		 	case .PROXY:fallthrough
		 	case .QUERY:fallthrough
		 	case .QUICK:fallthrough
		 	case .REBUILD:fallthrough
		 	case .RECOVER:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REDO_BUFFER_SIZE:fallthrough
		 	case .REDUNDANT:fallthrough
		 	case .RELAY:fallthrough
		 	case .RELAY_LOG_FILE:fallthrough
		 	case .RELAY_LOG_POS:fallthrough
		 	case .RELAYLOG:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REORGANIZE:fallthrough
		 	case .REPAIR:fallthrough
		 	case .REPLICATE_DO_DB:fallthrough
		 	case .REPLICATE_DO_TABLE:fallthrough
		 	case .REPLICATE_IGNORE_DB:fallthrough
		 	case .REPLICATE_IGNORE_TABLE:fallthrough
		 	case .REPLICATE_REWRITE_DB:fallthrough
		 	case .REPLICATE_WILD_DO_TABLE:fallthrough
		 	case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 	case .REPLICATION:fallthrough
		 	case .RESET:fallthrough
		 	case .RESUME:fallthrough
		 	case .RETURNED_SQLSTATE:fallthrough
		 	case .RETURNING:fallthrough
		 	case .RETURNS:fallthrough
		 	case .REUSE:fallthrough
		 	case .ROLE:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROTATE:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_FORMAT:fallthrough
		 	case .RTREE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEDULE:fallthrough
		 	case .SECURITY:fallthrough
		 	case .SERVER:fallthrough
		 	case .SESSION:fallthrough
		 	case .SHARE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SIGNED:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SLAVE:fallthrough
		 	case .SLOW:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOCKET:fallthrough
		 	case .SOME:fallthrough
		 	case .SONAME:fallthrough
		 	case .SOUNDS:fallthrough
		 	case .SOURCE:fallthrough
		 	case .SQL_AFTER_GTIDS:fallthrough
		 	case .SQL_AFTER_MTS_GAPS:fallthrough
		 	case .SQL_BEFORE_GTIDS:fallthrough
		 	case .SQL_BUFFER_RESULT:fallthrough
		 	case .SQL_CACHE:fallthrough
		 	case .SQL_NO_CACHE:fallthrough
		 	case .SQL_THREAD:fallthrough
		 	case .START:fallthrough
		 	case .STARTS:fallthrough
		 	case .STATS_AUTO_RECALC:fallthrough
		 	case .STATS_PERSISTENT:fallthrough
		 	case .STATS_SAMPLE_PAGES:fallthrough
		 	case .STATUS:fallthrough
		 	case .STOP:fallthrough
		 	case .STORAGE:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBCLASS_ORIGIN:fallthrough
		 	case .SUBJECT:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBPARTITIONS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .SWAPS:fallthrough
		 	case .SWITCHES:fallthrough
		 	case .TABLE_NAME:fallthrough
		 	case .TABLESPACE:fallthrough
		 	case .TABLE_TYPE:fallthrough
		 	case .TEMPORARY:fallthrough
		 	case .TEMPTABLE:fallthrough
		 	case .THAN:fallthrough
		 	case .TRADITIONAL:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSACTIONAL:fallthrough
		 	case .TRIGGERS:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDEFINED:fallthrough
		 	case .UNDOFILE:fallthrough
		 	case .UNDO_BUFFER_SIZE:fallthrough
		 	case .UNINSTALL:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPGRADE:fallthrough
		 	case .USER:fallthrough
		 	case .USE_FRM:fallthrough
		 	case .USER_RESOURCES:fallthrough
		 	case .VALIDATION:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARIABLES:fallthrough
		 	case .VIEW:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .VISIBLE:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNINGS:fallthrough
		 	case .WITHOUT:fallthrough
		 	case .WORK:fallthrough
		 	case .WRAPPER:fallthrough
		 	case .X509:fallthrough
		 	case .XA:fallthrough
		 	case .XML:fallthrough
		 	case .EUR:fallthrough
		 	case .USA:fallthrough
		 	case .JIS:fallthrough
		 	case .ISO:fallthrough
		 	case .INTERNAL:fallthrough
		 	case .QUARTER:fallthrough
		 	case .MONTH:fallthrough
		 	case .DAY:fallthrough
		 	case .HOUR:fallthrough
		 	case .MINUTE:fallthrough
		 	case .WEEK:fallthrough
		 	case .SECOND:fallthrough
		 	case .MICROSECOND:fallthrough
		 	case .ADMIN:fallthrough
		 	case .AUDIT_ABORT_EXEMPT:fallthrough
		 	case .AUDIT_ADMIN:fallthrough
		 	case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 	case .BACKUP_ADMIN:fallthrough
		 	case .BINLOG_ADMIN:fallthrough
		 	case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 	case .CLONE_ADMIN:fallthrough
		 	case .CONNECTION_ADMIN:fallthrough
		 	case .ENCRYPTION_KEY_ADMIN:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .FILE:fallthrough
		 	case .FIREWALL_ADMIN:fallthrough
		 	case .FIREWALL_EXEMPT:fallthrough
		 	case .FIREWALL_USER:fallthrough
		 	case .GROUP_REPLICATION_ADMIN:fallthrough
		 	case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 	case .INVOKE:fallthrough
		 	case .LAMBDA:fallthrough
		 	case .NDB_STORED_USER:fallthrough
		 	case .PASSWORDLESS_USER_ADMIN:fallthrough
		 	case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .PROCESS:fallthrough
		 	case .RELOAD:fallthrough
		 	case .REPLICATION_APPLIER:fallthrough
		 	case .REPLICATION_SLAVE_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_USER:fallthrough
		 	case .ROLE_ADMIN:fallthrough
		 	case .ROUTINE:fallthrough
		 	case .S3:fallthrough
		 	case .SESSION_VARIABLES_ADMIN:fallthrough
		 	case .SET_USER_ID:fallthrough
		 	case .SHOW_ROUTINE:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SUPER:fallthrough
		 	case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 	case .TABLES:fallthrough
		 	case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 	case .VERSION_TOKEN_ADMIN:fallthrough
		 	case .XA_RECOVER_ADMIN:fallthrough
		 	case .ARMSCII8:fallthrough
		 	case .ASCII:fallthrough
		 	case .BIG5:fallthrough
		 	case .CP1250:fallthrough
		 	case .CP1251:fallthrough
		 	case .CP1256:fallthrough
		 	case .CP1257:fallthrough
		 	case .CP850:fallthrough
		 	case .CP852:fallthrough
		 	case .CP866:fallthrough
		 	case .CP932:fallthrough
		 	case .DEC8:fallthrough
		 	case .EUCJPMS:fallthrough
		 	case .EUCKR:fallthrough
		 	case .GB18030:fallthrough
		 	case .GB2312:fallthrough
		 	case .GBK:fallthrough
		 	case .GEOSTD8:fallthrough
		 	case .GREEK:fallthrough
		 	case .HEBREW:fallthrough
		 	case .HP8:fallthrough
		 	case .KEYBCS2:fallthrough
		 	case .KOI8R:fallthrough
		 	case .KOI8U:fallthrough
		 	case .LATIN1:fallthrough
		 	case .LATIN2:fallthrough
		 	case .LATIN5:fallthrough
		 	case .LATIN7:fallthrough
		 	case .MACCE:fallthrough
		 	case .MACROMAN:fallthrough
		 	case .SJIS:fallthrough
		 	case .SWE7:fallthrough
		 	case .TIS620:fallthrough
		 	case .UCS2:fallthrough
		 	case .UJIS:fallthrough
		 	case .UTF16:fallthrough
		 	case .UTF16LE:fallthrough
		 	case .UTF32:fallthrough
		 	case .UTF8:fallthrough
		 	case .UTF8MB3:fallthrough
		 	case .UTF8MB4:fallthrough
		 	case .ARCHIVE:fallthrough
		 	case .BLACKHOLE:fallthrough
		 	case .CSV:fallthrough
		 	case .FEDERATED:fallthrough
		 	case .INNODB:fallthrough
		 	case .MEMORY:fallthrough
		 	case .MRG_MYISAM:fallthrough
		 	case .MYISAM:fallthrough
		 	case .NDB:fallthrough
		 	case .NDBCLUSTER:fallthrough
		 	case .PERFORMANCE_SCHEMA:fallthrough
		 	case .TOKUDB:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .GEOMETRYCOLLECTION:fallthrough
		 	case .LINESTRING:fallthrough
		 	case .MULTILINESTRING:fallthrough
		 	case .MULTIPOINT:fallthrough
		 	case .MULTIPOLYGON:fallthrough
		 	case .POINT:fallthrough
		 	case .POLYGON:fallthrough
		 	case .ABS:fallthrough
		 	case .ACOS:fallthrough
		 	case .ADDDATE:fallthrough
		 	case .ADDTIME:fallthrough
		 	case .AES_DECRYPT:fallthrough
		 	case .AES_ENCRYPT:fallthrough
		 	case .AREA:fallthrough
		 	case .ASBINARY:fallthrough
		 	case .ASIN:fallthrough
		 	case .ASTEXT:fallthrough
		 	case .ASWKB:fallthrough
		 	case .ASWKT:fallthrough
		 	case .ASYMMETRIC_DECRYPT:fallthrough
		 	case .ASYMMETRIC_DERIVE:fallthrough
		 	case .ASYMMETRIC_ENCRYPT:fallthrough
		 	case .ASYMMETRIC_SIGN:fallthrough
		 	case .ASYMMETRIC_VERIFY:fallthrough
		 	case .ATAN:fallthrough
		 	case .ATAN2:fallthrough
		 	case .BENCHMARK:fallthrough
		 	case .BIN:fallthrough
		 	case .BIT_COUNT:fallthrough
		 	case .BIT_LENGTH:fallthrough
		 	case .BUFFER:fallthrough
		 	case .CATALOG_NAME:fallthrough
		 	case .CEIL:fallthrough
		 	case .CEILING:fallthrough
		 	case .CENTROID:fallthrough
		 	case .CHARACTER_LENGTH:fallthrough
		 	case .CHARSET:fallthrough
		 	case .CHAR_LENGTH:fallthrough
		 	case .COERCIBILITY:fallthrough
		 	case .COLLATION:fallthrough
		 	case .COMPRESS:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_WS:fallthrough
		 	case .CONNECTION_ID:fallthrough
		 	case .CONV:fallthrough
		 	case .CONVERT_TZ:fallthrough
		 	case .COS:fallthrough
		 	case .COT:fallthrough
		 	case .CRC32:fallthrough
		 	case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 	case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 	case .CREATE_DH_PARAMETERS:fallthrough
		 	case .CREATE_DIGEST:fallthrough
		 	case .CROSSES:fallthrough
		 	case .DATEDIFF:fallthrough
		 	case .DATE_FORMAT:fallthrough
		 	case .DAYNAME:fallthrough
		 	case .DAYOFMONTH:fallthrough
		 	case .DAYOFWEEK:fallthrough
		 	case .DAYOFYEAR:fallthrough
		 	case .DECODE:fallthrough
		 	case .DEGREES:fallthrough
		 	case .DES_DECRYPT:fallthrough
		 	case .DES_ENCRYPT:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISJOINT:fallthrough
		 	case .ELT:fallthrough
		 	case .ENCODE:fallthrough
		 	case .ENCRYPT:fallthrough
		 	case .ENDPOINT:fallthrough
		 	case .ENGINE_ATTRIBUTE:fallthrough
		 	case .ENVELOPE:fallthrough
		 	case .EQUALS:fallthrough
		 	case .EXP:fallthrough
		 	case .EXPORT_SET:fallthrough
		 	case .EXTERIORRING:fallthrough
		 	case .EXTRACTVALUE:fallthrough
		 	case .FIELD:fallthrough
		 	case .FIND_IN_SET:fallthrough
		 	case .FLOOR:fallthrough
		 	case .FORMAT:fallthrough
		 	case .FOUND_ROWS:fallthrough
		 	case .FROM_BASE64:fallthrough
		 	case .FROM_DAYS:fallthrough
		 	case .FROM_UNIXTIME:fallthrough
		 	case .GEOMCOLLFROMTEXT:fallthrough
		 	case .GEOMCOLLFROMWKB:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .GEOMETRYFROMTEXT:fallthrough
		 	case .GEOMETRYFROMWKB:fallthrough
		 	case .GEOMETRYN:fallthrough
		 	case .GEOMETRYTYPE:fallthrough
		 	case .GEOMFROMTEXT:fallthrough
		 	case .GEOMFROMWKB:fallthrough
		 	case .GET_FORMAT:fallthrough
		 	case .GET_LOCK:fallthrough
		 	case .GLENGTH:fallthrough
		 	case .GREATEST:fallthrough
		 	case .GTID_SUBSET:fallthrough
		 	case .GTID_SUBTRACT:fallthrough
		 	case .HEX:fallthrough
		 	case .IFNULL:fallthrough
		 	case .INET6_ATON:fallthrough
		 	case .INET6_NTOA:fallthrough
		 	case .INET_ATON:fallthrough
		 	case .INET_NTOA:fallthrough
		 	case .INSTR:fallthrough
		 	case .INTERIORRINGN:fallthrough
		 	case .INTERSECTS:fallthrough
		 	case .ISCLOSED:fallthrough
		 	case .ISEMPTY:fallthrough
		 	case .ISNULL:fallthrough
		 	case .ISSIMPLE:fallthrough
		 	case .IS_FREE_LOCK:fallthrough
		 	case .IS_IPV4:fallthrough
		 	case .IS_IPV4_COMPAT:fallthrough
		 	case .IS_IPV4_MAPPED:fallthrough
		 	case .IS_IPV6:fallthrough
		 	case .IS_USED_LOCK:fallthrough
		 	case .LAST_INSERT_ID:fallthrough
		 	case .LCASE:fallthrough
		 	case .LEAST:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LINEFROMTEXT:fallthrough
		 	case .LINEFROMWKB:fallthrough
		 	case .LINESTRINGFROMTEXT:fallthrough
		 	case .LINESTRINGFROMWKB:fallthrough
		 	case .LN:fallthrough
		 	case .LOAD_FILE:fallthrough
		 	case .LOCATE:fallthrough
		 	case .LOG:fallthrough
		 	case .LOG10:fallthrough
		 	case .LOG2:fallthrough
		 	case .LOWER:fallthrough
		 	case .LPAD:fallthrough
		 	case .LTRIM:fallthrough
		 	case .MAKEDATE:fallthrough
		 	case .MAKETIME:fallthrough
		 	case .MAKE_SET:fallthrough
		 	case .MASTER_POS_WAIT:fallthrough
		 	case .MBRCONTAINS:fallthrough
		 	case .MBRDISJOINT:fallthrough
		 	case .MBREQUAL:fallthrough
		 	case .MBRINTERSECTS:fallthrough
		 	case .MBROVERLAPS:fallthrough
		 	case .MBRTOUCHES:fallthrough
		 	case .MBRWITHIN:fallthrough
		 	case .MD5:fallthrough
		 	case .MLINEFROMTEXT:fallthrough
		 	case .MLINEFROMWKB:fallthrough
		 	case .MONTHNAME:fallthrough
		 	case .MPOINTFROMTEXT:fallthrough
		 	case .MPOINTFROMWKB:fallthrough
		 	case .MPOLYFROMTEXT:fallthrough
		 	case .MPOLYFROMWKB:fallthrough
		 	case .MULTILINESTRINGFROMTEXT:fallthrough
		 	case .MULTILINESTRINGFROMWKB:fallthrough
		 	case .MULTIPOINTFROMTEXT:fallthrough
		 	case .MULTIPOINTFROMWKB:fallthrough
		 	case .MULTIPOLYGONFROMTEXT:fallthrough
		 	case .MULTIPOLYGONFROMWKB:fallthrough
		 	case .NAME_CONST:fallthrough
		 	case .NULLIF:fallthrough
		 	case .NUMGEOMETRIES:fallthrough
		 	case .NUMINTERIORRINGS:fallthrough
		 	case .NUMPOINTS:fallthrough
		 	case .OCT:fallthrough
		 	case .OCTET_LENGTH:fallthrough
		 	case .ORD:fallthrough
		 	case .OVERLAPS:fallthrough
		 	case .PERIOD_ADD:fallthrough
		 	case .PERIOD_DIFF:fallthrough
		 	case .PI:fallthrough
		 	case .POINTFROMTEXT:fallthrough
		 	case .POINTFROMWKB:fallthrough
		 	case .POINTN:fallthrough
		 	case .POLYFROMTEXT:fallthrough
		 	case .POLYFROMWKB:fallthrough
		 	case .POLYGONFROMTEXT:fallthrough
		 	case .POLYGONFROMWKB:fallthrough
		 	case .POW:fallthrough
		 	case .POWER:fallthrough
		 	case .QUOTE:fallthrough
		 	case .RADIANS:fallthrough
		 	case .RAND:fallthrough
		 	case .RANDOM:fallthrough
		 	case .RANDOM_BYTES:fallthrough
		 	case .RELEASE_LOCK:fallthrough
		 	case .REVERSE:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_COUNT:fallthrough
		 	case .RPAD:fallthrough
		 	case .RTRIM:fallthrough
		 	case .SEC_TO_TIME:fallthrough
		 	case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 	case .SESSION_USER:fallthrough
		 	case .SHA:fallthrough
		 	case .SHA1:fallthrough
		 	case .SHA2:fallthrough
		 	case .SCHEMA_NAME:fallthrough
		 	case .SIGN:fallthrough
		 	case .SIN:fallthrough
		 	case .SLEEP:fallthrough
		 	case .SOUNDEX:fallthrough
		 	case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 	case .SQRT:fallthrough
		 	case .SRID:fallthrough
		 	case .STARTPOINT:fallthrough
		 	case .STRCMP:fallthrough
		 	case .STR_TO_DATE:fallthrough
		 	case .ST_AREA:fallthrough
		 	case .ST_ASBINARY:fallthrough
		 	case .ST_ASTEXT:fallthrough
		 	case .ST_ASWKB:fallthrough
		 	case .ST_ASWKT:fallthrough
		 	case .ST_BUFFER:fallthrough
		 	case .ST_CENTROID:fallthrough
		 	case .ST_CONTAINS:fallthrough
		 	case .ST_CROSSES:fallthrough
		 	case .ST_DIFFERENCE:fallthrough
		 	case .ST_DIMENSION:fallthrough
		 	case .ST_DISJOINT:fallthrough
		 	case .ST_DISTANCE:fallthrough
		 	case .ST_ENDPOINT:fallthrough
		 	case .ST_ENVELOPE:fallthrough
		 	case .ST_EQUALS:fallthrough
		 	case .ST_EXTERIORRING:fallthrough
		 	case .ST_GEOMCOLLFROMTEXT:fallthrough
		 	case .ST_GEOMCOLLFROMTXT:fallthrough
		 	case .ST_GEOMCOLLFROMWKB:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .ST_GEOMETRYFROMTEXT:fallthrough
		 	case .ST_GEOMETRYFROMWKB:fallthrough
		 	case .ST_GEOMETRYN:fallthrough
		 	case .ST_GEOMETRYTYPE:fallthrough
		 	case .ST_GEOMFROMTEXT:fallthrough
		 	case .ST_GEOMFROMWKB:fallthrough
		 	case .ST_INTERIORRINGN:fallthrough
		 	case .ST_INTERSECTION:fallthrough
		 	case .ST_INTERSECTS:fallthrough
		 	case .ST_ISCLOSED:fallthrough
		 	case .ST_ISEMPTY:fallthrough
		 	case .ST_ISSIMPLE:fallthrough
		 	case .ST_LINEFROMTEXT:fallthrough
		 	case .ST_LINEFROMWKB:fallthrough
		 	case .ST_LINESTRINGFROMTEXT:fallthrough
		 	case .ST_LINESTRINGFROMWKB:fallthrough
		 	case .ST_NUMGEOMETRIES:fallthrough
		 	case .ST_NUMINTERIORRING:fallthrough
		 	case .ST_NUMINTERIORRINGS:fallthrough
		 	case .ST_NUMPOINTS:fallthrough
		 	case .ST_OVERLAPS:fallthrough
		 	case .ST_POINTFROMTEXT:fallthrough
		 	case .ST_POINTFROMWKB:fallthrough
		 	case .ST_POINTN:fallthrough
		 	case .ST_POLYFROMTEXT:fallthrough
		 	case .ST_POLYFROMWKB:fallthrough
		 	case .ST_POLYGONFROMTEXT:fallthrough
		 	case .ST_POLYGONFROMWKB:fallthrough
		 	case .ST_SRID:fallthrough
		 	case .ST_STARTPOINT:fallthrough
		 	case .ST_SYMDIFFERENCE:fallthrough
		 	case .ST_TOUCHES:fallthrough
		 	case .ST_UNION:fallthrough
		 	case .ST_WITHIN:fallthrough
		 	case .ST_X:fallthrough
		 	case .ST_Y:fallthrough
		 	case .SUBDATE:fallthrough
		 	case .SUBSTRING_INDEX:fallthrough
		 	case .SUBTIME:fallthrough
		 	case .SYSTEM_USER:fallthrough
		 	case .TAN:fallthrough
		 	case .TIMEDIFF:fallthrough
		 	case .TIMESTAMPADD:fallthrough
		 	case .TIMESTAMPDIFF:fallthrough
		 	case .TIME_FORMAT:fallthrough
		 	case .TIME_TO_SEC:fallthrough
		 	case .TOUCHES:fallthrough
		 	case .TO_BASE64:fallthrough
		 	case .TO_DAYS:fallthrough
		 	case .TO_SECONDS:fallthrough
		 	case .TP_CONNECTION_ADMIN:fallthrough
		 	case .UCASE:fallthrough
		 	case .UNCOMPRESS:fallthrough
		 	case .UNCOMPRESSED_LENGTH:fallthrough
		 	case .UNHEX:fallthrough
		 	case .UNIX_TIMESTAMP:fallthrough
		 	case .UPDATEXML:fallthrough
		 	case .UPPER:fallthrough
		 	case .UUID:fallthrough
		 	case .UUID_SHORT:fallthrough
		 	case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 	case .VERSION:fallthrough
		 	case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 	case .WEEKDAY:fallthrough
		 	case .WEEKOFYEAR:fallthrough
		 	case .WEIGHT_STRING:fallthrough
		 	case .WITHIN:fallthrough
		 	case .YEARWEEK:fallthrough
		 	case .Y_FUNCTION:fallthrough
		 	case .X_FUNCTION:fallthrough
		 	case .MOD:fallthrough
		 	case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 	case .STRING_LITERAL:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3519)
		 		try uid()

		 		break

		 	case .LOCAL_ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3520)
		 		try match(MySqlParser.Tokens.LOCAL_ID.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LockClauseContext: ParserRuleContext {
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func UPDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPDATE.rawValue, 0)
			}
			open
			func LOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCK.rawValue, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, 0)
			}
			open
			func SHARE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHARE.rawValue, 0)
			}
			open
			func MODE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MODE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_lockClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLockClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLockClause(self)
			}
		}
	}
	@discardableResult
	 open func lockClause() throws -> LockClauseContext {
		var _localctx: LockClauseContext
		_localctx = LockClauseContext(_ctx, getState())
		try enterRule(_localctx, 212, MySqlParser.RULE_lockClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3529)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FOR:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3523)
		 		try match(MySqlParser.Tokens.FOR.rawValue)
		 		setState(3524)
		 		try match(MySqlParser.Tokens.UPDATE.rawValue)

		 		break

		 	case .LOCK:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3525)
		 		try match(MySqlParser.Tokens.LOCK.rawValue)
		 		setState(3526)
		 		try match(MySqlParser.Tokens.IN.rawValue)
		 		setState(3527)
		 		try match(MySqlParser.Tokens.SHARE.rawValue)
		 		setState(3528)
		 		try match(MySqlParser.Tokens.MODE.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SingleDeleteStatementContext: ParserRuleContext {
		open var priority: Token!
			open
			func DELETE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DELETE.rawValue, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func QUICK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUICK.rawValue, 0)
			}
			open
			func IGNORE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func WHERE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHERE.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func orderByClause() -> OrderByClauseContext? {
				return getRuleContext(OrderByClauseContext.self, 0)
			}
			open
			func LIMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIMIT.rawValue, 0)
			}
			open
			func limitClauseAtom() -> LimitClauseAtomContext? {
				return getRuleContext(LimitClauseAtomContext.self, 0)
			}
			open
			func LOW_PRIORITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOW_PRIORITY.rawValue, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_singleDeleteStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSingleDeleteStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSingleDeleteStatement(self)
			}
		}
	}
	@discardableResult
	 open func singleDeleteStatement() throws -> SingleDeleteStatementContext {
		var _localctx: SingleDeleteStatementContext
		_localctx = SingleDeleteStatementContext(_ctx, getState())
		try enterRule(_localctx, 214, MySqlParser.RULE_singleDeleteStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3531)
		 	try match(MySqlParser.Tokens.DELETE.rawValue)
		 	setState(3533)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LOW_PRIORITY.rawValue) {
		 		setState(3532)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.LOW_PRIORITY.rawValue)
		 				_localctx.castdown(SingleDeleteStatementContext.self).priority = assignmentValue
		 		     }()


		 	}

		 	setState(3536)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.QUICK.rawValue) {
		 		setState(3535)
		 		try match(MySqlParser.Tokens.QUICK.rawValue)

		 	}

		 	setState(3539)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IGNORE.rawValue) {
		 		setState(3538)
		 		try match(MySqlParser.Tokens.IGNORE.rawValue)

		 	}

		 	setState(3541)
		 	try match(MySqlParser.Tokens.FROM.rawValue)
		 	setState(3542)
		 	try tableName()
		 	setState(3547)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,491,_ctx)) {
		 	case 1:
		 		setState(3544)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.AS.rawValue) {
		 			setState(3543)
		 			try match(MySqlParser.Tokens.AS.rawValue)

		 		}

		 		setState(3546)
		 		try uid()

		 		break
		 	default: break
		 	}
		 	setState(3554)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.PARTITION.rawValue) {
		 		setState(3549)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(3550)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3551)
		 		try uidList()
		 		setState(3552)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(3558)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WHERE.rawValue) {
		 		setState(3556)
		 		try match(MySqlParser.Tokens.WHERE.rawValue)
		 		setState(3557)
		 		try expression(0)

		 	}

		 	setState(3561)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ORDER.rawValue) {
		 		setState(3560)
		 		try orderByClause()

		 	}

		 	setState(3565)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LIMIT.rawValue) {
		 		setState(3563)
		 		try match(MySqlParser.Tokens.LIMIT.rawValue)
		 		setState(3564)
		 		try limitClauseAtom()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultipleDeleteStatementContext: ParserRuleContext {
		open var priority: Token!
			open
			func DELETE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DELETE.rawValue, 0)
			}
			open
			func tableName() -> [TableNameContext] {
				return getRuleContexts(TableNameContext.self)
			}
			open
			func tableName(_ i: Int) -> TableNameContext? {
				return getRuleContext(TableNameContext.self, i)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func tableSources() -> TableSourcesContext? {
				return getRuleContext(TableSourcesContext.self, 0)
			}
			open
			func USING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USING.rawValue, 0)
			}
			open
			func QUICK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUICK.rawValue, 0)
			}
			open
			func IGNORE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE.rawValue, 0)
			}
			open
			func WHERE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHERE.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func LOW_PRIORITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOW_PRIORITY.rawValue, 0)
			}
			open
			func DOT() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.DOT.rawValue)
			}
			open
			func DOT(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DOT.rawValue, i)
			}
			open
			func STAR() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.STAR.rawValue)
			}
			open
			func STAR(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STAR.rawValue, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_multipleDeleteStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMultipleDeleteStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMultipleDeleteStatement(self)
			}
		}
	}
	@discardableResult
	 open func multipleDeleteStatement() throws -> MultipleDeleteStatementContext {
		var _localctx: MultipleDeleteStatementContext
		_localctx = MultipleDeleteStatementContext(_ctx, getState())
		try enterRule(_localctx, 216, MySqlParser.RULE_multipleDeleteStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3567)
		 	try match(MySqlParser.Tokens.DELETE.rawValue)
		 	setState(3569)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LOW_PRIORITY.rawValue) {
		 		setState(3568)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.LOW_PRIORITY.rawValue)
		 				_localctx.castdown(MultipleDeleteStatementContext.self).priority = assignmentValue
		 		     }()


		 	}

		 	setState(3572)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,497,_ctx)) {
		 	case 1:
		 		setState(3571)
		 		try match(MySqlParser.Tokens.QUICK.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(3575)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IGNORE.rawValue) {
		 		setState(3574)
		 		try match(MySqlParser.Tokens.IGNORE.rawValue)

		 	}

		 	setState(3616)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ARRAY:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .BUCKETS:fallthrough
		 	case .CONDITION:fallthrough
		 	case .CURRENT:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DIAGNOSTICS:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENFORCED:fallthrough
		 	case .EXCEPT:fallthrough
		 	case .GROUP:fallthrough
		 	case .IF:fallthrough
		 	case .IGNORED:fallthrough
		 	case .INSERT:fallthrough
		 	case .LATERAL:fallthrough
		 	case .LEFT:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OPTIONAL:fallthrough
		 	case .ORDER:fallthrough
		 	case .PRIMARY:fallthrough
		 	case .REPEAT:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SKIP_QUERY_REWRITE:fallthrough
		 	case .STACKED:fallthrough
		 	case .DATE:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .DATETIME:fallthrough
		 	case .YEAR:fallthrough
		 	case .BINARY:fallthrough
		 	case .TEXT:fallthrough
		 	case .ENUM:fallthrough
		 	case .SERIAL:fallthrough
		 	case .JSON_ARRAY:fallthrough
		 	case .JSON_ARRAYAGG:fallthrough
		 	case .JSON_ARRAY_APPEND:fallthrough
		 	case .JSON_ARRAY_INSERT:fallthrough
		 	case .JSON_CONTAINS:fallthrough
		 	case .JSON_CONTAINS_PATH:fallthrough
		 	case .JSON_DEPTH:fallthrough
		 	case .JSON_EXTRACT:fallthrough
		 	case .JSON_INSERT:fallthrough
		 	case .JSON_KEYS:fallthrough
		 	case .JSON_LENGTH:fallthrough
		 	case .JSON_MERGE:fallthrough
		 	case .JSON_MERGE_PATCH:fallthrough
		 	case .JSON_MERGE_PRESERVE:fallthrough
		 	case .JSON_OBJECT:fallthrough
		 	case .JSON_OBJECTAGG:fallthrough
		 	case .JSON_OVERLAPS:fallthrough
		 	case .JSON_PRETTY:fallthrough
		 	case .JSON_QUOTE:fallthrough
		 	case .JSON_REMOVE:fallthrough
		 	case .JSON_REPLACE:fallthrough
		 	case .JSON_SCHEMA_VALID:fallthrough
		 	case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 	case .JSON_SEARCH:fallthrough
		 	case .JSON_SET:fallthrough
		 	case .JSON_STORAGE_FREE:fallthrough
		 	case .JSON_STORAGE_SIZE:fallthrough
		 	case .JSON_TABLE:fallthrough
		 	case .JSON_TYPE:fallthrough
		 	case .JSON_UNQUOTE:fallthrough
		 	case .JSON_VALID:fallthrough
		 	case .JSON_VALUE:fallthrough
		 	case .NESTED:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .PATH:fallthrough
		 	case .AVG:fallthrough
		 	case .BIT_AND:fallthrough
		 	case .BIT_OR:fallthrough
		 	case .BIT_XOR:fallthrough
		 	case .COUNT:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .GROUP_CONCAT:fallthrough
		 	case .LAG:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NTH_VALUE:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .STD:fallthrough
		 	case .STDDEV:fallthrough
		 	case .STDDEV_POP:fallthrough
		 	case .STDDEV_SAMP:fallthrough
		 	case .SUM:fallthrough
		 	case .VAR_POP:fallthrough
		 	case .VAR_SAMP:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .CURRENT_DATE:fallthrough
		 	case .CURRENT_TIME:fallthrough
		 	case .CURRENT_TIMESTAMP:fallthrough
		 	case .LOCALTIME:fallthrough
		 	case .CURDATE:fallthrough
		 	case .CURTIME:fallthrough
		 	case .DATE_ADD:fallthrough
		 	case .DATE_SUB:fallthrough
		 	case .LOCALTIMESTAMP:fallthrough
		 	case .NOW:fallthrough
		 	case .POSITION:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .SUBSTRING:fallthrough
		 	case .SYSDATE:fallthrough
		 	case .TRIM:fallthrough
		 	case .UTC_DATE:fallthrough
		 	case .UTC_TIME:fallthrough
		 	case .UTC_TIMESTAMP:fallthrough
		 	case .ACCOUNT:fallthrough
		 	case .ACTION:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALGORITHM:fallthrough
		 	case .ANY:fallthrough
		 	case .AT:fallthrough
		 	case .AUTHORS:fallthrough
		 	case .AUTOCOMMIT:fallthrough
		 	case .AUTOEXTEND_SIZE:fallthrough
		 	case .AUTO_INCREMENT:fallthrough
		 	case .AVG_ROW_LENGTH:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BINLOG:fallthrough
		 	case .BIT:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BOOL:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BTREE:fallthrough
		 	case .CACHE:fallthrough
		 	case .CASCADED:fallthrough
		 	case .CHAIN:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CHECKSUM:fallthrough
		 	case .PAGE_CHECKSUM:fallthrough
		 	case .CIPHER:fallthrough
		 	case .CLASS_ORIGIN:fallthrough
		 	case .CLIENT:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTERING:fallthrough
		 	case .COALESCE:fallthrough
		 	case .CODE:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COLUMN_FORMAT:fallthrough
		 	case .COLUMN_NAME:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMPACT:fallthrough
		 	case .COMPLETION:fallthrough
		 	case .COMPRESSED:fallthrough
		 	case .COMPRESSION:fallthrough
		 	case .CONCURRENT:fallthrough
		 	case .CONNECT:fallthrough
		 	case .CONNECTION:fallthrough
		 	case .CONSISTENT:fallthrough
		 	case .CONSTRAINT_CATALOG:fallthrough
		 	case .CONSTRAINT_SCHEMA:fallthrough
		 	case .CONSTRAINT_NAME:fallthrough
		 	case .CONTAINS:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTRIBUTORS:fallthrough
		 	case .COPY:fallthrough
		 	case .CPU:fallthrough
		 	case .CURSOR_NAME:fallthrough
		 	case .DATA:fallthrough
		 	case .DATAFILE:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DEFAULT_AUTH:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DELAY_KEY_WRITE:fallthrough
		 	case .DES_KEY_FILE:fallthrough
		 	case .DIRECTORY:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISCARD:fallthrough
		 	case .DISK:fallthrough
		 	case .DO:fallthrough
		 	case .DUMPFILE:fallthrough
		 	case .DUPLICATE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .END:fallthrough
		 	case .ENDS:fallthrough
		 	case .ENGINE:fallthrough
		 	case .ENGINES:fallthrough
		 	case .ERROR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVEN:fallthrough
		 	case .EVENT:fallthrough
		 	case .EVENTS:fallthrough
		 	case .EVERY:fallthrough
		 	case .EXCHANGE:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPIRE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .EXTENT_SIZE:fallthrough
		 	case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 	case .FAST:fallthrough
		 	case .FAULTS:fallthrough
		 	case .FIELDS:fallthrough
		 	case .FILE_BLOCK_SIZE:fallthrough
		 	case .FILTER:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIXED:fallthrough
		 	case .FLUSH:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FOUND:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GENERAL:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GRANTS:fallthrough
		 	case .GROUP_REPLICATION:fallthrough
		 	case .HANDLER:fallthrough
		 	case .HASH:fallthrough
		 	case .HELP:fallthrough
		 	case .HISTORY:fallthrough
		 	case .HOST:fallthrough
		 	case .HOSTS:fallthrough
		 	case .IDENTIFIED:fallthrough
		 	case .IGNORE_SERVER_IDS:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INDEXES:fallthrough
		 	case .INITIAL_SIZE:fallthrough
		 	case .INPLACE:fallthrough
		 	case .INSERT_METHOD:fallthrough
		 	case .INSTALL:fallthrough
		 	case .INSTANCE:fallthrough
		 	case .INSTANT:fallthrough
		 	case .INVISIBLE:fallthrough
		 	case .INVOKER:fallthrough
		 	case .IO:fallthrough
		 	case .IO_THREAD:fallthrough
		 	case .IPC:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ISSUER:fallthrough
		 	case .JSON:fallthrough
		 	case .KEY_BLOCK_SIZE:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LEAVES:fallthrough
		 	case .LESS:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOGFILE:fallthrough
		 	case .LOGS:fallthrough
		 	case .MASTER:fallthrough
		 	case .MASTER_AUTO_POSITION:fallthrough
		 	case .MASTER_CONNECT_RETRY:fallthrough
		 	case .MASTER_DELAY:fallthrough
		 	case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 	case .MASTER_HOST:fallthrough
		 	case .MASTER_LOG_FILE:fallthrough
		 	case .MASTER_LOG_POS:fallthrough
		 	case .MASTER_PASSWORD:fallthrough
		 	case .MASTER_PORT:fallthrough
		 	case .MASTER_RETRY_COUNT:fallthrough
		 	case .MASTER_SSL:fallthrough
		 	case .MASTER_SSL_CA:fallthrough
		 	case .MASTER_SSL_CAPATH:fallthrough
		 	case .MASTER_SSL_CERT:fallthrough
		 	case .MASTER_SSL_CIPHER:fallthrough
		 	case .MASTER_SSL_CRL:fallthrough
		 	case .MASTER_SSL_CRLPATH:fallthrough
		 	case .MASTER_SSL_KEY:fallthrough
		 	case .MASTER_TLS_VERSION:fallthrough
		 	case .MASTER_USER:fallthrough
		 	case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 	case .MAX_QUERIES_PER_HOUR:fallthrough
		 	case .MAX_ROWS:fallthrough
		 	case .MAX_SIZE:fallthrough
		 	case .MAX_UPDATES_PER_HOUR:fallthrough
		 	case .MAX_USER_CONNECTIONS:fallthrough
		 	case .MEDIUM:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MESSAGE_TEXT:fallthrough
		 	case .MID:fallthrough
		 	case .MIGRATE:fallthrough
		 	case .MIN_ROWS:fallthrough
		 	case .MODE:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MUTEX:fallthrough
		 	case .MYSQL:fallthrough
		 	case .MYSQL_ERRNO:fallthrough
		 	case .NAME:fallthrough
		 	case .NAMES:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NEVER:fallthrough
		 	case .NEXT:fallthrough
		 	case .NO:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOWAIT:fallthrough
		 	case .NODEGROUP:fallthrough
		 	case .NONE:fallthrough
		 	case .ODBC:fallthrough
		 	case .OFFLINE:fallthrough
		 	case .OFFSET:fallthrough
		 	case .OF:fallthrough
		 	case .OJ:fallthrough
		 	case .OLD_PASSWORD:fallthrough
		 	case .ONE:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .OPTIMIZER_COSTS:fallthrough
		 	case .OPTIONS:fallthrough
		 	case .OWNER:fallthrough
		 	case .PACK_KEYS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PARSER:fallthrough
		 	case .PARTIAL:fallthrough
		 	case .PARTITIONING:fallthrough
		 	case .PARTITIONS:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PASSWORD_LOCK_TIME:fallthrough
		 	case .PHASE:fallthrough
		 	case .PLUGIN:fallthrough
		 	case .PLUGIN_DIR:fallthrough
		 	case .PLUGINS:fallthrough
		 	case .PORT:fallthrough
		 	case .PRECEDES:fallthrough
		 	case .PREPARE:fallthrough
		 	case .PRESERVE:fallthrough
		 	case .PREV:fallthrough
		 	case .PROCESSLIST:fallthrough
		 	case .PROFILE:fallthrough
		 	case .PROFILES:fallthrough
		 	case .PROXY:fallthrough
		 	case .QUERY:fallthrough
		 	case .QUICK:fallthrough
		 	case .REBUILD:fallthrough
		 	case .RECOVER:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REDO_BUFFER_SIZE:fallthrough
		 	case .REDUNDANT:fallthrough
		 	case .RELAY:fallthrough
		 	case .RELAY_LOG_FILE:fallthrough
		 	case .RELAY_LOG_POS:fallthrough
		 	case .RELAYLOG:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REORGANIZE:fallthrough
		 	case .REPAIR:fallthrough
		 	case .REPLICATE_DO_DB:fallthrough
		 	case .REPLICATE_DO_TABLE:fallthrough
		 	case .REPLICATE_IGNORE_DB:fallthrough
		 	case .REPLICATE_IGNORE_TABLE:fallthrough
		 	case .REPLICATE_REWRITE_DB:fallthrough
		 	case .REPLICATE_WILD_DO_TABLE:fallthrough
		 	case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 	case .REPLICATION:fallthrough
		 	case .RESET:fallthrough
		 	case .RESUME:fallthrough
		 	case .RETURNED_SQLSTATE:fallthrough
		 	case .RETURNING:fallthrough
		 	case .RETURNS:fallthrough
		 	case .REUSE:fallthrough
		 	case .ROLE:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROTATE:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_FORMAT:fallthrough
		 	case .RTREE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEDULE:fallthrough
		 	case .SECURITY:fallthrough
		 	case .SERVER:fallthrough
		 	case .SESSION:fallthrough
		 	case .SHARE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SIGNED:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SLAVE:fallthrough
		 	case .SLOW:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOCKET:fallthrough
		 	case .SOME:fallthrough
		 	case .SONAME:fallthrough
		 	case .SOUNDS:fallthrough
		 	case .SOURCE:fallthrough
		 	case .SQL_AFTER_GTIDS:fallthrough
		 	case .SQL_AFTER_MTS_GAPS:fallthrough
		 	case .SQL_BEFORE_GTIDS:fallthrough
		 	case .SQL_BUFFER_RESULT:fallthrough
		 	case .SQL_CACHE:fallthrough
		 	case .SQL_NO_CACHE:fallthrough
		 	case .SQL_THREAD:fallthrough
		 	case .START:fallthrough
		 	case .STARTS:fallthrough
		 	case .STATS_AUTO_RECALC:fallthrough
		 	case .STATS_PERSISTENT:fallthrough
		 	case .STATS_SAMPLE_PAGES:fallthrough
		 	case .STATUS:fallthrough
		 	case .STOP:fallthrough
		 	case .STORAGE:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBCLASS_ORIGIN:fallthrough
		 	case .SUBJECT:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBPARTITIONS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .SWAPS:fallthrough
		 	case .SWITCHES:fallthrough
		 	case .TABLE_NAME:fallthrough
		 	case .TABLESPACE:fallthrough
		 	case .TABLE_TYPE:fallthrough
		 	case .TEMPORARY:fallthrough
		 	case .TEMPTABLE:fallthrough
		 	case .THAN:fallthrough
		 	case .TRADITIONAL:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSACTIONAL:fallthrough
		 	case .TRIGGERS:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDEFINED:fallthrough
		 	case .UNDOFILE:fallthrough
		 	case .UNDO_BUFFER_SIZE:fallthrough
		 	case .UNINSTALL:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPGRADE:fallthrough
		 	case .USER:fallthrough
		 	case .USE_FRM:fallthrough
		 	case .USER_RESOURCES:fallthrough
		 	case .VALIDATION:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARIABLES:fallthrough
		 	case .VIEW:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .VISIBLE:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNINGS:fallthrough
		 	case .WITHOUT:fallthrough
		 	case .WORK:fallthrough
		 	case .WRAPPER:fallthrough
		 	case .X509:fallthrough
		 	case .XA:fallthrough
		 	case .XML:fallthrough
		 	case .EUR:fallthrough
		 	case .USA:fallthrough
		 	case .JIS:fallthrough
		 	case .ISO:fallthrough
		 	case .INTERNAL:fallthrough
		 	case .QUARTER:fallthrough
		 	case .MONTH:fallthrough
		 	case .DAY:fallthrough
		 	case .HOUR:fallthrough
		 	case .MINUTE:fallthrough
		 	case .WEEK:fallthrough
		 	case .SECOND:fallthrough
		 	case .MICROSECOND:fallthrough
		 	case .ADMIN:fallthrough
		 	case .AUDIT_ABORT_EXEMPT:fallthrough
		 	case .AUDIT_ADMIN:fallthrough
		 	case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 	case .BACKUP_ADMIN:fallthrough
		 	case .BINLOG_ADMIN:fallthrough
		 	case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 	case .CLONE_ADMIN:fallthrough
		 	case .CONNECTION_ADMIN:fallthrough
		 	case .ENCRYPTION_KEY_ADMIN:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .FILE:fallthrough
		 	case .FIREWALL_ADMIN:fallthrough
		 	case .FIREWALL_EXEMPT:fallthrough
		 	case .FIREWALL_USER:fallthrough
		 	case .GROUP_REPLICATION_ADMIN:fallthrough
		 	case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 	case .INVOKE:fallthrough
		 	case .LAMBDA:fallthrough
		 	case .NDB_STORED_USER:fallthrough
		 	case .PASSWORDLESS_USER_ADMIN:fallthrough
		 	case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .PROCESS:fallthrough
		 	case .RELOAD:fallthrough
		 	case .REPLICATION_APPLIER:fallthrough
		 	case .REPLICATION_SLAVE_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_USER:fallthrough
		 	case .ROLE_ADMIN:fallthrough
		 	case .ROUTINE:fallthrough
		 	case .S3:fallthrough
		 	case .SESSION_VARIABLES_ADMIN:fallthrough
		 	case .SET_USER_ID:fallthrough
		 	case .SHOW_ROUTINE:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SUPER:fallthrough
		 	case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 	case .TABLES:fallthrough
		 	case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 	case .VERSION_TOKEN_ADMIN:fallthrough
		 	case .XA_RECOVER_ADMIN:fallthrough
		 	case .ARMSCII8:fallthrough
		 	case .ASCII:fallthrough
		 	case .BIG5:fallthrough
		 	case .CP1250:fallthrough
		 	case .CP1251:fallthrough
		 	case .CP1256:fallthrough
		 	case .CP1257:fallthrough
		 	case .CP850:fallthrough
		 	case .CP852:fallthrough
		 	case .CP866:fallthrough
		 	case .CP932:fallthrough
		 	case .DEC8:fallthrough
		 	case .EUCJPMS:fallthrough
		 	case .EUCKR:fallthrough
		 	case .GB18030:fallthrough
		 	case .GB2312:fallthrough
		 	case .GBK:fallthrough
		 	case .GEOSTD8:fallthrough
		 	case .GREEK:fallthrough
		 	case .HEBREW:fallthrough
		 	case .HP8:fallthrough
		 	case .KEYBCS2:fallthrough
		 	case .KOI8R:fallthrough
		 	case .KOI8U:fallthrough
		 	case .LATIN1:fallthrough
		 	case .LATIN2:fallthrough
		 	case .LATIN5:fallthrough
		 	case .LATIN7:fallthrough
		 	case .MACCE:fallthrough
		 	case .MACROMAN:fallthrough
		 	case .SJIS:fallthrough
		 	case .SWE7:fallthrough
		 	case .TIS620:fallthrough
		 	case .UCS2:fallthrough
		 	case .UJIS:fallthrough
		 	case .UTF16:fallthrough
		 	case .UTF16LE:fallthrough
		 	case .UTF32:fallthrough
		 	case .UTF8:fallthrough
		 	case .UTF8MB3:fallthrough
		 	case .UTF8MB4:fallthrough
		 	case .ARCHIVE:fallthrough
		 	case .BLACKHOLE:fallthrough
		 	case .CSV:fallthrough
		 	case .FEDERATED:fallthrough
		 	case .INNODB:fallthrough
		 	case .MEMORY:fallthrough
		 	case .MRG_MYISAM:fallthrough
		 	case .MYISAM:fallthrough
		 	case .NDB:fallthrough
		 	case .NDBCLUSTER:fallthrough
		 	case .PERFORMANCE_SCHEMA:fallthrough
		 	case .TOKUDB:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .GEOMETRYCOLLECTION:fallthrough
		 	case .LINESTRING:fallthrough
		 	case .MULTILINESTRING:fallthrough
		 	case .MULTIPOINT:fallthrough
		 	case .MULTIPOLYGON:fallthrough
		 	case .POINT:fallthrough
		 	case .POLYGON:fallthrough
		 	case .ABS:fallthrough
		 	case .ACOS:fallthrough
		 	case .ADDDATE:fallthrough
		 	case .ADDTIME:fallthrough
		 	case .AES_DECRYPT:fallthrough
		 	case .AES_ENCRYPT:fallthrough
		 	case .AREA:fallthrough
		 	case .ASBINARY:fallthrough
		 	case .ASIN:fallthrough
		 	case .ASTEXT:fallthrough
		 	case .ASWKB:fallthrough
		 	case .ASWKT:fallthrough
		 	case .ASYMMETRIC_DECRYPT:fallthrough
		 	case .ASYMMETRIC_DERIVE:fallthrough
		 	case .ASYMMETRIC_ENCRYPT:fallthrough
		 	case .ASYMMETRIC_SIGN:fallthrough
		 	case .ASYMMETRIC_VERIFY:fallthrough
		 	case .ATAN:fallthrough
		 	case .ATAN2:fallthrough
		 	case .BENCHMARK:fallthrough
		 	case .BIN:fallthrough
		 	case .BIT_COUNT:fallthrough
		 	case .BIT_LENGTH:fallthrough
		 	case .BUFFER:fallthrough
		 	case .CATALOG_NAME:fallthrough
		 	case .CEIL:fallthrough
		 	case .CEILING:fallthrough
		 	case .CENTROID:fallthrough
		 	case .CHARACTER_LENGTH:fallthrough
		 	case .CHARSET:fallthrough
		 	case .CHAR_LENGTH:fallthrough
		 	case .COERCIBILITY:fallthrough
		 	case .COLLATION:fallthrough
		 	case .COMPRESS:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_WS:fallthrough
		 	case .CONNECTION_ID:fallthrough
		 	case .CONV:fallthrough
		 	case .CONVERT_TZ:fallthrough
		 	case .COS:fallthrough
		 	case .COT:fallthrough
		 	case .CRC32:fallthrough
		 	case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 	case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 	case .CREATE_DH_PARAMETERS:fallthrough
		 	case .CREATE_DIGEST:fallthrough
		 	case .CROSSES:fallthrough
		 	case .DATEDIFF:fallthrough
		 	case .DATE_FORMAT:fallthrough
		 	case .DAYNAME:fallthrough
		 	case .DAYOFMONTH:fallthrough
		 	case .DAYOFWEEK:fallthrough
		 	case .DAYOFYEAR:fallthrough
		 	case .DECODE:fallthrough
		 	case .DEGREES:fallthrough
		 	case .DES_DECRYPT:fallthrough
		 	case .DES_ENCRYPT:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISJOINT:fallthrough
		 	case .ELT:fallthrough
		 	case .ENCODE:fallthrough
		 	case .ENCRYPT:fallthrough
		 	case .ENDPOINT:fallthrough
		 	case .ENGINE_ATTRIBUTE:fallthrough
		 	case .ENVELOPE:fallthrough
		 	case .EQUALS:fallthrough
		 	case .EXP:fallthrough
		 	case .EXPORT_SET:fallthrough
		 	case .EXTERIORRING:fallthrough
		 	case .EXTRACTVALUE:fallthrough
		 	case .FIELD:fallthrough
		 	case .FIND_IN_SET:fallthrough
		 	case .FLOOR:fallthrough
		 	case .FORMAT:fallthrough
		 	case .FOUND_ROWS:fallthrough
		 	case .FROM_BASE64:fallthrough
		 	case .FROM_DAYS:fallthrough
		 	case .FROM_UNIXTIME:fallthrough
		 	case .GEOMCOLLFROMTEXT:fallthrough
		 	case .GEOMCOLLFROMWKB:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .GEOMETRYFROMTEXT:fallthrough
		 	case .GEOMETRYFROMWKB:fallthrough
		 	case .GEOMETRYN:fallthrough
		 	case .GEOMETRYTYPE:fallthrough
		 	case .GEOMFROMTEXT:fallthrough
		 	case .GEOMFROMWKB:fallthrough
		 	case .GET_FORMAT:fallthrough
		 	case .GET_LOCK:fallthrough
		 	case .GLENGTH:fallthrough
		 	case .GREATEST:fallthrough
		 	case .GTID_SUBSET:fallthrough
		 	case .GTID_SUBTRACT:fallthrough
		 	case .HEX:fallthrough
		 	case .IFNULL:fallthrough
		 	case .INET6_ATON:fallthrough
		 	case .INET6_NTOA:fallthrough
		 	case .INET_ATON:fallthrough
		 	case .INET_NTOA:fallthrough
		 	case .INSTR:fallthrough
		 	case .INTERIORRINGN:fallthrough
		 	case .INTERSECTS:fallthrough
		 	case .ISCLOSED:fallthrough
		 	case .ISEMPTY:fallthrough
		 	case .ISNULL:fallthrough
		 	case .ISSIMPLE:fallthrough
		 	case .IS_FREE_LOCK:fallthrough
		 	case .IS_IPV4:fallthrough
		 	case .IS_IPV4_COMPAT:fallthrough
		 	case .IS_IPV4_MAPPED:fallthrough
		 	case .IS_IPV6:fallthrough
		 	case .IS_USED_LOCK:fallthrough
		 	case .LAST_INSERT_ID:fallthrough
		 	case .LCASE:fallthrough
		 	case .LEAST:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LINEFROMTEXT:fallthrough
		 	case .LINEFROMWKB:fallthrough
		 	case .LINESTRINGFROMTEXT:fallthrough
		 	case .LINESTRINGFROMWKB:fallthrough
		 	case .LN:fallthrough
		 	case .LOAD_FILE:fallthrough
		 	case .LOCATE:fallthrough
		 	case .LOG:fallthrough
		 	case .LOG10:fallthrough
		 	case .LOG2:fallthrough
		 	case .LOWER:fallthrough
		 	case .LPAD:fallthrough
		 	case .LTRIM:fallthrough
		 	case .MAKEDATE:fallthrough
		 	case .MAKETIME:fallthrough
		 	case .MAKE_SET:fallthrough
		 	case .MASTER_POS_WAIT:fallthrough
		 	case .MBRCONTAINS:fallthrough
		 	case .MBRDISJOINT:fallthrough
		 	case .MBREQUAL:fallthrough
		 	case .MBRINTERSECTS:fallthrough
		 	case .MBROVERLAPS:fallthrough
		 	case .MBRTOUCHES:fallthrough
		 	case .MBRWITHIN:fallthrough
		 	case .MD5:fallthrough
		 	case .MLINEFROMTEXT:fallthrough
		 	case .MLINEFROMWKB:fallthrough
		 	case .MONTHNAME:fallthrough
		 	case .MPOINTFROMTEXT:fallthrough
		 	case .MPOINTFROMWKB:fallthrough
		 	case .MPOLYFROMTEXT:fallthrough
		 	case .MPOLYFROMWKB:fallthrough
		 	case .MULTILINESTRINGFROMTEXT:fallthrough
		 	case .MULTILINESTRINGFROMWKB:fallthrough
		 	case .MULTIPOINTFROMTEXT:fallthrough
		 	case .MULTIPOINTFROMWKB:fallthrough
		 	case .MULTIPOLYGONFROMTEXT:fallthrough
		 	case .MULTIPOLYGONFROMWKB:fallthrough
		 	case .NAME_CONST:fallthrough
		 	case .NULLIF:fallthrough
		 	case .NUMGEOMETRIES:fallthrough
		 	case .NUMINTERIORRINGS:fallthrough
		 	case .NUMPOINTS:fallthrough
		 	case .OCT:fallthrough
		 	case .OCTET_LENGTH:fallthrough
		 	case .ORD:fallthrough
		 	case .OVERLAPS:fallthrough
		 	case .PERIOD_ADD:fallthrough
		 	case .PERIOD_DIFF:fallthrough
		 	case .PI:fallthrough
		 	case .POINTFROMTEXT:fallthrough
		 	case .POINTFROMWKB:fallthrough
		 	case .POINTN:fallthrough
		 	case .POLYFROMTEXT:fallthrough
		 	case .POLYFROMWKB:fallthrough
		 	case .POLYGONFROMTEXT:fallthrough
		 	case .POLYGONFROMWKB:fallthrough
		 	case .POW:fallthrough
		 	case .POWER:fallthrough
		 	case .QUOTE:fallthrough
		 	case .RADIANS:fallthrough
		 	case .RAND:fallthrough
		 	case .RANDOM:fallthrough
		 	case .RANDOM_BYTES:fallthrough
		 	case .RELEASE_LOCK:fallthrough
		 	case .REVERSE:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_COUNT:fallthrough
		 	case .RPAD:fallthrough
		 	case .RTRIM:fallthrough
		 	case .SEC_TO_TIME:fallthrough
		 	case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 	case .SESSION_USER:fallthrough
		 	case .SHA:fallthrough
		 	case .SHA1:fallthrough
		 	case .SHA2:fallthrough
		 	case .SCHEMA_NAME:fallthrough
		 	case .SIGN:fallthrough
		 	case .SIN:fallthrough
		 	case .SLEEP:fallthrough
		 	case .SOUNDEX:fallthrough
		 	case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 	case .SQRT:fallthrough
		 	case .SRID:fallthrough
		 	case .STARTPOINT:fallthrough
		 	case .STRCMP:fallthrough
		 	case .STR_TO_DATE:fallthrough
		 	case .ST_AREA:fallthrough
		 	case .ST_ASBINARY:fallthrough
		 	case .ST_ASTEXT:fallthrough
		 	case .ST_ASWKB:fallthrough
		 	case .ST_ASWKT:fallthrough
		 	case .ST_BUFFER:fallthrough
		 	case .ST_CENTROID:fallthrough
		 	case .ST_CONTAINS:fallthrough
		 	case .ST_CROSSES:fallthrough
		 	case .ST_DIFFERENCE:fallthrough
		 	case .ST_DIMENSION:fallthrough
		 	case .ST_DISJOINT:fallthrough
		 	case .ST_DISTANCE:fallthrough
		 	case .ST_ENDPOINT:fallthrough
		 	case .ST_ENVELOPE:fallthrough
		 	case .ST_EQUALS:fallthrough
		 	case .ST_EXTERIORRING:fallthrough
		 	case .ST_GEOMCOLLFROMTEXT:fallthrough
		 	case .ST_GEOMCOLLFROMTXT:fallthrough
		 	case .ST_GEOMCOLLFROMWKB:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .ST_GEOMETRYFROMTEXT:fallthrough
		 	case .ST_GEOMETRYFROMWKB:fallthrough
		 	case .ST_GEOMETRYN:fallthrough
		 	case .ST_GEOMETRYTYPE:fallthrough
		 	case .ST_GEOMFROMTEXT:fallthrough
		 	case .ST_GEOMFROMWKB:fallthrough
		 	case .ST_INTERIORRINGN:fallthrough
		 	case .ST_INTERSECTION:fallthrough
		 	case .ST_INTERSECTS:fallthrough
		 	case .ST_ISCLOSED:fallthrough
		 	case .ST_ISEMPTY:fallthrough
		 	case .ST_ISSIMPLE:fallthrough
		 	case .ST_LINEFROMTEXT:fallthrough
		 	case .ST_LINEFROMWKB:fallthrough
		 	case .ST_LINESTRINGFROMTEXT:fallthrough
		 	case .ST_LINESTRINGFROMWKB:fallthrough
		 	case .ST_NUMGEOMETRIES:fallthrough
		 	case .ST_NUMINTERIORRING:fallthrough
		 	case .ST_NUMINTERIORRINGS:fallthrough
		 	case .ST_NUMPOINTS:fallthrough
		 	case .ST_OVERLAPS:fallthrough
		 	case .ST_POINTFROMTEXT:fallthrough
		 	case .ST_POINTFROMWKB:fallthrough
		 	case .ST_POINTN:fallthrough
		 	case .ST_POLYFROMTEXT:fallthrough
		 	case .ST_POLYFROMWKB:fallthrough
		 	case .ST_POLYGONFROMTEXT:fallthrough
		 	case .ST_POLYGONFROMWKB:fallthrough
		 	case .ST_SRID:fallthrough
		 	case .ST_STARTPOINT:fallthrough
		 	case .ST_SYMDIFFERENCE:fallthrough
		 	case .ST_TOUCHES:fallthrough
		 	case .ST_UNION:fallthrough
		 	case .ST_WITHIN:fallthrough
		 	case .ST_X:fallthrough
		 	case .ST_Y:fallthrough
		 	case .SUBDATE:fallthrough
		 	case .SUBSTRING_INDEX:fallthrough
		 	case .SUBTIME:fallthrough
		 	case .SYSTEM_USER:fallthrough
		 	case .TAN:fallthrough
		 	case .TIMEDIFF:fallthrough
		 	case .TIMESTAMPADD:fallthrough
		 	case .TIMESTAMPDIFF:fallthrough
		 	case .TIME_FORMAT:fallthrough
		 	case .TIME_TO_SEC:fallthrough
		 	case .TOUCHES:fallthrough
		 	case .TO_BASE64:fallthrough
		 	case .TO_DAYS:fallthrough
		 	case .TO_SECONDS:fallthrough
		 	case .TP_CONNECTION_ADMIN:fallthrough
		 	case .UCASE:fallthrough
		 	case .UNCOMPRESS:fallthrough
		 	case .UNCOMPRESSED_LENGTH:fallthrough
		 	case .UNHEX:fallthrough
		 	case .UNIX_TIMESTAMP:fallthrough
		 	case .UPDATEXML:fallthrough
		 	case .UPPER:fallthrough
		 	case .UUID:fallthrough
		 	case .UUID_SHORT:fallthrough
		 	case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 	case .VERSION:fallthrough
		 	case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 	case .WEEKDAY:fallthrough
		 	case .WEEKOFYEAR:fallthrough
		 	case .WEIGHT_STRING:fallthrough
		 	case .WITHIN:fallthrough
		 	case .YEARWEEK:fallthrough
		 	case .Y_FUNCTION:fallthrough
		 	case .X_FUNCTION:fallthrough
		 	case .MOD:fallthrough
		 	case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 	case .STRING_LITERAL:fallthrough
		 	case .ID:
		 		setState(3577)
		 		try tableName()
		 		setState(3580)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DOT.rawValue) {
		 			setState(3578)
		 			try match(MySqlParser.Tokens.DOT.rawValue)
		 			setState(3579)
		 			try match(MySqlParser.Tokens.STAR.rawValue)

		 		}

		 		setState(3590)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(3582)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3583)
		 			try tableName()
		 			setState(3586)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.DOT.rawValue) {
		 				setState(3584)
		 				try match(MySqlParser.Tokens.DOT.rawValue)
		 				setState(3585)
		 				try match(MySqlParser.Tokens.STAR.rawValue)

		 			}



		 			setState(3592)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3593)
		 		try match(MySqlParser.Tokens.FROM.rawValue)
		 		setState(3594)
		 		try tableSources()

		 		break

		 	case .FROM:
		 		setState(3596)
		 		try match(MySqlParser.Tokens.FROM.rawValue)
		 		setState(3597)
		 		try tableName()
		 		setState(3600)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DOT.rawValue) {
		 			setState(3598)
		 			try match(MySqlParser.Tokens.DOT.rawValue)
		 			setState(3599)
		 			try match(MySqlParser.Tokens.STAR.rawValue)

		 		}

		 		setState(3610)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(3602)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3603)
		 			try tableName()
		 			setState(3606)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.DOT.rawValue) {
		 				setState(3604)
		 				try match(MySqlParser.Tokens.DOT.rawValue)
		 				setState(3605)
		 				try match(MySqlParser.Tokens.STAR.rawValue)

		 			}



		 			setState(3612)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3613)
		 		try match(MySqlParser.Tokens.USING.rawValue)
		 		setState(3614)
		 		try tableSources()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3620)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WHERE.rawValue) {
		 		setState(3618)
		 		try match(MySqlParser.Tokens.WHERE.rawValue)
		 		setState(3619)
		 		try expression(0)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HandlerOpenStatementContext: ParserRuleContext {
			open
			func HANDLER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HANDLER.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func OPEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPEN.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_handlerOpenStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHandlerOpenStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHandlerOpenStatement(self)
			}
		}
	}
	@discardableResult
	 open func handlerOpenStatement() throws -> HandlerOpenStatementContext {
		var _localctx: HandlerOpenStatementContext
		_localctx = HandlerOpenStatementContext(_ctx, getState())
		try enterRule(_localctx, 218, MySqlParser.RULE_handlerOpenStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3622)
		 	try match(MySqlParser.Tokens.HANDLER.rawValue)
		 	setState(3623)
		 	try tableName()
		 	setState(3624)
		 	try match(MySqlParser.Tokens.OPEN.rawValue)
		 	setState(3629)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,508,_ctx)) {
		 	case 1:
		 		setState(3626)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.AS.rawValue) {
		 			setState(3625)
		 			try match(MySqlParser.Tokens.AS.rawValue)

		 		}

		 		setState(3628)
		 		try uid()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HandlerReadIndexStatementContext: ParserRuleContext {
		open var index: UidContext!
		open var moveOrder: Token!
			open
			func HANDLER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HANDLER.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func READ() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.READ.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func comparisonOperator() -> ComparisonOperatorContext? {
				return getRuleContext(ComparisonOperatorContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func constants() -> ConstantsContext? {
				return getRuleContext(ConstantsContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func WHERE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHERE.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func LIMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIMIT.rawValue, 0)
			}
			open
			func limitClauseAtom() -> LimitClauseAtomContext? {
				return getRuleContext(LimitClauseAtomContext.self, 0)
			}
			open
			func FIRST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIRST.rawValue, 0)
			}
			open
			func NEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NEXT.rawValue, 0)
			}
			open
			func PREV() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PREV.rawValue, 0)
			}
			open
			func LAST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LAST.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_handlerReadIndexStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHandlerReadIndexStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHandlerReadIndexStatement(self)
			}
		}
	}
	@discardableResult
	 open func handlerReadIndexStatement() throws -> HandlerReadIndexStatementContext {
		var _localctx: HandlerReadIndexStatementContext
		_localctx = HandlerReadIndexStatementContext(_ctx, getState())
		try enterRule(_localctx, 220, MySqlParser.RULE_handlerReadIndexStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3631)
		 	try match(MySqlParser.Tokens.HANDLER.rawValue)
		 	setState(3632)
		 	try tableName()
		 	setState(3633)
		 	try match(MySqlParser.Tokens.READ.rawValue)
		 	setState(3634)
		 	try {
		 			let assignmentValue = try uid()
		 			_localctx.castdown(HandlerReadIndexStatementContext.self).index = assignmentValue
		 	     }()

		 	setState(3641)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .EQUAL_SYMBOL:fallthrough
		 	case .GREATER_SYMBOL:fallthrough
		 	case .LESS_SYMBOL:fallthrough
		 	case .EXCLAMATION_SYMBOL:
		 		setState(3635)
		 		try comparisonOperator()
		 		setState(3636)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3637)
		 		try constants()
		 		setState(3638)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case .FIRST:fallthrough
		 	case .LAST:fallthrough
		 	case .NEXT:fallthrough
		 	case .PREV:
		 		setState(3640)
		 		_localctx.castdown(HandlerReadIndexStatementContext.self).moveOrder = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FIRST.rawValue || _la == MySqlParser.Tokens.LAST.rawValue || _la == MySqlParser.Tokens.NEXT.rawValue || _la == MySqlParser.Tokens.PREV.rawValue)) {
		 			_localctx.castdown(HandlerReadIndexStatementContext.self).moveOrder = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(3645)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WHERE.rawValue) {
		 		setState(3643)
		 		try match(MySqlParser.Tokens.WHERE.rawValue)
		 		setState(3644)
		 		try expression(0)

		 	}

		 	setState(3649)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LIMIT.rawValue) {
		 		setState(3647)
		 		try match(MySqlParser.Tokens.LIMIT.rawValue)
		 		setState(3648)
		 		try limitClauseAtom()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HandlerReadStatementContext: ParserRuleContext {
		open var moveOrder: Token!
			open
			func HANDLER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HANDLER.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func READ() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.READ.rawValue, 0)
			}
			open
			func FIRST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIRST.rawValue, 0)
			}
			open
			func NEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NEXT.rawValue, 0)
			}
			open
			func WHERE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHERE.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func LIMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIMIT.rawValue, 0)
			}
			open
			func limitClauseAtom() -> LimitClauseAtomContext? {
				return getRuleContext(LimitClauseAtomContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_handlerReadStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHandlerReadStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHandlerReadStatement(self)
			}
		}
	}
	@discardableResult
	 open func handlerReadStatement() throws -> HandlerReadStatementContext {
		var _localctx: HandlerReadStatementContext
		_localctx = HandlerReadStatementContext(_ctx, getState())
		try enterRule(_localctx, 222, MySqlParser.RULE_handlerReadStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3651)
		 	try match(MySqlParser.Tokens.HANDLER.rawValue)
		 	setState(3652)
		 	try tableName()
		 	setState(3653)
		 	try match(MySqlParser.Tokens.READ.rawValue)
		 	setState(3654)
		 	_localctx.castdown(HandlerReadStatementContext.self).moveOrder = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.FIRST.rawValue || _la == MySqlParser.Tokens.NEXT.rawValue)) {
		 		_localctx.castdown(HandlerReadStatementContext.self).moveOrder = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3657)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WHERE.rawValue) {
		 		setState(3655)
		 		try match(MySqlParser.Tokens.WHERE.rawValue)
		 		setState(3656)
		 		try expression(0)

		 	}

		 	setState(3661)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LIMIT.rawValue) {
		 		setState(3659)
		 		try match(MySqlParser.Tokens.LIMIT.rawValue)
		 		setState(3660)
		 		try limitClauseAtom()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HandlerCloseStatementContext: ParserRuleContext {
			open
			func HANDLER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HANDLER.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func CLOSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CLOSE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_handlerCloseStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHandlerCloseStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHandlerCloseStatement(self)
			}
		}
	}
	@discardableResult
	 open func handlerCloseStatement() throws -> HandlerCloseStatementContext {
		var _localctx: HandlerCloseStatementContext
		_localctx = HandlerCloseStatementContext(_ctx, getState())
		try enterRule(_localctx, 224, MySqlParser.RULE_handlerCloseStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3663)
		 	try match(MySqlParser.Tokens.HANDLER.rawValue)
		 	setState(3664)
		 	try tableName()
		 	setState(3665)
		 	try match(MySqlParser.Tokens.CLOSE.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SingleUpdateStatementContext: ParserRuleContext {
		open var priority: Token!
			open
			func UPDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPDATE.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func updatedElement() -> [UpdatedElementContext] {
				return getRuleContexts(UpdatedElementContext.self)
			}
			open
			func updatedElement(_ i: Int) -> UpdatedElementContext? {
				return getRuleContext(UpdatedElementContext.self, i)
			}
			open
			func IGNORE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func WHERE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHERE.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func orderByClause() -> OrderByClauseContext? {
				return getRuleContext(OrderByClauseContext.self, 0)
			}
			open
			func limitClause() -> LimitClauseContext? {
				return getRuleContext(LimitClauseContext.self, 0)
			}
			open
			func LOW_PRIORITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOW_PRIORITY.rawValue, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_singleUpdateStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSingleUpdateStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSingleUpdateStatement(self)
			}
		}
	}
	@discardableResult
	 open func singleUpdateStatement() throws -> SingleUpdateStatementContext {
		var _localctx: SingleUpdateStatementContext
		_localctx = SingleUpdateStatementContext(_ctx, getState())
		try enterRule(_localctx, 226, MySqlParser.RULE_singleUpdateStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3667)
		 	try match(MySqlParser.Tokens.UPDATE.rawValue)
		 	setState(3669)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LOW_PRIORITY.rawValue) {
		 		setState(3668)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.LOW_PRIORITY.rawValue)
		 				_localctx.castdown(SingleUpdateStatementContext.self).priority = assignmentValue
		 		     }()


		 	}

		 	setState(3672)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IGNORE.rawValue) {
		 		setState(3671)
		 		try match(MySqlParser.Tokens.IGNORE.rawValue)

		 	}

		 	setState(3674)
		 	try tableName()
		 	setState(3679)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513126400) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 		setState(3676)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.AS.rawValue) {
		 			setState(3675)
		 			try match(MySqlParser.Tokens.AS.rawValue)

		 		}

		 		setState(3678)
		 		try uid()

		 	}

		 	setState(3681)
		 	try match(MySqlParser.Tokens.SET.rawValue)
		 	setState(3682)
		 	try updatedElement()
		 	setState(3687)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(3683)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(3684)
		 		try updatedElement()


		 		setState(3689)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3692)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WHERE.rawValue) {
		 		setState(3690)
		 		try match(MySqlParser.Tokens.WHERE.rawValue)
		 		setState(3691)
		 		try expression(0)

		 	}

		 	setState(3695)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ORDER.rawValue) {
		 		setState(3694)
		 		try orderByClause()

		 	}

		 	setState(3698)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LIMIT.rawValue) {
		 		setState(3697)
		 		try limitClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultipleUpdateStatementContext: ParserRuleContext {
		open var priority: Token!
			open
			func UPDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPDATE.rawValue, 0)
			}
			open
			func tableSources() -> TableSourcesContext? {
				return getRuleContext(TableSourcesContext.self, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func updatedElement() -> [UpdatedElementContext] {
				return getRuleContexts(UpdatedElementContext.self)
			}
			open
			func updatedElement(_ i: Int) -> UpdatedElementContext? {
				return getRuleContext(UpdatedElementContext.self, i)
			}
			open
			func IGNORE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func WHERE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHERE.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func LOW_PRIORITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOW_PRIORITY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_multipleUpdateStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMultipleUpdateStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMultipleUpdateStatement(self)
			}
		}
	}
	@discardableResult
	 open func multipleUpdateStatement() throws -> MultipleUpdateStatementContext {
		var _localctx: MultipleUpdateStatementContext
		_localctx = MultipleUpdateStatementContext(_ctx, getState())
		try enterRule(_localctx, 228, MySqlParser.RULE_multipleUpdateStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3700)
		 	try match(MySqlParser.Tokens.UPDATE.rawValue)
		 	setState(3702)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LOW_PRIORITY.rawValue) {
		 		setState(3701)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.LOW_PRIORITY.rawValue)
		 				_localctx.castdown(MultipleUpdateStatementContext.self).priority = assignmentValue
		 		     }()


		 	}

		 	setState(3705)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IGNORE.rawValue) {
		 		setState(3704)
		 		try match(MySqlParser.Tokens.IGNORE.rawValue)

		 	}

		 	setState(3707)
		 	try tableSources()
		 	setState(3708)
		 	try match(MySqlParser.Tokens.SET.rawValue)
		 	setState(3709)
		 	try updatedElement()
		 	setState(3714)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(3710)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(3711)
		 		try updatedElement()


		 		setState(3716)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(3719)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WHERE.rawValue) {
		 		setState(3717)
		 		try match(MySqlParser.Tokens.WHERE.rawValue)
		 		setState(3718)
		 		try expression(0)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OrderByClauseContext: ParserRuleContext {
			open
			func ORDER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ORDER.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func orderByExpression() -> [OrderByExpressionContext] {
				return getRuleContexts(OrderByExpressionContext.self)
			}
			open
			func orderByExpression(_ i: Int) -> OrderByExpressionContext? {
				return getRuleContext(OrderByExpressionContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_orderByClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterOrderByClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitOrderByClause(self)
			}
		}
	}
	@discardableResult
	 open func orderByClause() throws -> OrderByClauseContext {
		var _localctx: OrderByClauseContext
		_localctx = OrderByClauseContext(_ctx, getState())
		try enterRule(_localctx, 230, MySqlParser.RULE_orderByClause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3721)
		 	try match(MySqlParser.Tokens.ORDER.rawValue)
		 	setState(3722)
		 	try match(MySqlParser.Tokens.BY.rawValue)
		 	setState(3723)
		 	try orderByExpression()
		 	setState(3728)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,526,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3724)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3725)
		 			try orderByExpression()

		 	 
		 		}
		 		setState(3730)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,526,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OrderByExpressionContext: ParserRuleContext {
		open var order: Token!
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func ASC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASC.rawValue, 0)
			}
			open
			func DESC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DESC.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_orderByExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterOrderByExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitOrderByExpression(self)
			}
		}
	}
	@discardableResult
	 open func orderByExpression() throws -> OrderByExpressionContext {
		var _localctx: OrderByExpressionContext
		_localctx = OrderByExpressionContext(_ctx, getState())
		try enterRule(_localctx, 232, MySqlParser.RULE_orderByExpression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3731)
		 	try expression(0)
		 	setState(3733)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,527,_ctx)) {
		 	case 1:
		 		setState(3732)
		 		_localctx.castdown(OrderByExpressionContext.self).order = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ASC.rawValue || _la == MySqlParser.Tokens.DESC.rawValue)) {
		 			_localctx.castdown(OrderByExpressionContext.self).order = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TableSourcesContext: ParserRuleContext {
			open
			func tableSource() -> [TableSourceContext] {
				return getRuleContexts(TableSourceContext.self)
			}
			open
			func tableSource(_ i: Int) -> TableSourceContext? {
				return getRuleContext(TableSourceContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tableSources
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableSources(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableSources(self)
			}
		}
	}
	@discardableResult
	 open func tableSources() throws -> TableSourcesContext {
		var _localctx: TableSourcesContext
		_localctx = TableSourcesContext(_ctx, getState())
		try enterRule(_localctx, 234, MySqlParser.RULE_tableSources)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3735)
		 	try tableSource()
		 	setState(3740)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,528,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3736)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(3737)
		 			try tableSource()

		 	 
		 		}
		 		setState(3742)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,528,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TableSourceContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tableSource
		}
	}
	public class TableJsonContext: TableSourceContext {
			open
			func jsonTable() -> JsonTableContext? {
				return getRuleContext(JsonTableContext.self, 0)
			}

		public
		init(_ ctx: TableSourceContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableJson(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableJson(self)
			}
		}
	}
	public class TableSourceNestedContext: TableSourceContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func tableSourceItem() -> TableSourceItemContext? {
				return getRuleContext(TableSourceItemContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func joinPart() -> [JoinPartContext] {
				return getRuleContexts(JoinPartContext.self)
			}
			open
			func joinPart(_ i: Int) -> JoinPartContext? {
				return getRuleContext(JoinPartContext.self, i)
			}

		public
		init(_ ctx: TableSourceContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableSourceNested(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableSourceNested(self)
			}
		}
	}
	public class TableSourceBaseContext: TableSourceContext {
			open
			func tableSourceItem() -> TableSourceItemContext? {
				return getRuleContext(TableSourceItemContext.self, 0)
			}
			open
			func joinPart() -> [JoinPartContext] {
				return getRuleContexts(JoinPartContext.self)
			}
			open
			func joinPart(_ i: Int) -> JoinPartContext? {
				return getRuleContext(JoinPartContext.self, i)
			}

		public
		init(_ ctx: TableSourceContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableSourceBase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableSourceBase(self)
			}
		}
	}
	@discardableResult
	 open func tableSource() throws -> TableSourceContext {
		var _localctx: TableSourceContext
		_localctx = TableSourceContext(_ctx, getState())
		try enterRule(_localctx, 236, MySqlParser.RULE_tableSource)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(3761)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,531, _ctx)) {
		 	case 1:
		 		_localctx =  TableSourceBaseContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3743)
		 		try tableSourceItem()
		 		setState(3747)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,529,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(3744)
		 				try joinPart()

		 		 
		 			}
		 			setState(3749)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,529,_ctx)
		 		}

		 		break
		 	case 2:
		 		_localctx =  TableSourceNestedContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3750)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3751)
		 		try tableSourceItem()
		 		setState(3755)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (((Int64((_la - 34)) & ~0x3f) == 0 && ((Int64(1) << (_la - 34)) & -9150751492863426559) != 0) || ((Int64((_la - 113)) & ~0x3f) == 0 && ((Int64(1) << (_la - 113)) & 288230410511450113) != 0)) {
		 			setState(3752)
		 			try joinPart()


		 			setState(3757)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(3758)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 3:
		 		_localctx =  TableJsonContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3760)
		 		try jsonTable()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TableSourceItemContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tableSourceItem
		}
	}
	public class SubqueryTableItemContext: TableSourceItemContext {
		public var parenthesisSubquery: SelectStatementContext!
		public var alias: UidContext!
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}

		public
		init(_ ctx: TableSourceItemContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSubqueryTableItem(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSubqueryTableItem(self)
			}
		}
	}
	public class AtomTableItemContext: TableSourceItemContext {
		public var alias: UidContext!
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func indexHint() -> [IndexHintContext] {
				return getRuleContexts(IndexHintContext.self)
			}
			open
			func indexHint(_ i: Int) -> IndexHintContext? {
				return getRuleContext(IndexHintContext.self, i)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: TableSourceItemContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAtomTableItem(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAtomTableItem(self)
			}
		}
	}
	public class TableSourcesItemContext: TableSourceItemContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func tableSources() -> TableSourcesContext? {
				return getRuleContext(TableSourcesContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: TableSourceItemContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableSourcesItem(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableSourcesItem(self)
			}
		}
	}
	@discardableResult
	 open func tableSourceItem() throws -> TableSourceItemContext {
		var _localctx: TableSourceItemContext
		_localctx = TableSourceItemContext(_ctx, getState())
		try enterRule(_localctx, 238, MySqlParser.RULE_tableSourceItem)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(3803)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,539, _ctx)) {
		 	case 1:
		 		_localctx =  AtomTableItemContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3763)
		 		try tableName()
		 		setState(3769)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.PARTITION.rawValue) {
		 			setState(3764)
		 			try match(MySqlParser.Tokens.PARTITION.rawValue)
		 			setState(3765)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(3766)
		 			try uidList()
		 			setState(3767)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		}

		 		setState(3775)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,534,_ctx)) {
		 		case 1:
		 			setState(3772)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.AS.rawValue) {
		 				setState(3771)
		 				try match(MySqlParser.Tokens.AS.rawValue)

		 			}

		 			setState(3774)
		 			try {
		 					let assignmentValue = try uid()
		 					_localctx.castdown(AtomTableItemContext.self).alias = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(3785)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,536,_ctx)) {
		 		case 1:
		 			setState(3777)
		 			try indexHint()
		 			setState(3782)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,535,_ctx)
		 			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 				if ( _alt==1 ) {
		 					setState(3778)
		 					try match(MySqlParser.Tokens.COMMA.rawValue)
		 					setState(3779)
		 					try indexHint()

		 			 
		 				}
		 				setState(3784)
		 				try _errHandler.sync(self)
		 				_alt = try getInterpreter().adaptivePredict(_input,535,_ctx)
		 			}

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		_localctx =  SubqueryTableItemContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3792)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,537, _ctx)) {
		 		case 1:
		 			setState(3787)
		 			try selectStatement()

		 			break
		 		case 2:
		 			setState(3788)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(3789)
		 			try {
		 					let assignmentValue = try selectStatement()
		 					_localctx.castdown(SubqueryTableItemContext.self).parenthesisSubquery = assignmentValue
		 			     }()

		 			setState(3790)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(3795)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.AS.rawValue) {
		 			setState(3794)
		 			try match(MySqlParser.Tokens.AS.rawValue)

		 		}

		 		setState(3797)
		 		try {
		 				let assignmentValue = try uid()
		 				_localctx.castdown(SubqueryTableItemContext.self).alias = assignmentValue
		 		     }()


		 		break
		 	case 3:
		 		_localctx =  TableSourcesItemContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3799)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3800)
		 		try tableSources()
		 		setState(3801)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexHintContext: ParserRuleContext {
		open var indexHintAction: Token!
		open var keyFormat: Token!
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func USE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USE.rawValue, 0)
			}
			open
			func IGNORE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE.rawValue, 0)
			}
			open
			func FORCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FORCE.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func indexHintType() -> IndexHintTypeContext? {
				return getRuleContext(IndexHintTypeContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_indexHint
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIndexHint(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIndexHint(self)
			}
		}
	}
	@discardableResult
	 open func indexHint() throws -> IndexHintContext {
		var _localctx: IndexHintContext
		_localctx = IndexHintContext(_ctx, getState())
		try enterRule(_localctx, 240, MySqlParser.RULE_indexHint)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3805)
		 	_localctx.castdown(IndexHintContext.self).indexHintAction = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.FORCE.rawValue || _la == MySqlParser.Tokens.IGNORE.rawValue || _la == MySqlParser.Tokens.USE.rawValue)) {
		 		_localctx.castdown(IndexHintContext.self).indexHintAction = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3806)
		 	_localctx.castdown(IndexHintContext.self).keyFormat = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue)) {
		 		_localctx.castdown(IndexHintContext.self).keyFormat = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(3809)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.FOR.rawValue) {
		 		setState(3807)
		 		try match(MySqlParser.Tokens.FOR.rawValue)
		 		setState(3808)
		 		try indexHintType()

		 	}

		 	setState(3811)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(3812)
		 	try uidList()
		 	setState(3813)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexHintTypeContext: ParserRuleContext {
			open
			func JOIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JOIN.rawValue, 0)
			}
			open
			func ORDER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ORDER.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func GROUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_indexHintType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIndexHintType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIndexHintType(self)
			}
		}
	}
	@discardableResult
	 open func indexHintType() throws -> IndexHintTypeContext {
		var _localctx: IndexHintTypeContext
		_localctx = IndexHintTypeContext(_ctx, getState())
		try enterRule(_localctx, 242, MySqlParser.RULE_indexHintType)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3820)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .JOIN:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3815)
		 		try match(MySqlParser.Tokens.JOIN.rawValue)

		 		break

		 	case .ORDER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3816)
		 		try match(MySqlParser.Tokens.ORDER.rawValue)
		 		setState(3817)
		 		try match(MySqlParser.Tokens.BY.rawValue)

		 		break

		 	case .GROUP:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3818)
		 		try match(MySqlParser.Tokens.GROUP.rawValue)
		 		setState(3819)
		 		try match(MySqlParser.Tokens.BY.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class JoinPartContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_joinPart
		}
	}
	public class InnerJoinContext: JoinPartContext {
			open
			func JOIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JOIN.rawValue, 0)
			}
			open
			func tableSourceItem() -> TableSourceItemContext? {
				return getRuleContext(TableSourceItemContext.self, 0)
			}
			open
			func LATERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LATERAL.rawValue, 0)
			}
			open
			func joinSpec() -> [JoinSpecContext] {
				return getRuleContexts(JoinSpecContext.self)
			}
			open
			func joinSpec(_ i: Int) -> JoinSpecContext? {
				return getRuleContext(JoinSpecContext.self, i)
			}
			open
			func INNER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INNER.rawValue, 0)
			}
			open
			func CROSS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CROSS.rawValue, 0)
			}

		public
		init(_ ctx: JoinPartContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterInnerJoin(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitInnerJoin(self)
			}
		}
	}
	public class NaturalJoinContext: JoinPartContext {
			open
			func NATURAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NATURAL.rawValue, 0)
			}
			open
			func JOIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JOIN.rawValue, 0)
			}
			open
			func tableSourceItem() -> TableSourceItemContext? {
				return getRuleContext(TableSourceItemContext.self, 0)
			}
			open
			func LEFT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEFT.rawValue, 0)
			}
			open
			func RIGHT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RIGHT.rawValue, 0)
			}
			open
			func OUTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OUTER.rawValue, 0)
			}

		public
		init(_ ctx: JoinPartContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterNaturalJoin(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitNaturalJoin(self)
			}
		}
	}
	public class OuterJoinContext: JoinPartContext {
			open
			func JOIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JOIN.rawValue, 0)
			}
			open
			func tableSourceItem() -> TableSourceItemContext? {
				return getRuleContext(TableSourceItemContext.self, 0)
			}
			open
			func LEFT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEFT.rawValue, 0)
			}
			open
			func RIGHT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RIGHT.rawValue, 0)
			}
			open
			func OUTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OUTER.rawValue, 0)
			}
			open
			func LATERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LATERAL.rawValue, 0)
			}
			open
			func joinSpec() -> [JoinSpecContext] {
				return getRuleContexts(JoinSpecContext.self)
			}
			open
			func joinSpec(_ i: Int) -> JoinSpecContext? {
				return getRuleContext(JoinSpecContext.self, i)
			}

		public
		init(_ ctx: JoinPartContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterOuterJoin(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitOuterJoin(self)
			}
		}
	}
	public class StraightJoinContext: JoinPartContext {
			open
			func STRAIGHT_JOIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRAIGHT_JOIN.rawValue, 0)
			}
			open
			func tableSourceItem() -> TableSourceItemContext? {
				return getRuleContext(TableSourceItemContext.self, 0)
			}
			open
			func ON() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ON.rawValue)
			}
			open
			func ON(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, i)
			}
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}

		public
		init(_ ctx: JoinPartContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterStraightJoin(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitStraightJoin(self)
			}
		}
	}
	@discardableResult
	 open func joinPart() throws -> JoinPartContext {
		var _localctx: JoinPartContext
		_localctx = JoinPartContext(_ctx, getState())
		try enterRule(_localctx, 244, MySqlParser.RULE_joinPart)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(3869)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CROSS:fallthrough
		 	case .INNER:fallthrough
		 	case .JOIN:
		 		_localctx =  InnerJoinContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3823)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CROSS.rawValue || _la == MySqlParser.Tokens.INNER.rawValue) {
		 			setState(3822)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.CROSS.rawValue || _la == MySqlParser.Tokens.INNER.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(3825)
		 		try match(MySqlParser.Tokens.JOIN.rawValue)
		 		setState(3827)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,543,_ctx)) {
		 		case 1:
		 			setState(3826)
		 			try match(MySqlParser.Tokens.LATERAL.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(3829)
		 		try tableSourceItem()
		 		setState(3833)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,544,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(3830)
		 				try joinSpec()

		 		 
		 			}
		 			setState(3835)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,544,_ctx)
		 		}

		 		break

		 	case .STRAIGHT_JOIN:
		 		_localctx =  StraightJoinContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3836)
		 		try match(MySqlParser.Tokens.STRAIGHT_JOIN.rawValue)
		 		setState(3837)
		 		try tableSourceItem()
		 		setState(3842)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,545,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(3838)
		 				try match(MySqlParser.Tokens.ON.rawValue)
		 				setState(3839)
		 				try expression(0)

		 		 
		 			}
		 			setState(3844)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,545,_ctx)
		 		}

		 		break
		 	case .LEFT:fallthrough
		 	case .RIGHT:
		 		_localctx =  OuterJoinContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(3845)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.LEFT.rawValue || _la == MySqlParser.Tokens.RIGHT.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(3847)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.OUTER.rawValue) {
		 			setState(3846)
		 			try match(MySqlParser.Tokens.OUTER.rawValue)

		 		}

		 		setState(3849)
		 		try match(MySqlParser.Tokens.JOIN.rawValue)
		 		setState(3851)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,547,_ctx)) {
		 		case 1:
		 			setState(3850)
		 			try match(MySqlParser.Tokens.LATERAL.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(3853)
		 		try tableSourceItem()
		 		setState(3857)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,548,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(3854)
		 				try joinSpec()

		 		 
		 			}
		 			setState(3859)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,548,_ctx)
		 		}

		 		break

		 	case .NATURAL:
		 		_localctx =  NaturalJoinContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(3860)
		 		try match(MySqlParser.Tokens.NATURAL.rawValue)
		 		setState(3865)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LEFT.rawValue || _la == MySqlParser.Tokens.RIGHT.rawValue) {
		 			setState(3861)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.LEFT.rawValue || _la == MySqlParser.Tokens.RIGHT.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(3863)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.OUTER.rawValue) {
		 				setState(3862)
		 				try match(MySqlParser.Tokens.OUTER.rawValue)

		 			}


		 		}

		 		setState(3867)
		 		try match(MySqlParser.Tokens.JOIN.rawValue)
		 		setState(3868)
		 		try tableSourceItem()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class JoinSpecContext: ParserRuleContext {
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func USING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USING.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_joinSpec
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterJoinSpec(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitJoinSpec(self)
			}
		}
	}
	@discardableResult
	 open func joinSpec() throws -> JoinSpecContext {
		var _localctx: JoinSpecContext
		_localctx = JoinSpecContext(_ctx, getState())
		try enterRule(_localctx, 246, MySqlParser.RULE_joinSpec)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3878)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ON:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3871)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(3872)
		 		try expression(0)


		 		break

		 	case .USING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3873)
		 		try match(MySqlParser.Tokens.USING.rawValue)
		 		setState(3874)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3875)
		 		try uidList()
		 		setState(3876)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class QueryExpressionContext: ParserRuleContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func querySpecification() -> QuerySpecificationContext? {
				return getRuleContext(QuerySpecificationContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func queryExpression() -> QueryExpressionContext? {
				return getRuleContext(QueryExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_queryExpression
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterQueryExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitQueryExpression(self)
			}
		}
	}
	@discardableResult
	 open func queryExpression() throws -> QueryExpressionContext {
		var _localctx: QueryExpressionContext
		_localctx = QueryExpressionContext(_ctx, getState())
		try enterRule(_localctx, 248, MySqlParser.RULE_queryExpression)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3888)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,553, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3880)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3881)
		 		try querySpecification()
		 		setState(3882)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3884)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3885)
		 		try queryExpression()
		 		setState(3886)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class QueryExpressionNointoContext: ParserRuleContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func querySpecificationNointo() -> QuerySpecificationNointoContext? {
				return getRuleContext(QuerySpecificationNointoContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func queryExpressionNointo() -> QueryExpressionNointoContext? {
				return getRuleContext(QueryExpressionNointoContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_queryExpressionNointo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterQueryExpressionNointo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitQueryExpressionNointo(self)
			}
		}
	}
	@discardableResult
	 open func queryExpressionNointo() throws -> QueryExpressionNointoContext {
		var _localctx: QueryExpressionNointoContext
		_localctx = QueryExpressionNointoContext(_ctx, getState())
		try enterRule(_localctx, 250, MySqlParser.RULE_queryExpressionNointo)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(3898)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,554, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3890)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3891)
		 		try querySpecificationNointo()
		 		setState(3892)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3894)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(3895)
		 		try queryExpressionNointo()
		 		setState(3896)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class QuerySpecificationContext: ParserRuleContext {
			open
			func SELECT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SELECT.rawValue, 0)
			}
			open
			func selectElements() -> SelectElementsContext? {
				return getRuleContext(SelectElementsContext.self, 0)
			}
			open
			func fromClause() -> FromClauseContext? {
				return getRuleContext(FromClauseContext.self, 0)
			}
			open
			func selectSpec() -> [SelectSpecContext] {
				return getRuleContexts(SelectSpecContext.self)
			}
			open
			func selectSpec(_ i: Int) -> SelectSpecContext? {
				return getRuleContext(SelectSpecContext.self, i)
			}
			open
			func selectIntoExpression() -> SelectIntoExpressionContext? {
				return getRuleContext(SelectIntoExpressionContext.self, 0)
			}
			open
			func groupByClause() -> GroupByClauseContext? {
				return getRuleContext(GroupByClauseContext.self, 0)
			}
			open
			func havingClause() -> HavingClauseContext? {
				return getRuleContext(HavingClauseContext.self, 0)
			}
			open
			func windowClause() -> WindowClauseContext? {
				return getRuleContext(WindowClauseContext.self, 0)
			}
			open
			func orderByClause() -> OrderByClauseContext? {
				return getRuleContext(OrderByClauseContext.self, 0)
			}
			open
			func limitClause() -> LimitClauseContext? {
				return getRuleContext(LimitClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_querySpecification
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterQuerySpecification(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitQuerySpecification(self)
			}
		}
	}
	@discardableResult
	 open func querySpecification() throws -> QuerySpecificationContext {
		var _localctx: QuerySpecificationContext
		_localctx = QuerySpecificationContext(_ctx, getState())
		try enterRule(_localctx, 252, MySqlParser.RULE_querySpecification)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(3954)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,569, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(3900)
		 		try match(MySqlParser.Tokens.SELECT.rawValue)
		 		setState(3904)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,555,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(3901)
		 				try selectSpec()

		 		 
		 			}
		 			setState(3906)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,555,_ctx)
		 		}
		 		setState(3907)
		 		try selectElements()
		 		setState(3909)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.INTO.rawValue) {
		 			setState(3908)
		 			try selectIntoExpression()

		 		}

		 		setState(3911)
		 		try fromClause()
		 		setState(3913)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,557,_ctx)) {
		 		case 1:
		 			setState(3912)
		 			try groupByClause()

		 			break
		 		default: break
		 		}
		 		setState(3916)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.HAVING.rawValue) {
		 			setState(3915)
		 			try havingClause()

		 		}

		 		setState(3919)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.WINDOW.rawValue) {
		 			setState(3918)
		 			try windowClause()

		 		}

		 		setState(3922)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,560,_ctx)) {
		 		case 1:
		 			setState(3921)
		 			try orderByClause()

		 			break
		 		default: break
		 		}
		 		setState(3925)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,561,_ctx)) {
		 		case 1:
		 			setState(3924)
		 			try limitClause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(3927)
		 		try match(MySqlParser.Tokens.SELECT.rawValue)
		 		setState(3931)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,562,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(3928)
		 				try selectSpec()

		 		 
		 			}
		 			setState(3933)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,562,_ctx)
		 		}
		 		setState(3934)
		 		try selectElements()
		 		setState(3935)
		 		try fromClause()
		 		setState(3937)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,563,_ctx)) {
		 		case 1:
		 			setState(3936)
		 			try groupByClause()

		 			break
		 		default: break
		 		}
		 		setState(3940)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.HAVING.rawValue) {
		 			setState(3939)
		 			try havingClause()

		 		}

		 		setState(3943)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.WINDOW.rawValue) {
		 			setState(3942)
		 			try windowClause()

		 		}

		 		setState(3946)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,566,_ctx)) {
		 		case 1:
		 			setState(3945)
		 			try orderByClause()

		 			break
		 		default: break
		 		}
		 		setState(3949)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,567,_ctx)) {
		 		case 1:
		 			setState(3948)
		 			try limitClause()

		 			break
		 		default: break
		 		}
		 		setState(3952)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.INTO.rawValue) {
		 			setState(3951)
		 			try selectIntoExpression()

		 		}


		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class QuerySpecificationNointoContext: ParserRuleContext {
			open
			func SELECT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SELECT.rawValue, 0)
			}
			open
			func selectElements() -> SelectElementsContext? {
				return getRuleContext(SelectElementsContext.self, 0)
			}
			open
			func fromClause() -> FromClauseContext? {
				return getRuleContext(FromClauseContext.self, 0)
			}
			open
			func selectSpec() -> [SelectSpecContext] {
				return getRuleContexts(SelectSpecContext.self)
			}
			open
			func selectSpec(_ i: Int) -> SelectSpecContext? {
				return getRuleContext(SelectSpecContext.self, i)
			}
			open
			func groupByClause() -> GroupByClauseContext? {
				return getRuleContext(GroupByClauseContext.self, 0)
			}
			open
			func havingClause() -> HavingClauseContext? {
				return getRuleContext(HavingClauseContext.self, 0)
			}
			open
			func windowClause() -> WindowClauseContext? {
				return getRuleContext(WindowClauseContext.self, 0)
			}
			open
			func orderByClause() -> OrderByClauseContext? {
				return getRuleContext(OrderByClauseContext.self, 0)
			}
			open
			func limitClause() -> LimitClauseContext? {
				return getRuleContext(LimitClauseContext.self, 0)
			}
			open
			func unionStatement() -> UnionStatementContext? {
				return getRuleContext(UnionStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_querySpecificationNointo
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterQuerySpecificationNointo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitQuerySpecificationNointo(self)
			}
		}
	}
	@discardableResult
	 open func querySpecificationNointo() throws -> QuerySpecificationNointoContext {
		var _localctx: QuerySpecificationNointoContext
		_localctx = QuerySpecificationNointoContext(_ctx, getState())
		try enterRule(_localctx, 254, MySqlParser.RULE_querySpecificationNointo)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3956)
		 	try match(MySqlParser.Tokens.SELECT.rawValue)
		 	setState(3960)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,570,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(3957)
		 			try selectSpec()

		 	 
		 		}
		 		setState(3962)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,570,_ctx)
		 	}
		 	setState(3963)
		 	try selectElements()
		 	setState(3964)
		 	try fromClause()
		 	setState(3966)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,571,_ctx)) {
		 	case 1:
		 		setState(3965)
		 		try groupByClause()

		 		break
		 	default: break
		 	}
		 	setState(3969)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.HAVING.rawValue) {
		 		setState(3968)
		 		try havingClause()

		 	}

		 	setState(3972)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WINDOW.rawValue) {
		 		setState(3971)
		 		try windowClause()

		 	}

		 	setState(3975)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,574,_ctx)) {
		 	case 1:
		 		setState(3974)
		 		try orderByClause()

		 		break
		 	default: break
		 	}
		 	setState(3978)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,575,_ctx)) {
		 	case 1:
		 		setState(3977)
		 		try limitClause()

		 		break
		 	default: break
		 	}
		 	setState(3981)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,576,_ctx)) {
		 	case 1:
		 		setState(3980)
		 		try unionStatement()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnionParenthesisContext: ParserRuleContext {
		open var unionType: Token!
			open
			func UNION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNION.rawValue, 0)
			}
			open
			func queryExpressionNointo() -> QueryExpressionNointoContext? {
				return getRuleContext(QueryExpressionNointoContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func DISTINCT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISTINCT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_unionParenthesis
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUnionParenthesis(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUnionParenthesis(self)
			}
		}
	}
	@discardableResult
	 open func unionParenthesis() throws -> UnionParenthesisContext {
		var _localctx: UnionParenthesisContext
		_localctx = UnionParenthesisContext(_ctx, getState())
		try enterRule(_localctx, 256, MySqlParser.RULE_unionParenthesis)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3983)
		 	try match(MySqlParser.Tokens.UNION.rawValue)
		 	setState(3985)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ALL.rawValue || _la == MySqlParser.Tokens.DISTINCT.rawValue) {
		 		setState(3984)
		 		_localctx.castdown(UnionParenthesisContext.self).unionType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ALL.rawValue || _la == MySqlParser.Tokens.DISTINCT.rawValue)) {
		 			_localctx.castdown(UnionParenthesisContext.self).unionType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3987)
		 	try queryExpressionNointo()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnionStatementContext: ParserRuleContext {
		open var unionType: Token!
			open
			func UNION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNION.rawValue, 0)
			}
			open
			func querySpecificationNointo() -> QuerySpecificationNointoContext? {
				return getRuleContext(QuerySpecificationNointoContext.self, 0)
			}
			open
			func queryExpressionNointo() -> QueryExpressionNointoContext? {
				return getRuleContext(QueryExpressionNointoContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func DISTINCT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISTINCT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_unionStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUnionStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUnionStatement(self)
			}
		}
	}
	@discardableResult
	 open func unionStatement() throws -> UnionStatementContext {
		var _localctx: UnionStatementContext
		_localctx = UnionStatementContext(_ctx, getState())
		try enterRule(_localctx, 258, MySqlParser.RULE_unionStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3989)
		 	try match(MySqlParser.Tokens.UNION.rawValue)
		 	setState(3991)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ALL.rawValue || _la == MySqlParser.Tokens.DISTINCT.rawValue) {
		 		setState(3990)
		 		_localctx.castdown(UnionStatementContext.self).unionType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ALL.rawValue || _la == MySqlParser.Tokens.DISTINCT.rawValue)) {
		 			_localctx.castdown(UnionStatementContext.self).unionType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(3995)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SELECT:
		 		setState(3993)
		 		try querySpecificationNointo()

		 		break

		 	case .LR_BRACKET:
		 		setState(3994)
		 		try queryExpressionNointo()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LateralStatementContext: ParserRuleContext {
			open
			func LATERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LATERAL.rawValue, 0)
			}
			open
			func querySpecificationNointo() -> QuerySpecificationNointoContext? {
				return getRuleContext(QuerySpecificationNointoContext.self, 0)
			}
			open
			func queryExpressionNointo() -> QueryExpressionNointoContext? {
				return getRuleContext(QueryExpressionNointoContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_lateralStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLateralStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLateralStatement(self)
			}
		}
	}
	@discardableResult
	 open func lateralStatement() throws -> LateralStatementContext {
		var _localctx: LateralStatementContext
		_localctx = LateralStatementContext(_ctx, getState())
		try enterRule(_localctx, 260, MySqlParser.RULE_lateralStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(3997)
		 	try match(MySqlParser.Tokens.LATERAL.rawValue)
		 	setState(4012)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,583, _ctx)) {
		 	case 1:
		 		setState(3998)
		 		try querySpecificationNointo()

		 		break
		 	case 2:
		 		setState(3999)
		 		try queryExpressionNointo()

		 		break
		 	case 3:
		 		setState(4000)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4003)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .SELECT:
		 			setState(4001)
		 			try querySpecificationNointo()

		 			break

		 		case .LR_BRACKET:
		 			setState(4002)
		 			try queryExpressionNointo()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4005)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(4010)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,582,_ctx)) {
		 		case 1:
		 			setState(4007)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.AS.rawValue) {
		 				setState(4006)
		 				try match(MySqlParser.Tokens.AS.rawValue)

		 			}

		 			setState(4009)
		 			try uid()

		 			break
		 		default: break
		 		}


		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class JsonTableContext: ParserRuleContext {
			open
			func JSON_TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_TABLE.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func STRING_LITERAL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.STRING_LITERAL.rawValue)
			}
			open
			func STRING_LITERAL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, i)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}
			open
			func COLUMNS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMNS.rawValue, 0)
			}
			open
			func jsonColumnList() -> JsonColumnListContext? {
				return getRuleContext(JsonColumnListContext.self, 0)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_jsonTable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterJsonTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitJsonTable(self)
			}
		}
	}
	@discardableResult
	 open func jsonTable() throws -> JsonTableContext {
		var _localctx: JsonTableContext
		_localctx = JsonTableContext(_ctx, getState())
		try enterRule(_localctx, 262, MySqlParser.RULE_jsonTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4014)
		 	try match(MySqlParser.Tokens.JSON_TABLE.rawValue)
		 	setState(4015)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(4016)
		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 	setState(4017)
		 	try match(MySqlParser.Tokens.COMMA.rawValue)
		 	setState(4018)
		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 	setState(4019)
		 	try match(MySqlParser.Tokens.COLUMNS.rawValue)
		 	setState(4020)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(4021)
		 	try jsonColumnList()
		 	setState(4022)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(4023)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(4028)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,585,_ctx)) {
		 	case 1:
		 		setState(4025)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.AS.rawValue) {
		 			setState(4024)
		 			try match(MySqlParser.Tokens.AS.rawValue)

		 		}

		 		setState(4027)
		 		try uid()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class JsonColumnListContext: ParserRuleContext {
			open
			func jsonColumn() -> [JsonColumnContext] {
				return getRuleContexts(JsonColumnContext.self)
			}
			open
			func jsonColumn(_ i: Int) -> JsonColumnContext? {
				return getRuleContext(JsonColumnContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_jsonColumnList
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterJsonColumnList(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitJsonColumnList(self)
			}
		}
	}
	@discardableResult
	 open func jsonColumnList() throws -> JsonColumnListContext {
		var _localctx: JsonColumnListContext
		_localctx = JsonColumnListContext(_ctx, getState())
		try enterRule(_localctx, 264, MySqlParser.RULE_jsonColumnList)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4030)
		 	try jsonColumn()
		 	setState(4035)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(4031)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(4032)
		 		try jsonColumn()


		 		setState(4037)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class JsonColumnContext: ParserRuleContext {
			open
			func fullColumnName() -> FullColumnNameContext? {
				return getRuleContext(FullColumnNameContext.self, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func ORDINALITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ORDINALITY.rawValue, 0)
			}
			open
			func dataType() -> DataTypeContext? {
				return getRuleContext(DataTypeContext.self, 0)
			}
			open
			func PATH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PATH.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func EXISTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXISTS.rawValue, 0)
			}
			open
			func jsonOnEmpty() -> JsonOnEmptyContext? {
				return getRuleContext(JsonOnEmptyContext.self, 0)
			}
			open
			func jsonOnError() -> JsonOnErrorContext? {
				return getRuleContext(JsonOnErrorContext.self, 0)
			}
			open
			func NESTED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NESTED.rawValue, 0)
			}
			open
			func COLUMNS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMNS.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func jsonColumnList() -> JsonColumnListContext? {
				return getRuleContext(JsonColumnListContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_jsonColumn
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterJsonColumn(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitJsonColumn(self)
			}
		}
	}
	@discardableResult
	 open func jsonColumn() throws -> JsonColumnContext {
		var _localctx: JsonColumnContext
		_localctx = JsonColumnContext(_ctx, getState())
		try enterRule(_localctx, 266, MySqlParser.RULE_jsonColumn)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4067)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,592, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4038)
		 		try fullColumnName()
		 		setState(4055)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .FOR:
		 			setState(4039)
		 			try match(MySqlParser.Tokens.FOR.rawValue)
		 			setState(4040)
		 			try match(MySqlParser.Tokens.ORDINALITY.rawValue)

		 			break
		 		case .CHARACTER:fallthrough
		 		case .SET:fallthrough
		 		case .TINYINT:fallthrough
		 		case .SMALLINT:fallthrough
		 		case .MEDIUMINT:fallthrough
		 		case .MIDDLEINT:fallthrough
		 		case .INT:fallthrough
		 		case .INT1:fallthrough
		 		case .INT2:fallthrough
		 		case .INT3:fallthrough
		 		case .INT4:fallthrough
		 		case .INT8:fallthrough
		 		case .INTEGER:fallthrough
		 		case .BIGINT:fallthrough
		 		case .REAL:fallthrough
		 		case .DOUBLE:fallthrough
		 		case .FLOAT:fallthrough
		 		case .FLOAT4:fallthrough
		 		case .FLOAT8:fallthrough
		 		case .DECIMAL:fallthrough
		 		case .DEC:fallthrough
		 		case .NUMERIC:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .CHAR:fallthrough
		 		case .VARCHAR:fallthrough
		 		case .NVARCHAR:fallthrough
		 		case .NATIONAL:fallthrough
		 		case .BINARY:fallthrough
		 		case .VARBINARY:fallthrough
		 		case .TINYBLOB:fallthrough
		 		case .BLOB:fallthrough
		 		case .MEDIUMBLOB:fallthrough
		 		case .LONG:fallthrough
		 		case .LONGBLOB:fallthrough
		 		case .TINYTEXT:fallthrough
		 		case .TEXT:fallthrough
		 		case .MEDIUMTEXT:fallthrough
		 		case .LONGTEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .BIT:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .FIXED:fallthrough
		 		case .JSON:fallthrough
		 		case .NCHAR:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .GEOMCOLLECTION:fallthrough
		 		case .GEOMETRY:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:
		 			setState(4041)
		 			try dataType()
		 			setState(4053)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .PATH:
		 				setState(4042)
		 				try match(MySqlParser.Tokens.PATH.rawValue)
		 				setState(4043)
		 				try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				setState(4045)
		 				try _errHandler.sync(self)
		 				switch (try getInterpreter().adaptivePredict(_input,587,_ctx)) {
		 				case 1:
		 					setState(4044)
		 					try jsonOnEmpty()

		 					break
		 				default: break
		 				}
		 				setState(4048)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				if (_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.NULL_LITERAL.rawValue || _la == MySqlParser.Tokens.ERROR.rawValue) {
		 					setState(4047)
		 					try jsonOnError()

		 				}


		 				break

		 			case .EXISTS:
		 				setState(4050)
		 				try match(MySqlParser.Tokens.EXISTS.rawValue)
		 				setState(4051)
		 				try match(MySqlParser.Tokens.PATH.rawValue)
		 				setState(4052)
		 				try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4057)
		 		try match(MySqlParser.Tokens.NESTED.rawValue)
		 		setState(4059)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.PATH.rawValue) {
		 			setState(4058)
		 			try match(MySqlParser.Tokens.PATH.rawValue)

		 		}

		 		setState(4061)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 		setState(4062)
		 		try match(MySqlParser.Tokens.COLUMNS.rawValue)
		 		setState(4063)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4064)
		 		try jsonColumnList()
		 		setState(4065)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class JsonOnEmptyContext: ParserRuleContext {
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func EMPTY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EMPTY.rawValue, 0)
			}
			open
			func NULL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NULL_LITERAL.rawValue, 0)
			}
			open
			func ERROR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ERROR.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func defaultValue() -> DefaultValueContext? {
				return getRuleContext(DefaultValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_jsonOnEmpty
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterJsonOnEmpty(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitJsonOnEmpty(self)
			}
		}
	}
	@discardableResult
	 open func jsonOnEmpty() throws -> JsonOnEmptyContext {
		var _localctx: JsonOnEmptyContext
		_localctx = JsonOnEmptyContext(_ctx, getState())
		try enterRule(_localctx, 268, MySqlParser.RULE_jsonOnEmpty)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4073)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NULL_LITERAL:
		 		setState(4069)
		 		try match(MySqlParser.Tokens.NULL_LITERAL.rawValue)

		 		break

		 	case .ERROR:
		 		setState(4070)
		 		try match(MySqlParser.Tokens.ERROR.rawValue)

		 		break

		 	case .DEFAULT:
		 		setState(4071)
		 		try match(MySqlParser.Tokens.DEFAULT.rawValue)
		 		setState(4072)
		 		try defaultValue()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4075)
		 	try match(MySqlParser.Tokens.ON.rawValue)
		 	setState(4076)
		 	try match(MySqlParser.Tokens.EMPTY.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class JsonOnErrorContext: ParserRuleContext {
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func ERROR() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ERROR.rawValue)
			}
			open
			func ERROR(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ERROR.rawValue, i)
			}
			open
			func NULL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NULL_LITERAL.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func defaultValue() -> DefaultValueContext? {
				return getRuleContext(DefaultValueContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_jsonOnError
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterJsonOnError(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitJsonOnError(self)
			}
		}
	}
	@discardableResult
	 open func jsonOnError() throws -> JsonOnErrorContext {
		var _localctx: JsonOnErrorContext
		_localctx = JsonOnErrorContext(_ctx, getState())
		try enterRule(_localctx, 270, MySqlParser.RULE_jsonOnError)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4082)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .NULL_LITERAL:
		 		setState(4078)
		 		try match(MySqlParser.Tokens.NULL_LITERAL.rawValue)

		 		break

		 	case .ERROR:
		 		setState(4079)
		 		try match(MySqlParser.Tokens.ERROR.rawValue)

		 		break

		 	case .DEFAULT:
		 		setState(4080)
		 		try match(MySqlParser.Tokens.DEFAULT.rawValue)
		 		setState(4081)
		 		try defaultValue()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(4084)
		 	try match(MySqlParser.Tokens.ON.rawValue)
		 	setState(4085)
		 	try match(MySqlParser.Tokens.ERROR.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SelectSpecContext: ParserRuleContext {
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func DISTINCT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISTINCT.rawValue, 0)
			}
			open
			func DISTINCTROW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISTINCTROW.rawValue, 0)
			}
			open
			func HIGH_PRIORITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HIGH_PRIORITY.rawValue, 0)
			}
			open
			func STRAIGHT_JOIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRAIGHT_JOIN.rawValue, 0)
			}
			open
			func SQL_SMALL_RESULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_SMALL_RESULT.rawValue, 0)
			}
			open
			func SQL_BIG_RESULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_BIG_RESULT.rawValue, 0)
			}
			open
			func SQL_BUFFER_RESULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_BUFFER_RESULT.rawValue, 0)
			}
			open
			func SQL_CACHE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_CACHE.rawValue, 0)
			}
			open
			func SQL_NO_CACHE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_NO_CACHE.rawValue, 0)
			}
			open
			func SQL_CALC_FOUND_ROWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_CALC_FOUND_ROWS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_selectSpec
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSelectSpec(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSelectSpec(self)
			}
		}
	}
	@discardableResult
	 open func selectSpec() throws -> SelectSpecContext {
		var _localctx: SelectSpecContext
		_localctx = SelectSpecContext(_ctx, getState())
		try enterRule(_localctx, 272, MySqlParser.RULE_selectSpec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4095)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ALL:fallthrough
		 	case .DISTINCT:fallthrough
		 	case .DISTINCTROW:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4087)
		 		_la = try _input.LA(1)
		 		if (!(((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 1688849860264000) != 0))) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .HIGH_PRIORITY:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4088)
		 		try match(MySqlParser.Tokens.HIGH_PRIORITY.rawValue)

		 		break

		 	case .STRAIGHT_JOIN:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4089)
		 		try match(MySqlParser.Tokens.STRAIGHT_JOIN.rawValue)

		 		break

		 	case .SQL_SMALL_RESULT:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4090)
		 		try match(MySqlParser.Tokens.SQL_SMALL_RESULT.rawValue)

		 		break

		 	case .SQL_BIG_RESULT:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4091)
		 		try match(MySqlParser.Tokens.SQL_BIG_RESULT.rawValue)

		 		break

		 	case .SQL_BUFFER_RESULT:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(4092)
		 		try match(MySqlParser.Tokens.SQL_BUFFER_RESULT.rawValue)

		 		break
		 	case .SQL_CACHE:fallthrough
		 	case .SQL_NO_CACHE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(4093)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.SQL_CACHE.rawValue || _la == MySqlParser.Tokens.SQL_NO_CACHE.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .SQL_CALC_FOUND_ROWS:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(4094)
		 		try match(MySqlParser.Tokens.SQL_CALC_FOUND_ROWS.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SelectElementsContext: ParserRuleContext {
		open var star: Token!
			open
			func selectElement() -> [SelectElementContext] {
				return getRuleContexts(SelectElementContext.self)
			}
			open
			func selectElement(_ i: Int) -> SelectElementContext? {
				return getRuleContext(SelectElementContext.self, i)
			}
			open
			func STAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STAR.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_selectElements
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSelectElements(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSelectElements(self)
			}
		}
	}
	@discardableResult
	 open func selectElements() throws -> SelectElementsContext {
		var _localctx: SelectElementsContext
		_localctx = SelectElementsContext(_ctx, getState())
		try enterRule(_localctx, 274, MySqlParser.RULE_selectElements)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4099)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,596, _ctx)) {
		 	case 1:
		 		setState(4097)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STAR.rawValue)
		 				_localctx.castdown(SelectElementsContext.self).star = assignmentValue
		 		     }()


		 		break
		 	case 2:
		 		setState(4098)
		 		try selectElement()

		 		break
		 	default: break
		 	}
		 	setState(4105)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,597,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4101)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(4102)
		 			try selectElement()

		 	 
		 		}
		 		setState(4107)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,597,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SelectElementContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_selectElement
		}
	}
	public class SelectExpressionElementContext: SelectElementContext {
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func LOCAL_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL_ID.rawValue, 0)
			}
			open
			func VAR_ASSIGN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VAR_ASSIGN.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}

		public
		init(_ ctx: SelectElementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSelectExpressionElement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSelectExpressionElement(self)
			}
		}
	}
	public class SelectFunctionElementContext: SelectElementContext {
			open
			func functionCall() -> FunctionCallContext? {
				return getRuleContext(FunctionCallContext.self, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}

		public
		init(_ ctx: SelectElementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSelectFunctionElement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSelectFunctionElement(self)
			}
		}
	}
	public class SelectStarElementContext: SelectElementContext {
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func DOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DOT.rawValue, 0)
			}
			open
			func STAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STAR.rawValue, 0)
			}

		public
		init(_ ctx: SelectElementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSelectStarElement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSelectStarElement(self)
			}
		}
	}
	public class SelectColumnElementContext: SelectElementContext {
			open
			func fullColumnName() -> FullColumnNameContext? {
				return getRuleContext(FullColumnNameContext.self, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}

		public
		init(_ ctx: SelectElementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSelectColumnElement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSelectColumnElement(self)
			}
		}
	}
	@discardableResult
	 open func selectElement() throws -> SelectElementContext {
		var _localctx: SelectElementContext
		_localctx = SelectElementContext(_ctx, getState())
		try enterRule(_localctx, 276, MySqlParser.RULE_selectElement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4137)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,605, _ctx)) {
		 	case 1:
		 		_localctx =  SelectStarElementContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4108)
		 		try fullId()
		 		setState(4109)
		 		try match(MySqlParser.Tokens.DOT.rawValue)
		 		setState(4110)
		 		try match(MySqlParser.Tokens.STAR.rawValue)

		 		break
		 	case 2:
		 		_localctx =  SelectColumnElementContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4112)
		 		try fullColumnName()
		 		setState(4117)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,599,_ctx)) {
		 		case 1:
		 			setState(4114)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.AS.rawValue) {
		 				setState(4113)
		 				try match(MySqlParser.Tokens.AS.rawValue)

		 			}

		 			setState(4116)
		 			try uid()

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		_localctx =  SelectFunctionElementContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4119)
		 		try functionCall()
		 		setState(4124)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,601,_ctx)) {
		 		case 1:
		 			setState(4121)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.AS.rawValue) {
		 				setState(4120)
		 				try match(MySqlParser.Tokens.AS.rawValue)

		 			}

		 			setState(4123)
		 			try uid()

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		_localctx =  SelectExpressionElementContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4128)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,602,_ctx)) {
		 		case 1:
		 			setState(4126)
		 			try match(MySqlParser.Tokens.LOCAL_ID.rawValue)
		 			setState(4127)
		 			try match(MySqlParser.Tokens.VAR_ASSIGN.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(4130)
		 		try expression(0)
		 		setState(4135)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,604,_ctx)) {
		 		case 1:
		 			setState(4132)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.AS.rawValue) {
		 				setState(4131)
		 				try match(MySqlParser.Tokens.AS.rawValue)

		 			}

		 			setState(4134)
		 			try uid()

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SelectIntoExpressionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_selectIntoExpression
		}
	}
	public class SelectIntoVariablesContext: SelectIntoExpressionContext {
			open
			func INTO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTO.rawValue, 0)
			}
			open
			func assignmentField() -> [AssignmentFieldContext] {
				return getRuleContexts(AssignmentFieldContext.self)
			}
			open
			func assignmentField(_ i: Int) -> AssignmentFieldContext? {
				return getRuleContext(AssignmentFieldContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: SelectIntoExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSelectIntoVariables(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSelectIntoVariables(self)
			}
		}
	}
	public class SelectIntoTextFileContext: SelectIntoExpressionContext {
		public var filename: Token!
		public var charset: CharsetNameContext!
		public var fieldsFormat: Token!
			open
			func INTO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTO.rawValue, 0)
			}
			open
			func OUTFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OUTFILE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func LINES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINES.rawValue, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func FIELDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIELDS.rawValue, 0)
			}
			open
			func COLUMNS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMNS.rawValue, 0)
			}
			open
			func selectFieldsInto() -> [SelectFieldsIntoContext] {
				return getRuleContexts(SelectFieldsIntoContext.self)
			}
			open
			func selectFieldsInto(_ i: Int) -> SelectFieldsIntoContext? {
				return getRuleContext(SelectFieldsIntoContext.self, i)
			}
			open
			func selectLinesInto() -> [SelectLinesIntoContext] {
				return getRuleContexts(SelectLinesIntoContext.self)
			}
			open
			func selectLinesInto(_ i: Int) -> SelectLinesIntoContext? {
				return getRuleContext(SelectLinesIntoContext.self, i)
			}

		public
		init(_ ctx: SelectIntoExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSelectIntoTextFile(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSelectIntoTextFile(self)
			}
		}
	}
	public class SelectIntoDumpFileContext: SelectIntoExpressionContext {
			open
			func INTO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTO.rawValue, 0)
			}
			open
			func DUMPFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DUMPFILE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: SelectIntoExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSelectIntoDumpFile(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSelectIntoDumpFile(self)
			}
		}
	}
	@discardableResult
	 open func selectIntoExpression() throws -> SelectIntoExpressionContext {
		var _localctx: SelectIntoExpressionContext
		_localctx = SelectIntoExpressionContext(_ctx, getState())
		try enterRule(_localctx, 278, MySqlParser.RULE_selectIntoExpression)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4175)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,612, _ctx)) {
		 	case 1:
		 		_localctx =  SelectIntoVariablesContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4139)
		 		try match(MySqlParser.Tokens.INTO.rawValue)
		 		setState(4140)
		 		try assignmentField()
		 		setState(4145)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(4141)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(4142)
		 			try assignmentField()


		 			setState(4147)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		_localctx =  SelectIntoDumpFileContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4148)
		 		try match(MySqlParser.Tokens.INTO.rawValue)
		 		setState(4149)
		 		try match(MySqlParser.Tokens.DUMPFILE.rawValue)
		 		setState(4150)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 3:
		 		_localctx =  SelectIntoTextFileContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4151)
		 		try match(MySqlParser.Tokens.INTO.rawValue)
		 		setState(4152)
		 		try match(MySqlParser.Tokens.OUTFILE.rawValue)
		 		setState(4153)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(SelectIntoTextFileContext.self).filename = assignmentValue
		 		     }()

		 		setState(4157)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CHARACTER.rawValue) {
		 			setState(4154)
		 			try match(MySqlParser.Tokens.CHARACTER.rawValue)
		 			setState(4155)
		 			try match(MySqlParser.Tokens.SET.rawValue)
		 			setState(4156)
		 			try {
		 					let assignmentValue = try charsetName()
		 					_localctx.castdown(SelectIntoTextFileContext.self).charset = assignmentValue
		 			     }()


		 		}

		 		setState(4165)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,609,_ctx)) {
		 		case 1:
		 			setState(4159)
		 			_localctx.castdown(SelectIntoTextFileContext.self).fieldsFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.COLUMNS.rawValue || _la == MySqlParser.Tokens.FIELDS.rawValue)) {
		 				_localctx.castdown(SelectIntoTextFileContext.self).fieldsFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(4161) 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			repeat {
		 				setState(4160)
		 				try selectFieldsInto()


		 				setState(4163); 
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			} while (_la == MySqlParser.Tokens.ENCLOSED.rawValue || _la == MySqlParser.Tokens.ESCAPED.rawValue || _la == MySqlParser.Tokens.OPTIONALLY.rawValue || _la == MySqlParser.Tokens.TERMINATED.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(4173)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LINES.rawValue) {
		 			setState(4167)
		 			try match(MySqlParser.Tokens.LINES.rawValue)
		 			setState(4169) 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			repeat {
		 				setState(4168)
		 				try selectLinesInto()


		 				setState(4171); 
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			} while (_la == MySqlParser.Tokens.STARTING.rawValue || _la == MySqlParser.Tokens.TERMINATED.rawValue)

		 		}



		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SelectFieldsIntoContext: ParserRuleContext {
		open var terminationField: Token!
		open var enclosion: Token!
		open var escaping: Token!
			open
			func TERMINATED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TERMINATED.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func ENCLOSED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENCLOSED.rawValue, 0)
			}
			open
			func OPTIONALLY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTIONALLY.rawValue, 0)
			}
			open
			func ESCAPED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ESCAPED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_selectFieldsInto
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSelectFieldsInto(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSelectFieldsInto(self)
			}
		}
	}
	@discardableResult
	 open func selectFieldsInto() throws -> SelectFieldsIntoContext {
		var _localctx: SelectFieldsIntoContext
		_localctx = SelectFieldsIntoContext(_ctx, getState())
		try enterRule(_localctx, 280, MySqlParser.RULE_selectFieldsInto)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4189)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .TERMINATED:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4177)
		 		try match(MySqlParser.Tokens.TERMINATED.rawValue)
		 		setState(4178)
		 		try match(MySqlParser.Tokens.BY.rawValue)
		 		setState(4179)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(SelectFieldsIntoContext.self).terminationField = assignmentValue
		 		     }()


		 		break
		 	case .ENCLOSED:fallthrough
		 	case .OPTIONALLY:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4181)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.OPTIONALLY.rawValue) {
		 			setState(4180)
		 			try match(MySqlParser.Tokens.OPTIONALLY.rawValue)

		 		}

		 		setState(4183)
		 		try match(MySqlParser.Tokens.ENCLOSED.rawValue)
		 		setState(4184)
		 		try match(MySqlParser.Tokens.BY.rawValue)
		 		setState(4185)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(SelectFieldsIntoContext.self).enclosion = assignmentValue
		 		     }()


		 		break

		 	case .ESCAPED:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4186)
		 		try match(MySqlParser.Tokens.ESCAPED.rawValue)
		 		setState(4187)
		 		try match(MySqlParser.Tokens.BY.rawValue)
		 		setState(4188)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(SelectFieldsIntoContext.self).escaping = assignmentValue
		 		     }()


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SelectLinesIntoContext: ParserRuleContext {
		open var starting: Token!
		open var terminationLine: Token!
			open
			func STARTING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STARTING.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func TERMINATED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TERMINATED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_selectLinesInto
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSelectLinesInto(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSelectLinesInto(self)
			}
		}
	}
	@discardableResult
	 open func selectLinesInto() throws -> SelectLinesIntoContext {
		var _localctx: SelectLinesIntoContext
		_localctx = SelectLinesIntoContext(_ctx, getState())
		try enterRule(_localctx, 282, MySqlParser.RULE_selectLinesInto)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4197)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .STARTING:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4191)
		 		try match(MySqlParser.Tokens.STARTING.rawValue)
		 		setState(4192)
		 		try match(MySqlParser.Tokens.BY.rawValue)
		 		setState(4193)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(SelectLinesIntoContext.self).starting = assignmentValue
		 		     }()


		 		break

		 	case .TERMINATED:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4194)
		 		try match(MySqlParser.Tokens.TERMINATED.rawValue)
		 		setState(4195)
		 		try match(MySqlParser.Tokens.BY.rawValue)
		 		setState(4196)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(SelectLinesIntoContext.self).terminationLine = assignmentValue
		 		     }()


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FromClauseContext: ParserRuleContext {
		open var whereExpr: ExpressionContext!
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func tableSources() -> TableSourcesContext? {
				return getRuleContext(TableSourcesContext.self, 0)
			}
			open
			func WHERE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHERE.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_fromClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFromClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFromClause(self)
			}
		}
	}
	@discardableResult
	 open func fromClause() throws -> FromClauseContext {
		var _localctx: FromClauseContext
		_localctx = FromClauseContext(_ctx, getState())
		try enterRule(_localctx, 284, MySqlParser.RULE_fromClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4201)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.FROM.rawValue) {
		 		setState(4199)
		 		try match(MySqlParser.Tokens.FROM.rawValue)
		 		setState(4200)
		 		try tableSources()

		 	}

		 	setState(4205)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WHERE.rawValue) {
		 		setState(4203)
		 		try match(MySqlParser.Tokens.WHERE.rawValue)
		 		setState(4204)
		 		try {
		 				let assignmentValue = try expression(0)
		 				_localctx.castdown(FromClauseContext.self).whereExpr = assignmentValue
		 		     }()


		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GroupByClauseContext: ParserRuleContext {
			open
			func GROUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func groupByItem() -> [GroupByItemContext] {
				return getRuleContexts(GroupByItemContext.self)
			}
			open
			func groupByItem(_ i: Int) -> GroupByItemContext? {
				return getRuleContext(GroupByItemContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func ROLLUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLLUP.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_groupByClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterGroupByClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitGroupByClause(self)
			}
		}
	}
	@discardableResult
	 open func groupByClause() throws -> GroupByClauseContext {
		var _localctx: GroupByClauseContext
		_localctx = GroupByClauseContext(_ctx, getState())
		try enterRule(_localctx, 286, MySqlParser.RULE_groupByClause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4207)
		 	try match(MySqlParser.Tokens.GROUP.rawValue)
		 	setState(4208)
		 	try match(MySqlParser.Tokens.BY.rawValue)
		 	setState(4209)
		 	try groupByItem()
		 	setState(4214)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,618,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4210)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(4211)
		 			try groupByItem()

		 	 
		 		}
		 		setState(4216)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,618,_ctx)
		 	}
		 	setState(4219)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,619,_ctx)) {
		 	case 1:
		 		setState(4217)
		 		try match(MySqlParser.Tokens.WITH.rawValue)
		 		setState(4218)
		 		try match(MySqlParser.Tokens.ROLLUP.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HavingClauseContext: ParserRuleContext {
		open var havingExpr: ExpressionContext!
			open
			func HAVING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HAVING.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_havingClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHavingClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHavingClause(self)
			}
		}
	}
	@discardableResult
	 open func havingClause() throws -> HavingClauseContext {
		var _localctx: HavingClauseContext
		_localctx = HavingClauseContext(_ctx, getState())
		try enterRule(_localctx, 288, MySqlParser.RULE_havingClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4221)
		 	try match(MySqlParser.Tokens.HAVING.rawValue)
		 	setState(4222)
		 	try {
		 			let assignmentValue = try expression(0)
		 			_localctx.castdown(HavingClauseContext.self).havingExpr = assignmentValue
		 	     }()


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WindowClauseContext: ParserRuleContext {
			open
			func WINDOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WINDOW.rawValue, 0)
			}
			open
			func windowName() -> [WindowNameContext] {
				return getRuleContexts(WindowNameContext.self)
			}
			open
			func windowName(_ i: Int) -> WindowNameContext? {
				return getRuleContext(WindowNameContext.self, i)
			}
			open
			func AS() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.AS.rawValue)
			}
			open
			func AS(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, i)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func windowSpec() -> [WindowSpecContext] {
				return getRuleContexts(WindowSpecContext.self)
			}
			open
			func windowSpec(_ i: Int) -> WindowSpecContext? {
				return getRuleContext(WindowSpecContext.self, i)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_windowClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterWindowClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitWindowClause(self)
			}
		}
	}
	@discardableResult
	 open func windowClause() throws -> WindowClauseContext {
		var _localctx: WindowClauseContext
		_localctx = WindowClauseContext(_ctx, getState())
		try enterRule(_localctx, 290, MySqlParser.RULE_windowClause)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4224)
		 	try match(MySqlParser.Tokens.WINDOW.rawValue)
		 	setState(4225)
		 	try windowName()
		 	setState(4226)
		 	try match(MySqlParser.Tokens.AS.rawValue)
		 	setState(4227)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(4228)
		 	try windowSpec()
		 	setState(4229)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 	setState(4239)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,620,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4230)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(4231)
		 			try windowName()
		 			setState(4232)
		 			try match(MySqlParser.Tokens.AS.rawValue)
		 			setState(4233)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(4234)
		 			try windowSpec()
		 			setState(4235)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	 
		 		}
		 		setState(4241)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,620,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GroupByItemContext: ParserRuleContext {
		open var order: Token!
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func ASC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASC.rawValue, 0)
			}
			open
			func DESC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DESC.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_groupByItem
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterGroupByItem(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitGroupByItem(self)
			}
		}
	}
	@discardableResult
	 open func groupByItem() throws -> GroupByItemContext {
		var _localctx: GroupByItemContext
		_localctx = GroupByItemContext(_ctx, getState())
		try enterRule(_localctx, 292, MySqlParser.RULE_groupByItem)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4242)
		 	try expression(0)
		 	setState(4244)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,621,_ctx)) {
		 	case 1:
		 		setState(4243)
		 		_localctx.castdown(GroupByItemContext.self).order = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ASC.rawValue || _la == MySqlParser.Tokens.DESC.rawValue)) {
		 			_localctx.castdown(GroupByItemContext.self).order = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LimitClauseContext: ParserRuleContext {
		open var offset: LimitClauseAtomContext!
		open var limit: LimitClauseAtomContext!
			open
			func LIMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIMIT.rawValue, 0)
			}
			open
			func OFFSET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OFFSET.rawValue, 0)
			}
			open
			func limitClauseAtom() -> [LimitClauseAtomContext] {
				return getRuleContexts(LimitClauseAtomContext.self)
			}
			open
			func limitClauseAtom(_ i: Int) -> LimitClauseAtomContext? {
				return getRuleContext(LimitClauseAtomContext.self, i)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_limitClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLimitClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLimitClause(self)
			}
		}
	}
	@discardableResult
	 open func limitClause() throws -> LimitClauseContext {
		var _localctx: LimitClauseContext
		_localctx = LimitClauseContext(_ctx, getState())
		try enterRule(_localctx, 294, MySqlParser.RULE_limitClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4246)
		 	try match(MySqlParser.Tokens.LIMIT.rawValue)
		 	setState(4257)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,623, _ctx)) {
		 	case 1:
		 		setState(4250)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,622,_ctx)) {
		 		case 1:
		 			setState(4247)
		 			try {
		 					let assignmentValue = try limitClauseAtom()
		 					_localctx.castdown(LimitClauseContext.self).offset = assignmentValue
		 			     }()

		 			setState(4248)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(4252)
		 		try {
		 				let assignmentValue = try limitClauseAtom()
		 				_localctx.castdown(LimitClauseContext.self).limit = assignmentValue
		 		     }()


		 		break
		 	case 2:
		 		setState(4253)
		 		try {
		 				let assignmentValue = try limitClauseAtom()
		 				_localctx.castdown(LimitClauseContext.self).limit = assignmentValue
		 		     }()

		 		setState(4254)
		 		try match(MySqlParser.Tokens.OFFSET.rawValue)
		 		setState(4255)
		 		try {
		 				let assignmentValue = try limitClauseAtom()
		 				_localctx.castdown(LimitClauseContext.self).offset = assignmentValue
		 		     }()


		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LimitClauseAtomContext: ParserRuleContext {
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func mysqlVariable() -> MysqlVariableContext? {
				return getRuleContext(MysqlVariableContext.self, 0)
			}
			open
			func simpleId() -> SimpleIdContext? {
				return getRuleContext(SimpleIdContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_limitClauseAtom
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLimitClauseAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLimitClauseAtom(self)
			}
		}
	}
	@discardableResult
	 open func limitClauseAtom() throws -> LimitClauseAtomContext {
		var _localctx: LimitClauseAtomContext
		_localctx = LimitClauseAtomContext(_ctx, getState())
		try enterRule(_localctx, 296, MySqlParser.RULE_limitClauseAtom)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4262)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ZERO_DECIMAL:fallthrough
		 	case .ONE_DECIMAL:fallthrough
		 	case .TWO_DECIMAL:fallthrough
		 	case .DECIMAL_LITERAL:fallthrough
		 	case .REAL_LITERAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4259)
		 		try decimalLiteral()

		 		break
		 	case .LOCAL_ID:fallthrough
		 	case .GLOBAL_ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4260)
		 		try mysqlVariable()

		 		break
		 	case .ARRAY:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .BUCKETS:fallthrough
		 	case .CONDITION:fallthrough
		 	case .CURRENT:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DIAGNOSTICS:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENFORCED:fallthrough
		 	case .EXCEPT:fallthrough
		 	case .GROUP:fallthrough
		 	case .IF:fallthrough
		 	case .IGNORED:fallthrough
		 	case .INSERT:fallthrough
		 	case .LATERAL:fallthrough
		 	case .LEFT:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OPTIONAL:fallthrough
		 	case .ORDER:fallthrough
		 	case .PRIMARY:fallthrough
		 	case .REPEAT:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SKIP_QUERY_REWRITE:fallthrough
		 	case .STACKED:fallthrough
		 	case .DATE:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .DATETIME:fallthrough
		 	case .YEAR:fallthrough
		 	case .BINARY:fallthrough
		 	case .TEXT:fallthrough
		 	case .ENUM:fallthrough
		 	case .SERIAL:fallthrough
		 	case .JSON_ARRAY:fallthrough
		 	case .JSON_ARRAYAGG:fallthrough
		 	case .JSON_ARRAY_APPEND:fallthrough
		 	case .JSON_ARRAY_INSERT:fallthrough
		 	case .JSON_CONTAINS:fallthrough
		 	case .JSON_CONTAINS_PATH:fallthrough
		 	case .JSON_DEPTH:fallthrough
		 	case .JSON_EXTRACT:fallthrough
		 	case .JSON_INSERT:fallthrough
		 	case .JSON_KEYS:fallthrough
		 	case .JSON_LENGTH:fallthrough
		 	case .JSON_MERGE:fallthrough
		 	case .JSON_MERGE_PATCH:fallthrough
		 	case .JSON_MERGE_PRESERVE:fallthrough
		 	case .JSON_OBJECT:fallthrough
		 	case .JSON_OBJECTAGG:fallthrough
		 	case .JSON_OVERLAPS:fallthrough
		 	case .JSON_PRETTY:fallthrough
		 	case .JSON_QUOTE:fallthrough
		 	case .JSON_REMOVE:fallthrough
		 	case .JSON_REPLACE:fallthrough
		 	case .JSON_SCHEMA_VALID:fallthrough
		 	case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 	case .JSON_SEARCH:fallthrough
		 	case .JSON_SET:fallthrough
		 	case .JSON_STORAGE_FREE:fallthrough
		 	case .JSON_STORAGE_SIZE:fallthrough
		 	case .JSON_TABLE:fallthrough
		 	case .JSON_TYPE:fallthrough
		 	case .JSON_UNQUOTE:fallthrough
		 	case .JSON_VALID:fallthrough
		 	case .JSON_VALUE:fallthrough
		 	case .NESTED:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .PATH:fallthrough
		 	case .AVG:fallthrough
		 	case .BIT_AND:fallthrough
		 	case .BIT_OR:fallthrough
		 	case .BIT_XOR:fallthrough
		 	case .COUNT:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .GROUP_CONCAT:fallthrough
		 	case .LAG:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NTH_VALUE:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .STD:fallthrough
		 	case .STDDEV:fallthrough
		 	case .STDDEV_POP:fallthrough
		 	case .STDDEV_SAMP:fallthrough
		 	case .SUM:fallthrough
		 	case .VAR_POP:fallthrough
		 	case .VAR_SAMP:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .CURRENT_DATE:fallthrough
		 	case .CURRENT_TIME:fallthrough
		 	case .CURRENT_TIMESTAMP:fallthrough
		 	case .LOCALTIME:fallthrough
		 	case .CURDATE:fallthrough
		 	case .CURTIME:fallthrough
		 	case .DATE_ADD:fallthrough
		 	case .DATE_SUB:fallthrough
		 	case .LOCALTIMESTAMP:fallthrough
		 	case .NOW:fallthrough
		 	case .POSITION:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .SUBSTRING:fallthrough
		 	case .SYSDATE:fallthrough
		 	case .TRIM:fallthrough
		 	case .UTC_DATE:fallthrough
		 	case .UTC_TIME:fallthrough
		 	case .UTC_TIMESTAMP:fallthrough
		 	case .ACCOUNT:fallthrough
		 	case .ACTION:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALGORITHM:fallthrough
		 	case .ANY:fallthrough
		 	case .AT:fallthrough
		 	case .AUTHORS:fallthrough
		 	case .AUTOCOMMIT:fallthrough
		 	case .AUTOEXTEND_SIZE:fallthrough
		 	case .AUTO_INCREMENT:fallthrough
		 	case .AVG_ROW_LENGTH:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BINLOG:fallthrough
		 	case .BIT:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BOOL:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BTREE:fallthrough
		 	case .CACHE:fallthrough
		 	case .CASCADED:fallthrough
		 	case .CHAIN:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CHECKSUM:fallthrough
		 	case .PAGE_CHECKSUM:fallthrough
		 	case .CIPHER:fallthrough
		 	case .CLASS_ORIGIN:fallthrough
		 	case .CLIENT:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTERING:fallthrough
		 	case .COALESCE:fallthrough
		 	case .CODE:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COLUMN_FORMAT:fallthrough
		 	case .COLUMN_NAME:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMPACT:fallthrough
		 	case .COMPLETION:fallthrough
		 	case .COMPRESSED:fallthrough
		 	case .COMPRESSION:fallthrough
		 	case .CONCURRENT:fallthrough
		 	case .CONNECT:fallthrough
		 	case .CONNECTION:fallthrough
		 	case .CONSISTENT:fallthrough
		 	case .CONSTRAINT_CATALOG:fallthrough
		 	case .CONSTRAINT_SCHEMA:fallthrough
		 	case .CONSTRAINT_NAME:fallthrough
		 	case .CONTAINS:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTRIBUTORS:fallthrough
		 	case .COPY:fallthrough
		 	case .CPU:fallthrough
		 	case .CURSOR_NAME:fallthrough
		 	case .DATA:fallthrough
		 	case .DATAFILE:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DEFAULT_AUTH:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DELAY_KEY_WRITE:fallthrough
		 	case .DES_KEY_FILE:fallthrough
		 	case .DIRECTORY:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISCARD:fallthrough
		 	case .DISK:fallthrough
		 	case .DO:fallthrough
		 	case .DUMPFILE:fallthrough
		 	case .DUPLICATE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .END:fallthrough
		 	case .ENDS:fallthrough
		 	case .ENGINE:fallthrough
		 	case .ENGINES:fallthrough
		 	case .ERROR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVEN:fallthrough
		 	case .EVENT:fallthrough
		 	case .EVENTS:fallthrough
		 	case .EVERY:fallthrough
		 	case .EXCHANGE:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPIRE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .EXTENT_SIZE:fallthrough
		 	case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 	case .FAST:fallthrough
		 	case .FAULTS:fallthrough
		 	case .FIELDS:fallthrough
		 	case .FILE_BLOCK_SIZE:fallthrough
		 	case .FILTER:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIXED:fallthrough
		 	case .FLUSH:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FOUND:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GENERAL:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GRANTS:fallthrough
		 	case .GROUP_REPLICATION:fallthrough
		 	case .HANDLER:fallthrough
		 	case .HASH:fallthrough
		 	case .HELP:fallthrough
		 	case .HISTORY:fallthrough
		 	case .HOST:fallthrough
		 	case .HOSTS:fallthrough
		 	case .IDENTIFIED:fallthrough
		 	case .IGNORE_SERVER_IDS:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INDEXES:fallthrough
		 	case .INITIAL_SIZE:fallthrough
		 	case .INPLACE:fallthrough
		 	case .INSERT_METHOD:fallthrough
		 	case .INSTALL:fallthrough
		 	case .INSTANCE:fallthrough
		 	case .INSTANT:fallthrough
		 	case .INVISIBLE:fallthrough
		 	case .INVOKER:fallthrough
		 	case .IO:fallthrough
		 	case .IO_THREAD:fallthrough
		 	case .IPC:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ISSUER:fallthrough
		 	case .JSON:fallthrough
		 	case .KEY_BLOCK_SIZE:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LEAVES:fallthrough
		 	case .LESS:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOGFILE:fallthrough
		 	case .LOGS:fallthrough
		 	case .MASTER:fallthrough
		 	case .MASTER_AUTO_POSITION:fallthrough
		 	case .MASTER_CONNECT_RETRY:fallthrough
		 	case .MASTER_DELAY:fallthrough
		 	case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 	case .MASTER_HOST:fallthrough
		 	case .MASTER_LOG_FILE:fallthrough
		 	case .MASTER_LOG_POS:fallthrough
		 	case .MASTER_PASSWORD:fallthrough
		 	case .MASTER_PORT:fallthrough
		 	case .MASTER_RETRY_COUNT:fallthrough
		 	case .MASTER_SSL:fallthrough
		 	case .MASTER_SSL_CA:fallthrough
		 	case .MASTER_SSL_CAPATH:fallthrough
		 	case .MASTER_SSL_CERT:fallthrough
		 	case .MASTER_SSL_CIPHER:fallthrough
		 	case .MASTER_SSL_CRL:fallthrough
		 	case .MASTER_SSL_CRLPATH:fallthrough
		 	case .MASTER_SSL_KEY:fallthrough
		 	case .MASTER_TLS_VERSION:fallthrough
		 	case .MASTER_USER:fallthrough
		 	case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 	case .MAX_QUERIES_PER_HOUR:fallthrough
		 	case .MAX_ROWS:fallthrough
		 	case .MAX_SIZE:fallthrough
		 	case .MAX_UPDATES_PER_HOUR:fallthrough
		 	case .MAX_USER_CONNECTIONS:fallthrough
		 	case .MEDIUM:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MESSAGE_TEXT:fallthrough
		 	case .MID:fallthrough
		 	case .MIGRATE:fallthrough
		 	case .MIN_ROWS:fallthrough
		 	case .MODE:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MUTEX:fallthrough
		 	case .MYSQL:fallthrough
		 	case .MYSQL_ERRNO:fallthrough
		 	case .NAME:fallthrough
		 	case .NAMES:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NEVER:fallthrough
		 	case .NEXT:fallthrough
		 	case .NO:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOWAIT:fallthrough
		 	case .NODEGROUP:fallthrough
		 	case .NONE:fallthrough
		 	case .ODBC:fallthrough
		 	case .OFFLINE:fallthrough
		 	case .OFFSET:fallthrough
		 	case .OF:fallthrough
		 	case .OJ:fallthrough
		 	case .OLD_PASSWORD:fallthrough
		 	case .ONE:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .OPTIMIZER_COSTS:fallthrough
		 	case .OPTIONS:fallthrough
		 	case .OWNER:fallthrough
		 	case .PACK_KEYS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PARSER:fallthrough
		 	case .PARTIAL:fallthrough
		 	case .PARTITIONING:fallthrough
		 	case .PARTITIONS:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PASSWORD_LOCK_TIME:fallthrough
		 	case .PHASE:fallthrough
		 	case .PLUGIN:fallthrough
		 	case .PLUGIN_DIR:fallthrough
		 	case .PLUGINS:fallthrough
		 	case .PORT:fallthrough
		 	case .PRECEDES:fallthrough
		 	case .PREPARE:fallthrough
		 	case .PRESERVE:fallthrough
		 	case .PREV:fallthrough
		 	case .PROCESSLIST:fallthrough
		 	case .PROFILE:fallthrough
		 	case .PROFILES:fallthrough
		 	case .PROXY:fallthrough
		 	case .QUERY:fallthrough
		 	case .QUICK:fallthrough
		 	case .REBUILD:fallthrough
		 	case .RECOVER:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REDO_BUFFER_SIZE:fallthrough
		 	case .REDUNDANT:fallthrough
		 	case .RELAY:fallthrough
		 	case .RELAY_LOG_FILE:fallthrough
		 	case .RELAY_LOG_POS:fallthrough
		 	case .RELAYLOG:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REORGANIZE:fallthrough
		 	case .REPAIR:fallthrough
		 	case .REPLICATE_DO_DB:fallthrough
		 	case .REPLICATE_DO_TABLE:fallthrough
		 	case .REPLICATE_IGNORE_DB:fallthrough
		 	case .REPLICATE_IGNORE_TABLE:fallthrough
		 	case .REPLICATE_REWRITE_DB:fallthrough
		 	case .REPLICATE_WILD_DO_TABLE:fallthrough
		 	case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 	case .REPLICATION:fallthrough
		 	case .RESET:fallthrough
		 	case .RESUME:fallthrough
		 	case .RETURNED_SQLSTATE:fallthrough
		 	case .RETURNING:fallthrough
		 	case .RETURNS:fallthrough
		 	case .REUSE:fallthrough
		 	case .ROLE:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROTATE:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_FORMAT:fallthrough
		 	case .RTREE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEDULE:fallthrough
		 	case .SECURITY:fallthrough
		 	case .SERVER:fallthrough
		 	case .SESSION:fallthrough
		 	case .SHARE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SIGNED:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SLAVE:fallthrough
		 	case .SLOW:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOCKET:fallthrough
		 	case .SOME:fallthrough
		 	case .SONAME:fallthrough
		 	case .SOUNDS:fallthrough
		 	case .SOURCE:fallthrough
		 	case .SQL_AFTER_GTIDS:fallthrough
		 	case .SQL_AFTER_MTS_GAPS:fallthrough
		 	case .SQL_BEFORE_GTIDS:fallthrough
		 	case .SQL_BUFFER_RESULT:fallthrough
		 	case .SQL_CACHE:fallthrough
		 	case .SQL_NO_CACHE:fallthrough
		 	case .SQL_THREAD:fallthrough
		 	case .START:fallthrough
		 	case .STARTS:fallthrough
		 	case .STATS_AUTO_RECALC:fallthrough
		 	case .STATS_PERSISTENT:fallthrough
		 	case .STATS_SAMPLE_PAGES:fallthrough
		 	case .STATUS:fallthrough
		 	case .STOP:fallthrough
		 	case .STORAGE:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBCLASS_ORIGIN:fallthrough
		 	case .SUBJECT:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBPARTITIONS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .SWAPS:fallthrough
		 	case .SWITCHES:fallthrough
		 	case .TABLE_NAME:fallthrough
		 	case .TABLESPACE:fallthrough
		 	case .TABLE_TYPE:fallthrough
		 	case .TEMPORARY:fallthrough
		 	case .TEMPTABLE:fallthrough
		 	case .THAN:fallthrough
		 	case .TRADITIONAL:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSACTIONAL:fallthrough
		 	case .TRIGGERS:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDEFINED:fallthrough
		 	case .UNDOFILE:fallthrough
		 	case .UNDO_BUFFER_SIZE:fallthrough
		 	case .UNINSTALL:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPGRADE:fallthrough
		 	case .USER:fallthrough
		 	case .USE_FRM:fallthrough
		 	case .USER_RESOURCES:fallthrough
		 	case .VALIDATION:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARIABLES:fallthrough
		 	case .VIEW:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .VISIBLE:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNINGS:fallthrough
		 	case .WITHOUT:fallthrough
		 	case .WORK:fallthrough
		 	case .WRAPPER:fallthrough
		 	case .X509:fallthrough
		 	case .XA:fallthrough
		 	case .XML:fallthrough
		 	case .EUR:fallthrough
		 	case .USA:fallthrough
		 	case .JIS:fallthrough
		 	case .ISO:fallthrough
		 	case .INTERNAL:fallthrough
		 	case .QUARTER:fallthrough
		 	case .MONTH:fallthrough
		 	case .DAY:fallthrough
		 	case .HOUR:fallthrough
		 	case .MINUTE:fallthrough
		 	case .WEEK:fallthrough
		 	case .SECOND:fallthrough
		 	case .MICROSECOND:fallthrough
		 	case .ADMIN:fallthrough
		 	case .AUDIT_ABORT_EXEMPT:fallthrough
		 	case .AUDIT_ADMIN:fallthrough
		 	case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 	case .BACKUP_ADMIN:fallthrough
		 	case .BINLOG_ADMIN:fallthrough
		 	case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 	case .CLONE_ADMIN:fallthrough
		 	case .CONNECTION_ADMIN:fallthrough
		 	case .ENCRYPTION_KEY_ADMIN:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .FILE:fallthrough
		 	case .FIREWALL_ADMIN:fallthrough
		 	case .FIREWALL_EXEMPT:fallthrough
		 	case .FIREWALL_USER:fallthrough
		 	case .GROUP_REPLICATION_ADMIN:fallthrough
		 	case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 	case .INVOKE:fallthrough
		 	case .LAMBDA:fallthrough
		 	case .NDB_STORED_USER:fallthrough
		 	case .PASSWORDLESS_USER_ADMIN:fallthrough
		 	case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .PROCESS:fallthrough
		 	case .RELOAD:fallthrough
		 	case .REPLICATION_APPLIER:fallthrough
		 	case .REPLICATION_SLAVE_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_USER:fallthrough
		 	case .ROLE_ADMIN:fallthrough
		 	case .ROUTINE:fallthrough
		 	case .S3:fallthrough
		 	case .SESSION_VARIABLES_ADMIN:fallthrough
		 	case .SET_USER_ID:fallthrough
		 	case .SHOW_ROUTINE:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SUPER:fallthrough
		 	case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 	case .TABLES:fallthrough
		 	case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 	case .VERSION_TOKEN_ADMIN:fallthrough
		 	case .XA_RECOVER_ADMIN:fallthrough
		 	case .ARMSCII8:fallthrough
		 	case .ASCII:fallthrough
		 	case .BIG5:fallthrough
		 	case .CP1250:fallthrough
		 	case .CP1251:fallthrough
		 	case .CP1256:fallthrough
		 	case .CP1257:fallthrough
		 	case .CP850:fallthrough
		 	case .CP852:fallthrough
		 	case .CP866:fallthrough
		 	case .CP932:fallthrough
		 	case .DEC8:fallthrough
		 	case .EUCJPMS:fallthrough
		 	case .EUCKR:fallthrough
		 	case .GB18030:fallthrough
		 	case .GB2312:fallthrough
		 	case .GBK:fallthrough
		 	case .GEOSTD8:fallthrough
		 	case .GREEK:fallthrough
		 	case .HEBREW:fallthrough
		 	case .HP8:fallthrough
		 	case .KEYBCS2:fallthrough
		 	case .KOI8R:fallthrough
		 	case .KOI8U:fallthrough
		 	case .LATIN1:fallthrough
		 	case .LATIN2:fallthrough
		 	case .LATIN5:fallthrough
		 	case .LATIN7:fallthrough
		 	case .MACCE:fallthrough
		 	case .MACROMAN:fallthrough
		 	case .SJIS:fallthrough
		 	case .SWE7:fallthrough
		 	case .TIS620:fallthrough
		 	case .UCS2:fallthrough
		 	case .UJIS:fallthrough
		 	case .UTF16:fallthrough
		 	case .UTF16LE:fallthrough
		 	case .UTF32:fallthrough
		 	case .UTF8:fallthrough
		 	case .UTF8MB3:fallthrough
		 	case .UTF8MB4:fallthrough
		 	case .ARCHIVE:fallthrough
		 	case .BLACKHOLE:fallthrough
		 	case .CSV:fallthrough
		 	case .FEDERATED:fallthrough
		 	case .INNODB:fallthrough
		 	case .MEMORY:fallthrough
		 	case .MRG_MYISAM:fallthrough
		 	case .MYISAM:fallthrough
		 	case .NDB:fallthrough
		 	case .NDBCLUSTER:fallthrough
		 	case .PERFORMANCE_SCHEMA:fallthrough
		 	case .TOKUDB:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .GEOMETRYCOLLECTION:fallthrough
		 	case .LINESTRING:fallthrough
		 	case .MULTILINESTRING:fallthrough
		 	case .MULTIPOINT:fallthrough
		 	case .MULTIPOLYGON:fallthrough
		 	case .POINT:fallthrough
		 	case .POLYGON:fallthrough
		 	case .ABS:fallthrough
		 	case .ACOS:fallthrough
		 	case .ADDDATE:fallthrough
		 	case .ADDTIME:fallthrough
		 	case .AES_DECRYPT:fallthrough
		 	case .AES_ENCRYPT:fallthrough
		 	case .AREA:fallthrough
		 	case .ASBINARY:fallthrough
		 	case .ASIN:fallthrough
		 	case .ASTEXT:fallthrough
		 	case .ASWKB:fallthrough
		 	case .ASWKT:fallthrough
		 	case .ASYMMETRIC_DECRYPT:fallthrough
		 	case .ASYMMETRIC_DERIVE:fallthrough
		 	case .ASYMMETRIC_ENCRYPT:fallthrough
		 	case .ASYMMETRIC_SIGN:fallthrough
		 	case .ASYMMETRIC_VERIFY:fallthrough
		 	case .ATAN:fallthrough
		 	case .ATAN2:fallthrough
		 	case .BENCHMARK:fallthrough
		 	case .BIN:fallthrough
		 	case .BIT_COUNT:fallthrough
		 	case .BIT_LENGTH:fallthrough
		 	case .BUFFER:fallthrough
		 	case .CATALOG_NAME:fallthrough
		 	case .CEIL:fallthrough
		 	case .CEILING:fallthrough
		 	case .CENTROID:fallthrough
		 	case .CHARACTER_LENGTH:fallthrough
		 	case .CHARSET:fallthrough
		 	case .CHAR_LENGTH:fallthrough
		 	case .COERCIBILITY:fallthrough
		 	case .COLLATION:fallthrough
		 	case .COMPRESS:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_WS:fallthrough
		 	case .CONNECTION_ID:fallthrough
		 	case .CONV:fallthrough
		 	case .CONVERT_TZ:fallthrough
		 	case .COS:fallthrough
		 	case .COT:fallthrough
		 	case .CRC32:fallthrough
		 	case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 	case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 	case .CREATE_DH_PARAMETERS:fallthrough
		 	case .CREATE_DIGEST:fallthrough
		 	case .CROSSES:fallthrough
		 	case .DATEDIFF:fallthrough
		 	case .DATE_FORMAT:fallthrough
		 	case .DAYNAME:fallthrough
		 	case .DAYOFMONTH:fallthrough
		 	case .DAYOFWEEK:fallthrough
		 	case .DAYOFYEAR:fallthrough
		 	case .DECODE:fallthrough
		 	case .DEGREES:fallthrough
		 	case .DES_DECRYPT:fallthrough
		 	case .DES_ENCRYPT:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISJOINT:fallthrough
		 	case .ELT:fallthrough
		 	case .ENCODE:fallthrough
		 	case .ENCRYPT:fallthrough
		 	case .ENDPOINT:fallthrough
		 	case .ENGINE_ATTRIBUTE:fallthrough
		 	case .ENVELOPE:fallthrough
		 	case .EQUALS:fallthrough
		 	case .EXP:fallthrough
		 	case .EXPORT_SET:fallthrough
		 	case .EXTERIORRING:fallthrough
		 	case .EXTRACTVALUE:fallthrough
		 	case .FIELD:fallthrough
		 	case .FIND_IN_SET:fallthrough
		 	case .FLOOR:fallthrough
		 	case .FORMAT:fallthrough
		 	case .FOUND_ROWS:fallthrough
		 	case .FROM_BASE64:fallthrough
		 	case .FROM_DAYS:fallthrough
		 	case .FROM_UNIXTIME:fallthrough
		 	case .GEOMCOLLFROMTEXT:fallthrough
		 	case .GEOMCOLLFROMWKB:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .GEOMETRYFROMTEXT:fallthrough
		 	case .GEOMETRYFROMWKB:fallthrough
		 	case .GEOMETRYN:fallthrough
		 	case .GEOMETRYTYPE:fallthrough
		 	case .GEOMFROMTEXT:fallthrough
		 	case .GEOMFROMWKB:fallthrough
		 	case .GET_FORMAT:fallthrough
		 	case .GET_LOCK:fallthrough
		 	case .GLENGTH:fallthrough
		 	case .GREATEST:fallthrough
		 	case .GTID_SUBSET:fallthrough
		 	case .GTID_SUBTRACT:fallthrough
		 	case .HEX:fallthrough
		 	case .IFNULL:fallthrough
		 	case .INET6_ATON:fallthrough
		 	case .INET6_NTOA:fallthrough
		 	case .INET_ATON:fallthrough
		 	case .INET_NTOA:fallthrough
		 	case .INSTR:fallthrough
		 	case .INTERIORRINGN:fallthrough
		 	case .INTERSECTS:fallthrough
		 	case .ISCLOSED:fallthrough
		 	case .ISEMPTY:fallthrough
		 	case .ISNULL:fallthrough
		 	case .ISSIMPLE:fallthrough
		 	case .IS_FREE_LOCK:fallthrough
		 	case .IS_IPV4:fallthrough
		 	case .IS_IPV4_COMPAT:fallthrough
		 	case .IS_IPV4_MAPPED:fallthrough
		 	case .IS_IPV6:fallthrough
		 	case .IS_USED_LOCK:fallthrough
		 	case .LAST_INSERT_ID:fallthrough
		 	case .LCASE:fallthrough
		 	case .LEAST:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LINEFROMTEXT:fallthrough
		 	case .LINEFROMWKB:fallthrough
		 	case .LINESTRINGFROMTEXT:fallthrough
		 	case .LINESTRINGFROMWKB:fallthrough
		 	case .LN:fallthrough
		 	case .LOAD_FILE:fallthrough
		 	case .LOCATE:fallthrough
		 	case .LOG:fallthrough
		 	case .LOG10:fallthrough
		 	case .LOG2:fallthrough
		 	case .LOWER:fallthrough
		 	case .LPAD:fallthrough
		 	case .LTRIM:fallthrough
		 	case .MAKEDATE:fallthrough
		 	case .MAKETIME:fallthrough
		 	case .MAKE_SET:fallthrough
		 	case .MASTER_POS_WAIT:fallthrough
		 	case .MBRCONTAINS:fallthrough
		 	case .MBRDISJOINT:fallthrough
		 	case .MBREQUAL:fallthrough
		 	case .MBRINTERSECTS:fallthrough
		 	case .MBROVERLAPS:fallthrough
		 	case .MBRTOUCHES:fallthrough
		 	case .MBRWITHIN:fallthrough
		 	case .MD5:fallthrough
		 	case .MLINEFROMTEXT:fallthrough
		 	case .MLINEFROMWKB:fallthrough
		 	case .MONTHNAME:fallthrough
		 	case .MPOINTFROMTEXT:fallthrough
		 	case .MPOINTFROMWKB:fallthrough
		 	case .MPOLYFROMTEXT:fallthrough
		 	case .MPOLYFROMWKB:fallthrough
		 	case .MULTILINESTRINGFROMTEXT:fallthrough
		 	case .MULTILINESTRINGFROMWKB:fallthrough
		 	case .MULTIPOINTFROMTEXT:fallthrough
		 	case .MULTIPOINTFROMWKB:fallthrough
		 	case .MULTIPOLYGONFROMTEXT:fallthrough
		 	case .MULTIPOLYGONFROMWKB:fallthrough
		 	case .NAME_CONST:fallthrough
		 	case .NULLIF:fallthrough
		 	case .NUMGEOMETRIES:fallthrough
		 	case .NUMINTERIORRINGS:fallthrough
		 	case .NUMPOINTS:fallthrough
		 	case .OCT:fallthrough
		 	case .OCTET_LENGTH:fallthrough
		 	case .ORD:fallthrough
		 	case .OVERLAPS:fallthrough
		 	case .PERIOD_ADD:fallthrough
		 	case .PERIOD_DIFF:fallthrough
		 	case .PI:fallthrough
		 	case .POINTFROMTEXT:fallthrough
		 	case .POINTFROMWKB:fallthrough
		 	case .POINTN:fallthrough
		 	case .POLYFROMTEXT:fallthrough
		 	case .POLYFROMWKB:fallthrough
		 	case .POLYGONFROMTEXT:fallthrough
		 	case .POLYGONFROMWKB:fallthrough
		 	case .POW:fallthrough
		 	case .POWER:fallthrough
		 	case .QUOTE:fallthrough
		 	case .RADIANS:fallthrough
		 	case .RAND:fallthrough
		 	case .RANDOM:fallthrough
		 	case .RANDOM_BYTES:fallthrough
		 	case .RELEASE_LOCK:fallthrough
		 	case .REVERSE:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_COUNT:fallthrough
		 	case .RPAD:fallthrough
		 	case .RTRIM:fallthrough
		 	case .SEC_TO_TIME:fallthrough
		 	case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 	case .SESSION_USER:fallthrough
		 	case .SHA:fallthrough
		 	case .SHA1:fallthrough
		 	case .SHA2:fallthrough
		 	case .SCHEMA_NAME:fallthrough
		 	case .SIGN:fallthrough
		 	case .SIN:fallthrough
		 	case .SLEEP:fallthrough
		 	case .SOUNDEX:fallthrough
		 	case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 	case .SQRT:fallthrough
		 	case .SRID:fallthrough
		 	case .STARTPOINT:fallthrough
		 	case .STRCMP:fallthrough
		 	case .STR_TO_DATE:fallthrough
		 	case .ST_AREA:fallthrough
		 	case .ST_ASBINARY:fallthrough
		 	case .ST_ASTEXT:fallthrough
		 	case .ST_ASWKB:fallthrough
		 	case .ST_ASWKT:fallthrough
		 	case .ST_BUFFER:fallthrough
		 	case .ST_CENTROID:fallthrough
		 	case .ST_CONTAINS:fallthrough
		 	case .ST_CROSSES:fallthrough
		 	case .ST_DIFFERENCE:fallthrough
		 	case .ST_DIMENSION:fallthrough
		 	case .ST_DISJOINT:fallthrough
		 	case .ST_DISTANCE:fallthrough
		 	case .ST_ENDPOINT:fallthrough
		 	case .ST_ENVELOPE:fallthrough
		 	case .ST_EQUALS:fallthrough
		 	case .ST_EXTERIORRING:fallthrough
		 	case .ST_GEOMCOLLFROMTEXT:fallthrough
		 	case .ST_GEOMCOLLFROMTXT:fallthrough
		 	case .ST_GEOMCOLLFROMWKB:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .ST_GEOMETRYFROMTEXT:fallthrough
		 	case .ST_GEOMETRYFROMWKB:fallthrough
		 	case .ST_GEOMETRYN:fallthrough
		 	case .ST_GEOMETRYTYPE:fallthrough
		 	case .ST_GEOMFROMTEXT:fallthrough
		 	case .ST_GEOMFROMWKB:fallthrough
		 	case .ST_INTERIORRINGN:fallthrough
		 	case .ST_INTERSECTION:fallthrough
		 	case .ST_INTERSECTS:fallthrough
		 	case .ST_ISCLOSED:fallthrough
		 	case .ST_ISEMPTY:fallthrough
		 	case .ST_ISSIMPLE:fallthrough
		 	case .ST_LINEFROMTEXT:fallthrough
		 	case .ST_LINEFROMWKB:fallthrough
		 	case .ST_LINESTRINGFROMTEXT:fallthrough
		 	case .ST_LINESTRINGFROMWKB:fallthrough
		 	case .ST_NUMGEOMETRIES:fallthrough
		 	case .ST_NUMINTERIORRING:fallthrough
		 	case .ST_NUMINTERIORRINGS:fallthrough
		 	case .ST_NUMPOINTS:fallthrough
		 	case .ST_OVERLAPS:fallthrough
		 	case .ST_POINTFROMTEXT:fallthrough
		 	case .ST_POINTFROMWKB:fallthrough
		 	case .ST_POINTN:fallthrough
		 	case .ST_POLYFROMTEXT:fallthrough
		 	case .ST_POLYFROMWKB:fallthrough
		 	case .ST_POLYGONFROMTEXT:fallthrough
		 	case .ST_POLYGONFROMWKB:fallthrough
		 	case .ST_SRID:fallthrough
		 	case .ST_STARTPOINT:fallthrough
		 	case .ST_SYMDIFFERENCE:fallthrough
		 	case .ST_TOUCHES:fallthrough
		 	case .ST_UNION:fallthrough
		 	case .ST_WITHIN:fallthrough
		 	case .ST_X:fallthrough
		 	case .ST_Y:fallthrough
		 	case .SUBDATE:fallthrough
		 	case .SUBSTRING_INDEX:fallthrough
		 	case .SUBTIME:fallthrough
		 	case .SYSTEM_USER:fallthrough
		 	case .TAN:fallthrough
		 	case .TIMEDIFF:fallthrough
		 	case .TIMESTAMPADD:fallthrough
		 	case .TIMESTAMPDIFF:fallthrough
		 	case .TIME_FORMAT:fallthrough
		 	case .TIME_TO_SEC:fallthrough
		 	case .TOUCHES:fallthrough
		 	case .TO_BASE64:fallthrough
		 	case .TO_DAYS:fallthrough
		 	case .TO_SECONDS:fallthrough
		 	case .TP_CONNECTION_ADMIN:fallthrough
		 	case .UCASE:fallthrough
		 	case .UNCOMPRESS:fallthrough
		 	case .UNCOMPRESSED_LENGTH:fallthrough
		 	case .UNHEX:fallthrough
		 	case .UNIX_TIMESTAMP:fallthrough
		 	case .UPDATEXML:fallthrough
		 	case .UPPER:fallthrough
		 	case .UUID:fallthrough
		 	case .UUID_SHORT:fallthrough
		 	case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 	case .VERSION:fallthrough
		 	case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 	case .WEEKDAY:fallthrough
		 	case .WEEKOFYEAR:fallthrough
		 	case .WEIGHT_STRING:fallthrough
		 	case .WITHIN:fallthrough
		 	case .YEARWEEK:fallthrough
		 	case .Y_FUNCTION:fallthrough
		 	case .X_FUNCTION:fallthrough
		 	case .MOD:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4261)
		 		try simpleId()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StartTransactionContext: ParserRuleContext {
			open
			func START() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.START.rawValue, 0)
			}
			open
			func TRANSACTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRANSACTION.rawValue, 0)
			}
			open
			func transactionMode() -> [TransactionModeContext] {
				return getRuleContexts(TransactionModeContext.self)
			}
			open
			func transactionMode(_ i: Int) -> TransactionModeContext? {
				return getRuleContext(TransactionModeContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_startTransaction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterStartTransaction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitStartTransaction(self)
			}
		}
	}
	@discardableResult
	 open func startTransaction() throws -> StartTransactionContext {
		var _localctx: StartTransactionContext
		_localctx = StartTransactionContext(_ctx, getState())
		try enterRule(_localctx, 298, MySqlParser.RULE_startTransaction)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4264)
		 	try match(MySqlParser.Tokens.START.rawValue)
		 	setState(4265)
		 	try match(MySqlParser.Tokens.TRANSACTION.rawValue)
		 	setState(4274)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,626,_ctx)) {
		 	case 1:
		 		setState(4266)
		 		try transactionMode()
		 		setState(4271)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(4267)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(4268)
		 			try transactionMode()


		 			setState(4273)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BeginWorkContext: ParserRuleContext {
			open
			func BEGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BEGIN.rawValue, 0)
			}
			open
			func WORK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WORK.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_beginWork
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterBeginWork(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitBeginWork(self)
			}
		}
	}
	@discardableResult
	 open func beginWork() throws -> BeginWorkContext {
		var _localctx: BeginWorkContext
		_localctx = BeginWorkContext(_ctx, getState())
		try enterRule(_localctx, 300, MySqlParser.RULE_beginWork)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4276)
		 	try match(MySqlParser.Tokens.BEGIN.rawValue)
		 	setState(4278)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WORK.rawValue) {
		 		setState(4277)
		 		try match(MySqlParser.Tokens.WORK.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CommitWorkContext: ParserRuleContext {
		open var nochain: Token!
		open var norelease: Token!
			open
			func COMMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMIT.rawValue, 0)
			}
			open
			func WORK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WORK.rawValue, 0)
			}
			open
			func AND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AND.rawValue, 0)
			}
			open
			func CHAIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHAIN.rawValue, 0)
			}
			open
			func RELEASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELEASE.rawValue, 0)
			}
			open
			func NO() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.NO.rawValue)
			}
			open
			func NO(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NO.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_commitWork
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCommitWork(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCommitWork(self)
			}
		}
	}
	@discardableResult
	 open func commitWork() throws -> CommitWorkContext {
		var _localctx: CommitWorkContext
		_localctx = CommitWorkContext(_ctx, getState())
		try enterRule(_localctx, 302, MySqlParser.RULE_commitWork)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4280)
		 	try match(MySqlParser.Tokens.COMMIT.rawValue)
		 	setState(4282)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WORK.rawValue) {
		 		setState(4281)
		 		try match(MySqlParser.Tokens.WORK.rawValue)

		 	}

		 	setState(4289)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.AND.rawValue) {
		 		setState(4284)
		 		try match(MySqlParser.Tokens.AND.rawValue)
		 		setState(4286)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.NO.rawValue) {
		 			setState(4285)
		 			try {
		 					let assignmentValue = try match(MySqlParser.Tokens.NO.rawValue)
		 					_localctx.castdown(CommitWorkContext.self).nochain = assignmentValue
		 			     }()


		 		}

		 		setState(4288)
		 		try match(MySqlParser.Tokens.CHAIN.rawValue)

		 	}

		 	setState(4295)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,632,_ctx)) {
		 	case 1:
		 		setState(4292)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.NO.rawValue) {
		 			setState(4291)
		 			try {
		 					let assignmentValue = try match(MySqlParser.Tokens.NO.rawValue)
		 					_localctx.castdown(CommitWorkContext.self).norelease = assignmentValue
		 			     }()


		 		}

		 		setState(4294)
		 		try match(MySqlParser.Tokens.RELEASE.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RollbackWorkContext: ParserRuleContext {
		open var nochain: Token!
		open var norelease: Token!
			open
			func ROLLBACK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLLBACK.rawValue, 0)
			}
			open
			func WORK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WORK.rawValue, 0)
			}
			open
			func AND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AND.rawValue, 0)
			}
			open
			func CHAIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHAIN.rawValue, 0)
			}
			open
			func RELEASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELEASE.rawValue, 0)
			}
			open
			func NO() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.NO.rawValue)
			}
			open
			func NO(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NO.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_rollbackWork
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRollbackWork(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRollbackWork(self)
			}
		}
	}
	@discardableResult
	 open func rollbackWork() throws -> RollbackWorkContext {
		var _localctx: RollbackWorkContext
		_localctx = RollbackWorkContext(_ctx, getState())
		try enterRule(_localctx, 304, MySqlParser.RULE_rollbackWork)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4297)
		 	try match(MySqlParser.Tokens.ROLLBACK.rawValue)
		 	setState(4299)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WORK.rawValue) {
		 		setState(4298)
		 		try match(MySqlParser.Tokens.WORK.rawValue)

		 	}

		 	setState(4306)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.AND.rawValue) {
		 		setState(4301)
		 		try match(MySqlParser.Tokens.AND.rawValue)
		 		setState(4303)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.NO.rawValue) {
		 			setState(4302)
		 			try {
		 					let assignmentValue = try match(MySqlParser.Tokens.NO.rawValue)
		 					_localctx.castdown(RollbackWorkContext.self).nochain = assignmentValue
		 			     }()


		 		}

		 		setState(4305)
		 		try match(MySqlParser.Tokens.CHAIN.rawValue)

		 	}

		 	setState(4312)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,637,_ctx)) {
		 	case 1:
		 		setState(4309)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.NO.rawValue) {
		 			setState(4308)
		 			try {
		 					let assignmentValue = try match(MySqlParser.Tokens.NO.rawValue)
		 					_localctx.castdown(RollbackWorkContext.self).norelease = assignmentValue
		 			     }()


		 		}

		 		setState(4311)
		 		try match(MySqlParser.Tokens.RELEASE.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SavepointStatementContext: ParserRuleContext {
			open
			func SAVEPOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SAVEPOINT.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_savepointStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSavepointStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSavepointStatement(self)
			}
		}
	}
	@discardableResult
	 open func savepointStatement() throws -> SavepointStatementContext {
		var _localctx: SavepointStatementContext
		_localctx = SavepointStatementContext(_ctx, getState())
		try enterRule(_localctx, 306, MySqlParser.RULE_savepointStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4314)
		 	try match(MySqlParser.Tokens.SAVEPOINT.rawValue)
		 	setState(4315)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RollbackStatementContext: ParserRuleContext {
			open
			func ROLLBACK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLLBACK.rawValue, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func WORK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WORK.rawValue, 0)
			}
			open
			func SAVEPOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SAVEPOINT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_rollbackStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRollbackStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRollbackStatement(self)
			}
		}
	}
	@discardableResult
	 open func rollbackStatement() throws -> RollbackStatementContext {
		var _localctx: RollbackStatementContext
		_localctx = RollbackStatementContext(_ctx, getState())
		try enterRule(_localctx, 308, MySqlParser.RULE_rollbackStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4317)
		 	try match(MySqlParser.Tokens.ROLLBACK.rawValue)
		 	setState(4319)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.WORK.rawValue) {
		 		setState(4318)
		 		try match(MySqlParser.Tokens.WORK.rawValue)

		 	}

		 	setState(4321)
		 	try match(MySqlParser.Tokens.TO.rawValue)
		 	setState(4323)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,639,_ctx)) {
		 	case 1:
		 		setState(4322)
		 		try match(MySqlParser.Tokens.SAVEPOINT.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4325)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReleaseStatementContext: ParserRuleContext {
			open
			func RELEASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELEASE.rawValue, 0)
			}
			open
			func SAVEPOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SAVEPOINT.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_releaseStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterReleaseStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitReleaseStatement(self)
			}
		}
	}
	@discardableResult
	 open func releaseStatement() throws -> ReleaseStatementContext {
		var _localctx: ReleaseStatementContext
		_localctx = ReleaseStatementContext(_ctx, getState())
		try enterRule(_localctx, 310, MySqlParser.RULE_releaseStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4327)
		 	try match(MySqlParser.Tokens.RELEASE.rawValue)
		 	setState(4328)
		 	try match(MySqlParser.Tokens.SAVEPOINT.rawValue)
		 	setState(4329)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LockTablesContext: ParserRuleContext {
			open
			func LOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCK.rawValue, 0)
			}
			open
			func lockTableElement() -> [LockTableElementContext] {
				return getRuleContexts(LockTableElementContext.self)
			}
			open
			func lockTableElement(_ i: Int) -> LockTableElementContext? {
				return getRuleContext(LockTableElementContext.self, i)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func TABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLES.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func waitNowaitClause() -> WaitNowaitClauseContext? {
				return getRuleContext(WaitNowaitClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_lockTables
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLockTables(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLockTables(self)
			}
		}
	}
	@discardableResult
	 open func lockTables() throws -> LockTablesContext {
		var _localctx: LockTablesContext
		_localctx = LockTablesContext(_ctx, getState())
		try enterRule(_localctx, 312, MySqlParser.RULE_lockTables)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4331)
		 	try match(MySqlParser.Tokens.LOCK.rawValue)
		 	setState(4332)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.TABLE.rawValue || _la == MySqlParser.Tokens.TABLES.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4333)
		 	try lockTableElement()
		 	setState(4338)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(4334)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(4335)
		 		try lockTableElement()


		 		setState(4340)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4342)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.NOWAIT.rawValue || _la == MySqlParser.Tokens.WAIT.rawValue) {
		 		setState(4341)
		 		try waitNowaitClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UnlockTablesContext: ParserRuleContext {
			open
			func UNLOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNLOCK.rawValue, 0)
			}
			open
			func TABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLES.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_unlockTables
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUnlockTables(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUnlockTables(self)
			}
		}
	}
	@discardableResult
	 open func unlockTables() throws -> UnlockTablesContext {
		var _localctx: UnlockTablesContext
		_localctx = UnlockTablesContext(_ctx, getState())
		try enterRule(_localctx, 314, MySqlParser.RULE_unlockTables)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4344)
		 	try match(MySqlParser.Tokens.UNLOCK.rawValue)
		 	setState(4345)
		 	try match(MySqlParser.Tokens.TABLES.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetAutocommitStatementContext: ParserRuleContext {
		open var autocommitValue: Token!
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func AUTOCOMMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTOCOMMIT.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func ZERO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZERO_DECIMAL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_setAutocommitStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSetAutocommitStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSetAutocommitStatement(self)
			}
		}
	}
	@discardableResult
	 open func setAutocommitStatement() throws -> SetAutocommitStatementContext {
		var _localctx: SetAutocommitStatementContext
		_localctx = SetAutocommitStatementContext(_ctx, getState())
		try enterRule(_localctx, 316, MySqlParser.RULE_setAutocommitStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4347)
		 	try match(MySqlParser.Tokens.SET.rawValue)
		 	setState(4348)
		 	try match(MySqlParser.Tokens.AUTOCOMMIT.rawValue)
		 	setState(4349)
		 	try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 	setState(4350)
		 	_localctx.castdown(SetAutocommitStatementContext.self).autocommitValue = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.ZERO_DECIMAL.rawValue || _la == MySqlParser.Tokens.ONE_DECIMAL.rawValue)) {
		 		_localctx.castdown(SetAutocommitStatementContext.self).autocommitValue = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetTransactionStatementContext: ParserRuleContext {
		open var transactionContext: Token!
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func TRANSACTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRANSACTION.rawValue, 0)
			}
			open
			func transactionOption() -> [TransactionOptionContext] {
				return getRuleContexts(TransactionOptionContext.self)
			}
			open
			func transactionOption(_ i: Int) -> TransactionOptionContext? {
				return getRuleContext(TransactionOptionContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func GLOBAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GLOBAL.rawValue, 0)
			}
			open
			func SESSION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SESSION.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_setTransactionStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSetTransactionStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSetTransactionStatement(self)
			}
		}
	}
	@discardableResult
	 open func setTransactionStatement() throws -> SetTransactionStatementContext {
		var _localctx: SetTransactionStatementContext
		_localctx = SetTransactionStatementContext(_ctx, getState())
		try enterRule(_localctx, 318, MySqlParser.RULE_setTransactionStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4352)
		 	try match(MySqlParser.Tokens.SET.rawValue)
		 	setState(4354)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.GLOBAL.rawValue || _la == MySqlParser.Tokens.SESSION.rawValue) {
		 		setState(4353)
		 		_localctx.castdown(SetTransactionStatementContext.self).transactionContext = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.GLOBAL.rawValue || _la == MySqlParser.Tokens.SESSION.rawValue)) {
		 			_localctx.castdown(SetTransactionStatementContext.self).transactionContext = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(4356)
		 	try match(MySqlParser.Tokens.TRANSACTION.rawValue)
		 	setState(4357)
		 	try transactionOption()
		 	setState(4362)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(4358)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(4359)
		 		try transactionOption()


		 		setState(4364)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TransactionModeContext: ParserRuleContext {
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func CONSISTENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSISTENT.rawValue, 0)
			}
			open
			func SNAPSHOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SNAPSHOT.rawValue, 0)
			}
			open
			func READ() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.READ.rawValue, 0)
			}
			open
			func WRITE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WRITE.rawValue, 0)
			}
			open
			func ONLY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONLY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_transactionMode
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTransactionMode(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTransactionMode(self)
			}
		}
	}
	@discardableResult
	 open func transactionMode() throws -> TransactionModeContext {
		var _localctx: TransactionModeContext
		_localctx = TransactionModeContext(_ctx, getState())
		try enterRule(_localctx, 320, MySqlParser.RULE_transactionMode)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4372)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,644, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4365)
		 		try match(MySqlParser.Tokens.WITH.rawValue)
		 		setState(4366)
		 		try match(MySqlParser.Tokens.CONSISTENT.rawValue)
		 		setState(4367)
		 		try match(MySqlParser.Tokens.SNAPSHOT.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4368)
		 		try match(MySqlParser.Tokens.READ.rawValue)
		 		setState(4369)
		 		try match(MySqlParser.Tokens.WRITE.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4370)
		 		try match(MySqlParser.Tokens.READ.rawValue)
		 		setState(4371)
		 		try match(MySqlParser.Tokens.ONLY.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LockTableElementContext: ParserRuleContext {
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func lockAction() -> LockActionContext? {
				return getRuleContext(LockActionContext.self, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_lockTableElement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLockTableElement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLockTableElement(self)
			}
		}
	}
	@discardableResult
	 open func lockTableElement() throws -> LockTableElementContext {
		var _localctx: LockTableElementContext
		_localctx = LockTableElementContext(_ctx, getState())
		try enterRule(_localctx, 322, MySqlParser.RULE_lockTableElement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4374)
		 	try tableName()
		 	setState(4379)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513126400) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 		setState(4376)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.AS.rawValue) {
		 			setState(4375)
		 			try match(MySqlParser.Tokens.AS.rawValue)

		 		}

		 		setState(4378)
		 		try uid()

		 	}

		 	setState(4381)
		 	try lockAction()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LockActionContext: ParserRuleContext {
			open
			func READ() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.READ.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL.rawValue, 0)
			}
			open
			func WRITE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WRITE.rawValue, 0)
			}
			open
			func LOW_PRIORITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOW_PRIORITY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_lockAction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLockAction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLockAction(self)
			}
		}
	}
	@discardableResult
	 open func lockAction() throws -> LockActionContext {
		var _localctx: LockActionContext
		_localctx = LockActionContext(_ctx, getState())
		try enterRule(_localctx, 324, MySqlParser.RULE_lockAction)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4391)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .READ:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4383)
		 		try match(MySqlParser.Tokens.READ.rawValue)
		 		setState(4385)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LOCAL.rawValue) {
		 			setState(4384)
		 			try match(MySqlParser.Tokens.LOCAL.rawValue)

		 		}


		 		break
		 	case .LOW_PRIORITY:fallthrough
		 	case .WRITE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4388)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LOW_PRIORITY.rawValue) {
		 			setState(4387)
		 			try match(MySqlParser.Tokens.LOW_PRIORITY.rawValue)

		 		}

		 		setState(4390)
		 		try match(MySqlParser.Tokens.WRITE.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TransactionOptionContext: ParserRuleContext {
			open
			func ISOLATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ISOLATION.rawValue, 0)
			}
			open
			func LEVEL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEVEL.rawValue, 0)
			}
			open
			func transactionLevel() -> TransactionLevelContext? {
				return getRuleContext(TransactionLevelContext.self, 0)
			}
			open
			func READ() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.READ.rawValue, 0)
			}
			open
			func WRITE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WRITE.rawValue, 0)
			}
			open
			func ONLY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONLY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_transactionOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTransactionOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTransactionOption(self)
			}
		}
	}
	@discardableResult
	 open func transactionOption() throws -> TransactionOptionContext {
		var _localctx: TransactionOptionContext
		_localctx = TransactionOptionContext(_ctx, getState())
		try enterRule(_localctx, 326, MySqlParser.RULE_transactionOption)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4400)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,650, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4393)
		 		try match(MySqlParser.Tokens.ISOLATION.rawValue)
		 		setState(4394)
		 		try match(MySqlParser.Tokens.LEVEL.rawValue)
		 		setState(4395)
		 		try transactionLevel()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4396)
		 		try match(MySqlParser.Tokens.READ.rawValue)
		 		setState(4397)
		 		try match(MySqlParser.Tokens.WRITE.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4398)
		 		try match(MySqlParser.Tokens.READ.rawValue)
		 		setState(4399)
		 		try match(MySqlParser.Tokens.ONLY.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TransactionLevelContext: ParserRuleContext {
			open
			func REPEATABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPEATABLE.rawValue, 0)
			}
			open
			func READ() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.READ.rawValue, 0)
			}
			open
			func COMMITTED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMITTED.rawValue, 0)
			}
			open
			func UNCOMMITTED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNCOMMITTED.rawValue, 0)
			}
			open
			func SERIALIZABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SERIALIZABLE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_transactionLevel
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTransactionLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTransactionLevel(self)
			}
		}
	}
	@discardableResult
	 open func transactionLevel() throws -> TransactionLevelContext {
		var _localctx: TransactionLevelContext
		_localctx = TransactionLevelContext(_ctx, getState())
		try enterRule(_localctx, 328, MySqlParser.RULE_transactionLevel)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4409)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,651, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4402)
		 		try match(MySqlParser.Tokens.REPEATABLE.rawValue)
		 		setState(4403)
		 		try match(MySqlParser.Tokens.READ.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4404)
		 		try match(MySqlParser.Tokens.READ.rawValue)
		 		setState(4405)
		 		try match(MySqlParser.Tokens.COMMITTED.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4406)
		 		try match(MySqlParser.Tokens.READ.rawValue)
		 		setState(4407)
		 		try match(MySqlParser.Tokens.UNCOMMITTED.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4408)
		 		try match(MySqlParser.Tokens.SERIALIZABLE.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ChangeMasterContext: ParserRuleContext {
			open
			func CHANGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHANGE.rawValue, 0)
			}
			open
			func MASTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER.rawValue, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func masterOption() -> [MasterOptionContext] {
				return getRuleContexts(MasterOptionContext.self)
			}
			open
			func masterOption(_ i: Int) -> MasterOptionContext? {
				return getRuleContext(MasterOptionContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func channelOption() -> ChannelOptionContext? {
				return getRuleContext(ChannelOptionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_changeMaster
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterChangeMaster(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitChangeMaster(self)
			}
		}
	}
	@discardableResult
	 open func changeMaster() throws -> ChangeMasterContext {
		var _localctx: ChangeMasterContext
		_localctx = ChangeMasterContext(_ctx, getState())
		try enterRule(_localctx, 330, MySqlParser.RULE_changeMaster)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4411)
		 	try match(MySqlParser.Tokens.CHANGE.rawValue)
		 	setState(4412)
		 	try match(MySqlParser.Tokens.MASTER.rawValue)
		 	setState(4413)
		 	try match(MySqlParser.Tokens.TO.rawValue)
		 	setState(4414)
		 	try masterOption()
		 	setState(4419)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(4415)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(4416)
		 		try masterOption()


		 		setState(4421)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4423)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.FOR.rawValue) {
		 		setState(4422)
		 		try channelOption()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ChangeReplicationFilterContext: ParserRuleContext {
			open
			func CHANGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHANGE.rawValue, 0)
			}
			open
			func REPLICATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATION.rawValue, 0)
			}
			open
			func FILTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FILTER.rawValue, 0)
			}
			open
			func replicationFilter() -> [ReplicationFilterContext] {
				return getRuleContexts(ReplicationFilterContext.self)
			}
			open
			func replicationFilter(_ i: Int) -> ReplicationFilterContext? {
				return getRuleContext(ReplicationFilterContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_changeReplicationFilter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterChangeReplicationFilter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitChangeReplicationFilter(self)
			}
		}
	}
	@discardableResult
	 open func changeReplicationFilter() throws -> ChangeReplicationFilterContext {
		var _localctx: ChangeReplicationFilterContext
		_localctx = ChangeReplicationFilterContext(_ctx, getState())
		try enterRule(_localctx, 332, MySqlParser.RULE_changeReplicationFilter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4425)
		 	try match(MySqlParser.Tokens.CHANGE.rawValue)
		 	setState(4426)
		 	try match(MySqlParser.Tokens.REPLICATION.rawValue)
		 	setState(4427)
		 	try match(MySqlParser.Tokens.FILTER.rawValue)
		 	setState(4428)
		 	try replicationFilter()
		 	setState(4433)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(4429)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(4430)
		 		try replicationFilter()


		 		setState(4435)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PurgeBinaryLogsContext: ParserRuleContext {
		open var purgeFormat: Token!
		open var fileName: Token!
		open var timeValue: Token!
			open
			func PURGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PURGE.rawValue, 0)
			}
			open
			func LOGS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOGS.rawValue, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}
			open
			func MASTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER.rawValue, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func BEFORE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BEFORE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_purgeBinaryLogs
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPurgeBinaryLogs(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPurgeBinaryLogs(self)
			}
		}
	}
	@discardableResult
	 open func purgeBinaryLogs() throws -> PurgeBinaryLogsContext {
		var _localctx: PurgeBinaryLogsContext
		_localctx = PurgeBinaryLogsContext(_ctx, getState())
		try enterRule(_localctx, 334, MySqlParser.RULE_purgeBinaryLogs)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4436)
		 	try match(MySqlParser.Tokens.PURGE.rawValue)
		 	setState(4437)
		 	_localctx.castdown(PurgeBinaryLogsContext.self).purgeFormat = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.BINARY.rawValue || _la == MySqlParser.Tokens.MASTER.rawValue)) {
		 		_localctx.castdown(PurgeBinaryLogsContext.self).purgeFormat = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4438)
		 	try match(MySqlParser.Tokens.LOGS.rawValue)
		 	setState(4443)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .TO:
		 		setState(4439)
		 		try match(MySqlParser.Tokens.TO.rawValue)
		 		setState(4440)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(PurgeBinaryLogsContext.self).fileName = assignmentValue
		 		     }()


		 		break

		 	case .BEFORE:
		 		setState(4441)
		 		try match(MySqlParser.Tokens.BEFORE.rawValue)
		 		setState(4442)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(PurgeBinaryLogsContext.self).timeValue = assignmentValue
		 		     }()


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ResetMasterContext: ParserRuleContext {
			open
			func RESET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESET.rawValue, 0)
			}
			open
			func MASTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_resetMaster
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterResetMaster(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitResetMaster(self)
			}
		}
	}
	@discardableResult
	 open func resetMaster() throws -> ResetMasterContext {
		var _localctx: ResetMasterContext
		_localctx = ResetMasterContext(_ctx, getState())
		try enterRule(_localctx, 336, MySqlParser.RULE_resetMaster)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4445)
		 	try match(MySqlParser.Tokens.RESET.rawValue)
		 	setState(4446)
		 	try match(MySqlParser.Tokens.MASTER.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ResetSlaveContext: ParserRuleContext {
			open
			func RESET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESET.rawValue, 0)
			}
			open
			func SLAVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SLAVE.rawValue, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func channelOption() -> ChannelOptionContext? {
				return getRuleContext(ChannelOptionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_resetSlave
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterResetSlave(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitResetSlave(self)
			}
		}
	}
	@discardableResult
	 open func resetSlave() throws -> ResetSlaveContext {
		var _localctx: ResetSlaveContext
		_localctx = ResetSlaveContext(_ctx, getState())
		try enterRule(_localctx, 338, MySqlParser.RULE_resetSlave)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4448)
		 	try match(MySqlParser.Tokens.RESET.rawValue)
		 	setState(4449)
		 	try match(MySqlParser.Tokens.SLAVE.rawValue)
		 	setState(4451)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ALL.rawValue) {
		 		setState(4450)
		 		try match(MySqlParser.Tokens.ALL.rawValue)

		 	}

		 	setState(4454)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.FOR.rawValue) {
		 		setState(4453)
		 		try channelOption()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StartSlaveContext: ParserRuleContext {
			open
			func START() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.START.rawValue, 0)
			}
			open
			func SLAVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SLAVE.rawValue, 0)
			}
			open
			func threadType() -> [ThreadTypeContext] {
				return getRuleContexts(ThreadTypeContext.self)
			}
			open
			func threadType(_ i: Int) -> ThreadTypeContext? {
				return getRuleContext(ThreadTypeContext.self, i)
			}
			open
			func UNTIL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNTIL.rawValue, 0)
			}
			open
			func untilOption() -> UntilOptionContext? {
				return getRuleContext(UntilOptionContext.self, 0)
			}
			open
			func connectionOption() -> [ConnectionOptionContext] {
				return getRuleContexts(ConnectionOptionContext.self)
			}
			open
			func connectionOption(_ i: Int) -> ConnectionOptionContext? {
				return getRuleContext(ConnectionOptionContext.self, i)
			}
			open
			func channelOption() -> ChannelOptionContext? {
				return getRuleContext(ChannelOptionContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_startSlave
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterStartSlave(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitStartSlave(self)
			}
		}
	}
	@discardableResult
	 open func startSlave() throws -> StartSlaveContext {
		var _localctx: StartSlaveContext
		_localctx = StartSlaveContext(_ctx, getState())
		try enterRule(_localctx, 340, MySqlParser.RULE_startSlave)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4456)
		 	try match(MySqlParser.Tokens.START.rawValue)
		 	setState(4457)
		 	try match(MySqlParser.Tokens.SLAVE.rawValue)
		 	setState(4466)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IO_THREAD.rawValue || _la == MySqlParser.Tokens.SQL_THREAD.rawValue) {
		 		setState(4458)
		 		try threadType()
		 		setState(4463)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(4459)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(4460)
		 			try threadType()


		 			setState(4465)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}

		 	setState(4470)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.UNTIL.rawValue) {
		 		setState(4468)
		 		try match(MySqlParser.Tokens.UNTIL.rawValue)
		 		setState(4469)
		 		try untilOption()

		 	}

		 	setState(4475)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.DEFAULT_AUTH.rawValue || _la == MySqlParser.Tokens.PASSWORD.rawValue || _la == MySqlParser.Tokens.PLUGIN_DIR.rawValue || _la == MySqlParser.Tokens.USER.rawValue) {
		 		setState(4472)
		 		try connectionOption()


		 		setState(4477)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4479)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.FOR.rawValue) {
		 		setState(4478)
		 		try channelOption()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StopSlaveContext: ParserRuleContext {
			open
			func STOP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STOP.rawValue, 0)
			}
			open
			func SLAVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SLAVE.rawValue, 0)
			}
			open
			func threadType() -> [ThreadTypeContext] {
				return getRuleContexts(ThreadTypeContext.self)
			}
			open
			func threadType(_ i: Int) -> ThreadTypeContext? {
				return getRuleContext(ThreadTypeContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_stopSlave
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterStopSlave(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitStopSlave(self)
			}
		}
	}
	@discardableResult
	 open func stopSlave() throws -> StopSlaveContext {
		var _localctx: StopSlaveContext
		_localctx = StopSlaveContext(_ctx, getState())
		try enterRule(_localctx, 342, MySqlParser.RULE_stopSlave)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4481)
		 	try match(MySqlParser.Tokens.STOP.rawValue)
		 	setState(4482)
		 	try match(MySqlParser.Tokens.SLAVE.rawValue)
		 	setState(4491)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IO_THREAD.rawValue || _la == MySqlParser.Tokens.SQL_THREAD.rawValue) {
		 		setState(4483)
		 		try threadType()
		 		setState(4488)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(4484)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(4485)
		 			try threadType()


		 			setState(4490)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StartGroupReplicationContext: ParserRuleContext {
			open
			func START() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.START.rawValue, 0)
			}
			open
			func GROUP_REPLICATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP_REPLICATION.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_startGroupReplication
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterStartGroupReplication(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitStartGroupReplication(self)
			}
		}
	}
	@discardableResult
	 open func startGroupReplication() throws -> StartGroupReplicationContext {
		var _localctx: StartGroupReplicationContext
		_localctx = StartGroupReplicationContext(_ctx, getState())
		try enterRule(_localctx, 344, MySqlParser.RULE_startGroupReplication)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4493)
		 	try match(MySqlParser.Tokens.START.rawValue)
		 	setState(4494)
		 	try match(MySqlParser.Tokens.GROUP_REPLICATION.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StopGroupReplicationContext: ParserRuleContext {
			open
			func STOP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STOP.rawValue, 0)
			}
			open
			func GROUP_REPLICATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP_REPLICATION.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_stopGroupReplication
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterStopGroupReplication(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitStopGroupReplication(self)
			}
		}
	}
	@discardableResult
	 open func stopGroupReplication() throws -> StopGroupReplicationContext {
		var _localctx: StopGroupReplicationContext
		_localctx = StopGroupReplicationContext(_ctx, getState())
		try enterRule(_localctx, 346, MySqlParser.RULE_stopGroupReplication)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4496)
		 	try match(MySqlParser.Tokens.STOP.rawValue)
		 	setState(4497)
		 	try match(MySqlParser.Tokens.GROUP_REPLICATION.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MasterOptionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_masterOption
		}
	}
	public class MasterStringOptionContext: MasterOptionContext {
			open
			func stringMasterOption() -> StringMasterOptionContext? {
				return getRuleContext(StringMasterOptionContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: MasterOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMasterStringOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMasterStringOption(self)
			}
		}
	}
	public class MasterRealOptionContext: MasterOptionContext {
			open
			func MASTER_HEARTBEAT_PERIOD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_HEARTBEAT_PERIOD.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func REAL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REAL_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: MasterOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMasterRealOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMasterRealOption(self)
			}
		}
	}
	public class MasterBoolOptionContext: MasterOptionContext {
		public var boolVal: Token!
			open
			func boolMasterOption() -> BoolMasterOptionContext? {
				return getRuleContext(BoolMasterOptionContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func ZERO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZERO_DECIMAL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}

		public
		init(_ ctx: MasterOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMasterBoolOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMasterBoolOption(self)
			}
		}
	}
	public class MasterUidListOptionContext: MasterOptionContext {
			open
			func IGNORE_SERVER_IDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE_SERVER_IDS.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: MasterOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMasterUidListOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMasterUidListOption(self)
			}
		}
	}
	public class MasterDecimalOptionContext: MasterOptionContext {
			open
			func decimalMasterOption() -> DecimalMasterOptionContext? {
				return getRuleContext(DecimalMasterOptionContext.self, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}

		public
		init(_ ctx: MasterOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMasterDecimalOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMasterDecimalOption(self)
			}
		}
	}
	@discardableResult
	 open func masterOption() throws -> MasterOptionContext {
		var _localctx: MasterOptionContext
		_localctx = MasterOptionContext(_ctx, getState())
		try enterRule(_localctx, 348, MySqlParser.RULE_masterOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4528)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .MASTER_BIND:fallthrough
		 	case .MASTER_HOST:fallthrough
		 	case .MASTER_LOG_FILE:fallthrough
		 	case .MASTER_PASSWORD:fallthrough
		 	case .MASTER_SSL_CA:fallthrough
		 	case .MASTER_SSL_CAPATH:fallthrough
		 	case .MASTER_SSL_CERT:fallthrough
		 	case .MASTER_SSL_CIPHER:fallthrough
		 	case .MASTER_SSL_CRL:fallthrough
		 	case .MASTER_SSL_CRLPATH:fallthrough
		 	case .MASTER_SSL_KEY:fallthrough
		 	case .MASTER_TLS_VERSION:fallthrough
		 	case .MASTER_USER:fallthrough
		 	case .RELAY_LOG_FILE:
		 		_localctx =  MasterStringOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4499)
		 		try stringMasterOption()
		 		setState(4500)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4501)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case .MASTER_CONNECT_RETRY:fallthrough
		 	case .MASTER_DELAY:fallthrough
		 	case .MASTER_LOG_POS:fallthrough
		 	case .MASTER_PORT:fallthrough
		 	case .MASTER_RETRY_COUNT:fallthrough
		 	case .RELAY_LOG_POS:
		 		_localctx =  MasterDecimalOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4503)
		 		try decimalMasterOption()
		 		setState(4504)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4505)
		 		try decimalLiteral()

		 		break
		 	case .MASTER_SSL_VERIFY_SERVER_CERT:fallthrough
		 	case .MASTER_AUTO_POSITION:fallthrough
		 	case .MASTER_SSL:
		 		_localctx =  MasterBoolOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4507)
		 		try boolMasterOption()
		 		setState(4508)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4509)
		 		_localctx.castdown(MasterBoolOptionContext.self).boolVal = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ZERO_DECIMAL.rawValue || _la == MySqlParser.Tokens.ONE_DECIMAL.rawValue)) {
		 			_localctx.castdown(MasterBoolOptionContext.self).boolVal = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break

		 	case .MASTER_HEARTBEAT_PERIOD:
		 		_localctx =  MasterRealOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4511)
		 		try match(MySqlParser.Tokens.MASTER_HEARTBEAT_PERIOD.rawValue)
		 		setState(4512)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4513)
		 		try match(MySqlParser.Tokens.REAL_LITERAL.rawValue)

		 		break

		 	case .IGNORE_SERVER_IDS:
		 		_localctx =  MasterUidListOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4514)
		 		try match(MySqlParser.Tokens.IGNORE_SERVER_IDS.rawValue)
		 		setState(4515)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4516)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4525)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 			setState(4517)
		 			try uid()
		 			setState(4522)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 				setState(4518)
		 				try match(MySqlParser.Tokens.COMMA.rawValue)
		 				setState(4519)
		 				try uid()


		 				setState(4524)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}

		 		}

		 		setState(4527)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringMasterOptionContext: ParserRuleContext {
			open
			func MASTER_BIND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_BIND.rawValue, 0)
			}
			open
			func MASTER_HOST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_HOST.rawValue, 0)
			}
			open
			func MASTER_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_USER.rawValue, 0)
			}
			open
			func MASTER_PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_PASSWORD.rawValue, 0)
			}
			open
			func MASTER_LOG_FILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_LOG_FILE.rawValue, 0)
			}
			open
			func RELAY_LOG_FILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELAY_LOG_FILE.rawValue, 0)
			}
			open
			func MASTER_SSL_CA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CA.rawValue, 0)
			}
			open
			func MASTER_SSL_CAPATH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CAPATH.rawValue, 0)
			}
			open
			func MASTER_SSL_CERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CERT.rawValue, 0)
			}
			open
			func MASTER_SSL_CRL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CRL.rawValue, 0)
			}
			open
			func MASTER_SSL_CRLPATH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CRLPATH.rawValue, 0)
			}
			open
			func MASTER_SSL_KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_KEY.rawValue, 0)
			}
			open
			func MASTER_SSL_CIPHER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CIPHER.rawValue, 0)
			}
			open
			func MASTER_TLS_VERSION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_TLS_VERSION.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_stringMasterOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterStringMasterOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitStringMasterOption(self)
			}
		}
	}
	@discardableResult
	 open func stringMasterOption() throws -> StringMasterOptionContext {
		var _localctx: StringMasterOptionContext
		_localctx = StringMasterOptionContext(_ctx, getState())
		try enterRule(_localctx, 350, MySqlParser.RULE_stringMasterOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4530)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.MASTER_BIND.rawValue || ((Int64((_la - 482)) & ~0x3f) == 0 && ((Int64(1) << (_la - 482)) & 65419) != 0) || _la == MySqlParser.Tokens.RELAY_LOG_FILE.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DecimalMasterOptionContext: ParserRuleContext {
			open
			func MASTER_PORT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_PORT.rawValue, 0)
			}
			open
			func MASTER_CONNECT_RETRY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_CONNECT_RETRY.rawValue, 0)
			}
			open
			func MASTER_RETRY_COUNT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_RETRY_COUNT.rawValue, 0)
			}
			open
			func MASTER_DELAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_DELAY.rawValue, 0)
			}
			open
			func MASTER_LOG_POS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_LOG_POS.rawValue, 0)
			}
			open
			func RELAY_LOG_POS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELAY_LOG_POS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_decimalMasterOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDecimalMasterOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDecimalMasterOption(self)
			}
		}
	}
	@discardableResult
	 open func decimalMasterOption() throws -> DecimalMasterOptionContext {
		var _localctx: DecimalMasterOptionContext
		_localctx = DecimalMasterOptionContext(_ctx, getState())
		try enterRule(_localctx, 352, MySqlParser.RULE_decimalMasterOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4532)
		 	_la = try _input.LA(1)
		 	if (!(((Int64((_la - 479)) & ~0x3f) == 0 && ((Int64(1) << (_la - 479)) & 419) != 0) || _la == MySqlParser.Tokens.RELAY_LOG_POS.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BoolMasterOptionContext: ParserRuleContext {
			open
			func MASTER_AUTO_POSITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_AUTO_POSITION.rawValue, 0)
			}
			open
			func MASTER_SSL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL.rawValue, 0)
			}
			open
			func MASTER_SSL_VERIFY_SERVER_CERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_VERIFY_SERVER_CERT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_boolMasterOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterBoolMasterOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitBoolMasterOption(self)
			}
		}
	}
	@discardableResult
	 open func boolMasterOption() throws -> BoolMasterOptionContext {
		var _localctx: BoolMasterOptionContext
		_localctx = BoolMasterOptionContext(_ctx, getState())
		try enterRule(_localctx, 354, MySqlParser.RULE_boolMasterOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4534)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.MASTER_SSL_VERIFY_SERVER_CERT.rawValue || _la == MySqlParser.Tokens.MASTER_AUTO_POSITION.rawValue || _la == MySqlParser.Tokens.MASTER_SSL.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ChannelOptionContext: ParserRuleContext {
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func CHANNEL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHANNEL.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_channelOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterChannelOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitChannelOption(self)
			}
		}
	}
	@discardableResult
	 open func channelOption() throws -> ChannelOptionContext {
		var _localctx: ChannelOptionContext
		_localctx = ChannelOptionContext(_ctx, getState())
		try enterRule(_localctx, 356, MySqlParser.RULE_channelOption)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4536)
		 	try match(MySqlParser.Tokens.FOR.rawValue)
		 	setState(4537)
		 	try match(MySqlParser.Tokens.CHANNEL.rawValue)
		 	setState(4538)
		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReplicationFilterContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_replicationFilter
		}
	}
	public class WildIgnoreTableReplicationContext: ReplicationFilterContext {
			open
			func REPLICATE_WILD_IGNORE_TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_WILD_IGNORE_TABLE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func simpleStrings() -> SimpleStringsContext? {
				return getRuleContext(SimpleStringsContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: ReplicationFilterContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterWildIgnoreTableReplication(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitWildIgnoreTableReplication(self)
			}
		}
	}
	public class DoTableReplicationContext: ReplicationFilterContext {
			open
			func REPLICATE_DO_TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_DO_TABLE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func tables() -> TablesContext? {
				return getRuleContext(TablesContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: ReplicationFilterContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDoTableReplication(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDoTableReplication(self)
			}
		}
	}
	public class IgnoreTableReplicationContext: ReplicationFilterContext {
			open
			func REPLICATE_IGNORE_TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_IGNORE_TABLE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func tables() -> TablesContext? {
				return getRuleContext(TablesContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: ReplicationFilterContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIgnoreTableReplication(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIgnoreTableReplication(self)
			}
		}
	}
	public class RewriteDbReplicationContext: ReplicationFilterContext {
			open
			func REPLICATE_REWRITE_DB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_REWRITE_DB.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func tablePair() -> [TablePairContext] {
				return getRuleContexts(TablePairContext.self)
			}
			open
			func tablePair(_ i: Int) -> TablePairContext? {
				return getRuleContext(TablePairContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: ReplicationFilterContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRewriteDbReplication(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRewriteDbReplication(self)
			}
		}
	}
	public class DoDbReplicationContext: ReplicationFilterContext {
			open
			func REPLICATE_DO_DB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_DO_DB.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: ReplicationFilterContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDoDbReplication(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDoDbReplication(self)
			}
		}
	}
	public class IgnoreDbReplicationContext: ReplicationFilterContext {
			open
			func REPLICATE_IGNORE_DB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_IGNORE_DB.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: ReplicationFilterContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIgnoreDbReplication(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIgnoreDbReplication(self)
			}
		}
	}
	public class WildDoTableReplicationContext: ReplicationFilterContext {
			open
			func REPLICATE_WILD_DO_TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_WILD_DO_TABLE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func simpleStrings() -> SimpleStringsContext? {
				return getRuleContext(SimpleStringsContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: ReplicationFilterContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterWildDoTableReplication(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitWildDoTableReplication(self)
			}
		}
	}
	@discardableResult
	 open func replicationFilter() throws -> ReplicationFilterContext {
		var _localctx: ReplicationFilterContext
		_localctx = ReplicationFilterContext(_ctx, getState())
		try enterRule(_localctx, 358, MySqlParser.RULE_replicationFilter)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4589)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .REPLICATE_DO_DB:
		 		_localctx =  DoDbReplicationContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4540)
		 		try match(MySqlParser.Tokens.REPLICATE_DO_DB.rawValue)
		 		setState(4541)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4542)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4543)
		 		try uidList()
		 		setState(4544)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break

		 	case .REPLICATE_IGNORE_DB:
		 		_localctx =  IgnoreDbReplicationContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4546)
		 		try match(MySqlParser.Tokens.REPLICATE_IGNORE_DB.rawValue)
		 		setState(4547)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4548)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4549)
		 		try uidList()
		 		setState(4550)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break

		 	case .REPLICATE_DO_TABLE:
		 		_localctx =  DoTableReplicationContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4552)
		 		try match(MySqlParser.Tokens.REPLICATE_DO_TABLE.rawValue)
		 		setState(4553)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4554)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4555)
		 		try tables()
		 		setState(4556)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break

		 	case .REPLICATE_IGNORE_TABLE:
		 		_localctx =  IgnoreTableReplicationContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4558)
		 		try match(MySqlParser.Tokens.REPLICATE_IGNORE_TABLE.rawValue)
		 		setState(4559)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4560)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4561)
		 		try tables()
		 		setState(4562)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break

		 	case .REPLICATE_WILD_DO_TABLE:
		 		_localctx =  WildDoTableReplicationContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4564)
		 		try match(MySqlParser.Tokens.REPLICATE_WILD_DO_TABLE.rawValue)
		 		setState(4565)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4566)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4567)
		 		try simpleStrings()
		 		setState(4568)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break

		 	case .REPLICATE_WILD_IGNORE_TABLE:
		 		_localctx =  WildIgnoreTableReplicationContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(4570)
		 		try match(MySqlParser.Tokens.REPLICATE_WILD_IGNORE_TABLE.rawValue)
		 		setState(4571)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4572)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4573)
		 		try simpleStrings()
		 		setState(4574)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break

		 	case .REPLICATE_REWRITE_DB:
		 		_localctx =  RewriteDbReplicationContext(_localctx);
		 		try enterOuterAlt(_localctx, 7)
		 		setState(4576)
		 		try match(MySqlParser.Tokens.REPLICATE_REWRITE_DB.rawValue)
		 		setState(4577)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4578)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(4579)
		 		try tablePair()
		 		setState(4584)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(4580)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(4581)
		 			try tablePair()


		 			setState(4586)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4587)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TablePairContext: ParserRuleContext {
		open var firstTable: TableNameContext!
		open var secondTable: TableNameContext!
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func tableName() -> [TableNameContext] {
				return getRuleContexts(TableNameContext.self)
			}
			open
			func tableName(_ i: Int) -> TableNameContext? {
				return getRuleContext(TableNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tablePair
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTablePair(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTablePair(self)
			}
		}
	}
	@discardableResult
	 open func tablePair() throws -> TablePairContext {
		var _localctx: TablePairContext
		_localctx = TablePairContext(_ctx, getState())
		try enterRule(_localctx, 360, MySqlParser.RULE_tablePair)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4591)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(4592)
		 	try {
		 			let assignmentValue = try tableName()
		 			_localctx.castdown(TablePairContext.self).firstTable = assignmentValue
		 	     }()

		 	setState(4593)
		 	try match(MySqlParser.Tokens.COMMA.rawValue)
		 	setState(4594)
		 	try {
		 			let assignmentValue = try tableName()
		 			_localctx.castdown(TablePairContext.self).secondTable = assignmentValue
		 	     }()

		 	setState(4595)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ThreadTypeContext: ParserRuleContext {
			open
			func IO_THREAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IO_THREAD.rawValue, 0)
			}
			open
			func SQL_THREAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_THREAD.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_threadType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterThreadType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitThreadType(self)
			}
		}
	}
	@discardableResult
	 open func threadType() throws -> ThreadTypeContext {
		var _localctx: ThreadTypeContext
		_localctx = ThreadTypeContext(_ctx, getState())
		try enterRule(_localctx, 362, MySqlParser.RULE_threadType)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4597)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.IO_THREAD.rawValue || _la == MySqlParser.Tokens.SQL_THREAD.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UntilOptionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_untilOption
		}
	}
	public class GtidsUntilOptionContext: UntilOptionContext {
		public var gtids: Token!
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func gtuidSet() -> GtuidSetContext? {
				return getRuleContext(GtuidSetContext.self, 0)
			}
			open
			func SQL_BEFORE_GTIDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_BEFORE_GTIDS.rawValue, 0)
			}
			open
			func SQL_AFTER_GTIDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_AFTER_GTIDS.rawValue, 0)
			}

		public
		init(_ ctx: UntilOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterGtidsUntilOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitGtidsUntilOption(self)
			}
		}
	}
	public class SqlGapsUntilOptionContext: UntilOptionContext {
			open
			func SQL_AFTER_MTS_GAPS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_AFTER_MTS_GAPS.rawValue, 0)
			}

		public
		init(_ ctx: UntilOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSqlGapsUntilOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSqlGapsUntilOption(self)
			}
		}
	}
	public class MasterLogUntilOptionContext: UntilOptionContext {
			open
			func MASTER_LOG_FILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_LOG_FILE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}
			open
			func MASTER_LOG_POS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_LOG_POS.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}

		public
		init(_ ctx: UntilOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMasterLogUntilOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMasterLogUntilOption(self)
			}
		}
	}
	public class RelayLogUntilOptionContext: UntilOptionContext {
			open
			func RELAY_LOG_FILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELAY_LOG_FILE.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}
			open
			func RELAY_LOG_POS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELAY_LOG_POS.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}

		public
		init(_ ctx: UntilOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRelayLogUntilOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRelayLogUntilOption(self)
			}
		}
	}
	@discardableResult
	 open func untilOption() throws -> UntilOptionContext {
		var _localctx: UntilOptionContext
		_localctx = UntilOptionContext(_ctx, getState())
		try enterRule(_localctx, 364, MySqlParser.RULE_untilOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4617)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SQL_AFTER_GTIDS:fallthrough
		 	case .SQL_BEFORE_GTIDS:
		 		_localctx =  GtidsUntilOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4599)
		 		_localctx.castdown(GtidsUntilOptionContext.self).gtids = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.SQL_AFTER_GTIDS.rawValue || _la == MySqlParser.Tokens.SQL_BEFORE_GTIDS.rawValue)) {
		 			_localctx.castdown(GtidsUntilOptionContext.self).gtids = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(4600)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4601)
		 		try gtuidSet()

		 		break

		 	case .MASTER_LOG_FILE:
		 		_localctx =  MasterLogUntilOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4602)
		 		try match(MySqlParser.Tokens.MASTER_LOG_FILE.rawValue)
		 		setState(4603)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4604)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 		setState(4605)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(4606)
		 		try match(MySqlParser.Tokens.MASTER_LOG_POS.rawValue)
		 		setState(4607)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4608)
		 		try decimalLiteral()

		 		break

		 	case .RELAY_LOG_FILE:
		 		_localctx =  RelayLogUntilOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4609)
		 		try match(MySqlParser.Tokens.RELAY_LOG_FILE.rawValue)
		 		setState(4610)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4611)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 		setState(4612)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(4613)
		 		try match(MySqlParser.Tokens.RELAY_LOG_POS.rawValue)
		 		setState(4614)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4615)
		 		try decimalLiteral()

		 		break

		 	case .SQL_AFTER_MTS_GAPS:
		 		_localctx =  SqlGapsUntilOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4616)
		 		try match(MySqlParser.Tokens.SQL_AFTER_MTS_GAPS.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConnectionOptionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_connectionOption
		}
	}
	public class PluginDirConnectionOptionContext: ConnectionOptionContext {
		public var conOptPluginDir: Token!
			open
			func PLUGIN_DIR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PLUGIN_DIR.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: ConnectionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPluginDirConnectionOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPluginDirConnectionOption(self)
			}
		}
	}
	public class UserConnectionOptionContext: ConnectionOptionContext {
		public var conOptUser: Token!
			open
			func USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: ConnectionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUserConnectionOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUserConnectionOption(self)
			}
		}
	}
	public class DefaultAuthConnectionOptionContext: ConnectionOptionContext {
		public var conOptDefAuth: Token!
			open
			func DEFAULT_AUTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT_AUTH.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: ConnectionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDefaultAuthConnectionOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDefaultAuthConnectionOption(self)
			}
		}
	}
	public class PasswordConnectionOptionContext: ConnectionOptionContext {
		public var conOptPassword: Token!
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: ConnectionOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPasswordConnectionOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPasswordConnectionOption(self)
			}
		}
	}
	@discardableResult
	 open func connectionOption() throws -> ConnectionOptionContext {
		var _localctx: ConnectionOptionContext
		_localctx = ConnectionOptionContext(_ctx, getState())
		try enterRule(_localctx, 366, MySqlParser.RULE_connectionOption)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4631)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .USER:
		 		_localctx =  UserConnectionOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4619)
		 		try match(MySqlParser.Tokens.USER.rawValue)
		 		setState(4620)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4621)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(UserConnectionOptionContext.self).conOptUser = assignmentValue
		 		     }()


		 		break

		 	case .PASSWORD:
		 		_localctx =  PasswordConnectionOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4622)
		 		try match(MySqlParser.Tokens.PASSWORD.rawValue)
		 		setState(4623)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4624)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(PasswordConnectionOptionContext.self).conOptPassword = assignmentValue
		 		     }()


		 		break

		 	case .DEFAULT_AUTH:
		 		_localctx =  DefaultAuthConnectionOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4625)
		 		try match(MySqlParser.Tokens.DEFAULT_AUTH.rawValue)
		 		setState(4626)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4627)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(DefaultAuthConnectionOptionContext.self).conOptDefAuth = assignmentValue
		 		     }()


		 		break

		 	case .PLUGIN_DIR:
		 		_localctx =  PluginDirConnectionOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4628)
		 		try match(MySqlParser.Tokens.PLUGIN_DIR.rawValue)
		 		setState(4629)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(4630)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(PluginDirConnectionOptionContext.self).conOptPluginDir = assignmentValue
		 		     }()


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GtuidSetContext: ParserRuleContext {
			open
			func uuidSet() -> [UuidSetContext] {
				return getRuleContexts(UuidSetContext.self)
			}
			open
			func uuidSet(_ i: Int) -> UuidSetContext? {
				return getRuleContext(UuidSetContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_gtuidSet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterGtuidSet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitGtuidSet(self)
			}
		}
	}
	@discardableResult
	 open func gtuidSet() throws -> GtuidSetContext {
		var _localctx: GtuidSetContext
		_localctx = GtuidSetContext(_ctx, getState())
		try enterRule(_localctx, 368, MySqlParser.RULE_gtuidSet)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4642)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ZERO_DECIMAL:fallthrough
		 	case .ONE_DECIMAL:fallthrough
		 	case .TWO_DECIMAL:fallthrough
		 	case .DECIMAL_LITERAL:fallthrough
		 	case .REAL_LITERAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4633)
		 		try uuidSet()
		 		setState(4638)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(4634)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(4635)
		 			try uuidSet()


		 			setState(4640)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break

		 	case .STRING_LITERAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4641)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class XaStartTransactionContext: ParserRuleContext {
		open var xaStart: Token!
		open var xaAction: Token!
			open
			func XA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XA.rawValue, 0)
			}
			open
			func xid() -> XidContext? {
				return getRuleContext(XidContext.self, 0)
			}
			open
			func START() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.START.rawValue, 0)
			}
			open
			func BEGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BEGIN.rawValue, 0)
			}
			open
			func JOIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JOIN.rawValue, 0)
			}
			open
			func RESUME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESUME.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_xaStartTransaction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterXaStartTransaction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitXaStartTransaction(self)
			}
		}
	}
	@discardableResult
	 open func xaStartTransaction() throws -> XaStartTransactionContext {
		var _localctx: XaStartTransactionContext
		_localctx = XaStartTransactionContext(_ctx, getState())
		try enterRule(_localctx, 370, MySqlParser.RULE_xaStartTransaction)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4644)
		 	try match(MySqlParser.Tokens.XA.rawValue)
		 	setState(4645)
		 	_localctx.castdown(XaStartTransactionContext.self).xaStart = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.BEGIN.rawValue || _la == MySqlParser.Tokens.START.rawValue)) {
		 		_localctx.castdown(XaStartTransactionContext.self).xaStart = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4646)
		 	try xid()
		 	setState(4648)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.JOIN.rawValue || _la == MySqlParser.Tokens.RESUME.rawValue) {
		 		setState(4647)
		 		_localctx.castdown(XaStartTransactionContext.self).xaAction = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.JOIN.rawValue || _la == MySqlParser.Tokens.RESUME.rawValue)) {
		 			_localctx.castdown(XaStartTransactionContext.self).xaAction = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class XaEndTransactionContext: ParserRuleContext {
			open
			func XA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XA.rawValue, 0)
			}
			open
			func END() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.END.rawValue, 0)
			}
			open
			func xid() -> XidContext? {
				return getRuleContext(XidContext.self, 0)
			}
			open
			func SUSPEND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUSPEND.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func MIGRATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MIGRATE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_xaEndTransaction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterXaEndTransaction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitXaEndTransaction(self)
			}
		}
	}
	@discardableResult
	 open func xaEndTransaction() throws -> XaEndTransactionContext {
		var _localctx: XaEndTransactionContext
		_localctx = XaEndTransactionContext(_ctx, getState())
		try enterRule(_localctx, 372, MySqlParser.RULE_xaEndTransaction)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4650)
		 	try match(MySqlParser.Tokens.XA.rawValue)
		 	setState(4651)
		 	try match(MySqlParser.Tokens.END.rawValue)
		 	setState(4652)
		 	try xid()
		 	setState(4658)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.SUSPEND.rawValue) {
		 		setState(4653)
		 		try match(MySqlParser.Tokens.SUSPEND.rawValue)
		 		setState(4656)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FOR.rawValue) {
		 			setState(4654)
		 			try match(MySqlParser.Tokens.FOR.rawValue)
		 			setState(4655)
		 			try match(MySqlParser.Tokens.MIGRATE.rawValue)

		 		}


		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class XaPrepareStatementContext: ParserRuleContext {
			open
			func XA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XA.rawValue, 0)
			}
			open
			func PREPARE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PREPARE.rawValue, 0)
			}
			open
			func xid() -> XidContext? {
				return getRuleContext(XidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_xaPrepareStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterXaPrepareStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitXaPrepareStatement(self)
			}
		}
	}
	@discardableResult
	 open func xaPrepareStatement() throws -> XaPrepareStatementContext {
		var _localctx: XaPrepareStatementContext
		_localctx = XaPrepareStatementContext(_ctx, getState())
		try enterRule(_localctx, 374, MySqlParser.RULE_xaPrepareStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4660)
		 	try match(MySqlParser.Tokens.XA.rawValue)
		 	setState(4661)
		 	try match(MySqlParser.Tokens.PREPARE.rawValue)
		 	setState(4662)
		 	try xid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class XaCommitWorkContext: ParserRuleContext {
			open
			func XA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XA.rawValue, 0)
			}
			open
			func COMMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMIT.rawValue, 0)
			}
			open
			func xid() -> XidContext? {
				return getRuleContext(XidContext.self, 0)
			}
			open
			func ONE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE.rawValue, 0)
			}
			open
			func PHASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PHASE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_xaCommitWork
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterXaCommitWork(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitXaCommitWork(self)
			}
		}
	}
	@discardableResult
	 open func xaCommitWork() throws -> XaCommitWorkContext {
		var _localctx: XaCommitWorkContext
		_localctx = XaCommitWorkContext(_ctx, getState())
		try enterRule(_localctx, 376, MySqlParser.RULE_xaCommitWork)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4664)
		 	try match(MySqlParser.Tokens.XA.rawValue)
		 	setState(4665)
		 	try match(MySqlParser.Tokens.COMMIT.rawValue)
		 	setState(4666)
		 	try xid()
		 	setState(4669)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ONE.rawValue) {
		 		setState(4667)
		 		try match(MySqlParser.Tokens.ONE.rawValue)
		 		setState(4668)
		 		try match(MySqlParser.Tokens.PHASE.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class XaRollbackWorkContext: ParserRuleContext {
			open
			func XA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XA.rawValue, 0)
			}
			open
			func ROLLBACK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLLBACK.rawValue, 0)
			}
			open
			func xid() -> XidContext? {
				return getRuleContext(XidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_xaRollbackWork
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterXaRollbackWork(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitXaRollbackWork(self)
			}
		}
	}
	@discardableResult
	 open func xaRollbackWork() throws -> XaRollbackWorkContext {
		var _localctx: XaRollbackWorkContext
		_localctx = XaRollbackWorkContext(_ctx, getState())
		try enterRule(_localctx, 378, MySqlParser.RULE_xaRollbackWork)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4671)
		 	try match(MySqlParser.Tokens.XA.rawValue)
		 	setState(4672)
		 	try match(MySqlParser.Tokens.ROLLBACK.rawValue)
		 	setState(4673)
		 	try xid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class XaRecoverWorkContext: ParserRuleContext {
			open
			func XA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XA.rawValue, 0)
			}
			open
			func RECOVER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RECOVER.rawValue, 0)
			}
			open
			func CONVERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONVERT.rawValue, 0)
			}
			open
			func xid() -> XidContext? {
				return getRuleContext(XidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_xaRecoverWork
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterXaRecoverWork(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitXaRecoverWork(self)
			}
		}
	}
	@discardableResult
	 open func xaRecoverWork() throws -> XaRecoverWorkContext {
		var _localctx: XaRecoverWorkContext
		_localctx = XaRecoverWorkContext(_ctx, getState())
		try enterRule(_localctx, 380, MySqlParser.RULE_xaRecoverWork)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4675)
		 	try match(MySqlParser.Tokens.XA.rawValue)
		 	setState(4676)
		 	try match(MySqlParser.Tokens.RECOVER.rawValue)
		 	setState(4679)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.CONVERT.rawValue) {
		 		setState(4677)
		 		try match(MySqlParser.Tokens.CONVERT.rawValue)
		 		setState(4678)
		 		try xid()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PrepareStatementContext: ParserRuleContext {
		open var query: Token!
		open var variable: Token!
			open
			func PREPARE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PREPARE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func LOCAL_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL_ID.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_prepareStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPrepareStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPrepareStatement(self)
			}
		}
	}
	@discardableResult
	 open func prepareStatement() throws -> PrepareStatementContext {
		var _localctx: PrepareStatementContext
		_localctx = PrepareStatementContext(_ctx, getState())
		try enterRule(_localctx, 382, MySqlParser.RULE_prepareStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4681)
		 	try match(MySqlParser.Tokens.PREPARE.rawValue)
		 	setState(4682)
		 	try uid()
		 	setState(4683)
		 	try match(MySqlParser.Tokens.FROM.rawValue)
		 	setState(4686)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .STRING_LITERAL:
		 		setState(4684)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(PrepareStatementContext.self).query = assignmentValue
		 		     }()


		 		break

		 	case .LOCAL_ID:
		 		setState(4685)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.LOCAL_ID.rawValue)
		 				_localctx.castdown(PrepareStatementContext.self).variable = assignmentValue
		 		     }()


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExecuteStatementContext: ParserRuleContext {
			open
			func EXECUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXECUTE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func USING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USING.rawValue, 0)
			}
			open
			func userVariables() -> UserVariablesContext? {
				return getRuleContext(UserVariablesContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_executeStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterExecuteStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitExecuteStatement(self)
			}
		}
	}
	@discardableResult
	 open func executeStatement() throws -> ExecuteStatementContext {
		var _localctx: ExecuteStatementContext
		_localctx = ExecuteStatementContext(_ctx, getState())
		try enterRule(_localctx, 384, MySqlParser.RULE_executeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4688)
		 	try match(MySqlParser.Tokens.EXECUTE.rawValue)
		 	setState(4689)
		 	try uid()
		 	setState(4692)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.USING.rawValue) {
		 		setState(4690)
		 		try match(MySqlParser.Tokens.USING.rawValue)
		 		setState(4691)
		 		try userVariables()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DeallocatePrepareContext: ParserRuleContext {
		open var dropFormat: Token!
			open
			func PREPARE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PREPARE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func DEALLOCATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEALLOCATE.rawValue, 0)
			}
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_deallocatePrepare
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDeallocatePrepare(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDeallocatePrepare(self)
			}
		}
	}
	@discardableResult
	 open func deallocatePrepare() throws -> DeallocatePrepareContext {
		var _localctx: DeallocatePrepareContext
		_localctx = DeallocatePrepareContext(_ctx, getState())
		try enterRule(_localctx, 386, MySqlParser.RULE_deallocatePrepare)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4694)
		 	_localctx.castdown(DeallocatePrepareContext.self).dropFormat = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.DROP.rawValue || _la == MySqlParser.Tokens.DEALLOCATE.rawValue)) {
		 		_localctx.castdown(DeallocatePrepareContext.self).dropFormat = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4695)
		 	try match(MySqlParser.Tokens.PREPARE.rawValue)
		 	setState(4696)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RoutineBodyContext: ParserRuleContext {
			open
			func blockStatement() -> BlockStatementContext? {
				return getRuleContext(BlockStatementContext.self, 0)
			}
			open
			func sqlStatement() -> SqlStatementContext? {
				return getRuleContext(SqlStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_routineBody
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRoutineBody(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRoutineBody(self)
			}
		}
	}
	@discardableResult
	 open func routineBody() throws -> RoutineBodyContext {
		var _localctx: RoutineBodyContext
		_localctx = RoutineBodyContext(_ctx, getState())
		try enterRule(_localctx, 388, MySqlParser.RULE_routineBody)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4700)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,681, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4698)
		 		try blockStatement()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4699)
		 		try sqlStatement()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BlockStatementContext: ParserRuleContext {
			open
			func BEGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BEGIN.rawValue, 0)
			}
			open
			func END() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.END.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func COLON_SYMB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLON_SYMB.rawValue, 0)
			}
			open
			func declareVariable() -> [DeclareVariableContext] {
				return getRuleContexts(DeclareVariableContext.self)
			}
			open
			func declareVariable(_ i: Int) -> DeclareVariableContext? {
				return getRuleContext(DeclareVariableContext.self, i)
			}
			open
			func SEMI() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.SEMI.rawValue)
			}
			open
			func SEMI(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SEMI.rawValue, i)
			}
			open
			func declareCondition() -> [DeclareConditionContext] {
				return getRuleContexts(DeclareConditionContext.self)
			}
			open
			func declareCondition(_ i: Int) -> DeclareConditionContext? {
				return getRuleContext(DeclareConditionContext.self, i)
			}
			open
			func declareCursor() -> [DeclareCursorContext] {
				return getRuleContexts(DeclareCursorContext.self)
			}
			open
			func declareCursor(_ i: Int) -> DeclareCursorContext? {
				return getRuleContext(DeclareCursorContext.self, i)
			}
			open
			func declareHandler() -> [DeclareHandlerContext] {
				return getRuleContexts(DeclareHandlerContext.self)
			}
			open
			func declareHandler(_ i: Int) -> DeclareHandlerContext? {
				return getRuleContext(DeclareHandlerContext.self, i)
			}
			open
			func procedureSqlStatement() -> [ProcedureSqlStatementContext] {
				return getRuleContexts(ProcedureSqlStatementContext.self)
			}
			open
			func procedureSqlStatement(_ i: Int) -> ProcedureSqlStatementContext? {
				return getRuleContext(ProcedureSqlStatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_blockStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterBlockStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitBlockStatement(self)
			}
		}
	}
	@discardableResult
	 open func blockStatement() throws -> BlockStatementContext {
		var _localctx: BlockStatementContext
		_localctx = BlockStatementContext(_ctx, getState())
		try enterRule(_localctx, 390, MySqlParser.RULE_blockStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4705)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,682,_ctx)) {
		 	case 1:
		 		setState(4702)
		 		try uid()
		 		setState(4703)
		 		try match(MySqlParser.Tokens.COLON_SYMB.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4707)
		 	try match(MySqlParser.Tokens.BEGIN.rawValue)
		 	setState(4713)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,683,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4708)
		 			try declareVariable()
		 			setState(4709)
		 			try match(MySqlParser.Tokens.SEMI.rawValue)

		 	 
		 		}
		 		setState(4715)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,683,_ctx)
		 	}
		 	setState(4721)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,684,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4716)
		 			try declareCondition()
		 			setState(4717)
		 			try match(MySqlParser.Tokens.SEMI.rawValue)

		 	 
		 		}
		 		setState(4723)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,684,_ctx)
		 	}
		 	setState(4729)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,685,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4724)
		 			try declareCursor()
		 			setState(4725)
		 			try match(MySqlParser.Tokens.SEMI.rawValue)

		 	 
		 		}
		 		setState(4731)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,685,_ctx)
		 	}
		 	setState(4737)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.DECLARE.rawValue) {
		 		setState(4732)
		 		try declareHandler()
		 		setState(4733)
		 		try match(MySqlParser.Tokens.SEMI.rawValue)


		 		setState(4739)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4743)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,687,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(4740)
		 			try procedureSqlStatement()

		 	 
		 		}
		 		setState(4745)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,687,_ctx)
		 	}
		 	setState(4746)
		 	try match(MySqlParser.Tokens.END.rawValue)
		 	setState(4748)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,688,_ctx)) {
		 	case 1:
		 		setState(4747)
		 		try uid()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CaseStatementContext: ParserRuleContext {
			open
			func CASE() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.CASE.rawValue)
			}
			open
			func CASE(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CASE.rawValue, i)
			}
			open
			func END() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.END.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func caseAlternative() -> [CaseAlternativeContext] {
				return getRuleContexts(CaseAlternativeContext.self)
			}
			open
			func caseAlternative(_ i: Int) -> CaseAlternativeContext? {
				return getRuleContext(CaseAlternativeContext.self, i)
			}
			open
			func ELSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ELSE.rawValue, 0)
			}
			open
			func procedureSqlStatement() -> [ProcedureSqlStatementContext] {
				return getRuleContexts(ProcedureSqlStatementContext.self)
			}
			open
			func procedureSqlStatement(_ i: Int) -> ProcedureSqlStatementContext? {
				return getRuleContext(ProcedureSqlStatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_caseStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCaseStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCaseStatement(self)
			}
		}
	}
	@discardableResult
	 open func caseStatement() throws -> CaseStatementContext {
		var _localctx: CaseStatementContext
		_localctx = CaseStatementContext(_ctx, getState())
		try enterRule(_localctx, 392, MySqlParser.RULE_caseStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4750)
		 	try match(MySqlParser.Tokens.CASE.rawValue)
		 	setState(4753)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,689,_ctx)) {
		 	case 1:
		 		setState(4751)
		 		try uid()

		 		break
		 	case 2:
		 		setState(4752)
		 		try expression(0)

		 		break
		 	default: break
		 	}
		 	setState(4756) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(4755)
		 		try caseAlternative()


		 		setState(4758); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (_la == MySqlParser.Tokens.WHEN.rawValue)
		 	setState(4766)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ELSE.rawValue) {
		 		setState(4760)
		 		try match(MySqlParser.Tokens.ELSE.rawValue)
		 		setState(4762); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(4761)
		 				try procedureSqlStatement()


		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(4764); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,691,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 	}

		 	setState(4768)
		 	try match(MySqlParser.Tokens.END.rawValue)
		 	setState(4769)
		 	try match(MySqlParser.Tokens.CASE.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IfStatementContext: ParserRuleContext {
		open var _procedureSqlStatement: ProcedureSqlStatementContext!
		open var thenStatements: [ProcedureSqlStatementContext] = [ProcedureSqlStatementContext]()
		open var elseStatements: [ProcedureSqlStatementContext] = [ProcedureSqlStatementContext]()
			open
			func IF() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.IF.rawValue)
			}
			open
			func IF(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IF.rawValue, i)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func THEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.THEN.rawValue, 0)
			}
			open
			func END() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.END.rawValue, 0)
			}
			open
			func elifAlternative() -> [ElifAlternativeContext] {
				return getRuleContexts(ElifAlternativeContext.self)
			}
			open
			func elifAlternative(_ i: Int) -> ElifAlternativeContext? {
				return getRuleContext(ElifAlternativeContext.self, i)
			}
			open
			func ELSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ELSE.rawValue, 0)
			}
			open
			func procedureSqlStatement() -> [ProcedureSqlStatementContext] {
				return getRuleContexts(ProcedureSqlStatementContext.self)
			}
			open
			func procedureSqlStatement(_ i: Int) -> ProcedureSqlStatementContext? {
				return getRuleContext(ProcedureSqlStatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_ifStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIfStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIfStatement(self)
			}
		}
	}
	@discardableResult
	 open func ifStatement() throws -> IfStatementContext {
		var _localctx: IfStatementContext
		_localctx = IfStatementContext(_ctx, getState())
		try enterRule(_localctx, 394, MySqlParser.RULE_ifStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4771)
		 	try match(MySqlParser.Tokens.IF.rawValue)
		 	setState(4772)
		 	try expression(0)
		 	setState(4773)
		 	try match(MySqlParser.Tokens.THEN.rawValue)
		 	setState(4775); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4774)
		 			try {
		 					let assignmentValue = try procedureSqlStatement()
		 					_localctx.castdown(IfStatementContext.self)._procedureSqlStatement = assignmentValue
		 			     }()

		 			_localctx.castdown(IfStatementContext.self).thenStatements.append(_localctx.castdown(IfStatementContext.self)._procedureSqlStatement)


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4777); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,693,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4782)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.ELSEIF.rawValue) {
		 		setState(4779)
		 		try elifAlternative()


		 		setState(4784)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4791)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ELSE.rawValue) {
		 		setState(4785)
		 		try match(MySqlParser.Tokens.ELSE.rawValue)
		 		setState(4787); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(4786)
		 				try {
		 						let assignmentValue = try procedureSqlStatement()
		 						_localctx.castdown(IfStatementContext.self)._procedureSqlStatement = assignmentValue
		 				     }()

		 				_localctx.castdown(IfStatementContext.self).elseStatements.append(_localctx.castdown(IfStatementContext.self)._procedureSqlStatement)


		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(4789); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,695,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 	}

		 	setState(4793)
		 	try match(MySqlParser.Tokens.END.rawValue)
		 	setState(4794)
		 	try match(MySqlParser.Tokens.IF.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IterateStatementContext: ParserRuleContext {
			open
			func ITERATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ITERATE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_iterateStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIterateStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIterateStatement(self)
			}
		}
	}
	@discardableResult
	 open func iterateStatement() throws -> IterateStatementContext {
		var _localctx: IterateStatementContext
		_localctx = IterateStatementContext(_ctx, getState())
		try enterRule(_localctx, 396, MySqlParser.RULE_iterateStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4796)
		 	try match(MySqlParser.Tokens.ITERATE.rawValue)
		 	setState(4797)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LeaveStatementContext: ParserRuleContext {
			open
			func LEAVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEAVE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_leaveStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLeaveStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLeaveStatement(self)
			}
		}
	}
	@discardableResult
	 open func leaveStatement() throws -> LeaveStatementContext {
		var _localctx: LeaveStatementContext
		_localctx = LeaveStatementContext(_ctx, getState())
		try enterRule(_localctx, 398, MySqlParser.RULE_leaveStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4799)
		 	try match(MySqlParser.Tokens.LEAVE.rawValue)
		 	setState(4800)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LoopStatementContext: ParserRuleContext {
			open
			func LOOP() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LOOP.rawValue)
			}
			open
			func LOOP(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOOP.rawValue, i)
			}
			open
			func END() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.END.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func COLON_SYMB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLON_SYMB.rawValue, 0)
			}
			open
			func procedureSqlStatement() -> [ProcedureSqlStatementContext] {
				return getRuleContexts(ProcedureSqlStatementContext.self)
			}
			open
			func procedureSqlStatement(_ i: Int) -> ProcedureSqlStatementContext? {
				return getRuleContext(ProcedureSqlStatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_loopStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLoopStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLoopStatement(self)
			}
		}
	}
	@discardableResult
	 open func loopStatement() throws -> LoopStatementContext {
		var _localctx: LoopStatementContext
		_localctx = LoopStatementContext(_ctx, getState())
		try enterRule(_localctx, 400, MySqlParser.RULE_loopStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4805)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 		setState(4802)
		 		try uid()
		 		setState(4803)
		 		try match(MySqlParser.Tokens.COLON_SYMB.rawValue)

		 	}

		 	setState(4807)
		 	try match(MySqlParser.Tokens.LOOP.rawValue)
		 	setState(4809); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4808)
		 			try procedureSqlStatement()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4811); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,698,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4813)
		 	try match(MySqlParser.Tokens.END.rawValue)
		 	setState(4814)
		 	try match(MySqlParser.Tokens.LOOP.rawValue)
		 	setState(4816)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 		setState(4815)
		 		try uid()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RepeatStatementContext: ParserRuleContext {
			open
			func REPEAT() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.REPEAT.rawValue)
			}
			open
			func REPEAT(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPEAT.rawValue, i)
			}
			open
			func UNTIL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNTIL.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func END() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.END.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func COLON_SYMB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLON_SYMB.rawValue, 0)
			}
			open
			func procedureSqlStatement() -> [ProcedureSqlStatementContext] {
				return getRuleContexts(ProcedureSqlStatementContext.self)
			}
			open
			func procedureSqlStatement(_ i: Int) -> ProcedureSqlStatementContext? {
				return getRuleContext(ProcedureSqlStatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_repeatStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRepeatStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRepeatStatement(self)
			}
		}
	}
	@discardableResult
	 open func repeatStatement() throws -> RepeatStatementContext {
		var _localctx: RepeatStatementContext
		_localctx = RepeatStatementContext(_ctx, getState())
		try enterRule(_localctx, 402, MySqlParser.RULE_repeatStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4821)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,700,_ctx)) {
		 	case 1:
		 		setState(4818)
		 		try uid()
		 		setState(4819)
		 		try match(MySqlParser.Tokens.COLON_SYMB.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(4823)
		 	try match(MySqlParser.Tokens.REPEAT.rawValue)
		 	setState(4825); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4824)
		 			try procedureSqlStatement()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4827); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,701,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4829)
		 	try match(MySqlParser.Tokens.UNTIL.rawValue)
		 	setState(4830)
		 	try expression(0)
		 	setState(4831)
		 	try match(MySqlParser.Tokens.END.rawValue)
		 	setState(4832)
		 	try match(MySqlParser.Tokens.REPEAT.rawValue)
		 	setState(4834)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 		setState(4833)
		 		try uid()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ReturnStatementContext: ParserRuleContext {
			open
			func RETURN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RETURN.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_returnStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterReturnStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitReturnStatement(self)
			}
		}
	}
	@discardableResult
	 open func returnStatement() throws -> ReturnStatementContext {
		var _localctx: ReturnStatementContext
		_localctx = ReturnStatementContext(_ctx, getState())
		try enterRule(_localctx, 404, MySqlParser.RULE_returnStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4836)
		 	try match(MySqlParser.Tokens.RETURN.rawValue)
		 	setState(4837)
		 	try expression(0)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WhileStatementContext: ParserRuleContext {
			open
			func WHILE() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.WHILE.rawValue)
			}
			open
			func WHILE(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHILE.rawValue, i)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func DO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DO.rawValue, 0)
			}
			open
			func END() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.END.rawValue, 0)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func COLON_SYMB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLON_SYMB.rawValue, 0)
			}
			open
			func procedureSqlStatement() -> [ProcedureSqlStatementContext] {
				return getRuleContexts(ProcedureSqlStatementContext.self)
			}
			open
			func procedureSqlStatement(_ i: Int) -> ProcedureSqlStatementContext? {
				return getRuleContext(ProcedureSqlStatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_whileStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterWhileStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitWhileStatement(self)
			}
		}
	}
	@discardableResult
	 open func whileStatement() throws -> WhileStatementContext {
		var _localctx: WhileStatementContext
		_localctx = WhileStatementContext(_ctx, getState())
		try enterRule(_localctx, 406, MySqlParser.RULE_whileStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4842)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 		setState(4839)
		 		try uid()
		 		setState(4840)
		 		try match(MySqlParser.Tokens.COLON_SYMB.rawValue)

		 	}

		 	setState(4844)
		 	try match(MySqlParser.Tokens.WHILE.rawValue)
		 	setState(4845)
		 	try expression(0)
		 	setState(4846)
		 	try match(MySqlParser.Tokens.DO.rawValue)
		 	setState(4848); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4847)
		 			try procedureSqlStatement()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4850); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,704,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)
		 	setState(4852)
		 	try match(MySqlParser.Tokens.END.rawValue)
		 	setState(4853)
		 	try match(MySqlParser.Tokens.WHILE.rawValue)
		 	setState(4855)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756891332513122304) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055071174737) != 0) || ((Int64((_la - 140)) & ~0x3f) == 0 && ((Int64(1) << (_la - 140)) & 268698883) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17174494689) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & -1099511627777) != 0) || ((Int64((_la - 345)) & ~0x3f) == 0 && ((Int64(1) << (_la - 345)) & -2882305960540372993) != 0) || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & -4398063288321) != 0) || ((Int64((_la - 473)) & ~0x3f) == 0 && ((Int64(1) << (_la - 473)) & -16325548649218049) != 0) || ((Int64((_la - 537)) & ~0x3f) == 0 && ((Int64(1) << (_la - 537)) & -9007199258936065) != 0) || ((Int64((_la - 601)) & ~0x3f) == 0 && ((Int64(1) << (_la - 601)) & -68719476801) != 0) || ((Int64((_la - 665)) & ~0x3f) == 0 && ((Int64(1) << (_la - 665)) & -22236531750340609) != 0) || ((Int64((_la - 729)) & ~0x3f) == 0 && ((Int64(1) << (_la - 729)) & -65) != 0) || ((Int64((_la - 793)) & ~0x3f) == 0 && ((Int64(1) << (_la - 793)) & -6145) != 0) || ((Int64((_la - 857)) & ~0x3f) == 0 && ((Int64(1) << (_la - 857)) & -1) != 0) || ((Int64((_la - 921)) & ~0x3f) == 0 && ((Int64(1) << (_la - 921)) & -1) != 0) || ((Int64((_la - 985)) & ~0x3f) == 0 && ((Int64(1) << (_la - 985)) & -1) != 0) || ((Int64((_la - 1049)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1049)) & 576460752303423487) != 0) || ((Int64((_la - 1123)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1123)) & 8627683329) != 0)) {
		 		setState(4854)
		 		try uid()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CursorStatementContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_cursorStatement
		}
	}
	public class CloseCursorContext: CursorStatementContext {
			open
			func CLOSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CLOSE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}

		public
		init(_ ctx: CursorStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCloseCursor(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCloseCursor(self)
			}
		}
	}
	public class OpenCursorContext: CursorStatementContext {
			open
			func OPEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPEN.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}

		public
		init(_ ctx: CursorStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterOpenCursor(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitOpenCursor(self)
			}
		}
	}
	public class FetchCursorContext: CursorStatementContext {
			open
			func FETCH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FETCH.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func INTO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTO.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func NEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NEXT.rawValue, 0)
			}

		public
		init(_ ctx: CursorStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFetchCursor(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFetchCursor(self)
			}
		}
	}
	@discardableResult
	 open func cursorStatement() throws -> CursorStatementContext {
		var _localctx: CursorStatementContext
		_localctx = CursorStatementContext(_ctx, getState())
		try enterRule(_localctx, 408, MySqlParser.RULE_cursorStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4872)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CLOSE:
		 		_localctx =  CloseCursorContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4857)
		 		try match(MySqlParser.Tokens.CLOSE.rawValue)
		 		setState(4858)
		 		try uid()

		 		break

		 	case .FETCH:
		 		_localctx =  FetchCursorContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4859)
		 		try match(MySqlParser.Tokens.FETCH.rawValue)
		 		setState(4864)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,707,_ctx)) {
		 		case 1:
		 			setState(4861)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.NEXT.rawValue) {
		 				setState(4860)
		 				try match(MySqlParser.Tokens.NEXT.rawValue)

		 			}

		 			setState(4863)
		 			try match(MySqlParser.Tokens.FROM.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(4866)
		 		try uid()
		 		setState(4867)
		 		try match(MySqlParser.Tokens.INTO.rawValue)
		 		setState(4868)
		 		try uidList()

		 		break

		 	case .OPEN:
		 		_localctx =  OpenCursorContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4870)
		 		try match(MySqlParser.Tokens.OPEN.rawValue)
		 		setState(4871)
		 		try uid()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DeclareVariableContext: ParserRuleContext {
			open
			func DECLARE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DECLARE.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func dataType() -> DataTypeContext? {
				return getRuleContext(DataTypeContext.self, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_declareVariable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDeclareVariable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDeclareVariable(self)
			}
		}
	}
	@discardableResult
	 open func declareVariable() throws -> DeclareVariableContext {
		var _localctx: DeclareVariableContext
		_localctx = DeclareVariableContext(_ctx, getState())
		try enterRule(_localctx, 410, MySqlParser.RULE_declareVariable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4874)
		 	try match(MySqlParser.Tokens.DECLARE.rawValue)
		 	setState(4875)
		 	try uidList()
		 	setState(4876)
		 	try dataType()
		 	setState(4879)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.DEFAULT.rawValue) {
		 		setState(4877)
		 		try match(MySqlParser.Tokens.DEFAULT.rawValue)
		 		setState(4878)
		 		try expression(0)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DeclareConditionContext: ParserRuleContext {
			open
			func DECLARE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DECLARE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func CONDITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONDITION.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func SQLSTATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQLSTATE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_declareCondition
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDeclareCondition(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDeclareCondition(self)
			}
		}
	}
	@discardableResult
	 open func declareCondition() throws -> DeclareConditionContext {
		var _localctx: DeclareConditionContext
		_localctx = DeclareConditionContext(_ctx, getState())
		try enterRule(_localctx, 412, MySqlParser.RULE_declareCondition)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4881)
		 	try match(MySqlParser.Tokens.DECLARE.rawValue)
		 	setState(4882)
		 	try uid()
		 	setState(4883)
		 	try match(MySqlParser.Tokens.CONDITION.rawValue)
		 	setState(4884)
		 	try match(MySqlParser.Tokens.FOR.rawValue)
		 	setState(4891)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ZERO_DECIMAL:fallthrough
		 	case .ONE_DECIMAL:fallthrough
		 	case .TWO_DECIMAL:fallthrough
		 	case .DECIMAL_LITERAL:fallthrough
		 	case .REAL_LITERAL:
		 		setState(4885)
		 		try decimalLiteral()

		 		break

		 	case .SQLSTATE:
		 		setState(4886)
		 		try match(MySqlParser.Tokens.SQLSTATE.rawValue)
		 		setState(4888)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.VALUE.rawValue) {
		 			setState(4887)
		 			try match(MySqlParser.Tokens.VALUE.rawValue)

		 		}

		 		setState(4890)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DeclareCursorContext: ParserRuleContext {
			open
			func DECLARE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DECLARE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func CURSOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURSOR.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_declareCursor
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDeclareCursor(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDeclareCursor(self)
			}
		}
	}
	@discardableResult
	 open func declareCursor() throws -> DeclareCursorContext {
		var _localctx: DeclareCursorContext
		_localctx = DeclareCursorContext(_ctx, getState())
		try enterRule(_localctx, 414, MySqlParser.RULE_declareCursor)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4893)
		 	try match(MySqlParser.Tokens.DECLARE.rawValue)
		 	setState(4894)
		 	try uid()
		 	setState(4895)
		 	try match(MySqlParser.Tokens.CURSOR.rawValue)
		 	setState(4896)
		 	try match(MySqlParser.Tokens.FOR.rawValue)
		 	setState(4897)
		 	try selectStatement()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DeclareHandlerContext: ParserRuleContext {
		open var handlerAction: Token!
			open
			func DECLARE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DECLARE.rawValue, 0)
			}
			open
			func HANDLER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HANDLER.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func handlerConditionValue() -> [HandlerConditionValueContext] {
				return getRuleContexts(HandlerConditionValueContext.self)
			}
			open
			func handlerConditionValue(_ i: Int) -> HandlerConditionValueContext? {
				return getRuleContext(HandlerConditionValueContext.self, i)
			}
			open
			func routineBody() -> RoutineBodyContext? {
				return getRuleContext(RoutineBodyContext.self, 0)
			}
			open
			func CONTINUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONTINUE.rawValue, 0)
			}
			open
			func EXIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXIT.rawValue, 0)
			}
			open
			func UNDO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNDO.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_declareHandler
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDeclareHandler(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDeclareHandler(self)
			}
		}
	}
	@discardableResult
	 open func declareHandler() throws -> DeclareHandlerContext {
		var _localctx: DeclareHandlerContext
		_localctx = DeclareHandlerContext(_ctx, getState())
		try enterRule(_localctx, 416, MySqlParser.RULE_declareHandler)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4899)
		 	try match(MySqlParser.Tokens.DECLARE.rawValue)
		 	setState(4900)
		 	_localctx.castdown(DeclareHandlerContext.self).handlerAction = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.CONTINUE.rawValue || _la == MySqlParser.Tokens.EXIT.rawValue || _la == MySqlParser.Tokens.UNDO.rawValue)) {
		 		_localctx.castdown(DeclareHandlerContext.self).handlerAction = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(4901)
		 	try match(MySqlParser.Tokens.HANDLER.rawValue)
		 	setState(4902)
		 	try match(MySqlParser.Tokens.FOR.rawValue)
		 	setState(4903)
		 	try handlerConditionValue()
		 	setState(4908)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(4904)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(4905)
		 		try handlerConditionValue()


		 		setState(4910)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(4911)
		 	try routineBody()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HandlerConditionValueContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_handlerConditionValue
		}
	}
	public class HandlerConditionWarningContext: HandlerConditionValueContext {
			open
			func SQLWARNING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQLWARNING.rawValue, 0)
			}

		public
		init(_ ctx: HandlerConditionValueContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHandlerConditionWarning(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHandlerConditionWarning(self)
			}
		}
	}
	public class HandlerConditionCodeContext: HandlerConditionValueContext {
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}

		public
		init(_ ctx: HandlerConditionValueContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHandlerConditionCode(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHandlerConditionCode(self)
			}
		}
	}
	public class HandlerConditionNotfoundContext: HandlerConditionValueContext {
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
			open
			func FOUND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOUND.rawValue, 0)
			}

		public
		init(_ ctx: HandlerConditionValueContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHandlerConditionNotfound(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHandlerConditionNotfound(self)
			}
		}
	}
	public class HandlerConditionStateContext: HandlerConditionValueContext {
			open
			func SQLSTATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQLSTATE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUE.rawValue, 0)
			}

		public
		init(_ ctx: HandlerConditionValueContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHandlerConditionState(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHandlerConditionState(self)
			}
		}
	}
	public class HandlerConditionExceptionContext: HandlerConditionValueContext {
			open
			func SQLEXCEPTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQLEXCEPTION.rawValue, 0)
			}

		public
		init(_ ctx: HandlerConditionValueContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHandlerConditionException(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHandlerConditionException(self)
			}
		}
	}
	public class HandlerConditionNameContext: HandlerConditionValueContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}

		public
		init(_ ctx: HandlerConditionValueContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHandlerConditionName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHandlerConditionName(self)
			}
		}
	}
	@discardableResult
	 open func handlerConditionValue() throws -> HandlerConditionValueContext {
		var _localctx: HandlerConditionValueContext
		_localctx = HandlerConditionValueContext(_ctx, getState())
		try enterRule(_localctx, 418, MySqlParser.RULE_handlerConditionValue)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(4924)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ZERO_DECIMAL:fallthrough
		 	case .ONE_DECIMAL:fallthrough
		 	case .TWO_DECIMAL:fallthrough
		 	case .DECIMAL_LITERAL:fallthrough
		 	case .REAL_LITERAL:
		 		_localctx =  HandlerConditionCodeContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4913)
		 		try decimalLiteral()

		 		break

		 	case .SQLSTATE:
		 		_localctx =  HandlerConditionStateContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4914)
		 		try match(MySqlParser.Tokens.SQLSTATE.rawValue)
		 		setState(4916)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.VALUE.rawValue) {
		 			setState(4915)
		 			try match(MySqlParser.Tokens.VALUE.rawValue)

		 		}

		 		setState(4918)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case .ARRAY:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .BUCKETS:fallthrough
		 	case .CONDITION:fallthrough
		 	case .CURRENT:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DIAGNOSTICS:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENFORCED:fallthrough
		 	case .EXCEPT:fallthrough
		 	case .GROUP:fallthrough
		 	case .IF:fallthrough
		 	case .IGNORED:fallthrough
		 	case .INSERT:fallthrough
		 	case .LATERAL:fallthrough
		 	case .LEFT:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OPTIONAL:fallthrough
		 	case .ORDER:fallthrough
		 	case .PRIMARY:fallthrough
		 	case .REPEAT:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SKIP_QUERY_REWRITE:fallthrough
		 	case .STACKED:fallthrough
		 	case .DATE:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .DATETIME:fallthrough
		 	case .YEAR:fallthrough
		 	case .BINARY:fallthrough
		 	case .TEXT:fallthrough
		 	case .ENUM:fallthrough
		 	case .SERIAL:fallthrough
		 	case .JSON_ARRAY:fallthrough
		 	case .JSON_ARRAYAGG:fallthrough
		 	case .JSON_ARRAY_APPEND:fallthrough
		 	case .JSON_ARRAY_INSERT:fallthrough
		 	case .JSON_CONTAINS:fallthrough
		 	case .JSON_CONTAINS_PATH:fallthrough
		 	case .JSON_DEPTH:fallthrough
		 	case .JSON_EXTRACT:fallthrough
		 	case .JSON_INSERT:fallthrough
		 	case .JSON_KEYS:fallthrough
		 	case .JSON_LENGTH:fallthrough
		 	case .JSON_MERGE:fallthrough
		 	case .JSON_MERGE_PATCH:fallthrough
		 	case .JSON_MERGE_PRESERVE:fallthrough
		 	case .JSON_OBJECT:fallthrough
		 	case .JSON_OBJECTAGG:fallthrough
		 	case .JSON_OVERLAPS:fallthrough
		 	case .JSON_PRETTY:fallthrough
		 	case .JSON_QUOTE:fallthrough
		 	case .JSON_REMOVE:fallthrough
		 	case .JSON_REPLACE:fallthrough
		 	case .JSON_SCHEMA_VALID:fallthrough
		 	case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 	case .JSON_SEARCH:fallthrough
		 	case .JSON_SET:fallthrough
		 	case .JSON_STORAGE_FREE:fallthrough
		 	case .JSON_STORAGE_SIZE:fallthrough
		 	case .JSON_TABLE:fallthrough
		 	case .JSON_TYPE:fallthrough
		 	case .JSON_UNQUOTE:fallthrough
		 	case .JSON_VALID:fallthrough
		 	case .JSON_VALUE:fallthrough
		 	case .NESTED:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .PATH:fallthrough
		 	case .AVG:fallthrough
		 	case .BIT_AND:fallthrough
		 	case .BIT_OR:fallthrough
		 	case .BIT_XOR:fallthrough
		 	case .COUNT:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .GROUP_CONCAT:fallthrough
		 	case .LAG:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NTH_VALUE:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .STD:fallthrough
		 	case .STDDEV:fallthrough
		 	case .STDDEV_POP:fallthrough
		 	case .STDDEV_SAMP:fallthrough
		 	case .SUM:fallthrough
		 	case .VAR_POP:fallthrough
		 	case .VAR_SAMP:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .CURRENT_DATE:fallthrough
		 	case .CURRENT_TIME:fallthrough
		 	case .CURRENT_TIMESTAMP:fallthrough
		 	case .LOCALTIME:fallthrough
		 	case .CURDATE:fallthrough
		 	case .CURTIME:fallthrough
		 	case .DATE_ADD:fallthrough
		 	case .DATE_SUB:fallthrough
		 	case .LOCALTIMESTAMP:fallthrough
		 	case .NOW:fallthrough
		 	case .POSITION:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .SUBSTRING:fallthrough
		 	case .SYSDATE:fallthrough
		 	case .TRIM:fallthrough
		 	case .UTC_DATE:fallthrough
		 	case .UTC_TIME:fallthrough
		 	case .UTC_TIMESTAMP:fallthrough
		 	case .ACCOUNT:fallthrough
		 	case .ACTION:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALGORITHM:fallthrough
		 	case .ANY:fallthrough
		 	case .AT:fallthrough
		 	case .AUTHORS:fallthrough
		 	case .AUTOCOMMIT:fallthrough
		 	case .AUTOEXTEND_SIZE:fallthrough
		 	case .AUTO_INCREMENT:fallthrough
		 	case .AVG_ROW_LENGTH:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BINLOG:fallthrough
		 	case .BIT:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BOOL:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BTREE:fallthrough
		 	case .CACHE:fallthrough
		 	case .CASCADED:fallthrough
		 	case .CHAIN:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CHECKSUM:fallthrough
		 	case .PAGE_CHECKSUM:fallthrough
		 	case .CIPHER:fallthrough
		 	case .CLASS_ORIGIN:fallthrough
		 	case .CLIENT:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTERING:fallthrough
		 	case .COALESCE:fallthrough
		 	case .CODE:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COLUMN_FORMAT:fallthrough
		 	case .COLUMN_NAME:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMPACT:fallthrough
		 	case .COMPLETION:fallthrough
		 	case .COMPRESSED:fallthrough
		 	case .COMPRESSION:fallthrough
		 	case .CONCURRENT:fallthrough
		 	case .CONNECT:fallthrough
		 	case .CONNECTION:fallthrough
		 	case .CONSISTENT:fallthrough
		 	case .CONSTRAINT_CATALOG:fallthrough
		 	case .CONSTRAINT_SCHEMA:fallthrough
		 	case .CONSTRAINT_NAME:fallthrough
		 	case .CONTAINS:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTRIBUTORS:fallthrough
		 	case .COPY:fallthrough
		 	case .CPU:fallthrough
		 	case .CURSOR_NAME:fallthrough
		 	case .DATA:fallthrough
		 	case .DATAFILE:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DEFAULT_AUTH:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DELAY_KEY_WRITE:fallthrough
		 	case .DES_KEY_FILE:fallthrough
		 	case .DIRECTORY:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISCARD:fallthrough
		 	case .DISK:fallthrough
		 	case .DO:fallthrough
		 	case .DUMPFILE:fallthrough
		 	case .DUPLICATE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .END:fallthrough
		 	case .ENDS:fallthrough
		 	case .ENGINE:fallthrough
		 	case .ENGINES:fallthrough
		 	case .ERROR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVEN:fallthrough
		 	case .EVENT:fallthrough
		 	case .EVENTS:fallthrough
		 	case .EVERY:fallthrough
		 	case .EXCHANGE:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPIRE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .EXTENT_SIZE:fallthrough
		 	case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 	case .FAST:fallthrough
		 	case .FAULTS:fallthrough
		 	case .FIELDS:fallthrough
		 	case .FILE_BLOCK_SIZE:fallthrough
		 	case .FILTER:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIXED:fallthrough
		 	case .FLUSH:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FOUND:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GENERAL:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GRANTS:fallthrough
		 	case .GROUP_REPLICATION:fallthrough
		 	case .HANDLER:fallthrough
		 	case .HASH:fallthrough
		 	case .HELP:fallthrough
		 	case .HISTORY:fallthrough
		 	case .HOST:fallthrough
		 	case .HOSTS:fallthrough
		 	case .IDENTIFIED:fallthrough
		 	case .IGNORE_SERVER_IDS:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INDEXES:fallthrough
		 	case .INITIAL_SIZE:fallthrough
		 	case .INPLACE:fallthrough
		 	case .INSERT_METHOD:fallthrough
		 	case .INSTALL:fallthrough
		 	case .INSTANCE:fallthrough
		 	case .INSTANT:fallthrough
		 	case .INVISIBLE:fallthrough
		 	case .INVOKER:fallthrough
		 	case .IO:fallthrough
		 	case .IO_THREAD:fallthrough
		 	case .IPC:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ISSUER:fallthrough
		 	case .JSON:fallthrough
		 	case .KEY_BLOCK_SIZE:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LEAVES:fallthrough
		 	case .LESS:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOGFILE:fallthrough
		 	case .LOGS:fallthrough
		 	case .MASTER:fallthrough
		 	case .MASTER_AUTO_POSITION:fallthrough
		 	case .MASTER_CONNECT_RETRY:fallthrough
		 	case .MASTER_DELAY:fallthrough
		 	case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 	case .MASTER_HOST:fallthrough
		 	case .MASTER_LOG_FILE:fallthrough
		 	case .MASTER_LOG_POS:fallthrough
		 	case .MASTER_PASSWORD:fallthrough
		 	case .MASTER_PORT:fallthrough
		 	case .MASTER_RETRY_COUNT:fallthrough
		 	case .MASTER_SSL:fallthrough
		 	case .MASTER_SSL_CA:fallthrough
		 	case .MASTER_SSL_CAPATH:fallthrough
		 	case .MASTER_SSL_CERT:fallthrough
		 	case .MASTER_SSL_CIPHER:fallthrough
		 	case .MASTER_SSL_CRL:fallthrough
		 	case .MASTER_SSL_CRLPATH:fallthrough
		 	case .MASTER_SSL_KEY:fallthrough
		 	case .MASTER_TLS_VERSION:fallthrough
		 	case .MASTER_USER:fallthrough
		 	case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 	case .MAX_QUERIES_PER_HOUR:fallthrough
		 	case .MAX_ROWS:fallthrough
		 	case .MAX_SIZE:fallthrough
		 	case .MAX_UPDATES_PER_HOUR:fallthrough
		 	case .MAX_USER_CONNECTIONS:fallthrough
		 	case .MEDIUM:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MESSAGE_TEXT:fallthrough
		 	case .MID:fallthrough
		 	case .MIGRATE:fallthrough
		 	case .MIN_ROWS:fallthrough
		 	case .MODE:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MUTEX:fallthrough
		 	case .MYSQL:fallthrough
		 	case .MYSQL_ERRNO:fallthrough
		 	case .NAME:fallthrough
		 	case .NAMES:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NEVER:fallthrough
		 	case .NEXT:fallthrough
		 	case .NO:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOWAIT:fallthrough
		 	case .NODEGROUP:fallthrough
		 	case .NONE:fallthrough
		 	case .ODBC:fallthrough
		 	case .OFFLINE:fallthrough
		 	case .OFFSET:fallthrough
		 	case .OF:fallthrough
		 	case .OJ:fallthrough
		 	case .OLD_PASSWORD:fallthrough
		 	case .ONE:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .OPTIMIZER_COSTS:fallthrough
		 	case .OPTIONS:fallthrough
		 	case .OWNER:fallthrough
		 	case .PACK_KEYS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PARSER:fallthrough
		 	case .PARTIAL:fallthrough
		 	case .PARTITIONING:fallthrough
		 	case .PARTITIONS:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PASSWORD_LOCK_TIME:fallthrough
		 	case .PHASE:fallthrough
		 	case .PLUGIN:fallthrough
		 	case .PLUGIN_DIR:fallthrough
		 	case .PLUGINS:fallthrough
		 	case .PORT:fallthrough
		 	case .PRECEDES:fallthrough
		 	case .PREPARE:fallthrough
		 	case .PRESERVE:fallthrough
		 	case .PREV:fallthrough
		 	case .PROCESSLIST:fallthrough
		 	case .PROFILE:fallthrough
		 	case .PROFILES:fallthrough
		 	case .PROXY:fallthrough
		 	case .QUERY:fallthrough
		 	case .QUICK:fallthrough
		 	case .REBUILD:fallthrough
		 	case .RECOVER:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REDO_BUFFER_SIZE:fallthrough
		 	case .REDUNDANT:fallthrough
		 	case .RELAY:fallthrough
		 	case .RELAY_LOG_FILE:fallthrough
		 	case .RELAY_LOG_POS:fallthrough
		 	case .RELAYLOG:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REORGANIZE:fallthrough
		 	case .REPAIR:fallthrough
		 	case .REPLICATE_DO_DB:fallthrough
		 	case .REPLICATE_DO_TABLE:fallthrough
		 	case .REPLICATE_IGNORE_DB:fallthrough
		 	case .REPLICATE_IGNORE_TABLE:fallthrough
		 	case .REPLICATE_REWRITE_DB:fallthrough
		 	case .REPLICATE_WILD_DO_TABLE:fallthrough
		 	case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 	case .REPLICATION:fallthrough
		 	case .RESET:fallthrough
		 	case .RESUME:fallthrough
		 	case .RETURNED_SQLSTATE:fallthrough
		 	case .RETURNING:fallthrough
		 	case .RETURNS:fallthrough
		 	case .REUSE:fallthrough
		 	case .ROLE:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROTATE:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_FORMAT:fallthrough
		 	case .RTREE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEDULE:fallthrough
		 	case .SECURITY:fallthrough
		 	case .SERVER:fallthrough
		 	case .SESSION:fallthrough
		 	case .SHARE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SIGNED:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SLAVE:fallthrough
		 	case .SLOW:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOCKET:fallthrough
		 	case .SOME:fallthrough
		 	case .SONAME:fallthrough
		 	case .SOUNDS:fallthrough
		 	case .SOURCE:fallthrough
		 	case .SQL_AFTER_GTIDS:fallthrough
		 	case .SQL_AFTER_MTS_GAPS:fallthrough
		 	case .SQL_BEFORE_GTIDS:fallthrough
		 	case .SQL_BUFFER_RESULT:fallthrough
		 	case .SQL_CACHE:fallthrough
		 	case .SQL_NO_CACHE:fallthrough
		 	case .SQL_THREAD:fallthrough
		 	case .START:fallthrough
		 	case .STARTS:fallthrough
		 	case .STATS_AUTO_RECALC:fallthrough
		 	case .STATS_PERSISTENT:fallthrough
		 	case .STATS_SAMPLE_PAGES:fallthrough
		 	case .STATUS:fallthrough
		 	case .STOP:fallthrough
		 	case .STORAGE:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBCLASS_ORIGIN:fallthrough
		 	case .SUBJECT:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBPARTITIONS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .SWAPS:fallthrough
		 	case .SWITCHES:fallthrough
		 	case .TABLE_NAME:fallthrough
		 	case .TABLESPACE:fallthrough
		 	case .TABLE_TYPE:fallthrough
		 	case .TEMPORARY:fallthrough
		 	case .TEMPTABLE:fallthrough
		 	case .THAN:fallthrough
		 	case .TRADITIONAL:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSACTIONAL:fallthrough
		 	case .TRIGGERS:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDEFINED:fallthrough
		 	case .UNDOFILE:fallthrough
		 	case .UNDO_BUFFER_SIZE:fallthrough
		 	case .UNINSTALL:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPGRADE:fallthrough
		 	case .USER:fallthrough
		 	case .USE_FRM:fallthrough
		 	case .USER_RESOURCES:fallthrough
		 	case .VALIDATION:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARIABLES:fallthrough
		 	case .VIEW:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .VISIBLE:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNINGS:fallthrough
		 	case .WITHOUT:fallthrough
		 	case .WORK:fallthrough
		 	case .WRAPPER:fallthrough
		 	case .X509:fallthrough
		 	case .XA:fallthrough
		 	case .XML:fallthrough
		 	case .EUR:fallthrough
		 	case .USA:fallthrough
		 	case .JIS:fallthrough
		 	case .ISO:fallthrough
		 	case .INTERNAL:fallthrough
		 	case .QUARTER:fallthrough
		 	case .MONTH:fallthrough
		 	case .DAY:fallthrough
		 	case .HOUR:fallthrough
		 	case .MINUTE:fallthrough
		 	case .WEEK:fallthrough
		 	case .SECOND:fallthrough
		 	case .MICROSECOND:fallthrough
		 	case .ADMIN:fallthrough
		 	case .AUDIT_ABORT_EXEMPT:fallthrough
		 	case .AUDIT_ADMIN:fallthrough
		 	case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 	case .BACKUP_ADMIN:fallthrough
		 	case .BINLOG_ADMIN:fallthrough
		 	case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 	case .CLONE_ADMIN:fallthrough
		 	case .CONNECTION_ADMIN:fallthrough
		 	case .ENCRYPTION_KEY_ADMIN:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .FILE:fallthrough
		 	case .FIREWALL_ADMIN:fallthrough
		 	case .FIREWALL_EXEMPT:fallthrough
		 	case .FIREWALL_USER:fallthrough
		 	case .GROUP_REPLICATION_ADMIN:fallthrough
		 	case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 	case .INVOKE:fallthrough
		 	case .LAMBDA:fallthrough
		 	case .NDB_STORED_USER:fallthrough
		 	case .PASSWORDLESS_USER_ADMIN:fallthrough
		 	case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .PROCESS:fallthrough
		 	case .RELOAD:fallthrough
		 	case .REPLICATION_APPLIER:fallthrough
		 	case .REPLICATION_SLAVE_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_USER:fallthrough
		 	case .ROLE_ADMIN:fallthrough
		 	case .ROUTINE:fallthrough
		 	case .S3:fallthrough
		 	case .SESSION_VARIABLES_ADMIN:fallthrough
		 	case .SET_USER_ID:fallthrough
		 	case .SHOW_ROUTINE:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SUPER:fallthrough
		 	case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 	case .TABLES:fallthrough
		 	case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 	case .VERSION_TOKEN_ADMIN:fallthrough
		 	case .XA_RECOVER_ADMIN:fallthrough
		 	case .ARMSCII8:fallthrough
		 	case .ASCII:fallthrough
		 	case .BIG5:fallthrough
		 	case .CP1250:fallthrough
		 	case .CP1251:fallthrough
		 	case .CP1256:fallthrough
		 	case .CP1257:fallthrough
		 	case .CP850:fallthrough
		 	case .CP852:fallthrough
		 	case .CP866:fallthrough
		 	case .CP932:fallthrough
		 	case .DEC8:fallthrough
		 	case .EUCJPMS:fallthrough
		 	case .EUCKR:fallthrough
		 	case .GB18030:fallthrough
		 	case .GB2312:fallthrough
		 	case .GBK:fallthrough
		 	case .GEOSTD8:fallthrough
		 	case .GREEK:fallthrough
		 	case .HEBREW:fallthrough
		 	case .HP8:fallthrough
		 	case .KEYBCS2:fallthrough
		 	case .KOI8R:fallthrough
		 	case .KOI8U:fallthrough
		 	case .LATIN1:fallthrough
		 	case .LATIN2:fallthrough
		 	case .LATIN5:fallthrough
		 	case .LATIN7:fallthrough
		 	case .MACCE:fallthrough
		 	case .MACROMAN:fallthrough
		 	case .SJIS:fallthrough
		 	case .SWE7:fallthrough
		 	case .TIS620:fallthrough
		 	case .UCS2:fallthrough
		 	case .UJIS:fallthrough
		 	case .UTF16:fallthrough
		 	case .UTF16LE:fallthrough
		 	case .UTF32:fallthrough
		 	case .UTF8:fallthrough
		 	case .UTF8MB3:fallthrough
		 	case .UTF8MB4:fallthrough
		 	case .ARCHIVE:fallthrough
		 	case .BLACKHOLE:fallthrough
		 	case .CSV:fallthrough
		 	case .FEDERATED:fallthrough
		 	case .INNODB:fallthrough
		 	case .MEMORY:fallthrough
		 	case .MRG_MYISAM:fallthrough
		 	case .MYISAM:fallthrough
		 	case .NDB:fallthrough
		 	case .NDBCLUSTER:fallthrough
		 	case .PERFORMANCE_SCHEMA:fallthrough
		 	case .TOKUDB:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .GEOMETRYCOLLECTION:fallthrough
		 	case .LINESTRING:fallthrough
		 	case .MULTILINESTRING:fallthrough
		 	case .MULTIPOINT:fallthrough
		 	case .MULTIPOLYGON:fallthrough
		 	case .POINT:fallthrough
		 	case .POLYGON:fallthrough
		 	case .ABS:fallthrough
		 	case .ACOS:fallthrough
		 	case .ADDDATE:fallthrough
		 	case .ADDTIME:fallthrough
		 	case .AES_DECRYPT:fallthrough
		 	case .AES_ENCRYPT:fallthrough
		 	case .AREA:fallthrough
		 	case .ASBINARY:fallthrough
		 	case .ASIN:fallthrough
		 	case .ASTEXT:fallthrough
		 	case .ASWKB:fallthrough
		 	case .ASWKT:fallthrough
		 	case .ASYMMETRIC_DECRYPT:fallthrough
		 	case .ASYMMETRIC_DERIVE:fallthrough
		 	case .ASYMMETRIC_ENCRYPT:fallthrough
		 	case .ASYMMETRIC_SIGN:fallthrough
		 	case .ASYMMETRIC_VERIFY:fallthrough
		 	case .ATAN:fallthrough
		 	case .ATAN2:fallthrough
		 	case .BENCHMARK:fallthrough
		 	case .BIN:fallthrough
		 	case .BIT_COUNT:fallthrough
		 	case .BIT_LENGTH:fallthrough
		 	case .BUFFER:fallthrough
		 	case .CATALOG_NAME:fallthrough
		 	case .CEIL:fallthrough
		 	case .CEILING:fallthrough
		 	case .CENTROID:fallthrough
		 	case .CHARACTER_LENGTH:fallthrough
		 	case .CHARSET:fallthrough
		 	case .CHAR_LENGTH:fallthrough
		 	case .COERCIBILITY:fallthrough
		 	case .COLLATION:fallthrough
		 	case .COMPRESS:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_WS:fallthrough
		 	case .CONNECTION_ID:fallthrough
		 	case .CONV:fallthrough
		 	case .CONVERT_TZ:fallthrough
		 	case .COS:fallthrough
		 	case .COT:fallthrough
		 	case .CRC32:fallthrough
		 	case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 	case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 	case .CREATE_DH_PARAMETERS:fallthrough
		 	case .CREATE_DIGEST:fallthrough
		 	case .CROSSES:fallthrough
		 	case .DATEDIFF:fallthrough
		 	case .DATE_FORMAT:fallthrough
		 	case .DAYNAME:fallthrough
		 	case .DAYOFMONTH:fallthrough
		 	case .DAYOFWEEK:fallthrough
		 	case .DAYOFYEAR:fallthrough
		 	case .DECODE:fallthrough
		 	case .DEGREES:fallthrough
		 	case .DES_DECRYPT:fallthrough
		 	case .DES_ENCRYPT:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISJOINT:fallthrough
		 	case .ELT:fallthrough
		 	case .ENCODE:fallthrough
		 	case .ENCRYPT:fallthrough
		 	case .ENDPOINT:fallthrough
		 	case .ENGINE_ATTRIBUTE:fallthrough
		 	case .ENVELOPE:fallthrough
		 	case .EQUALS:fallthrough
		 	case .EXP:fallthrough
		 	case .EXPORT_SET:fallthrough
		 	case .EXTERIORRING:fallthrough
		 	case .EXTRACTVALUE:fallthrough
		 	case .FIELD:fallthrough
		 	case .FIND_IN_SET:fallthrough
		 	case .FLOOR:fallthrough
		 	case .FORMAT:fallthrough
		 	case .FOUND_ROWS:fallthrough
		 	case .FROM_BASE64:fallthrough
		 	case .FROM_DAYS:fallthrough
		 	case .FROM_UNIXTIME:fallthrough
		 	case .GEOMCOLLFROMTEXT:fallthrough
		 	case .GEOMCOLLFROMWKB:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .GEOMETRYFROMTEXT:fallthrough
		 	case .GEOMETRYFROMWKB:fallthrough
		 	case .GEOMETRYN:fallthrough
		 	case .GEOMETRYTYPE:fallthrough
		 	case .GEOMFROMTEXT:fallthrough
		 	case .GEOMFROMWKB:fallthrough
		 	case .GET_FORMAT:fallthrough
		 	case .GET_LOCK:fallthrough
		 	case .GLENGTH:fallthrough
		 	case .GREATEST:fallthrough
		 	case .GTID_SUBSET:fallthrough
		 	case .GTID_SUBTRACT:fallthrough
		 	case .HEX:fallthrough
		 	case .IFNULL:fallthrough
		 	case .INET6_ATON:fallthrough
		 	case .INET6_NTOA:fallthrough
		 	case .INET_ATON:fallthrough
		 	case .INET_NTOA:fallthrough
		 	case .INSTR:fallthrough
		 	case .INTERIORRINGN:fallthrough
		 	case .INTERSECTS:fallthrough
		 	case .ISCLOSED:fallthrough
		 	case .ISEMPTY:fallthrough
		 	case .ISNULL:fallthrough
		 	case .ISSIMPLE:fallthrough
		 	case .IS_FREE_LOCK:fallthrough
		 	case .IS_IPV4:fallthrough
		 	case .IS_IPV4_COMPAT:fallthrough
		 	case .IS_IPV4_MAPPED:fallthrough
		 	case .IS_IPV6:fallthrough
		 	case .IS_USED_LOCK:fallthrough
		 	case .LAST_INSERT_ID:fallthrough
		 	case .LCASE:fallthrough
		 	case .LEAST:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LINEFROMTEXT:fallthrough
		 	case .LINEFROMWKB:fallthrough
		 	case .LINESTRINGFROMTEXT:fallthrough
		 	case .LINESTRINGFROMWKB:fallthrough
		 	case .LN:fallthrough
		 	case .LOAD_FILE:fallthrough
		 	case .LOCATE:fallthrough
		 	case .LOG:fallthrough
		 	case .LOG10:fallthrough
		 	case .LOG2:fallthrough
		 	case .LOWER:fallthrough
		 	case .LPAD:fallthrough
		 	case .LTRIM:fallthrough
		 	case .MAKEDATE:fallthrough
		 	case .MAKETIME:fallthrough
		 	case .MAKE_SET:fallthrough
		 	case .MASTER_POS_WAIT:fallthrough
		 	case .MBRCONTAINS:fallthrough
		 	case .MBRDISJOINT:fallthrough
		 	case .MBREQUAL:fallthrough
		 	case .MBRINTERSECTS:fallthrough
		 	case .MBROVERLAPS:fallthrough
		 	case .MBRTOUCHES:fallthrough
		 	case .MBRWITHIN:fallthrough
		 	case .MD5:fallthrough
		 	case .MLINEFROMTEXT:fallthrough
		 	case .MLINEFROMWKB:fallthrough
		 	case .MONTHNAME:fallthrough
		 	case .MPOINTFROMTEXT:fallthrough
		 	case .MPOINTFROMWKB:fallthrough
		 	case .MPOLYFROMTEXT:fallthrough
		 	case .MPOLYFROMWKB:fallthrough
		 	case .MULTILINESTRINGFROMTEXT:fallthrough
		 	case .MULTILINESTRINGFROMWKB:fallthrough
		 	case .MULTIPOINTFROMTEXT:fallthrough
		 	case .MULTIPOINTFROMWKB:fallthrough
		 	case .MULTIPOLYGONFROMTEXT:fallthrough
		 	case .MULTIPOLYGONFROMWKB:fallthrough
		 	case .NAME_CONST:fallthrough
		 	case .NULLIF:fallthrough
		 	case .NUMGEOMETRIES:fallthrough
		 	case .NUMINTERIORRINGS:fallthrough
		 	case .NUMPOINTS:fallthrough
		 	case .OCT:fallthrough
		 	case .OCTET_LENGTH:fallthrough
		 	case .ORD:fallthrough
		 	case .OVERLAPS:fallthrough
		 	case .PERIOD_ADD:fallthrough
		 	case .PERIOD_DIFF:fallthrough
		 	case .PI:fallthrough
		 	case .POINTFROMTEXT:fallthrough
		 	case .POINTFROMWKB:fallthrough
		 	case .POINTN:fallthrough
		 	case .POLYFROMTEXT:fallthrough
		 	case .POLYFROMWKB:fallthrough
		 	case .POLYGONFROMTEXT:fallthrough
		 	case .POLYGONFROMWKB:fallthrough
		 	case .POW:fallthrough
		 	case .POWER:fallthrough
		 	case .QUOTE:fallthrough
		 	case .RADIANS:fallthrough
		 	case .RAND:fallthrough
		 	case .RANDOM:fallthrough
		 	case .RANDOM_BYTES:fallthrough
		 	case .RELEASE_LOCK:fallthrough
		 	case .REVERSE:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_COUNT:fallthrough
		 	case .RPAD:fallthrough
		 	case .RTRIM:fallthrough
		 	case .SEC_TO_TIME:fallthrough
		 	case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 	case .SESSION_USER:fallthrough
		 	case .SHA:fallthrough
		 	case .SHA1:fallthrough
		 	case .SHA2:fallthrough
		 	case .SCHEMA_NAME:fallthrough
		 	case .SIGN:fallthrough
		 	case .SIN:fallthrough
		 	case .SLEEP:fallthrough
		 	case .SOUNDEX:fallthrough
		 	case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 	case .SQRT:fallthrough
		 	case .SRID:fallthrough
		 	case .STARTPOINT:fallthrough
		 	case .STRCMP:fallthrough
		 	case .STR_TO_DATE:fallthrough
		 	case .ST_AREA:fallthrough
		 	case .ST_ASBINARY:fallthrough
		 	case .ST_ASTEXT:fallthrough
		 	case .ST_ASWKB:fallthrough
		 	case .ST_ASWKT:fallthrough
		 	case .ST_BUFFER:fallthrough
		 	case .ST_CENTROID:fallthrough
		 	case .ST_CONTAINS:fallthrough
		 	case .ST_CROSSES:fallthrough
		 	case .ST_DIFFERENCE:fallthrough
		 	case .ST_DIMENSION:fallthrough
		 	case .ST_DISJOINT:fallthrough
		 	case .ST_DISTANCE:fallthrough
		 	case .ST_ENDPOINT:fallthrough
		 	case .ST_ENVELOPE:fallthrough
		 	case .ST_EQUALS:fallthrough
		 	case .ST_EXTERIORRING:fallthrough
		 	case .ST_GEOMCOLLFROMTEXT:fallthrough
		 	case .ST_GEOMCOLLFROMTXT:fallthrough
		 	case .ST_GEOMCOLLFROMWKB:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .ST_GEOMETRYFROMTEXT:fallthrough
		 	case .ST_GEOMETRYFROMWKB:fallthrough
		 	case .ST_GEOMETRYN:fallthrough
		 	case .ST_GEOMETRYTYPE:fallthrough
		 	case .ST_GEOMFROMTEXT:fallthrough
		 	case .ST_GEOMFROMWKB:fallthrough
		 	case .ST_INTERIORRINGN:fallthrough
		 	case .ST_INTERSECTION:fallthrough
		 	case .ST_INTERSECTS:fallthrough
		 	case .ST_ISCLOSED:fallthrough
		 	case .ST_ISEMPTY:fallthrough
		 	case .ST_ISSIMPLE:fallthrough
		 	case .ST_LINEFROMTEXT:fallthrough
		 	case .ST_LINEFROMWKB:fallthrough
		 	case .ST_LINESTRINGFROMTEXT:fallthrough
		 	case .ST_LINESTRINGFROMWKB:fallthrough
		 	case .ST_NUMGEOMETRIES:fallthrough
		 	case .ST_NUMINTERIORRING:fallthrough
		 	case .ST_NUMINTERIORRINGS:fallthrough
		 	case .ST_NUMPOINTS:fallthrough
		 	case .ST_OVERLAPS:fallthrough
		 	case .ST_POINTFROMTEXT:fallthrough
		 	case .ST_POINTFROMWKB:fallthrough
		 	case .ST_POINTN:fallthrough
		 	case .ST_POLYFROMTEXT:fallthrough
		 	case .ST_POLYFROMWKB:fallthrough
		 	case .ST_POLYGONFROMTEXT:fallthrough
		 	case .ST_POLYGONFROMWKB:fallthrough
		 	case .ST_SRID:fallthrough
		 	case .ST_STARTPOINT:fallthrough
		 	case .ST_SYMDIFFERENCE:fallthrough
		 	case .ST_TOUCHES:fallthrough
		 	case .ST_UNION:fallthrough
		 	case .ST_WITHIN:fallthrough
		 	case .ST_X:fallthrough
		 	case .ST_Y:fallthrough
		 	case .SUBDATE:fallthrough
		 	case .SUBSTRING_INDEX:fallthrough
		 	case .SUBTIME:fallthrough
		 	case .SYSTEM_USER:fallthrough
		 	case .TAN:fallthrough
		 	case .TIMEDIFF:fallthrough
		 	case .TIMESTAMPADD:fallthrough
		 	case .TIMESTAMPDIFF:fallthrough
		 	case .TIME_FORMAT:fallthrough
		 	case .TIME_TO_SEC:fallthrough
		 	case .TOUCHES:fallthrough
		 	case .TO_BASE64:fallthrough
		 	case .TO_DAYS:fallthrough
		 	case .TO_SECONDS:fallthrough
		 	case .TP_CONNECTION_ADMIN:fallthrough
		 	case .UCASE:fallthrough
		 	case .UNCOMPRESS:fallthrough
		 	case .UNCOMPRESSED_LENGTH:fallthrough
		 	case .UNHEX:fallthrough
		 	case .UNIX_TIMESTAMP:fallthrough
		 	case .UPDATEXML:fallthrough
		 	case .UPPER:fallthrough
		 	case .UUID:fallthrough
		 	case .UUID_SHORT:fallthrough
		 	case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 	case .VERSION:fallthrough
		 	case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 	case .WEEKDAY:fallthrough
		 	case .WEEKOFYEAR:fallthrough
		 	case .WEIGHT_STRING:fallthrough
		 	case .WITHIN:fallthrough
		 	case .YEARWEEK:fallthrough
		 	case .Y_FUNCTION:fallthrough
		 	case .X_FUNCTION:fallthrough
		 	case .MOD:fallthrough
		 	case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 	case .STRING_LITERAL:fallthrough
		 	case .ID:
		 		_localctx =  HandlerConditionNameContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(4919)
		 		try uid()

		 		break

		 	case .SQLWARNING:
		 		_localctx =  HandlerConditionWarningContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(4920)
		 		try match(MySqlParser.Tokens.SQLWARNING.rawValue)

		 		break

		 	case .NOT:
		 		_localctx =  HandlerConditionNotfoundContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(4921)
		 		try match(MySqlParser.Tokens.NOT.rawValue)
		 		setState(4922)
		 		try match(MySqlParser.Tokens.FOUND.rawValue)

		 		break

		 	case .SQLEXCEPTION:
		 		_localctx =  HandlerConditionExceptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(4923)
		 		try match(MySqlParser.Tokens.SQLEXCEPTION.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ProcedureSqlStatementContext: ParserRuleContext {
			open
			func SEMI() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SEMI.rawValue, 0)
			}
			open
			func compoundStatement() -> CompoundStatementContext? {
				return getRuleContext(CompoundStatementContext.self, 0)
			}
			open
			func sqlStatement() -> SqlStatementContext? {
				return getRuleContext(SqlStatementContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_procedureSqlStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterProcedureSqlStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitProcedureSqlStatement(self)
			}
		}
	}
	@discardableResult
	 open func procedureSqlStatement() throws -> ProcedureSqlStatementContext {
		var _localctx: ProcedureSqlStatementContext
		_localctx = ProcedureSqlStatementContext(_ctx, getState())
		try enterRule(_localctx, 420, MySqlParser.RULE_procedureSqlStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4928)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,715, _ctx)) {
		 	case 1:
		 		setState(4926)
		 		try compoundStatement()

		 		break
		 	case 2:
		 		setState(4927)
		 		try sqlStatement()

		 		break
		 	default: break
		 	}
		 	setState(4930)
		 	try match(MySqlParser.Tokens.SEMI.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CaseAlternativeContext: ParserRuleContext {
			open
			func WHEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHEN.rawValue, 0)
			}
			open
			func THEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.THEN.rawValue, 0)
			}
			open
			func constant() -> ConstantContext? {
				return getRuleContext(ConstantContext.self, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func procedureSqlStatement() -> [ProcedureSqlStatementContext] {
				return getRuleContexts(ProcedureSqlStatementContext.self)
			}
			open
			func procedureSqlStatement(_ i: Int) -> ProcedureSqlStatementContext? {
				return getRuleContext(ProcedureSqlStatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_caseAlternative
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCaseAlternative(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCaseAlternative(self)
			}
		}
	}
	@discardableResult
	 open func caseAlternative() throws -> CaseAlternativeContext {
		var _localctx: CaseAlternativeContext
		_localctx = CaseAlternativeContext(_ctx, getState())
		try enterRule(_localctx, 422, MySqlParser.RULE_caseAlternative)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4932)
		 	try match(MySqlParser.Tokens.WHEN.rawValue)
		 	setState(4935)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,716, _ctx)) {
		 	case 1:
		 		setState(4933)
		 		try constant()

		 		break
		 	case 2:
		 		setState(4934)
		 		try expression(0)

		 		break
		 	default: break
		 	}
		 	setState(4937)
		 	try match(MySqlParser.Tokens.THEN.rawValue)
		 	setState(4939); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4938)
		 			try procedureSqlStatement()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4941); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,717,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ElifAlternativeContext: ParserRuleContext {
			open
			func ELSEIF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ELSEIF.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func THEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.THEN.rawValue, 0)
			}
			open
			func procedureSqlStatement() -> [ProcedureSqlStatementContext] {
				return getRuleContexts(ProcedureSqlStatementContext.self)
			}
			open
			func procedureSqlStatement(_ i: Int) -> ProcedureSqlStatementContext? {
				return getRuleContext(ProcedureSqlStatementContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_elifAlternative
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterElifAlternative(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitElifAlternative(self)
			}
		}
	}
	@discardableResult
	 open func elifAlternative() throws -> ElifAlternativeContext {
		var _localctx: ElifAlternativeContext
		_localctx = ElifAlternativeContext(_ctx, getState())
		try enterRule(_localctx, 424, MySqlParser.RULE_elifAlternative)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(4943)
		 	try match(MySqlParser.Tokens.ELSEIF.rawValue)
		 	setState(4944)
		 	try expression(0)
		 	setState(4945)
		 	try match(MySqlParser.Tokens.THEN.rawValue)
		 	setState(4947); 
		 	try _errHandler.sync(self)
		 	_alt = 1;
		 	repeat {
		 		switch (_alt) {
		 		case 1:
		 			setState(4946)
		 			try procedureSqlStatement()


		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(4949); 
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,718,_ctx)
		 	} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AlterUserContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_alterUser
		}
	}
	public class AlterUserMysqlV80Context: AlterUserContext {
		public var tlsNone: Token!
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER.rawValue, 0)
			}
			open
			func userAuthOption() -> [UserAuthOptionContext] {
				return getRuleContexts(UserAuthOptionContext.self)
			}
			open
			func userAuthOption(_ i: Int) -> UserAuthOptionContext? {
				return getRuleContext(UserAuthOptionContext.self, i)
			}
			open
			func ifExists() -> IfExistsContext? {
				return getRuleContext(IfExistsContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func REQUIRE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REQUIRE.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func userPasswordOption() -> [UserPasswordOptionContext] {
				return getRuleContexts(UserPasswordOptionContext.self)
			}
			open
			func userPasswordOption(_ i: Int) -> UserPasswordOptionContext? {
				return getRuleContext(UserPasswordOptionContext.self, i)
			}
			open
			func userLockOption() -> [UserLockOptionContext] {
				return getRuleContexts(UserLockOptionContext.self)
			}
			open
			func userLockOption(_ i: Int) -> UserLockOptionContext? {
				return getRuleContext(UserLockOptionContext.self, i)
			}
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func ATTRIBUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ATTRIBUTE.rawValue, 0)
			}
			open
			func tlsOption() -> [TlsOptionContext] {
				return getRuleContexts(TlsOptionContext.self)
			}
			open
			func tlsOption(_ i: Int) -> TlsOptionContext? {
				return getRuleContext(TlsOptionContext.self, i)
			}
			open
			func NONE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NONE.rawValue, 0)
			}
			open
			func userResourceOption() -> [UserResourceOptionContext] {
				return getRuleContexts(UserResourceOptionContext.self)
			}
			open
			func userResourceOption(_ i: Int) -> UserResourceOptionContext? {
				return getRuleContext(UserResourceOptionContext.self, i)
			}
			open
			func AND() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.AND.rawValue)
			}
			open
			func AND(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AND.rawValue, i)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func ROLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLE.rawValue, 0)
			}
			open
			func roleOption() -> RoleOptionContext? {
				return getRuleContext(RoleOptionContext.self, 0)
			}
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}

		public
		init(_ ctx: AlterUserContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterUserMysqlV80(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterUserMysqlV80(self)
			}
		}
	}
	public class AlterUserMysqlV56Context: AlterUserContext {
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER.rawValue, 0)
			}
			open
			func userSpecification() -> [UserSpecificationContext] {
				return getRuleContexts(UserSpecificationContext.self)
			}
			open
			func userSpecification(_ i: Int) -> UserSpecificationContext? {
				return getRuleContext(UserSpecificationContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: AlterUserContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAlterUserMysqlV56(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAlterUserMysqlV56(self)
			}
		}
	}
	@discardableResult
	 open func alterUser() throws -> AlterUserContext {
		var _localctx: AlterUserContext
		_localctx = AlterUserContext(_ctx, getState())
		try enterRule(_localctx, 426, MySqlParser.RULE_alterUser)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5024)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,733, _ctx)) {
		 	case 1:
		 		_localctx =  AlterUserMysqlV56Context(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(4951)
		 		try match(MySqlParser.Tokens.ALTER.rawValue)
		 		setState(4952)
		 		try match(MySqlParser.Tokens.USER.rawValue)
		 		setState(4953)
		 		try userSpecification()
		 		setState(4958)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(4954)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(4955)
		 			try userSpecification()


		 			setState(4960)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		_localctx =  AlterUserMysqlV80Context(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(4961)
		 		try match(MySqlParser.Tokens.ALTER.rawValue)
		 		setState(4962)
		 		try match(MySqlParser.Tokens.USER.rawValue)
		 		setState(4964)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.IF.rawValue) {
		 			setState(4963)
		 			try ifExists()

		 		}

		 		setState(4966)
		 		try userAuthOption()
		 		setState(4971)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(4967)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(4968)
		 			try userAuthOption()


		 			setState(4973)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(4988)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.REQUIRE.rawValue) {
		 			setState(4974)
		 			try match(MySqlParser.Tokens.REQUIRE.rawValue)
		 			setState(4986)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .NONE:
		 				setState(4975)
		 				try {
		 						let assignmentValue = try match(MySqlParser.Tokens.NONE.rawValue)
		 						_localctx.castdown(AlterUserMysqlV80Context.self).tlsNone = assignmentValue
		 				     }()


		 				break
		 			case .SSL:fallthrough
		 			case .CIPHER:fallthrough
		 			case .ISSUER:fallthrough
		 			case .SUBJECT:fallthrough
		 			case .X509:
		 				setState(4976)
		 				try tlsOption()
		 				setState(4983)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				while (_la == MySqlParser.Tokens.AND.rawValue || _la == MySqlParser.Tokens.SSL.rawValue || _la == MySqlParser.Tokens.CIPHER.rawValue || _la == MySqlParser.Tokens.ISSUER.rawValue || _la == MySqlParser.Tokens.SUBJECT.rawValue || _la == MySqlParser.Tokens.X509.rawValue) {
		 					setState(4978)
		 					try _errHandler.sync(self)
		 					_la = try _input.LA(1)
		 					if (_la == MySqlParser.Tokens.AND.rawValue) {
		 						setState(4977)
		 						try match(MySqlParser.Tokens.AND.rawValue)

		 					}

		 					setState(4980)
		 					try tlsOption()


		 					setState(4985)
		 					try _errHandler.sync(self)
		 					_la = try _input.LA(1)
		 				}

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 		}

		 		setState(4996)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,727,_ctx)) {
		 		case 1:
		 			setState(4990)
		 			try match(MySqlParser.Tokens.WITH.rawValue)
		 			setState(4992) 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			repeat {
		 				setState(4991)
		 				try userResourceOption()


		 				setState(4994); 
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			} while (((Int64((_la - 498)) & ~0x3f) == 0 && ((Int64(1) << (_la - 498)) & 51) != 0))

		 			break
		 		default: break
		 		}
		 		setState(5002)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.ACCOUNT.rawValue || _la == MySqlParser.Tokens.FAILED_LOGIN_ATTEMPTS.rawValue || _la == MySqlParser.Tokens.PASSWORD.rawValue || _la == MySqlParser.Tokens.PASSWORD_LOCK_TIME.rawValue) {
		 			setState(5000)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 			case .PASSWORD:fallthrough
		 			case .PASSWORD_LOCK_TIME:
		 				setState(4998)
		 				try userPasswordOption()

		 				break

		 			case .ACCOUNT:
		 				setState(4999)
		 				try userLockOption()

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			setState(5004)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(5009)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .COMMENT:
		 		 	setState(5005)
		 		 	try match(MySqlParser.Tokens.COMMENT.rawValue)
		 		 	setState(5006)
		 		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 			break

		 		case .ATTRIBUTE:
		 		 	setState(5007)
		 		 	try match(MySqlParser.Tokens.ATTRIBUTE.rawValue)
		 		 	setState(5008)
		 		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 			break
		 		case .EOF:fallthrough
		 		case .ALTER:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .CALL:fallthrough
		 		case .CHANGE:fallthrough
		 		case .CHECK:fallthrough
		 		case .CREATE:fallthrough
		 		case .DELETE:fallthrough
		 		case .DESC:fallthrough
		 		case .DESCRIBE:fallthrough
		 		case .DROP:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .GET:fallthrough
		 		case .GRANT:fallthrough
		 		case .INSERT:fallthrough
		 		case .KILL:fallthrough
		 		case .LOAD:fallthrough
		 		case .LOCK:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .PURGE:fallthrough
		 		case .RELEASE:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESIGNAL:fallthrough
		 		case .REVOKE:fallthrough
		 		case .SELECT:fallthrough
		 		case .SET:fallthrough
		 		case .SHOW:fallthrough
		 		case .SIGNAL:fallthrough
		 		case .TABLE:fallthrough
		 		case .UNLOCK:fallthrough
		 		case .UPDATE:fallthrough
		 		case .USE:fallthrough
		 		case .VALUES:fallthrough
		 		case .WITH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .CACHE:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .COMMIT:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DO:fallthrough
		 		case .FLUSH:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HELP:fallthrough
		 		case .INSTALL:fallthrough
		 		case .PREPARE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .RESET:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .START:fallthrough
		 		case .STOP:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .XA:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .MINUS:fallthrough
		 		case .LR_BRACKET:fallthrough
		 		case .SEMI:
		 			break
		 		default:
		 			break
		 		}

		 		break
		 	case 3:
		 		_localctx =  AlterUserMysqlV80Context(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5011)
		 		try match(MySqlParser.Tokens.ALTER.rawValue)
		 		setState(5012)
		 		try match(MySqlParser.Tokens.USER.rawValue)
		 		setState(5014)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,731,_ctx)) {
		 		case 1:
		 			setState(5013)
		 			try ifExists()

		 			break
		 		default: break
		 		}
		 		setState(5018)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,732, _ctx)) {
		 		case 1:
		 			setState(5016)
		 			try userName()

		 			break
		 		case 2:
		 			setState(5017)
		 			try uid()

		 			break
		 		default: break
		 		}
		 		setState(5020)
		 		try match(MySqlParser.Tokens.DEFAULT.rawValue)
		 		setState(5021)
		 		try match(MySqlParser.Tokens.ROLE.rawValue)
		 		setState(5022)
		 		try roleOption()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateUserContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createUser
		}
	}
	public class CreateUserMysqlV56Context: CreateUserContext {
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER.rawValue, 0)
			}
			open
			func userAuthOption() -> [UserAuthOptionContext] {
				return getRuleContexts(UserAuthOptionContext.self)
			}
			open
			func userAuthOption(_ i: Int) -> UserAuthOptionContext? {
				return getRuleContext(UserAuthOptionContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: CreateUserContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateUserMysqlV56(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateUserMysqlV56(self)
			}
		}
	}
	public class CreateUserMysqlV80Context: CreateUserContext {
		public var tlsNone: Token!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER.rawValue, 0)
			}
			open
			func userAuthOption() -> [UserAuthOptionContext] {
				return getRuleContexts(UserAuthOptionContext.self)
			}
			open
			func userAuthOption(_ i: Int) -> UserAuthOptionContext? {
				return getRuleContext(UserAuthOptionContext.self, i)
			}
			open
			func ifNotExists() -> IfNotExistsContext? {
				return getRuleContext(IfNotExistsContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func ROLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLE.rawValue, 0)
			}
			open
			func roleOption() -> RoleOptionContext? {
				return getRuleContext(RoleOptionContext.self, 0)
			}
			open
			func REQUIRE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REQUIRE.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func userPasswordOption() -> [UserPasswordOptionContext] {
				return getRuleContexts(UserPasswordOptionContext.self)
			}
			open
			func userPasswordOption(_ i: Int) -> UserPasswordOptionContext? {
				return getRuleContext(UserPasswordOptionContext.self, i)
			}
			open
			func userLockOption() -> [UserLockOptionContext] {
				return getRuleContexts(UserLockOptionContext.self)
			}
			open
			func userLockOption(_ i: Int) -> UserLockOptionContext? {
				return getRuleContext(UserLockOptionContext.self, i)
			}
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func ATTRIBUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ATTRIBUTE.rawValue, 0)
			}
			open
			func tlsOption() -> [TlsOptionContext] {
				return getRuleContexts(TlsOptionContext.self)
			}
			open
			func tlsOption(_ i: Int) -> TlsOptionContext? {
				return getRuleContext(TlsOptionContext.self, i)
			}
			open
			func NONE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NONE.rawValue, 0)
			}
			open
			func userResourceOption() -> [UserResourceOptionContext] {
				return getRuleContexts(UserResourceOptionContext.self)
			}
			open
			func userResourceOption(_ i: Int) -> UserResourceOptionContext? {
				return getRuleContext(UserResourceOptionContext.self, i)
			}
			open
			func AND() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.AND.rawValue)
			}
			open
			func AND(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AND.rawValue, i)
			}

		public
		init(_ ctx: CreateUserContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateUserMysqlV80(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateUserMysqlV80(self)
			}
		}
	}
	@discardableResult
	 open func createUser() throws -> CreateUserContext {
		var _localctx: CreateUserContext
		_localctx = CreateUserContext(_ctx, getState())
		try enterRule(_localctx, 428, MySqlParser.RULE_createUser)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5091)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,747, _ctx)) {
		 	case 1:
		 		_localctx =  CreateUserMysqlV56Context(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5026)
		 		try match(MySqlParser.Tokens.CREATE.rawValue)
		 		setState(5027)
		 		try match(MySqlParser.Tokens.USER.rawValue)
		 		setState(5028)
		 		try userAuthOption()
		 		setState(5033)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5029)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5030)
		 			try userAuthOption()


		 			setState(5035)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		_localctx =  CreateUserMysqlV80Context(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5036)
		 		try match(MySqlParser.Tokens.CREATE.rawValue)
		 		setState(5037)
		 		try match(MySqlParser.Tokens.USER.rawValue)
		 		setState(5039)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.IF.rawValue) {
		 			setState(5038)
		 			try ifNotExists()

		 		}

		 		setState(5041)
		 		try userAuthOption()
		 		setState(5046)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5042)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5043)
		 			try userAuthOption()


		 			setState(5048)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(5052)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DEFAULT.rawValue) {
		 			setState(5049)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)
		 			setState(5050)
		 			try match(MySqlParser.Tokens.ROLE.rawValue)
		 			setState(5051)
		 			try roleOption()

		 		}

		 		setState(5068)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.REQUIRE.rawValue) {
		 			setState(5054)
		 			try match(MySqlParser.Tokens.REQUIRE.rawValue)
		 			setState(5066)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .NONE:
		 				setState(5055)
		 				try {
		 						let assignmentValue = try match(MySqlParser.Tokens.NONE.rawValue)
		 						_localctx.castdown(CreateUserMysqlV80Context.self).tlsNone = assignmentValue
		 				     }()


		 				break
		 			case .SSL:fallthrough
		 			case .CIPHER:fallthrough
		 			case .ISSUER:fallthrough
		 			case .SUBJECT:fallthrough
		 			case .X509:
		 				setState(5056)
		 				try tlsOption()
		 				setState(5063)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				while (_la == MySqlParser.Tokens.AND.rawValue || _la == MySqlParser.Tokens.SSL.rawValue || _la == MySqlParser.Tokens.CIPHER.rawValue || _la == MySqlParser.Tokens.ISSUER.rawValue || _la == MySqlParser.Tokens.SUBJECT.rawValue || _la == MySqlParser.Tokens.X509.rawValue) {
		 					setState(5058)
		 					try _errHandler.sync(self)
		 					_la = try _input.LA(1)
		 					if (_la == MySqlParser.Tokens.AND.rawValue) {
		 						setState(5057)
		 						try match(MySqlParser.Tokens.AND.rawValue)

		 					}

		 					setState(5060)
		 					try tlsOption()


		 					setState(5065)
		 					try _errHandler.sync(self)
		 					_la = try _input.LA(1)
		 				}

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 		}

		 		setState(5076)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,743,_ctx)) {
		 		case 1:
		 			setState(5070)
		 			try match(MySqlParser.Tokens.WITH.rawValue)
		 			setState(5072) 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			repeat {
		 				setState(5071)
		 				try userResourceOption()


		 				setState(5074); 
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			} while (((Int64((_la - 498)) & ~0x3f) == 0 && ((Int64(1) << (_la - 498)) & 51) != 0))

		 			break
		 		default: break
		 		}
		 		setState(5082)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.ACCOUNT.rawValue || _la == MySqlParser.Tokens.FAILED_LOGIN_ATTEMPTS.rawValue || _la == MySqlParser.Tokens.PASSWORD.rawValue || _la == MySqlParser.Tokens.PASSWORD_LOCK_TIME.rawValue) {
		 			setState(5080)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 			case .PASSWORD:fallthrough
		 			case .PASSWORD_LOCK_TIME:
		 				setState(5078)
		 				try userPasswordOption()

		 				break

		 			case .ACCOUNT:
		 				setState(5079)
		 				try userLockOption()

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 			setState(5084)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(5089)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .COMMENT:
		 		 	setState(5085)
		 		 	try match(MySqlParser.Tokens.COMMENT.rawValue)
		 		 	setState(5086)
		 		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 			break

		 		case .ATTRIBUTE:
		 		 	setState(5087)
		 		 	try match(MySqlParser.Tokens.ATTRIBUTE.rawValue)
		 		 	setState(5088)
		 		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 			break
		 		case .EOF:fallthrough
		 		case .ALTER:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .CALL:fallthrough
		 		case .CHANGE:fallthrough
		 		case .CHECK:fallthrough
		 		case .CREATE:fallthrough
		 		case .DELETE:fallthrough
		 		case .DESC:fallthrough
		 		case .DESCRIBE:fallthrough
		 		case .DROP:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .GET:fallthrough
		 		case .GRANT:fallthrough
		 		case .INSERT:fallthrough
		 		case .KILL:fallthrough
		 		case .LOAD:fallthrough
		 		case .LOCK:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .PURGE:fallthrough
		 		case .RELEASE:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESIGNAL:fallthrough
		 		case .REVOKE:fallthrough
		 		case .SELECT:fallthrough
		 		case .SET:fallthrough
		 		case .SHOW:fallthrough
		 		case .SIGNAL:fallthrough
		 		case .TABLE:fallthrough
		 		case .UNLOCK:fallthrough
		 		case .UPDATE:fallthrough
		 		case .USE:fallthrough
		 		case .VALUES:fallthrough
		 		case .WITH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .CACHE:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .COMMIT:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DO:fallthrough
		 		case .FLUSH:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HELP:fallthrough
		 		case .INSTALL:fallthrough
		 		case .PREPARE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .RESET:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .START:fallthrough
		 		case .STOP:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .XA:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .MINUS:fallthrough
		 		case .LR_BRACKET:fallthrough
		 		case .SEMI:
		 			break
		 		default:
		 			break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DropUserContext: ParserRuleContext {
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER.rawValue, 0)
			}
			open
			func userName() -> [UserNameContext] {
				return getRuleContexts(UserNameContext.self)
			}
			open
			func userName(_ i: Int) -> UserNameContext? {
				return getRuleContext(UserNameContext.self, i)
			}
			open
			func ifExists() -> IfExistsContext? {
				return getRuleContext(IfExistsContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dropUser
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDropUser(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDropUser(self)
			}
		}
	}
	@discardableResult
	 open func dropUser() throws -> DropUserContext {
		var _localctx: DropUserContext
		_localctx = DropUserContext(_ctx, getState())
		try enterRule(_localctx, 430, MySqlParser.RULE_dropUser)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5093)
		 	try match(MySqlParser.Tokens.DROP.rawValue)
		 	setState(5094)
		 	try match(MySqlParser.Tokens.USER.rawValue)
		 	setState(5096)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IF.rawValue) {
		 		setState(5095)
		 		try ifExists()

		 	}

		 	setState(5098)
		 	try userName()
		 	setState(5103)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(5099)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(5100)
		 		try userName()


		 		setState(5105)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GrantStatementContext: ParserRuleContext {
		open var privilegeObject: Token!
		open var tlsNone: Token!
			open
			func GRANT() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.GRANT.rawValue)
			}
			open
			func GRANT(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GRANT.rawValue, i)
			}
			open
			func privelegeClause() -> [PrivelegeClauseContext] {
				return getRuleContexts(PrivelegeClauseContext.self)
			}
			open
			func privelegeClause(_ i: Int) -> PrivelegeClauseContext? {
				return getRuleContext(PrivelegeClauseContext.self, i)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func privilegeLevel() -> PrivilegeLevelContext? {
				return getRuleContext(PrivilegeLevelContext.self, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func userAuthOption() -> [UserAuthOptionContext] {
				return getRuleContexts(UserAuthOptionContext.self)
			}
			open
			func userAuthOption(_ i: Int) -> UserAuthOptionContext? {
				return getRuleContext(UserAuthOptionContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func REQUIRE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REQUIRE.rawValue, 0)
			}
			open
			func WITH() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.WITH.rawValue)
			}
			open
			func WITH(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, i)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
			open
			func userName() -> [UserNameContext] {
				return getRuleContexts(UserNameContext.self)
			}
			open
			func userName(_ i: Int) -> UserNameContext? {
				return getRuleContext(UserNameContext.self, i)
			}
			open
			func ROLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLE.rawValue, 0)
			}
			open
			func roleOption() -> RoleOptionContext? {
				return getRuleContext(RoleOptionContext.self, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FUNCTION.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCEDURE.rawValue, 0)
			}
			open
			func tlsOption() -> [TlsOptionContext] {
				return getRuleContexts(TlsOptionContext.self)
			}
			open
			func tlsOption(_ i: Int) -> TlsOptionContext? {
				return getRuleContext(TlsOptionContext.self, i)
			}
			open
			func NONE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NONE.rawValue, 0)
			}
			open
			func OPTION() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.OPTION.rawValue)
			}
			open
			func OPTION(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTION.rawValue, i)
			}
			open
			func userResourceOption() -> [UserResourceOptionContext] {
				return getRuleContexts(UserResourceOptionContext.self)
			}
			open
			func userResourceOption(_ i: Int) -> UserResourceOptionContext? {
				return getRuleContext(UserResourceOptionContext.self, i)
			}
			open
			func AND() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.AND.rawValue)
			}
			open
			func AND(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AND.rawValue, i)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADMIN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_grantStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterGrantStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitGrantStatement(self)
			}
		}
	}
	@discardableResult
	 open func grantStatement() throws -> GrantStatementContext {
		var _localctx: GrantStatementContext
		_localctx = GrantStatementContext(_ctx, getState())
		try enterRule(_localctx, 432, MySqlParser.RULE_grantStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(5199)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,768, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5106)
		 		try match(MySqlParser.Tokens.GRANT.rawValue)
		 		setState(5107)
		 		try privelegeClause()
		 		setState(5112)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5108)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5109)
		 			try privelegeClause()


		 			setState(5114)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(5115)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(5117)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,751,_ctx)) {
		 		case 1:
		 			setState(5116)
		 			_localctx.castdown(GrantStatementContext.self).privilegeObject = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.PROCEDURE.rawValue || _la == MySqlParser.Tokens.TABLE.rawValue || _la == MySqlParser.Tokens.FUNCTION.rawValue)) {
		 				_localctx.castdown(GrantStatementContext.self).privilegeObject = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(5119)
		 		try privilegeLevel()
		 		setState(5120)
		 		try match(MySqlParser.Tokens.TO.rawValue)
		 		setState(5121)
		 		try userAuthOption()
		 		setState(5126)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5122)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5123)
		 			try userAuthOption()


		 			setState(5128)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(5143)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.REQUIRE.rawValue) {
		 			setState(5129)
		 			try match(MySqlParser.Tokens.REQUIRE.rawValue)
		 			setState(5141)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .NONE:
		 				setState(5130)
		 				try {
		 						let assignmentValue = try match(MySqlParser.Tokens.NONE.rawValue)
		 						_localctx.castdown(GrantStatementContext.self).tlsNone = assignmentValue
		 				     }()


		 				break
		 			case .SSL:fallthrough
		 			case .CIPHER:fallthrough
		 			case .ISSUER:fallthrough
		 			case .SUBJECT:fallthrough
		 			case .X509:
		 				setState(5131)
		 				try tlsOption()
		 				setState(5138)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 				while (_la == MySqlParser.Tokens.AND.rawValue || _la == MySqlParser.Tokens.SSL.rawValue || _la == MySqlParser.Tokens.CIPHER.rawValue || _la == MySqlParser.Tokens.ISSUER.rawValue || _la == MySqlParser.Tokens.SUBJECT.rawValue || _la == MySqlParser.Tokens.X509.rawValue) {
		 					setState(5133)
		 					try _errHandler.sync(self)
		 					_la = try _input.LA(1)
		 					if (_la == MySqlParser.Tokens.AND.rawValue) {
		 						setState(5132)
		 						try match(MySqlParser.Tokens.AND.rawValue)

		 					}

		 					setState(5135)
		 					try tlsOption()


		 					setState(5140)
		 					try _errHandler.sync(self)
		 					_la = try _input.LA(1)
		 				}

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}

		 		}

		 		setState(5154)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,759,_ctx)) {
		 		case 1:
		 			setState(5145)
		 			try match(MySqlParser.Tokens.WITH.rawValue)
		 			setState(5151)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,758,_ctx)
		 			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 				if ( _alt==1 ) {
		 					setState(5149)
		 					try _errHandler.sync(self)
		 					switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 					case .GRANT:
		 						setState(5146)
		 						try match(MySqlParser.Tokens.GRANT.rawValue)
		 						setState(5147)
		 						try match(MySqlParser.Tokens.OPTION.rawValue)

		 						break
		 					case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 					case .MAX_QUERIES_PER_HOUR:fallthrough
		 					case .MAX_UPDATES_PER_HOUR:fallthrough
		 					case .MAX_USER_CONNECTIONS:
		 						setState(5148)
		 						try userResourceOption()

		 						break
		 					default:
		 						throw ANTLRException.recognition(e: NoViableAltException(self))
		 					}
		 			 
		 				}
		 				setState(5153)
		 				try _errHandler.sync(self)
		 				_alt = try getInterpreter().adaptivePredict(_input,758,_ctx)
		 			}

		 			break
		 		default: break
		 		}
		 		setState(5162)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.AS.rawValue) {
		 			setState(5156)
		 			try match(MySqlParser.Tokens.AS.rawValue)
		 			setState(5157)
		 			try userName()
		 			setState(5158)
		 			try match(MySqlParser.Tokens.WITH.rawValue)
		 			setState(5159)
		 			try match(MySqlParser.Tokens.ROLE.rawValue)
		 			setState(5160)
		 			try roleOption()

		 		}


		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5164)
		 		try match(MySqlParser.Tokens.GRANT.rawValue)
		 		setState(5167)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,761, _ctx)) {
		 		case 1:
		 			setState(5165)
		 			try userName()

		 			break
		 		case 2:
		 			setState(5166)
		 			try uid()

		 			break
		 		default: break
		 		}
		 		setState(5176)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5169)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5172)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,762, _ctx)) {
		 			case 1:
		 				setState(5170)
		 				try userName()

		 				break
		 			case 2:
		 				setState(5171)
		 				try uid()

		 				break
		 			default: break
		 			}


		 			setState(5178)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(5179)
		 		try match(MySqlParser.Tokens.TO.rawValue)
		 		setState(5182)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,764, _ctx)) {
		 		case 1:
		 			setState(5180)
		 			try userName()

		 			break
		 		case 2:
		 			setState(5181)
		 			try uid()

		 			break
		 		default: break
		 		}
		 		setState(5191)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5184)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5187)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,765, _ctx)) {
		 			case 1:
		 				setState(5185)
		 				try userName()

		 				break
		 			case 2:
		 				setState(5186)
		 				try uid()

		 				break
		 			default: break
		 			}


		 			setState(5193)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(5197)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,767,_ctx)) {
		 		case 1:
		 			setState(5194)
		 			try match(MySqlParser.Tokens.WITH.rawValue)
		 			setState(5195)
		 			try match(MySqlParser.Tokens.ADMIN.rawValue)
		 			setState(5196)
		 			try match(MySqlParser.Tokens.OPTION.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RoleOptionContext: ParserRuleContext {
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func NONE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NONE.rawValue, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func EXCEPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXCEPT.rawValue, 0)
			}
			open
			func userName() -> [UserNameContext] {
				return getRuleContexts(UserNameContext.self)
			}
			open
			func userName(_ i: Int) -> UserNameContext? {
				return getRuleContext(UserNameContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_roleOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRoleOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRoleOption(self)
			}
		}
	}
	@discardableResult
	 open func roleOption() throws -> RoleOptionContext {
		var _localctx: RoleOptionContext
		_localctx = RoleOptionContext(_ctx, getState())
		try enterRule(_localctx, 434, MySqlParser.RULE_roleOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5223)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,772, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5201)
		 		try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5202)
		 		try match(MySqlParser.Tokens.NONE.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5203)
		 		try match(MySqlParser.Tokens.ALL.rawValue)
		 		setState(5213)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.EXCEPT.rawValue) {
		 			setState(5204)
		 			try match(MySqlParser.Tokens.EXCEPT.rawValue)
		 			setState(5205)
		 			try userName()
		 			setState(5210)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 				setState(5206)
		 				try match(MySqlParser.Tokens.COMMA.rawValue)
		 				setState(5207)
		 				try userName()


		 				setState(5212)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}

		 		}


		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5215)
		 		try userName()
		 		setState(5220)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5216)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5217)
		 			try userName()


		 			setState(5222)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class GrantProxyContext: ParserRuleContext {
		open var fromFirst: UserNameContext!
		open var toFirst: UserNameContext!
		open var _userName: UserNameContext!
		open var toOther: [UserNameContext] = [UserNameContext]()
			open
			func GRANT() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.GRANT.rawValue)
			}
			open
			func GRANT(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GRANT.rawValue, i)
			}
			open
			func PROXY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROXY.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func userName() -> [UserNameContext] {
				return getRuleContexts(UserNameContext.self)
			}
			open
			func userName(_ i: Int) -> UserNameContext? {
				return getRuleContext(UserNameContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func OPTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTION.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_grantProxy
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterGrantProxy(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitGrantProxy(self)
			}
		}
	}
	@discardableResult
	 open func grantProxy() throws -> GrantProxyContext {
		var _localctx: GrantProxyContext
		_localctx = GrantProxyContext(_ctx, getState())
		try enterRule(_localctx, 436, MySqlParser.RULE_grantProxy)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5225)
		 	try match(MySqlParser.Tokens.GRANT.rawValue)
		 	setState(5226)
		 	try match(MySqlParser.Tokens.PROXY.rawValue)
		 	setState(5227)
		 	try match(MySqlParser.Tokens.ON.rawValue)
		 	setState(5228)
		 	try {
		 			let assignmentValue = try userName()
		 			_localctx.castdown(GrantProxyContext.self).fromFirst = assignmentValue
		 	     }()

		 	setState(5229)
		 	try match(MySqlParser.Tokens.TO.rawValue)
		 	setState(5230)
		 	try {
		 			let assignmentValue = try userName()
		 			_localctx.castdown(GrantProxyContext.self).toFirst = assignmentValue
		 	     }()

		 	setState(5235)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(5231)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(5232)
		 		try {
		 				let assignmentValue = try userName()
		 				_localctx.castdown(GrantProxyContext.self)._userName = assignmentValue
		 		     }()

		 		_localctx.castdown(GrantProxyContext.self).toOther.append(_localctx.castdown(GrantProxyContext.self)._userName)


		 		setState(5237)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(5241)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,774,_ctx)) {
		 	case 1:
		 		setState(5238)
		 		try match(MySqlParser.Tokens.WITH.rawValue)
		 		setState(5239)
		 		try match(MySqlParser.Tokens.GRANT.rawValue)
		 		setState(5240)
		 		try match(MySqlParser.Tokens.OPTION.rawValue)

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RenameUserContext: ParserRuleContext {
			open
			func RENAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RENAME.rawValue, 0)
			}
			open
			func USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER.rawValue, 0)
			}
			open
			func renameUserClause() -> [RenameUserClauseContext] {
				return getRuleContexts(RenameUserClauseContext.self)
			}
			open
			func renameUserClause(_ i: Int) -> RenameUserClauseContext? {
				return getRuleContext(RenameUserClauseContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_renameUser
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRenameUser(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRenameUser(self)
			}
		}
	}
	@discardableResult
	 open func renameUser() throws -> RenameUserContext {
		var _localctx: RenameUserContext
		_localctx = RenameUserContext(_ctx, getState())
		try enterRule(_localctx, 438, MySqlParser.RULE_renameUser)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5243)
		 	try match(MySqlParser.Tokens.RENAME.rawValue)
		 	setState(5244)
		 	try match(MySqlParser.Tokens.USER.rawValue)
		 	setState(5245)
		 	try renameUserClause()
		 	setState(5250)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(5246)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(5247)
		 		try renameUserClause()


		 		setState(5252)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RevokeStatementContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_revokeStatement
		}
	}
	public class DetailRevokeContext: RevokeStatementContext {
		public var privilegeObject: Token!
			open
			func REVOKE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REVOKE.rawValue, 0)
			}
			open
			func privelegeClause() -> [PrivelegeClauseContext] {
				return getRuleContexts(PrivelegeClauseContext.self)
			}
			open
			func privelegeClause(_ i: Int) -> PrivelegeClauseContext? {
				return getRuleContext(PrivelegeClauseContext.self, i)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func privilegeLevel() -> PrivilegeLevelContext? {
				return getRuleContext(PrivilegeLevelContext.self, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func userName() -> [UserNameContext] {
				return getRuleContexts(UserNameContext.self)
			}
			open
			func userName(_ i: Int) -> UserNameContext? {
				return getRuleContext(UserNameContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FUNCTION.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCEDURE.rawValue, 0)
			}

		public
		init(_ ctx: RevokeStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDetailRevoke(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDetailRevoke(self)
			}
		}
	}
	public class RoleRevokeContext: RevokeStatementContext {
			open
			func REVOKE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REVOKE.rawValue, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func userName() -> [UserNameContext] {
				return getRuleContexts(UserNameContext.self)
			}
			open
			func userName(_ i: Int) -> UserNameContext? {
				return getRuleContext(UserNameContext.self, i)
			}
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: RevokeStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRoleRevoke(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRoleRevoke(self)
			}
		}
	}
	public class ShortRevokeContext: RevokeStatementContext {
			open
			func REVOKE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REVOKE.rawValue, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func GRANT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GRANT.rawValue, 0)
			}
			open
			func OPTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTION.rawValue, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func userName() -> [UserNameContext] {
				return getRuleContexts(UserNameContext.self)
			}
			open
			func userName(_ i: Int) -> UserNameContext? {
				return getRuleContext(UserNameContext.self, i)
			}
			open
			func PRIVILEGES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRIVILEGES.rawValue, 0)
			}

		public
		init(_ ctx: RevokeStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShortRevoke(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShortRevoke(self)
			}
		}
	}
	@discardableResult
	 open func revokeStatement() throws -> RevokeStatementContext {
		var _localctx: RevokeStatementContext
		_localctx = RevokeStatementContext(_ctx, getState())
		try enterRule(_localctx, 440, MySqlParser.RULE_revokeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5323)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,787, _ctx)) {
		 	case 1:
		 		_localctx =  DetailRevokeContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5253)
		 		try match(MySqlParser.Tokens.REVOKE.rawValue)
		 		setState(5254)
		 		try privelegeClause()
		 		setState(5259)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5255)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5256)
		 			try privelegeClause()


		 			setState(5261)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(5262)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(5264)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,777,_ctx)) {
		 		case 1:
		 			setState(5263)
		 			_localctx.castdown(DetailRevokeContext.self).privilegeObject = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.PROCEDURE.rawValue || _la == MySqlParser.Tokens.TABLE.rawValue || _la == MySqlParser.Tokens.FUNCTION.rawValue)) {
		 				_localctx.castdown(DetailRevokeContext.self).privilegeObject = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(5266)
		 		try privilegeLevel()
		 		setState(5267)
		 		try match(MySqlParser.Tokens.FROM.rawValue)
		 		setState(5268)
		 		try userName()
		 		setState(5273)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5269)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5270)
		 			try userName()


		 			setState(5275)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		_localctx =  ShortRevokeContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5276)
		 		try match(MySqlParser.Tokens.REVOKE.rawValue)
		 		setState(5277)
		 		try match(MySqlParser.Tokens.ALL.rawValue)
		 		setState(5279)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.PRIVILEGES.rawValue) {
		 			setState(5278)
		 			try match(MySqlParser.Tokens.PRIVILEGES.rawValue)

		 		}

		 		setState(5281)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(5282)
		 		try match(MySqlParser.Tokens.GRANT.rawValue)
		 		setState(5283)
		 		try match(MySqlParser.Tokens.OPTION.rawValue)
		 		setState(5284)
		 		try match(MySqlParser.Tokens.FROM.rawValue)
		 		setState(5285)
		 		try userName()
		 		setState(5290)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5286)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5287)
		 			try userName()


		 			setState(5292)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 3:
		 		_localctx =  RoleRevokeContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5293)
		 		try match(MySqlParser.Tokens.REVOKE.rawValue)
		 		setState(5296)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,781, _ctx)) {
		 		case 1:
		 			setState(5294)
		 			try userName()

		 			break
		 		case 2:
		 			setState(5295)
		 			try uid()

		 			break
		 		default: break
		 		}
		 		setState(5305)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5298)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5301)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,782, _ctx)) {
		 			case 1:
		 				setState(5299)
		 				try userName()

		 				break
		 			case 2:
		 				setState(5300)
		 				try uid()

		 				break
		 			default: break
		 			}


		 			setState(5307)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(5308)
		 		try match(MySqlParser.Tokens.FROM.rawValue)
		 		setState(5311)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,784, _ctx)) {
		 		case 1:
		 			setState(5309)
		 			try userName()

		 			break
		 		case 2:
		 			setState(5310)
		 			try uid()

		 			break
		 		default: break
		 		}
		 		setState(5320)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5313)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5316)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,785, _ctx)) {
		 			case 1:
		 				setState(5314)
		 				try userName()

		 				break
		 			case 2:
		 				setState(5315)
		 				try uid()

		 				break
		 			default: break
		 			}


		 			setState(5322)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RevokeProxyContext: ParserRuleContext {
		open var onUser: UserNameContext!
		open var fromFirst: UserNameContext!
		open var _userName: UserNameContext!
		open var fromOther: [UserNameContext] = [UserNameContext]()
			open
			func REVOKE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REVOKE.rawValue, 0)
			}
			open
			func PROXY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROXY.rawValue, 0)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func userName() -> [UserNameContext] {
				return getRuleContexts(UserNameContext.self)
			}
			open
			func userName(_ i: Int) -> UserNameContext? {
				return getRuleContext(UserNameContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_revokeProxy
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRevokeProxy(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRevokeProxy(self)
			}
		}
	}
	@discardableResult
	 open func revokeProxy() throws -> RevokeProxyContext {
		var _localctx: RevokeProxyContext
		_localctx = RevokeProxyContext(_ctx, getState())
		try enterRule(_localctx, 442, MySqlParser.RULE_revokeProxy)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5325)
		 	try match(MySqlParser.Tokens.REVOKE.rawValue)
		 	setState(5326)
		 	try match(MySqlParser.Tokens.PROXY.rawValue)
		 	setState(5327)
		 	try match(MySqlParser.Tokens.ON.rawValue)
		 	setState(5328)
		 	try {
		 			let assignmentValue = try userName()
		 			_localctx.castdown(RevokeProxyContext.self).onUser = assignmentValue
		 	     }()

		 	setState(5329)
		 	try match(MySqlParser.Tokens.FROM.rawValue)
		 	setState(5330)
		 	try {
		 			let assignmentValue = try userName()
		 			_localctx.castdown(RevokeProxyContext.self).fromFirst = assignmentValue
		 	     }()

		 	setState(5335)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(5331)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(5332)
		 		try {
		 				let assignmentValue = try userName()
		 				_localctx.castdown(RevokeProxyContext.self)._userName = assignmentValue
		 		     }()

		 		_localctx.castdown(RevokeProxyContext.self).fromOther.append(_localctx.castdown(RevokeProxyContext.self)._userName)


		 		setState(5337)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetPasswordStatementContext: ParserRuleContext {
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func passwordFunctionClause() -> PasswordFunctionClauseContext? {
				return getRuleContext(PasswordFunctionClauseContext.self, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_setPasswordStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSetPasswordStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSetPasswordStatement(self)
			}
		}
	}
	@discardableResult
	 open func setPasswordStatement() throws -> SetPasswordStatementContext {
		var _localctx: SetPasswordStatementContext
		_localctx = SetPasswordStatementContext(_ctx, getState())
		try enterRule(_localctx, 444, MySqlParser.RULE_setPasswordStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5338)
		 	try match(MySqlParser.Tokens.SET.rawValue)
		 	setState(5339)
		 	try match(MySqlParser.Tokens.PASSWORD.rawValue)
		 	setState(5342)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.FOR.rawValue) {
		 		setState(5340)
		 		try match(MySqlParser.Tokens.FOR.rawValue)
		 		setState(5341)
		 		try userName()

		 	}

		 	setState(5344)
		 	try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 	setState(5347)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .OLD_PASSWORD:fallthrough
		 	case .PASSWORD:
		 		setState(5345)
		 		try passwordFunctionClause()

		 		break

		 	case .STRING_LITERAL:
		 		setState(5346)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UserSpecificationContext: ParserRuleContext {
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}
			open
			func userPasswordOption() -> UserPasswordOptionContext? {
				return getRuleContext(UserPasswordOptionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_userSpecification
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUserSpecification(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUserSpecification(self)
			}
		}
	}
	@discardableResult
	 open func userSpecification() throws -> UserSpecificationContext {
		var _localctx: UserSpecificationContext
		_localctx = UserSpecificationContext(_ctx, getState())
		try enterRule(_localctx, 446, MySqlParser.RULE_userSpecification)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5349)
		 	try userName()
		 	setState(5350)
		 	try userPasswordOption()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UserAuthOptionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_userAuthOption
		}
	}
	public class SimpleAuthOptionContext: UserAuthOptionContext {
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}

		public
		init(_ ctx: UserAuthOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSimpleAuthOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSimpleAuthOption(self)
			}
		}
	}
	public class ModuleAuthOptionContext: UserAuthOptionContext {
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}
			open
			func IDENTIFIED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IDENTIFIED.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func authenticationRule() -> AuthenticationRuleContext? {
				return getRuleContext(AuthenticationRuleContext.self, 0)
			}

		public
		init(_ ctx: UserAuthOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterModuleAuthOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitModuleAuthOption(self)
			}
		}
	}
	public class RandomAuthOptionContext: UserAuthOptionContext {
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}
			open
			func IDENTIFIED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IDENTIFIED.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func RANDOM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RANDOM.rawValue, 0)
			}
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD.rawValue, 0)
			}
			open
			func authOptionClause() -> AuthOptionClauseContext? {
				return getRuleContext(AuthOptionClauseContext.self, 0)
			}

		public
		init(_ ctx: UserAuthOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRandomAuthOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRandomAuthOption(self)
			}
		}
	}
	public class StringAuthOptionContext: UserAuthOptionContext {
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}
			open
			func IDENTIFIED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IDENTIFIED.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func authOptionClause() -> AuthOptionClauseContext? {
				return getRuleContext(AuthOptionClauseContext.self, 0)
			}

		public
		init(_ ctx: UserAuthOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterStringAuthOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitStringAuthOption(self)
			}
		}
	}
	public class HashAuthOptionContext: UserAuthOptionContext {
		public var hashed: Token!
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}
			open
			func IDENTIFIED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IDENTIFIED.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: UserAuthOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHashAuthOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHashAuthOption(self)
			}
		}
	}
	@discardableResult
	 open func userAuthOption() throws -> UserAuthOptionContext {
		var _localctx: UserAuthOptionContext
		_localctx = UserAuthOptionContext(_ctx, getState())
		try enterRule(_localctx, 448, MySqlParser.RULE_userAuthOption)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5377)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,791, _ctx)) {
		 	case 1:
		 		_localctx =  HashAuthOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5352)
		 		try userName()
		 		setState(5353)
		 		try match(MySqlParser.Tokens.IDENTIFIED.rawValue)
		 		setState(5354)
		 		try match(MySqlParser.Tokens.BY.rawValue)
		 		setState(5355)
		 		try match(MySqlParser.Tokens.PASSWORD.rawValue)
		 		setState(5356)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(HashAuthOptionContext.self).hashed = assignmentValue
		 		     }()


		 		break
		 	case 2:
		 		_localctx =  RandomAuthOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5358)
		 		try userName()
		 		setState(5359)
		 		try match(MySqlParser.Tokens.IDENTIFIED.rawValue)
		 		setState(5360)
		 		try match(MySqlParser.Tokens.BY.rawValue)
		 		setState(5361)
		 		try match(MySqlParser.Tokens.RANDOM.rawValue)
		 		setState(5362)
		 		try match(MySqlParser.Tokens.PASSWORD.rawValue)
		 		setState(5363)
		 		try authOptionClause()

		 		break
		 	case 3:
		 		_localctx =  StringAuthOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5365)
		 		try userName()
		 		setState(5366)
		 		try match(MySqlParser.Tokens.IDENTIFIED.rawValue)
		 		setState(5367)
		 		try match(MySqlParser.Tokens.BY.rawValue)
		 		setState(5368)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 		setState(5369)
		 		try authOptionClause()

		 		break
		 	case 4:
		 		_localctx =  ModuleAuthOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5371)
		 		try userName()
		 		setState(5372)
		 		try match(MySqlParser.Tokens.IDENTIFIED.rawValue)
		 		setState(5373)
		 		try match(MySqlParser.Tokens.WITH.rawValue)
		 		setState(5374)
		 		try authenticationRule()

		 		break
		 	case 5:
		 		_localctx =  SimpleAuthOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5376)
		 		try userName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AuthOptionClauseContext: ParserRuleContext {
			open
			func REPLACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLACE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func RETAIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RETAIN.rawValue, 0)
			}
			open
			func CURRENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT.rawValue, 0)
			}
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_authOptionClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAuthOptionClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAuthOptionClause(self)
			}
		}
	}
	@discardableResult
	 open func authOptionClause() throws -> AuthOptionClauseContext {
		var _localctx: AuthOptionClauseContext
		_localctx = AuthOptionClauseContext(_ctx, getState())
		try enterRule(_localctx, 450, MySqlParser.RULE_authOptionClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5381)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,792,_ctx)) {
		 	case 1:
		 		setState(5379)
		 		try match(MySqlParser.Tokens.REPLACE.rawValue)
		 		setState(5380)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(5386)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.RETAIN.rawValue) {
		 		setState(5383)
		 		try match(MySqlParser.Tokens.RETAIN.rawValue)
		 		setState(5384)
		 		try match(MySqlParser.Tokens.CURRENT.rawValue)
		 		setState(5385)
		 		try match(MySqlParser.Tokens.PASSWORD.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AuthenticationRuleContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_authenticationRule
		}
	}
	public class PasswordModuleOptionContext: AuthenticationRuleContext {
			open
			func authPlugin() -> AuthPluginContext? {
				return getRuleContext(AuthPluginContext.self, 0)
			}
			open
			func USING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USING.rawValue, 0)
			}
			open
			func passwordFunctionClause() -> PasswordFunctionClauseContext? {
				return getRuleContext(PasswordFunctionClauseContext.self, 0)
			}

		public
		init(_ ctx: AuthenticationRuleContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPasswordModuleOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPasswordModuleOption(self)
			}
		}
	}
	public class ModuleContext: AuthenticationRuleContext {
			open
			func authPlugin() -> AuthPluginContext? {
				return getRuleContext(AuthPluginContext.self, 0)
			}
			open
			func authOptionClause() -> AuthOptionClauseContext? {
				return getRuleContext(AuthOptionClauseContext.self, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func USING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USING.rawValue, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func RANDOM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RANDOM.rawValue, 0)
			}
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD.rawValue, 0)
			}

		public
		init(_ ctx: AuthenticationRuleContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterModule(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitModule(self)
			}
		}
	}
	@discardableResult
	 open func authenticationRule() throws -> AuthenticationRuleContext {
		var _localctx: AuthenticationRuleContext
		_localctx = AuthenticationRuleContext(_ctx, getState())
		try enterRule(_localctx, 452, MySqlParser.RULE_authenticationRule)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5402)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,796, _ctx)) {
		 	case 1:
		 		_localctx =  ModuleContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5388)
		 		try authPlugin()
		 		setState(5396)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,795,_ctx)) {
		 		case 1:
		 			setState(5389)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.AS.rawValue || _la == MySqlParser.Tokens.BY.rawValue || _la == MySqlParser.Tokens.USING.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(5393)
		 			try _errHandler.sync(self)
		 			switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 			case .STRING_LITERAL:
		 				setState(5390)
		 				try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 				break

		 			case .RANDOM:
		 				setState(5391)
		 				try match(MySqlParser.Tokens.RANDOM.rawValue)
		 				setState(5392)
		 				try match(MySqlParser.Tokens.PASSWORD.rawValue)

		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(5395)
		 			try authOptionClause()

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		_localctx =  PasswordModuleOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5398)
		 		try authPlugin()
		 		setState(5399)
		 		try match(MySqlParser.Tokens.USING.rawValue)
		 		setState(5400)
		 		try passwordFunctionClause()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TlsOptionContext: ParserRuleContext {
			open
			func SSL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SSL.rawValue, 0)
			}
			open
			func X509() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.X509.rawValue, 0)
			}
			open
			func CIPHER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CIPHER.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func ISSUER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ISSUER.rawValue, 0)
			}
			open
			func SUBJECT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBJECT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tlsOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTlsOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTlsOption(self)
			}
		}
	}
	@discardableResult
	 open func tlsOption() throws -> TlsOptionContext {
		var _localctx: TlsOptionContext
		_localctx = TlsOptionContext(_ctx, getState())
		try enterRule(_localctx, 454, MySqlParser.RULE_tlsOption)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5412)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SSL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5404)
		 		try match(MySqlParser.Tokens.SSL.rawValue)

		 		break

		 	case .X509:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5405)
		 		try match(MySqlParser.Tokens.X509.rawValue)

		 		break

		 	case .CIPHER:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5406)
		 		try match(MySqlParser.Tokens.CIPHER.rawValue)
		 		setState(5407)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .ISSUER:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5408)
		 		try match(MySqlParser.Tokens.ISSUER.rawValue)
		 		setState(5409)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .SUBJECT:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5410)
		 		try match(MySqlParser.Tokens.SUBJECT.rawValue)
		 		setState(5411)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UserResourceOptionContext: ParserRuleContext {
			open
			func MAX_QUERIES_PER_HOUR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_QUERIES_PER_HOUR.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func MAX_UPDATES_PER_HOUR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_UPDATES_PER_HOUR.rawValue, 0)
			}
			open
			func MAX_CONNECTIONS_PER_HOUR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_CONNECTIONS_PER_HOUR.rawValue, 0)
			}
			open
			func MAX_USER_CONNECTIONS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_USER_CONNECTIONS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_userResourceOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUserResourceOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUserResourceOption(self)
			}
		}
	}
	@discardableResult
	 open func userResourceOption() throws -> UserResourceOptionContext {
		var _localctx: UserResourceOptionContext
		_localctx = UserResourceOptionContext(_ctx, getState())
		try enterRule(_localctx, 456, MySqlParser.RULE_userResourceOption)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5422)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .MAX_QUERIES_PER_HOUR:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5414)
		 		try match(MySqlParser.Tokens.MAX_QUERIES_PER_HOUR.rawValue)
		 		setState(5415)
		 		try decimalLiteral()

		 		break

		 	case .MAX_UPDATES_PER_HOUR:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5416)
		 		try match(MySqlParser.Tokens.MAX_UPDATES_PER_HOUR.rawValue)
		 		setState(5417)
		 		try decimalLiteral()

		 		break

		 	case .MAX_CONNECTIONS_PER_HOUR:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5418)
		 		try match(MySqlParser.Tokens.MAX_CONNECTIONS_PER_HOUR.rawValue)
		 		setState(5419)
		 		try decimalLiteral()

		 		break

		 	case .MAX_USER_CONNECTIONS:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5420)
		 		try match(MySqlParser.Tokens.MAX_USER_CONNECTIONS.rawValue)
		 		setState(5421)
		 		try decimalLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UserPasswordOptionContext: ParserRuleContext {
		open var expireType: Token!
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD.rawValue, 0)
			}
			open
			func EXPIRE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXPIRE.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func DAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DAY.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func NEVER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NEVER.rawValue, 0)
			}
			open
			func INTERVAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTERVAL.rawValue, 0)
			}
			open
			func HISTORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HISTORY.rawValue, 0)
			}
			open
			func REUSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REUSE.rawValue, 0)
			}
			open
			func REQUIRE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REQUIRE.rawValue, 0)
			}
			open
			func CURRENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT.rawValue, 0)
			}
			open
			func OPTIONAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTIONAL.rawValue, 0)
			}
			open
			func FAILED_LOGIN_ATTEMPTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FAILED_LOGIN_ATTEMPTS.rawValue, 0)
			}
			open
			func PASSWORD_LOCK_TIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD_LOCK_TIME.rawValue, 0)
			}
			open
			func UNBOUNDED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNBOUNDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_userPasswordOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUserPasswordOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUserPasswordOption(self)
			}
		}
	}
	@discardableResult
	 open func userPasswordOption() throws -> UserPasswordOptionContext {
		var _localctx: UserPasswordOptionContext
		_localctx = UserPasswordOptionContext(_ctx, getState())
		try enterRule(_localctx, 458, MySqlParser.RULE_userPasswordOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5462)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,804, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5424)
		 		try match(MySqlParser.Tokens.PASSWORD.rawValue)
		 		setState(5425)
		 		try match(MySqlParser.Tokens.EXPIRE.rawValue)
		 		setState(5432)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .DEFAULT:
		 		 	setState(5426)
		 		 	try {
		 		 			let assignmentValue = try match(MySqlParser.Tokens.DEFAULT.rawValue)
		 		 			_localctx.castdown(UserPasswordOptionContext.self).expireType = assignmentValue
		 		 	     }()


		 			break

		 		case .NEVER:
		 		 	setState(5427)
		 		 	try {
		 		 			let assignmentValue = try match(MySqlParser.Tokens.NEVER.rawValue)
		 		 			_localctx.castdown(UserPasswordOptionContext.self).expireType = assignmentValue
		 		 	     }()


		 			break

		 		case .INTERVAL:
		 		 	setState(5428)
		 		 	try {
		 		 			let assignmentValue = try match(MySqlParser.Tokens.INTERVAL.rawValue)
		 		 			_localctx.castdown(UserPasswordOptionContext.self).expireType = assignmentValue
		 		 	     }()

		 		 	setState(5429)
		 		 	try decimalLiteral()
		 		 	setState(5430)
		 		 	try match(MySqlParser.Tokens.DAY.rawValue)

		 			break
		 		case .EOF:fallthrough
		 		case .ALTER:fallthrough
		 		case .ANALYZE:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .CALL:fallthrough
		 		case .CHANGE:fallthrough
		 		case .CHECK:fallthrough
		 		case .CREATE:fallthrough
		 		case .DELETE:fallthrough
		 		case .DESC:fallthrough
		 		case .DESCRIBE:fallthrough
		 		case .DROP:fallthrough
		 		case .EXPLAIN:fallthrough
		 		case .GET:fallthrough
		 		case .GRANT:fallthrough
		 		case .INSERT:fallthrough
		 		case .KILL:fallthrough
		 		case .LOAD:fallthrough
		 		case .LOCK:fallthrough
		 		case .OPTIMIZE:fallthrough
		 		case .PURGE:fallthrough
		 		case .RELEASE:fallthrough
		 		case .RENAME:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RESIGNAL:fallthrough
		 		case .REVOKE:fallthrough
		 		case .SELECT:fallthrough
		 		case .SET:fallthrough
		 		case .SHOW:fallthrough
		 		case .SIGNAL:fallthrough
		 		case .TABLE:fallthrough
		 		case .UNLOCK:fallthrough
		 		case .UPDATE:fallthrough
		 		case .USE:fallthrough
		 		case .VALUES:fallthrough
		 		case .WITH:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .CACHE:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DO:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FLUSH:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HELP:fallthrough
		 		case .INSTALL:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PREPARE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .RESET:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .START:fallthrough
		 		case .STOP:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .XA:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .MINUS:fallthrough
		 		case .LR_BRACKET:fallthrough
		 		case .COMMA:fallthrough
		 		case .SEMI:
		 			break
		 		default:
		 			break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5434)
		 		try match(MySqlParser.Tokens.PASSWORD.rawValue)
		 		setState(5435)
		 		try match(MySqlParser.Tokens.HISTORY.rawValue)
		 		setState(5438)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .DEFAULT:
		 			setState(5436)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		case .ZERO_DECIMAL:fallthrough
		 		case .ONE_DECIMAL:fallthrough
		 		case .TWO_DECIMAL:fallthrough
		 		case .DECIMAL_LITERAL:fallthrough
		 		case .REAL_LITERAL:
		 			setState(5437)
		 			try decimalLiteral()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5440)
		 		try match(MySqlParser.Tokens.PASSWORD.rawValue)
		 		setState(5441)
		 		try match(MySqlParser.Tokens.REUSE.rawValue)
		 		setState(5442)
		 		try match(MySqlParser.Tokens.INTERVAL.rawValue)
		 		setState(5447)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .DEFAULT:
		 			setState(5443)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		case .ZERO_DECIMAL:fallthrough
		 		case .ONE_DECIMAL:fallthrough
		 		case .TWO_DECIMAL:fallthrough
		 		case .DECIMAL_LITERAL:fallthrough
		 		case .REAL_LITERAL:
		 			setState(5444)
		 			try decimalLiteral()
		 			setState(5445)
		 			try match(MySqlParser.Tokens.DAY.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5449)
		 		try match(MySqlParser.Tokens.PASSWORD.rawValue)
		 		setState(5450)
		 		try match(MySqlParser.Tokens.REQUIRE.rawValue)
		 		setState(5451)
		 		try match(MySqlParser.Tokens.CURRENT.rawValue)
		 		setState(5453)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.OPTIONAL.rawValue) {
		 			setState(5452)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.OPTIONAL.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}


		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5455)
		 		try match(MySqlParser.Tokens.FAILED_LOGIN_ATTEMPTS.rawValue)
		 		setState(5456)
		 		try decimalLiteral()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5457)
		 		try match(MySqlParser.Tokens.PASSWORD_LOCK_TIME.rawValue)
		 		setState(5460)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ZERO_DECIMAL:fallthrough
		 		case .ONE_DECIMAL:fallthrough
		 		case .TWO_DECIMAL:fallthrough
		 		case .DECIMAL_LITERAL:fallthrough
		 		case .REAL_LITERAL:
		 			setState(5458)
		 			try decimalLiteral()

		 			break

		 		case .UNBOUNDED:
		 			setState(5459)
		 			try match(MySqlParser.Tokens.UNBOUNDED.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UserLockOptionContext: ParserRuleContext {
		open var lockType: Token!
			open
			func ACCOUNT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ACCOUNT.rawValue, 0)
			}
			open
			func LOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCK.rawValue, 0)
			}
			open
			func UNLOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNLOCK.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_userLockOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUserLockOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUserLockOption(self)
			}
		}
	}
	@discardableResult
	 open func userLockOption() throws -> UserLockOptionContext {
		var _localctx: UserLockOptionContext
		_localctx = UserLockOptionContext(_ctx, getState())
		try enterRule(_localctx, 460, MySqlParser.RULE_userLockOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5464)
		 	try match(MySqlParser.Tokens.ACCOUNT.rawValue)
		 	setState(5465)
		 	_localctx.castdown(UserLockOptionContext.self).lockType = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.LOCK.rawValue || _la == MySqlParser.Tokens.UNLOCK.rawValue)) {
		 		_localctx.castdown(UserLockOptionContext.self).lockType = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PrivelegeClauseContext: ParserRuleContext {
			open
			func privilege() -> PrivilegeContext? {
				return getRuleContext(PrivilegeContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_privelegeClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPrivelegeClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPrivelegeClause(self)
			}
		}
	}
	@discardableResult
	 open func privelegeClause() throws -> PrivelegeClauseContext {
		var _localctx: PrivelegeClauseContext
		_localctx = PrivelegeClauseContext(_ctx, getState())
		try enterRule(_localctx, 462, MySqlParser.RULE_privelegeClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5467)
		 	try privilege()
		 	setState(5472)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 		setState(5468)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(5469)
		 		try uidList()
		 		setState(5470)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PrivilegeContext: ParserRuleContext {
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func PRIVILEGES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRIVILEGES.rawValue, 0)
			}
			open
			func ALTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALTER.rawValue, 0)
			}
			open
			func ROUTINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROUTINE.rawValue, 0)
			}
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func TEMPORARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TEMPORARY.rawValue, 0)
			}
			open
			func TABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLES.rawValue, 0)
			}
			open
			func VIEW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VIEW.rawValue, 0)
			}
			open
			func USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER.rawValue, 0)
			}
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}
			open
			func ROLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLE.rawValue, 0)
			}
			open
			func DELETE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DELETE.rawValue, 0)
			}
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func EVENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVENT.rawValue, 0)
			}
			open
			func EXECUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXECUTE.rawValue, 0)
			}
			open
			func FILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FILE.rawValue, 0)
			}
			open
			func GRANT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GRANT.rawValue, 0)
			}
			open
			func OPTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTION.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func INSERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSERT.rawValue, 0)
			}
			open
			func LOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCK.rawValue, 0)
			}
			open
			func PROCESS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCESS.rawValue, 0)
			}
			open
			func PROXY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROXY.rawValue, 0)
			}
			open
			func REFERENCES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REFERENCES.rawValue, 0)
			}
			open
			func RELOAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELOAD.rawValue, 0)
			}
			open
			func REPLICATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATION.rawValue, 0)
			}
			open
			func CLIENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CLIENT.rawValue, 0)
			}
			open
			func SLAVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SLAVE.rawValue, 0)
			}
			open
			func SELECT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SELECT.rawValue, 0)
			}
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func DATABASES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATABASES.rawValue, 0)
			}
			open
			func SHUTDOWN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHUTDOWN.rawValue, 0)
			}
			open
			func SUPER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUPER.rawValue, 0)
			}
			open
			func TRIGGER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRIGGER.rawValue, 0)
			}
			open
			func UPDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPDATE.rawValue, 0)
			}
			open
			func USAGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USAGE.rawValue, 0)
			}
			open
			func APPLICATION_PASSWORD_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.APPLICATION_PASSWORD_ADMIN.rawValue, 0)
			}
			open
			func AUDIT_ABORT_EXEMPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUDIT_ABORT_EXEMPT.rawValue, 0)
			}
			open
			func AUDIT_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUDIT_ADMIN.rawValue, 0)
			}
			open
			func AUTHENTICATION_POLICY_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTHENTICATION_POLICY_ADMIN.rawValue, 0)
			}
			open
			func BACKUP_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BACKUP_ADMIN.rawValue, 0)
			}
			open
			func BINLOG_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINLOG_ADMIN.rawValue, 0)
			}
			open
			func BINLOG_ENCRYPTION_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINLOG_ENCRYPTION_ADMIN.rawValue, 0)
			}
			open
			func CLONE_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CLONE_ADMIN.rawValue, 0)
			}
			open
			func CONNECTION_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONNECTION_ADMIN.rawValue, 0)
			}
			open
			func ENCRYPTION_KEY_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENCRYPTION_KEY_ADMIN.rawValue, 0)
			}
			open
			func FIREWALL_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIREWALL_ADMIN.rawValue, 0)
			}
			open
			func FIREWALL_EXEMPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIREWALL_EXEMPT.rawValue, 0)
			}
			open
			func FIREWALL_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIREWALL_USER.rawValue, 0)
			}
			open
			func FLUSH_OPTIMIZER_COSTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FLUSH_OPTIMIZER_COSTS.rawValue, 0)
			}
			open
			func FLUSH_STATUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FLUSH_STATUS.rawValue, 0)
			}
			open
			func FLUSH_TABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FLUSH_TABLES.rawValue, 0)
			}
			open
			func FLUSH_USER_RESOURCES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FLUSH_USER_RESOURCES.rawValue, 0)
			}
			open
			func GROUP_REPLICATION_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP_REPLICATION_ADMIN.rawValue, 0)
			}
			open
			func INNODB_REDO_LOG_ARCHIVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INNODB_REDO_LOG_ARCHIVE.rawValue, 0)
			}
			open
			func INNODB_REDO_LOG_ENABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INNODB_REDO_LOG_ENABLE.rawValue, 0)
			}
			open
			func NDB_STORED_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NDB_STORED_USER.rawValue, 0)
			}
			open
			func PASSWORDLESS_USER_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORDLESS_USER_ADMIN.rawValue, 0)
			}
			open
			func PERSIST_RO_VARIABLES_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PERSIST_RO_VARIABLES_ADMIN.rawValue, 0)
			}
			open
			func REPLICATION_APPLIER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATION_APPLIER.rawValue, 0)
			}
			open
			func REPLICATION_SLAVE_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATION_SLAVE_ADMIN.rawValue, 0)
			}
			open
			func RESOURCE_GROUP_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESOURCE_GROUP_ADMIN.rawValue, 0)
			}
			open
			func RESOURCE_GROUP_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESOURCE_GROUP_USER.rawValue, 0)
			}
			open
			func ROLE_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLE_ADMIN.rawValue, 0)
			}
			open
			func SERVICE_CONNECTION_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SERVICE_CONNECTION_ADMIN.rawValue, 0)
			}
			open
			func SESSION_VARIABLES_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SESSION_VARIABLES_ADMIN.rawValue, 0)
			}
			open
			func SET_USER_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET_USER_ID.rawValue, 0)
			}
			open
			func SKIP_QUERY_REWRITE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SKIP_QUERY_REWRITE.rawValue, 0)
			}
			open
			func SHOW_ROUTINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW_ROUTINE.rawValue, 0)
			}
			open
			func SYSTEM_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SYSTEM_USER.rawValue, 0)
			}
			open
			func SYSTEM_VARIABLES_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SYSTEM_VARIABLES_ADMIN.rawValue, 0)
			}
			open
			func TABLE_ENCRYPTION_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE_ENCRYPTION_ADMIN.rawValue, 0)
			}
			open
			func TP_CONNECTION_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TP_CONNECTION_ADMIN.rawValue, 0)
			}
			open
			func VERSION_TOKEN_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VERSION_TOKEN_ADMIN.rawValue, 0)
			}
			open
			func XA_RECOVER_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XA_RECOVER_ADMIN.rawValue, 0)
			}
			open
			func LOAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOAD.rawValue, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func S3() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.S3.rawValue, 0)
			}
			open
			func INTO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTO.rawValue, 0)
			}
			open
			func INVOKE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INVOKE.rawValue, 0)
			}
			open
			func LAMBDA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LAMBDA.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_privilege
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPrivilege(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPrivilege(self)
			}
		}
	}
	@discardableResult
	 open func privilege() throws -> PrivilegeContext {
		var _localctx: PrivilegeContext
		_localctx = PrivilegeContext(_ctx, getState())
		try enterRule(_localctx, 464, MySqlParser.RULE_privilege)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5567)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,810, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5474)
		 		try match(MySqlParser.Tokens.ALL.rawValue)
		 		setState(5476)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.PRIVILEGES.rawValue) {
		 			setState(5475)
		 			try match(MySqlParser.Tokens.PRIVILEGES.rawValue)

		 		}


		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5478)
		 		try match(MySqlParser.Tokens.ALTER.rawValue)
		 		setState(5480)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.ROUTINE.rawValue) {
		 			setState(5479)
		 			try match(MySqlParser.Tokens.ROUTINE.rawValue)

		 		}


		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5482)
		 		try match(MySqlParser.Tokens.CREATE.rawValue)
		 		setState(5490)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .TEMPORARY:
		 		 	setState(5483)
		 		 	try match(MySqlParser.Tokens.TEMPORARY.rawValue)
		 		 	setState(5484)
		 		 	try match(MySqlParser.Tokens.TABLES.rawValue)

		 			break

		 		case .ROUTINE:
		 		 	setState(5485)
		 		 	try match(MySqlParser.Tokens.ROUTINE.rawValue)

		 			break

		 		case .VIEW:
		 		 	setState(5486)
		 		 	try match(MySqlParser.Tokens.VIEW.rawValue)

		 			break

		 		case .USER:
		 		 	setState(5487)
		 		 	try match(MySqlParser.Tokens.USER.rawValue)

		 			break

		 		case .TABLESPACE:
		 		 	setState(5488)
		 		 	try match(MySqlParser.Tokens.TABLESPACE.rawValue)

		 			break

		 		case .ROLE:
		 		 	setState(5489)
		 		 	try match(MySqlParser.Tokens.ROLE.rawValue)

		 			break
		 		case .ON:fallthrough
		 		case .LR_BRACKET:fallthrough
		 		case .COMMA:
		 			break
		 		default:
		 			break
		 		}

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5492)
		 		try match(MySqlParser.Tokens.DELETE.rawValue)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5493)
		 		try match(MySqlParser.Tokens.DROP.rawValue)
		 		setState(5495)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.ROLE.rawValue) {
		 			setState(5494)
		 			try match(MySqlParser.Tokens.ROLE.rawValue)

		 		}


		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5497)
		 		try match(MySqlParser.Tokens.EVENT.rawValue)

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(5498)
		 		try match(MySqlParser.Tokens.EXECUTE.rawValue)

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(5499)
		 		try match(MySqlParser.Tokens.FILE.rawValue)

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(5500)
		 		try match(MySqlParser.Tokens.GRANT.rawValue)
		 		setState(5501)
		 		try match(MySqlParser.Tokens.OPTION.rawValue)

		 		break
		 	case 10:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(5502)
		 		try match(MySqlParser.Tokens.INDEX.rawValue)

		 		break
		 	case 11:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(5503)
		 		try match(MySqlParser.Tokens.INSERT.rawValue)

		 		break
		 	case 12:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(5504)
		 		try match(MySqlParser.Tokens.LOCK.rawValue)
		 		setState(5505)
		 		try match(MySqlParser.Tokens.TABLES.rawValue)

		 		break
		 	case 13:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(5506)
		 		try match(MySqlParser.Tokens.PROCESS.rawValue)

		 		break
		 	case 14:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(5507)
		 		try match(MySqlParser.Tokens.PROXY.rawValue)

		 		break
		 	case 15:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(5508)
		 		try match(MySqlParser.Tokens.REFERENCES.rawValue)

		 		break
		 	case 16:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(5509)
		 		try match(MySqlParser.Tokens.RELOAD.rawValue)

		 		break
		 	case 17:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(5510)
		 		try match(MySqlParser.Tokens.REPLICATION.rawValue)
		 		setState(5511)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.CLIENT.rawValue || _la == MySqlParser.Tokens.SLAVE.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 18:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(5512)
		 		try match(MySqlParser.Tokens.SELECT.rawValue)

		 		break
		 	case 19:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(5513)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5514)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DATABASES.rawValue || _la == MySqlParser.Tokens.VIEW.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 20:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(5515)
		 		try match(MySqlParser.Tokens.SHUTDOWN.rawValue)

		 		break
		 	case 21:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(5516)
		 		try match(MySqlParser.Tokens.SUPER.rawValue)

		 		break
		 	case 22:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(5517)
		 		try match(MySqlParser.Tokens.TRIGGER.rawValue)

		 		break
		 	case 23:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(5518)
		 		try match(MySqlParser.Tokens.UPDATE.rawValue)

		 		break
		 	case 24:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(5519)
		 		try match(MySqlParser.Tokens.USAGE.rawValue)

		 		break
		 	case 25:
		 		try enterOuterAlt(_localctx, 25)
		 		setState(5520)
		 		try match(MySqlParser.Tokens.APPLICATION_PASSWORD_ADMIN.rawValue)

		 		break
		 	case 26:
		 		try enterOuterAlt(_localctx, 26)
		 		setState(5521)
		 		try match(MySqlParser.Tokens.AUDIT_ABORT_EXEMPT.rawValue)

		 		break
		 	case 27:
		 		try enterOuterAlt(_localctx, 27)
		 		setState(5522)
		 		try match(MySqlParser.Tokens.AUDIT_ADMIN.rawValue)

		 		break
		 	case 28:
		 		try enterOuterAlt(_localctx, 28)
		 		setState(5523)
		 		try match(MySqlParser.Tokens.AUTHENTICATION_POLICY_ADMIN.rawValue)

		 		break
		 	case 29:
		 		try enterOuterAlt(_localctx, 29)
		 		setState(5524)
		 		try match(MySqlParser.Tokens.BACKUP_ADMIN.rawValue)

		 		break
		 	case 30:
		 		try enterOuterAlt(_localctx, 30)
		 		setState(5525)
		 		try match(MySqlParser.Tokens.BINLOG_ADMIN.rawValue)

		 		break
		 	case 31:
		 		try enterOuterAlt(_localctx, 31)
		 		setState(5526)
		 		try match(MySqlParser.Tokens.BINLOG_ENCRYPTION_ADMIN.rawValue)

		 		break
		 	case 32:
		 		try enterOuterAlt(_localctx, 32)
		 		setState(5527)
		 		try match(MySqlParser.Tokens.CLONE_ADMIN.rawValue)

		 		break
		 	case 33:
		 		try enterOuterAlt(_localctx, 33)
		 		setState(5528)
		 		try match(MySqlParser.Tokens.CONNECTION_ADMIN.rawValue)

		 		break
		 	case 34:
		 		try enterOuterAlt(_localctx, 34)
		 		setState(5529)
		 		try match(MySqlParser.Tokens.ENCRYPTION_KEY_ADMIN.rawValue)

		 		break
		 	case 35:
		 		try enterOuterAlt(_localctx, 35)
		 		setState(5530)
		 		try match(MySqlParser.Tokens.FIREWALL_ADMIN.rawValue)

		 		break
		 	case 36:
		 		try enterOuterAlt(_localctx, 36)
		 		setState(5531)
		 		try match(MySqlParser.Tokens.FIREWALL_EXEMPT.rawValue)

		 		break
		 	case 37:
		 		try enterOuterAlt(_localctx, 37)
		 		setState(5532)
		 		try match(MySqlParser.Tokens.FIREWALL_USER.rawValue)

		 		break
		 	case 38:
		 		try enterOuterAlt(_localctx, 38)
		 		setState(5533)
		 		try match(MySqlParser.Tokens.FLUSH_OPTIMIZER_COSTS.rawValue)

		 		break
		 	case 39:
		 		try enterOuterAlt(_localctx, 39)
		 		setState(5534)
		 		try match(MySqlParser.Tokens.FLUSH_STATUS.rawValue)

		 		break
		 	case 40:
		 		try enterOuterAlt(_localctx, 40)
		 		setState(5535)
		 		try match(MySqlParser.Tokens.FLUSH_TABLES.rawValue)

		 		break
		 	case 41:
		 		try enterOuterAlt(_localctx, 41)
		 		setState(5536)
		 		try match(MySqlParser.Tokens.FLUSH_USER_RESOURCES.rawValue)

		 		break
		 	case 42:
		 		try enterOuterAlt(_localctx, 42)
		 		setState(5537)
		 		try match(MySqlParser.Tokens.GROUP_REPLICATION_ADMIN.rawValue)

		 		break
		 	case 43:
		 		try enterOuterAlt(_localctx, 43)
		 		setState(5538)
		 		try match(MySqlParser.Tokens.INNODB_REDO_LOG_ARCHIVE.rawValue)

		 		break
		 	case 44:
		 		try enterOuterAlt(_localctx, 44)
		 		setState(5539)
		 		try match(MySqlParser.Tokens.INNODB_REDO_LOG_ENABLE.rawValue)

		 		break
		 	case 45:
		 		try enterOuterAlt(_localctx, 45)
		 		setState(5540)
		 		try match(MySqlParser.Tokens.NDB_STORED_USER.rawValue)

		 		break
		 	case 46:
		 		try enterOuterAlt(_localctx, 46)
		 		setState(5541)
		 		try match(MySqlParser.Tokens.PASSWORDLESS_USER_ADMIN.rawValue)

		 		break
		 	case 47:
		 		try enterOuterAlt(_localctx, 47)
		 		setState(5542)
		 		try match(MySqlParser.Tokens.PERSIST_RO_VARIABLES_ADMIN.rawValue)

		 		break
		 	case 48:
		 		try enterOuterAlt(_localctx, 48)
		 		setState(5543)
		 		try match(MySqlParser.Tokens.REPLICATION_APPLIER.rawValue)

		 		break
		 	case 49:
		 		try enterOuterAlt(_localctx, 49)
		 		setState(5544)
		 		try match(MySqlParser.Tokens.REPLICATION_SLAVE_ADMIN.rawValue)

		 		break
		 	case 50:
		 		try enterOuterAlt(_localctx, 50)
		 		setState(5545)
		 		try match(MySqlParser.Tokens.RESOURCE_GROUP_ADMIN.rawValue)

		 		break
		 	case 51:
		 		try enterOuterAlt(_localctx, 51)
		 		setState(5546)
		 		try match(MySqlParser.Tokens.RESOURCE_GROUP_USER.rawValue)

		 		break
		 	case 52:
		 		try enterOuterAlt(_localctx, 52)
		 		setState(5547)
		 		try match(MySqlParser.Tokens.ROLE_ADMIN.rawValue)

		 		break
		 	case 53:
		 		try enterOuterAlt(_localctx, 53)
		 		setState(5548)
		 		try match(MySqlParser.Tokens.SERVICE_CONNECTION_ADMIN.rawValue)

		 		break
		 	case 54:
		 		try enterOuterAlt(_localctx, 54)
		 		setState(5549)
		 		try match(MySqlParser.Tokens.SESSION_VARIABLES_ADMIN.rawValue)

		 		break
		 	case 55:
		 		try enterOuterAlt(_localctx, 55)
		 		setState(5550)
		 		try match(MySqlParser.Tokens.SET_USER_ID.rawValue)

		 		break
		 	case 56:
		 		try enterOuterAlt(_localctx, 56)
		 		setState(5551)
		 		try match(MySqlParser.Tokens.SKIP_QUERY_REWRITE.rawValue)

		 		break
		 	case 57:
		 		try enterOuterAlt(_localctx, 57)
		 		setState(5552)
		 		try match(MySqlParser.Tokens.SHOW_ROUTINE.rawValue)

		 		break
		 	case 58:
		 		try enterOuterAlt(_localctx, 58)
		 		setState(5553)
		 		try match(MySqlParser.Tokens.SYSTEM_USER.rawValue)

		 		break
		 	case 59:
		 		try enterOuterAlt(_localctx, 59)
		 		setState(5554)
		 		try match(MySqlParser.Tokens.SYSTEM_VARIABLES_ADMIN.rawValue)

		 		break
		 	case 60:
		 		try enterOuterAlt(_localctx, 60)
		 		setState(5555)
		 		try match(MySqlParser.Tokens.TABLE_ENCRYPTION_ADMIN.rawValue)

		 		break
		 	case 61:
		 		try enterOuterAlt(_localctx, 61)
		 		setState(5556)
		 		try match(MySqlParser.Tokens.TP_CONNECTION_ADMIN.rawValue)

		 		break
		 	case 62:
		 		try enterOuterAlt(_localctx, 62)
		 		setState(5557)
		 		try match(MySqlParser.Tokens.VERSION_TOKEN_ADMIN.rawValue)

		 		break
		 	case 63:
		 		try enterOuterAlt(_localctx, 63)
		 		setState(5558)
		 		try match(MySqlParser.Tokens.XA_RECOVER_ADMIN.rawValue)

		 		break
		 	case 64:
		 		try enterOuterAlt(_localctx, 64)
		 		setState(5559)
		 		try match(MySqlParser.Tokens.LOAD.rawValue)
		 		setState(5560)
		 		try match(MySqlParser.Tokens.FROM.rawValue)
		 		setState(5561)
		 		try match(MySqlParser.Tokens.S3.rawValue)

		 		break
		 	case 65:
		 		try enterOuterAlt(_localctx, 65)
		 		setState(5562)
		 		try match(MySqlParser.Tokens.SELECT.rawValue)
		 		setState(5563)
		 		try match(MySqlParser.Tokens.INTO.rawValue)
		 		setState(5564)
		 		try match(MySqlParser.Tokens.S3.rawValue)

		 		break
		 	case 66:
		 		try enterOuterAlt(_localctx, 66)
		 		setState(5565)
		 		try match(MySqlParser.Tokens.INVOKE.rawValue)
		 		setState(5566)
		 		try match(MySqlParser.Tokens.LAMBDA.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PrivilegeLevelContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_privilegeLevel
		}
	}
	public class DefiniteSchemaPrivLevelContext: PrivilegeLevelContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func DOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DOT.rawValue, 0)
			}
			open
			func STAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STAR.rawValue, 0)
			}

		public
		init(_ ctx: PrivilegeLevelContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDefiniteSchemaPrivLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDefiniteSchemaPrivLevel(self)
			}
		}
	}
	public class DefiniteFullTablePrivLevel2Context: PrivilegeLevelContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func dottedId() -> DottedIdContext? {
				return getRuleContext(DottedIdContext.self, 0)
			}

		public
		init(_ ctx: PrivilegeLevelContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDefiniteFullTablePrivLevel2(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDefiniteFullTablePrivLevel2(self)
			}
		}
	}
	public class DefiniteFullTablePrivLevelContext: PrivilegeLevelContext {
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func DOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DOT.rawValue, 0)
			}

		public
		init(_ ctx: PrivilegeLevelContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDefiniteFullTablePrivLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDefiniteFullTablePrivLevel(self)
			}
		}
	}
	public class GlobalPrivLevelContext: PrivilegeLevelContext {
			open
			func STAR() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.STAR.rawValue)
			}
			open
			func STAR(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STAR.rawValue, i)
			}
			open
			func DOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DOT.rawValue, 0)
			}

		public
		init(_ ctx: PrivilegeLevelContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterGlobalPrivLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitGlobalPrivLevel(self)
			}
		}
	}
	public class DefiniteTablePrivLevelContext: PrivilegeLevelContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}

		public
		init(_ ctx: PrivilegeLevelContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDefiniteTablePrivLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDefiniteTablePrivLevel(self)
			}
		}
	}
	public class CurrentSchemaPriviLevelContext: PrivilegeLevelContext {
			open
			func STAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STAR.rawValue, 0)
			}

		public
		init(_ ctx: PrivilegeLevelContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCurrentSchemaPriviLevel(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCurrentSchemaPriviLevel(self)
			}
		}
	}
	@discardableResult
	 open func privilegeLevel() throws -> PrivilegeLevelContext {
		var _localctx: PrivilegeLevelContext
		_localctx = PrivilegeLevelContext(_ctx, getState())
		try enterRule(_localctx, 466, MySqlParser.RULE_privilegeLevel)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5585)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,811, _ctx)) {
		 	case 1:
		 		_localctx =  CurrentSchemaPriviLevelContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5569)
		 		try match(MySqlParser.Tokens.STAR.rawValue)

		 		break
		 	case 2:
		 		_localctx =  GlobalPrivLevelContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5570)
		 		try match(MySqlParser.Tokens.STAR.rawValue)
		 		setState(5571)
		 		try match(MySqlParser.Tokens.DOT.rawValue)
		 		setState(5572)
		 		try match(MySqlParser.Tokens.STAR.rawValue)

		 		break
		 	case 3:
		 		_localctx =  DefiniteSchemaPrivLevelContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5573)
		 		try uid()
		 		setState(5574)
		 		try match(MySqlParser.Tokens.DOT.rawValue)
		 		setState(5575)
		 		try match(MySqlParser.Tokens.STAR.rawValue)

		 		break
		 	case 4:
		 		_localctx =  DefiniteFullTablePrivLevelContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5577)
		 		try uid()
		 		setState(5578)
		 		try match(MySqlParser.Tokens.DOT.rawValue)
		 		setState(5579)
		 		try uid()

		 		break
		 	case 5:
		 		_localctx =  DefiniteFullTablePrivLevel2Context(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5581)
		 		try uid()
		 		setState(5582)
		 		try dottedId()

		 		break
		 	case 6:
		 		_localctx =  DefiniteTablePrivLevelContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5584)
		 		try uid()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RenameUserClauseContext: ParserRuleContext {
		open var fromFirst: UserNameContext!
		open var toFirst: UserNameContext!
			open
			func TO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO.rawValue, 0)
			}
			open
			func userName() -> [UserNameContext] {
				return getRuleContexts(UserNameContext.self)
			}
			open
			func userName(_ i: Int) -> UserNameContext? {
				return getRuleContext(UserNameContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_renameUserClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRenameUserClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRenameUserClause(self)
			}
		}
	}
	@discardableResult
	 open func renameUserClause() throws -> RenameUserClauseContext {
		var _localctx: RenameUserClauseContext
		_localctx = RenameUserClauseContext(_ctx, getState())
		try enterRule(_localctx, 468, MySqlParser.RULE_renameUserClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5587)
		 	try {
		 			let assignmentValue = try userName()
		 			_localctx.castdown(RenameUserClauseContext.self).fromFirst = assignmentValue
		 	     }()

		 	setState(5588)
		 	try match(MySqlParser.Tokens.TO.rawValue)
		 	setState(5589)
		 	try {
		 			let assignmentValue = try userName()
		 			_localctx.castdown(RenameUserClauseContext.self).toFirst = assignmentValue
		 	     }()


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AnalyzeTableContext: ParserRuleContext {
		open var actionOption: Token!
			open
			func ANALYZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ANALYZE.rawValue, 0)
			}
			open
			func tables() -> TablesContext? {
				return getRuleContext(TablesContext.self, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func TABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLES.rawValue, 0)
			}
			open
			func UPDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPDATE.rawValue, 0)
			}
			open
			func HISTOGRAM() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.HISTOGRAM.rawValue)
			}
			open
			func HISTOGRAM(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HISTOGRAM.rawValue, i)
			}
			open
			func ON() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ON.rawValue)
			}
			open
			func ON(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, i)
			}
			open
			func fullColumnName() -> [FullColumnNameContext] {
				return getRuleContexts(FullColumnNameContext.self)
			}
			open
			func fullColumnName(_ i: Int) -> FullColumnNameContext? {
				return getRuleContext(FullColumnNameContext.self, i)
			}
			open
			func DROP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DROP.rawValue, 0)
			}
			open
			func NO_WRITE_TO_BINLOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func BUCKETS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BUCKETS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_analyzeTable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAnalyzeTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAnalyzeTable(self)
			}
		}
	}
	@discardableResult
	 open func analyzeTable() throws -> AnalyzeTableContext {
		var _localctx: AnalyzeTableContext
		_localctx = AnalyzeTableContext(_ctx, getState())
		try enterRule(_localctx, 470, MySqlParser.RULE_analyzeTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5591)
		 	try match(MySqlParser.Tokens.ANALYZE.rawValue)
		 	setState(5593)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue) {
		 		setState(5592)
		 		_localctx.castdown(AnalyzeTableContext.self).actionOption = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue)) {
		 			_localctx.castdown(AnalyzeTableContext.self).actionOption = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(5595)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.TABLE.rawValue || _la == MySqlParser.Tokens.TABLES.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5596)
		 	try tables()
		 	setState(5614)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,815,_ctx)) {
		 	case 1:
		 		setState(5597)
		 		try match(MySqlParser.Tokens.UPDATE.rawValue)
		 		setState(5598)
		 		try match(MySqlParser.Tokens.HISTOGRAM.rawValue)
		 		setState(5599)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(5600)
		 		try fullColumnName()
		 		setState(5605)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5601)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5602)
		 			try fullColumnName()


		 			setState(5607)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(5612)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,814,_ctx)) {
		 		case 1:
		 			setState(5608)
		 			try match(MySqlParser.Tokens.WITH.rawValue)
		 			setState(5609)
		 			try decimalLiteral()
		 			setState(5610)
		 			try match(MySqlParser.Tokens.BUCKETS.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		 	setState(5627)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,817,_ctx)) {
		 	case 1:
		 		setState(5616)
		 		try match(MySqlParser.Tokens.DROP.rawValue)
		 		setState(5617)
		 		try match(MySqlParser.Tokens.HISTOGRAM.rawValue)
		 		setState(5618)
		 		try match(MySqlParser.Tokens.ON.rawValue)
		 		setState(5619)
		 		try fullColumnName()
		 		setState(5624)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5620)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5621)
		 			try fullColumnName()


		 			setState(5626)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CheckTableContext: ParserRuleContext {
			open
			func CHECK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECK.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tables() -> TablesContext? {
				return getRuleContext(TablesContext.self, 0)
			}
			open
			func checkTableOption() -> [CheckTableOptionContext] {
				return getRuleContexts(CheckTableOptionContext.self)
			}
			open
			func checkTableOption(_ i: Int) -> CheckTableOptionContext? {
				return getRuleContext(CheckTableOptionContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_checkTable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCheckTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCheckTable(self)
			}
		}
	}
	@discardableResult
	 open func checkTable() throws -> CheckTableContext {
		var _localctx: CheckTableContext
		_localctx = CheckTableContext(_ctx, getState())
		try enterRule(_localctx, 472, MySqlParser.RULE_checkTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5629)
		 	try match(MySqlParser.Tokens.CHECK.rawValue)
		 	setState(5630)
		 	try match(MySqlParser.Tokens.TABLE.rawValue)
		 	setState(5631)
		 	try tables()
		 	setState(5635)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.FOR.rawValue || _la == MySqlParser.Tokens.CHANGED.rawValue || _la == MySqlParser.Tokens.EXTENDED.rawValue || _la == MySqlParser.Tokens.FAST.rawValue || _la == MySqlParser.Tokens.MEDIUM.rawValue || _la == MySqlParser.Tokens.QUICK.rawValue) {
		 		setState(5632)
		 		try checkTableOption()


		 		setState(5637)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ChecksumTableContext: ParserRuleContext {
		open var actionOption: Token!
			open
			func CHECKSUM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECKSUM.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tables() -> TablesContext? {
				return getRuleContext(TablesContext.self, 0)
			}
			open
			func QUICK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUICK.rawValue, 0)
			}
			open
			func EXTENDED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXTENDED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_checksumTable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterChecksumTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitChecksumTable(self)
			}
		}
	}
	@discardableResult
	 open func checksumTable() throws -> ChecksumTableContext {
		var _localctx: ChecksumTableContext
		_localctx = ChecksumTableContext(_ctx, getState())
		try enterRule(_localctx, 474, MySqlParser.RULE_checksumTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5638)
		 	try match(MySqlParser.Tokens.CHECKSUM.rawValue)
		 	setState(5639)
		 	try match(MySqlParser.Tokens.TABLE.rawValue)
		 	setState(5640)
		 	try tables()
		 	setState(5642)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.EXTENDED.rawValue || _la == MySqlParser.Tokens.QUICK.rawValue) {
		 		setState(5641)
		 		_localctx.castdown(ChecksumTableContext.self).actionOption = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.EXTENDED.rawValue || _la == MySqlParser.Tokens.QUICK.rawValue)) {
		 			_localctx.castdown(ChecksumTableContext.self).actionOption = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OptimizeTableContext: ParserRuleContext {
		open var actionOption: Token!
			open
			func OPTIMIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTIMIZE.rawValue, 0)
			}
			open
			func tables() -> TablesContext? {
				return getRuleContext(TablesContext.self, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func TABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLES.rawValue, 0)
			}
			open
			func NO_WRITE_TO_BINLOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_optimizeTable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterOptimizeTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitOptimizeTable(self)
			}
		}
	}
	@discardableResult
	 open func optimizeTable() throws -> OptimizeTableContext {
		var _localctx: OptimizeTableContext
		_localctx = OptimizeTableContext(_ctx, getState())
		try enterRule(_localctx, 476, MySqlParser.RULE_optimizeTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5644)
		 	try match(MySqlParser.Tokens.OPTIMIZE.rawValue)
		 	setState(5646)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue) {
		 		setState(5645)
		 		_localctx.castdown(OptimizeTableContext.self).actionOption = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue)) {
		 			_localctx.castdown(OptimizeTableContext.self).actionOption = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(5648)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.TABLE.rawValue || _la == MySqlParser.Tokens.TABLES.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5649)
		 	try tables()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RepairTableContext: ParserRuleContext {
		open var actionOption: Token!
			open
			func REPAIR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPAIR.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tables() -> TablesContext? {
				return getRuleContext(TablesContext.self, 0)
			}
			open
			func QUICK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUICK.rawValue, 0)
			}
			open
			func EXTENDED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXTENDED.rawValue, 0)
			}
			open
			func USE_FRM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USE_FRM.rawValue, 0)
			}
			open
			func NO_WRITE_TO_BINLOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_repairTable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRepairTable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRepairTable(self)
			}
		}
	}
	@discardableResult
	 open func repairTable() throws -> RepairTableContext {
		var _localctx: RepairTableContext
		_localctx = RepairTableContext(_ctx, getState())
		try enterRule(_localctx, 478, MySqlParser.RULE_repairTable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5651)
		 	try match(MySqlParser.Tokens.REPAIR.rawValue)
		 	setState(5653)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue) {
		 		setState(5652)
		 		_localctx.castdown(RepairTableContext.self).actionOption = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue)) {
		 			_localctx.castdown(RepairTableContext.self).actionOption = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(5655)
		 	try match(MySqlParser.Tokens.TABLE.rawValue)
		 	setState(5656)
		 	try tables()
		 	setState(5658)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.QUICK.rawValue) {
		 		setState(5657)
		 		try match(MySqlParser.Tokens.QUICK.rawValue)

		 	}

		 	setState(5661)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.EXTENDED.rawValue) {
		 		setState(5660)
		 		try match(MySqlParser.Tokens.EXTENDED.rawValue)

		 	}

		 	setState(5664)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.USE_FRM.rawValue) {
		 		setState(5663)
		 		try match(MySqlParser.Tokens.USE_FRM.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CheckTableOptionContext: ParserRuleContext {
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func UPGRADE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPGRADE.rawValue, 0)
			}
			open
			func QUICK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUICK.rawValue, 0)
			}
			open
			func FAST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FAST.rawValue, 0)
			}
			open
			func MEDIUM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEDIUM.rawValue, 0)
			}
			open
			func EXTENDED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXTENDED.rawValue, 0)
			}
			open
			func CHANGED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHANGED.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_checkTableOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCheckTableOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCheckTableOption(self)
			}
		}
	}
	@discardableResult
	 open func checkTableOption() throws -> CheckTableOptionContext {
		var _localctx: CheckTableOptionContext
		_localctx = CheckTableOptionContext(_ctx, getState())
		try enterRule(_localctx, 480, MySqlParser.RULE_checkTableOption)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5673)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FOR:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5666)
		 		try match(MySqlParser.Tokens.FOR.rawValue)
		 		setState(5667)
		 		try match(MySqlParser.Tokens.UPGRADE.rawValue)

		 		break

		 	case .QUICK:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5668)
		 		try match(MySqlParser.Tokens.QUICK.rawValue)

		 		break

		 	case .FAST:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5669)
		 		try match(MySqlParser.Tokens.FAST.rawValue)

		 		break

		 	case .MEDIUM:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5670)
		 		try match(MySqlParser.Tokens.MEDIUM.rawValue)

		 		break

		 	case .EXTENDED:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5671)
		 		try match(MySqlParser.Tokens.EXTENDED.rawValue)

		 		break

		 	case .CHANGED:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5672)
		 		try match(MySqlParser.Tokens.CHANGED.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CreateUdfunctionContext: ParserRuleContext {
		open var returnType: Token!
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FUNCTION.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func RETURNS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RETURNS.rawValue, 0)
			}
			open
			func SONAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SONAME.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func STRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING.rawValue, 0)
			}
			open
			func INTEGER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTEGER.rawValue, 0)
			}
			open
			func REAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REAL.rawValue, 0)
			}
			open
			func DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DECIMAL.rawValue, 0)
			}
			open
			func AGGREGATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AGGREGATE.rawValue, 0)
			}
			open
			func ifNotExists() -> IfNotExistsContext? {
				return getRuleContext(IfNotExistsContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_createUdfunction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCreateUdfunction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCreateUdfunction(self)
			}
		}
	}
	@discardableResult
	 open func createUdfunction() throws -> CreateUdfunctionContext {
		var _localctx: CreateUdfunctionContext
		_localctx = CreateUdfunctionContext(_ctx, getState())
		try enterRule(_localctx, 482, MySqlParser.RULE_createUdfunction)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5675)
		 	try match(MySqlParser.Tokens.CREATE.rawValue)
		 	setState(5677)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.AGGREGATE.rawValue) {
		 		setState(5676)
		 		try match(MySqlParser.Tokens.AGGREGATE.rawValue)

		 	}

		 	setState(5679)
		 	try match(MySqlParser.Tokens.FUNCTION.rawValue)
		 	setState(5681)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,827,_ctx)) {
		 	case 1:
		 		setState(5680)
		 		try ifNotExists()

		 		break
		 	default: break
		 	}
		 	setState(5683)
		 	try uid()
		 	setState(5684)
		 	try match(MySqlParser.Tokens.RETURNS.rawValue)
		 	setState(5685)
		 	_localctx.castdown(CreateUdfunctionContext.self).returnType = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(((Int64((_la - 206)) & ~0x3f) == 0 && ((Int64(1) << (_la - 206)) & 261) != 0) || _la == MySqlParser.Tokens.STRING.rawValue)) {
		 		_localctx.castdown(CreateUdfunctionContext.self).returnType = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(5686)
		 	try match(MySqlParser.Tokens.SONAME.rawValue)
		 	setState(5687)
		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class InstallPluginContext: ParserRuleContext {
			open
			func INSTALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSTALL.rawValue, 0)
			}
			open
			func PLUGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PLUGIN.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func SONAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SONAME.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_installPlugin
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterInstallPlugin(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitInstallPlugin(self)
			}
		}
	}
	@discardableResult
	 open func installPlugin() throws -> InstallPluginContext {
		var _localctx: InstallPluginContext
		_localctx = InstallPluginContext(_ctx, getState())
		try enterRule(_localctx, 484, MySqlParser.RULE_installPlugin)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5689)
		 	try match(MySqlParser.Tokens.INSTALL.rawValue)
		 	setState(5690)
		 	try match(MySqlParser.Tokens.PLUGIN.rawValue)
		 	setState(5691)
		 	try uid()
		 	setState(5692)
		 	try match(MySqlParser.Tokens.SONAME.rawValue)
		 	setState(5693)
		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UninstallPluginContext: ParserRuleContext {
			open
			func UNINSTALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNINSTALL.rawValue, 0)
			}
			open
			func PLUGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PLUGIN.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_uninstallPlugin
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUninstallPlugin(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUninstallPlugin(self)
			}
		}
	}
	@discardableResult
	 open func uninstallPlugin() throws -> UninstallPluginContext {
		var _localctx: UninstallPluginContext
		_localctx = UninstallPluginContext(_ctx, getState())
		try enterRule(_localctx, 486, MySqlParser.RULE_uninstallPlugin)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5695)
		 	try match(MySqlParser.Tokens.UNINSTALL.rawValue)
		 	setState(5696)
		 	try match(MySqlParser.Tokens.PLUGIN.rawValue)
		 	setState(5697)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SetStatementContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_setStatement
		}
	}
	public class SetTransactionContext: SetStatementContext {
			open
			func setTransactionStatement() -> SetTransactionStatementContext? {
				return getRuleContext(SetTransactionStatementContext.self, 0)
			}

		public
		init(_ ctx: SetStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSetTransaction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSetTransaction(self)
			}
		}
	}
	public class SetCharsetContext: SetStatementContext {
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func charSet() -> CharSetContext? {
				return getRuleContext(CharSetContext.self, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}

		public
		init(_ ctx: SetStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSetCharset(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSetCharset(self)
			}
		}
	}
	public class SetNamesContext: SetStatementContext {
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func NAMES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NAMES.rawValue, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func COLLATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATE.rawValue, 0)
			}
			open
			func collationName() -> CollationNameContext? {
				return getRuleContext(CollationNameContext.self, 0)
			}

		public
		init(_ ctx: SetStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSetNames(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSetNames(self)
			}
		}
	}
	public class SetPasswordContext: SetStatementContext {
			open
			func setPasswordStatement() -> SetPasswordStatementContext? {
				return getRuleContext(SetPasswordStatementContext.self, 0)
			}

		public
		init(_ ctx: SetStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSetPassword(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSetPassword(self)
			}
		}
	}
	public class SetAutocommitContext: SetStatementContext {
			open
			func setAutocommitStatement() -> SetAutocommitStatementContext? {
				return getRuleContext(SetAutocommitStatementContext.self, 0)
			}

		public
		init(_ ctx: SetStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSetAutocommit(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSetAutocommit(self)
			}
		}
	}
	public class SetNewValueInsideTriggerContext: SetStatementContext {
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func fullId() -> [FullIdContext] {
				return getRuleContexts(FullIdContext.self)
			}
			open
			func fullId(_ i: Int) -> FullIdContext? {
				return getRuleContext(FullIdContext.self, i)
			}
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
			open
			func VAR_ASSIGN() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.VAR_ASSIGN.rawValue)
			}
			open
			func VAR_ASSIGN(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VAR_ASSIGN.rawValue, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: SetStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSetNewValueInsideTrigger(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSetNewValueInsideTrigger(self)
			}
		}
	}
	public class SetVariableContext: SetStatementContext {
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func variableClause() -> [VariableClauseContext] {
				return getRuleContexts(VariableClauseContext.self)
			}
			open
			func variableClause(_ i: Int) -> VariableClauseContext? {
				return getRuleContext(VariableClauseContext.self, i)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
			open
			func VAR_ASSIGN() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.VAR_ASSIGN.rawValue)
			}
			open
			func VAR_ASSIGN(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VAR_ASSIGN.rawValue, i)
			}
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}
			open
			func ON() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ON.rawValue)
			}
			open
			func ON(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: SetStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSetVariable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSetVariable(self)
			}
		}
	}
	@discardableResult
	 open func setStatement() throws -> SetStatementContext {
		var _localctx: SetStatementContext
		_localctx = SetStatementContext(_ctx, getState())
		try enterRule(_localctx, 488, MySqlParser.RULE_setStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5751)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,835, _ctx)) {
		 	case 1:
		 		_localctx =  SetVariableContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5699)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(5700)
		 		try variableClause()
		 		setState(5701)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.VAR_ASSIGN.rawValue || _la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5704)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,828, _ctx)) {
		 		case 1:
		 			setState(5702)
		 			try expression(0)

		 			break
		 		case 2:
		 			setState(5703)
		 			try match(MySqlParser.Tokens.ON.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(5715)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5706)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5707)
		 			try variableClause()
		 			setState(5708)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.VAR_ASSIGN.rawValue || _la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(5711)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,829, _ctx)) {
		 			case 1:
		 				setState(5709)
		 				try expression(0)

		 				break
		 			case 2:
		 				setState(5710)
		 				try match(MySqlParser.Tokens.ON.rawValue)

		 				break
		 			default: break
		 			}


		 			setState(5717)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		_localctx =  SetCharsetContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5718)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(5719)
		 		try charSet()
		 		setState(5722)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .BINARY:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:
		 			setState(5720)
		 			try charsetName()

		 			break

		 		case .DEFAULT:
		 			setState(5721)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 3:
		 		_localctx =  SetNamesContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5724)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(5725)
		 		try match(MySqlParser.Tokens.NAMES.rawValue)
		 		setState(5732)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .BINARY:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:
		 			setState(5726)
		 			try charsetName()
		 			setState(5729)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.COLLATE.rawValue) {
		 				setState(5727)
		 				try match(MySqlParser.Tokens.COLLATE.rawValue)
		 				setState(5728)
		 				try collationName()

		 			}


		 			break

		 		case .DEFAULT:
		 			setState(5731)
		 			try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 4:
		 		_localctx =  SetPasswordContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5734)
		 		try setPasswordStatement()

		 		break
		 	case 5:
		 		_localctx =  SetTransactionContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5735)
		 		try setTransactionStatement()

		 		break
		 	case 6:
		 		_localctx =  SetAutocommitContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5736)
		 		try setAutocommitStatement()

		 		break
		 	case 7:
		 		_localctx =  SetNewValueInsideTriggerContext(_localctx);
		 		try enterOuterAlt(_localctx, 7)
		 		setState(5737)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(5738)
		 		try fullId()
		 		setState(5739)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.VAR_ASSIGN.rawValue || _la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5740)
		 		try expression(0)
		 		setState(5748)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5741)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5742)
		 			try fullId()
		 			setState(5743)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.VAR_ASSIGN.rawValue || _la == MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(5744)
		 			try expression(0)


		 			setState(5750)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ShowStatementContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_showStatement
		}
	}
	public class ShowOpenTablesContext: ShowStatementContext {
		public var schemaFormat: Token!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func OPEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPEN.rawValue, 0)
			}
			open
			func TABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLES.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func showFilter() -> ShowFilterContext? {
				return getRuleContext(ShowFilterContext.self, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowOpenTables(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowOpenTables(self)
			}
		}
	}
	public class ShowGlobalInfoContext: ShowStatementContext {
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func showGlobalInfoClause() -> ShowGlobalInfoClauseContext? {
				return getRuleContext(ShowGlobalInfoClauseContext.self, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowGlobalInfo(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowGlobalInfo(self)
			}
		}
	}
	public class ShowCreateFullIdObjectContext: ShowStatementContext {
		public var namedEntity: Token!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func EVENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVENT.rawValue, 0)
			}
			open
			func FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FUNCTION.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCEDURE.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func TRIGGER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRIGGER.rawValue, 0)
			}
			open
			func VIEW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VIEW.rawValue, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowCreateFullIdObject(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowCreateFullIdObject(self)
			}
		}
	}
	public class ShowCreateUserContext: ShowStatementContext {
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER.rawValue, 0)
			}
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowCreateUser(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowCreateUser(self)
			}
		}
	}
	public class ShowErrorsContext: ShowStatementContext {
		public var errorFormat: Token!
		public var offset: DecimalLiteralContext!
		public var rowCount: DecimalLiteralContext!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func ERRORS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ERRORS.rawValue, 0)
			}
			open
			func WARNINGS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WARNINGS.rawValue, 0)
			}
			open
			func LIMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIMIT.rawValue, 0)
			}
			open
			func decimalLiteral() -> [DecimalLiteralContext] {
				return getRuleContexts(DecimalLiteralContext.self)
			}
			open
			func decimalLiteral(_ i: Int) -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, i)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowErrors(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowErrors(self)
			}
		}
	}
	public class ShowCountErrorsContext: ShowStatementContext {
		public var errorFormat: Token!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func COUNT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COUNT.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func STAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STAR.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func ERRORS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ERRORS.rawValue, 0)
			}
			open
			func WARNINGS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WARNINGS.rawValue, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowCountErrors(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowCountErrors(self)
			}
		}
	}
	public class ShowObjectFilterContext: ShowStatementContext {
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func showCommonEntity() -> ShowCommonEntityContext? {
				return getRuleContext(ShowCommonEntityContext.self, 0)
			}
			open
			func showFilter() -> ShowFilterContext? {
				return getRuleContext(ShowFilterContext.self, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowObjectFilter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowObjectFilter(self)
			}
		}
	}
	public class ShowCreateDbContext: ShowStatementContext {
		public var schemaFormat: Token!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func CREATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func DATABASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATABASE.rawValue, 0)
			}
			open
			func SCHEMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEMA.rawValue, 0)
			}
			open
			func ifNotExists() -> IfNotExistsContext? {
				return getRuleContext(IfNotExistsContext.self, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowCreateDb(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowCreateDb(self)
			}
		}
	}
	public class ShowEngineContext: ShowStatementContext {
		public var engineOption: Token!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func engineName() -> EngineNameContext? {
				return getRuleContext(EngineNameContext.self, 0)
			}
			open
			func STATUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATUS.rawValue, 0)
			}
			open
			func MUTEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MUTEX.rawValue, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowEngine(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowEngine(self)
			}
		}
	}
	public class ShowSchemaFilterContext: ShowStatementContext {
		public var schemaFormat: Token!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func showSchemaEntity() -> ShowSchemaEntityContext? {
				return getRuleContext(ShowSchemaEntityContext.self, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func showFilter() -> ShowFilterContext? {
				return getRuleContext(ShowFilterContext.self, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowSchemaFilter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowSchemaFilter(self)
			}
		}
	}
	public class ShowIndexesContext: ShowStatementContext {
		public var indexFormat: Token!
		public var tableFormat: Token!
		public var schemaFormat: Token!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func INDEXES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEXES.rawValue, 0)
			}
			open
			func KEYS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEYS.rawValue, 0)
			}
			open
			func FROM() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.FROM.rawValue)
			}
			open
			func FROM(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, i)
			}
			open
			func IN() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.IN.rawValue)
			}
			open
			func IN(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, i)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func WHERE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHERE.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowIndexes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowIndexes(self)
			}
		}
	}
	public class ShowLogEventsContext: ShowStatementContext {
		public var logFormat: Token!
		public var filename: Token!
		public var fromPosition: DecimalLiteralContext!
		public var offset: DecimalLiteralContext!
		public var rowCount: DecimalLiteralContext!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func EVENTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVENTS.rawValue, 0)
			}
			open
			func BINLOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINLOG.rawValue, 0)
			}
			open
			func RELAYLOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELAYLOG.rawValue, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func LIMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIMIT.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func decimalLiteral() -> [DecimalLiteralContext] {
				return getRuleContexts(DecimalLiteralContext.self)
			}
			open
			func decimalLiteral(_ i: Int) -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, i)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowLogEvents(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowLogEvents(self)
			}
		}
	}
	public class ShowMasterLogsContext: ShowStatementContext {
		public var logFormat: Token!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func LOGS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOGS.rawValue, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}
			open
			func MASTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER.rawValue, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowMasterLogs(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowMasterLogs(self)
			}
		}
	}
	public class ShowGrantsContext: ShowStatementContext {
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func GRANTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GRANTS.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowGrants(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowGrants(self)
			}
		}
	}
	public class ShowSlaveStatusContext: ShowStatementContext {
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func SLAVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SLAVE.rawValue, 0)
			}
			open
			func STATUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATUS.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func CHANNEL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHANNEL.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowSlaveStatus(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowSlaveStatus(self)
			}
		}
	}
	public class ShowRoutineContext: ShowStatementContext {
		public var routine: Token!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func CODE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CODE.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FUNCTION.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCEDURE.rawValue, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowRoutine(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowRoutine(self)
			}
		}
	}
	public class ShowProfileContext: ShowStatementContext {
		public var queryCount: DecimalLiteralContext!
		public var offset: DecimalLiteralContext!
		public var rowCount: DecimalLiteralContext!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func PROFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROFILE.rawValue, 0)
			}
			open
			func showProfileType() -> [ShowProfileTypeContext] {
				return getRuleContexts(ShowProfileTypeContext.self)
			}
			open
			func showProfileType(_ i: Int) -> ShowProfileTypeContext? {
				return getRuleContext(ShowProfileTypeContext.self, i)
			}
			open
			func LIMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIMIT.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func QUERY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUERY.rawValue, 0)
			}
			open
			func decimalLiteral() -> [DecimalLiteralContext] {
				return getRuleContexts(DecimalLiteralContext.self)
			}
			open
			func decimalLiteral(_ i: Int) -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, i)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowProfile(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowProfile(self)
			}
		}
	}
	public class ShowColumnsContext: ShowStatementContext {
		public var columnsFormat: Token!
		public var tableFormat: Token!
		public var schemaFormat: Token!
			open
			func SHOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func COLUMNS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMNS.rawValue, 0)
			}
			open
			func FIELDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIELDS.rawValue, 0)
			}
			open
			func FROM() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.FROM.rawValue)
			}
			open
			func FROM(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, i)
			}
			open
			func IN() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.IN.rawValue)
			}
			open
			func IN(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, i)
			}
			open
			func FULL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FULL.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func showFilter() -> ShowFilterContext? {
				return getRuleContext(ShowFilterContext.self, 0)
			}

		public
		init(_ ctx: ShowStatementContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowColumns(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowColumns(self)
			}
		}
	}
	@discardableResult
	 open func showStatement() throws -> ShowStatementContext {
		var _localctx: ShowStatementContext
		_localctx = ShowStatementContext(_ctx, getState())
		try enterRule(_localctx, 490, MySqlParser.RULE_showStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5906)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,858, _ctx)) {
		 	case 1:
		 		_localctx =  ShowMasterLogsContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5753)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5754)
		 		_localctx.castdown(ShowMasterLogsContext.self).logFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.BINARY.rawValue || _la == MySqlParser.Tokens.MASTER.rawValue)) {
		 			_localctx.castdown(ShowMasterLogsContext.self).logFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5755)
		 		try match(MySqlParser.Tokens.LOGS.rawValue)

		 		break
		 	case 2:
		 		_localctx =  ShowLogEventsContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5756)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5757)
		 		_localctx.castdown(ShowLogEventsContext.self).logFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.BINLOG.rawValue || _la == MySqlParser.Tokens.RELAYLOG.rawValue)) {
		 			_localctx.castdown(ShowLogEventsContext.self).logFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5758)
		 		try match(MySqlParser.Tokens.EVENTS.rawValue)
		 		setState(5761)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.IN.rawValue) {
		 			setState(5759)
		 			try match(MySqlParser.Tokens.IN.rawValue)
		 			setState(5760)
		 			try {
		 					let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 					_localctx.castdown(ShowLogEventsContext.self).filename = assignmentValue
		 			     }()


		 		}

		 		setState(5765)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FROM.rawValue) {
		 			setState(5763)
		 			try match(MySqlParser.Tokens.FROM.rawValue)
		 			setState(5764)
		 			try {
		 					let assignmentValue = try decimalLiteral()
		 					_localctx.castdown(ShowLogEventsContext.self).fromPosition = assignmentValue
		 			     }()


		 		}

		 		setState(5774)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LIMIT.rawValue) {
		 			setState(5767)
		 			try match(MySqlParser.Tokens.LIMIT.rawValue)
		 			setState(5771)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,838,_ctx)) {
		 			case 1:
		 				setState(5768)
		 				try {
		 						let assignmentValue = try decimalLiteral()
		 						_localctx.castdown(ShowLogEventsContext.self).offset = assignmentValue
		 				     }()

		 				setState(5769)
		 				try match(MySqlParser.Tokens.COMMA.rawValue)

		 				break
		 			default: break
		 			}
		 			setState(5773)
		 			try {
		 					let assignmentValue = try decimalLiteral()
		 					_localctx.castdown(ShowLogEventsContext.self).rowCount = assignmentValue
		 			     }()


		 		}


		 		break
		 	case 3:
		 		_localctx =  ShowObjectFilterContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5776)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5777)
		 		try showCommonEntity()
		 		setState(5779)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LIKE.rawValue || _la == MySqlParser.Tokens.WHERE.rawValue) {
		 			setState(5778)
		 			try showFilter()

		 		}


		 		break
		 	case 4:
		 		_localctx =  ShowColumnsContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5781)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5783)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FULL.rawValue) {
		 			setState(5782)
		 			try match(MySqlParser.Tokens.FULL.rawValue)

		 		}

		 		setState(5785)
		 		_localctx.castdown(ShowColumnsContext.self).columnsFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.COLUMNS.rawValue || _la == MySqlParser.Tokens.FIELDS.rawValue)) {
		 			_localctx.castdown(ShowColumnsContext.self).columnsFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5786)
		 		_localctx.castdown(ShowColumnsContext.self).tableFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FROM.rawValue || _la == MySqlParser.Tokens.IN.rawValue)) {
		 			_localctx.castdown(ShowColumnsContext.self).tableFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5787)
		 		try tableName()
		 		setState(5790)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FROM.rawValue || _la == MySqlParser.Tokens.IN.rawValue) {
		 			setState(5788)
		 			_localctx.castdown(ShowColumnsContext.self).schemaFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.FROM.rawValue || _la == MySqlParser.Tokens.IN.rawValue)) {
		 				_localctx.castdown(ShowColumnsContext.self).schemaFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(5789)
		 			try uid()

		 		}

		 		setState(5793)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LIKE.rawValue || _la == MySqlParser.Tokens.WHERE.rawValue) {
		 			setState(5792)
		 			try showFilter()

		 		}


		 		break
		 	case 5:
		 		_localctx =  ShowCreateDbContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5795)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5796)
		 		try match(MySqlParser.Tokens.CREATE.rawValue)
		 		setState(5797)
		 		_localctx.castdown(ShowCreateDbContext.self).schemaFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DATABASE.rawValue || _la == MySqlParser.Tokens.SCHEMA.rawValue)) {
		 			_localctx.castdown(ShowCreateDbContext.self).schemaFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5799)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,844,_ctx)) {
		 		case 1:
		 			setState(5798)
		 			try ifNotExists()

		 			break
		 		default: break
		 		}
		 		setState(5801)
		 		try uid()

		 		break
		 	case 6:
		 		_localctx =  ShowCreateFullIdObjectContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5802)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5803)
		 		try match(MySqlParser.Tokens.CREATE.rawValue)
		 		setState(5804)
		 		_localctx.castdown(ShowCreateFullIdObjectContext.self).namedEntity = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 131)) & ~0x3f) == 0 && ((Int64(1) << (_la - 131)) & 72567767433217) != 0) || _la == MySqlParser.Tokens.EVENT.rawValue || _la == MySqlParser.Tokens.FUNCTION.rawValue || _la == MySqlParser.Tokens.VIEW.rawValue)) {
		 			_localctx.castdown(ShowCreateFullIdObjectContext.self).namedEntity = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5805)
		 		try fullId()

		 		break
		 	case 7:
		 		_localctx =  ShowCreateUserContext(_localctx);
		 		try enterOuterAlt(_localctx, 7)
		 		setState(5806)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5807)
		 		try match(MySqlParser.Tokens.CREATE.rawValue)
		 		setState(5808)
		 		try match(MySqlParser.Tokens.USER.rawValue)
		 		setState(5809)
		 		try userName()

		 		break
		 	case 8:
		 		_localctx =  ShowEngineContext(_localctx);
		 		try enterOuterAlt(_localctx, 8)
		 		setState(5810)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5811)
		 		try match(MySqlParser.Tokens.ENGINE.rawValue)
		 		setState(5812)
		 		try engineName()
		 		setState(5813)
		 		_localctx.castdown(ShowEngineContext.self).engineOption = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.MUTEX.rawValue || _la == MySqlParser.Tokens.STATUS.rawValue)) {
		 			_localctx.castdown(ShowEngineContext.self).engineOption = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 9:
		 		_localctx =  ShowGlobalInfoContext(_localctx);
		 		try enterOuterAlt(_localctx, 9)
		 		setState(5815)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5816)
		 		try showGlobalInfoClause()

		 		break
		 	case 10:
		 		_localctx =  ShowErrorsContext(_localctx);
		 		try enterOuterAlt(_localctx, 10)
		 		setState(5817)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5818)
		 		_localctx.castdown(ShowErrorsContext.self).errorFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ERRORS.rawValue || _la == MySqlParser.Tokens.WARNINGS.rawValue)) {
		 			_localctx.castdown(ShowErrorsContext.self).errorFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5826)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LIMIT.rawValue) {
		 			setState(5819)
		 			try match(MySqlParser.Tokens.LIMIT.rawValue)
		 			setState(5823)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,845,_ctx)) {
		 			case 1:
		 				setState(5820)
		 				try {
		 						let assignmentValue = try decimalLiteral()
		 						_localctx.castdown(ShowErrorsContext.self).offset = assignmentValue
		 				     }()

		 				setState(5821)
		 				try match(MySqlParser.Tokens.COMMA.rawValue)

		 				break
		 			default: break
		 			}
		 			setState(5825)
		 			try {
		 					let assignmentValue = try decimalLiteral()
		 					_localctx.castdown(ShowErrorsContext.self).rowCount = assignmentValue
		 			     }()


		 		}


		 		break
		 	case 11:
		 		_localctx =  ShowCountErrorsContext(_localctx);
		 		try enterOuterAlt(_localctx, 11)
		 		setState(5828)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5829)
		 		try match(MySqlParser.Tokens.COUNT.rawValue)
		 		setState(5830)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(5831)
		 		try match(MySqlParser.Tokens.STAR.rawValue)
		 		setState(5832)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(5833)
		 		_localctx.castdown(ShowCountErrorsContext.self).errorFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ERRORS.rawValue || _la == MySqlParser.Tokens.WARNINGS.rawValue)) {
		 			_localctx.castdown(ShowCountErrorsContext.self).errorFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 12:
		 		_localctx =  ShowSchemaFilterContext(_localctx);
		 		try enterOuterAlt(_localctx, 12)
		 		setState(5834)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5835)
		 		try showSchemaEntity()
		 		setState(5838)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FROM.rawValue || _la == MySqlParser.Tokens.IN.rawValue) {
		 			setState(5836)
		 			_localctx.castdown(ShowSchemaFilterContext.self).schemaFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.FROM.rawValue || _la == MySqlParser.Tokens.IN.rawValue)) {
		 				_localctx.castdown(ShowSchemaFilterContext.self).schemaFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(5837)
		 			try uid()

		 		}

		 		setState(5841)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LIKE.rawValue || _la == MySqlParser.Tokens.WHERE.rawValue) {
		 			setState(5840)
		 			try showFilter()

		 		}


		 		break
		 	case 13:
		 		_localctx =  ShowRoutineContext(_localctx);
		 		try enterOuterAlt(_localctx, 13)
		 		setState(5843)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5844)
		 		_localctx.castdown(ShowRoutineContext.self).routine = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.PROCEDURE.rawValue || _la == MySqlParser.Tokens.FUNCTION.rawValue)) {
		 			_localctx.castdown(ShowRoutineContext.self).routine = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5845)
		 		try match(MySqlParser.Tokens.CODE.rawValue)
		 		setState(5846)
		 		try fullId()

		 		break
		 	case 14:
		 		_localctx =  ShowGrantsContext(_localctx);
		 		try enterOuterAlt(_localctx, 14)
		 		setState(5847)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5848)
		 		try match(MySqlParser.Tokens.GRANTS.rawValue)
		 		setState(5851)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FOR.rawValue) {
		 			setState(5849)
		 			try match(MySqlParser.Tokens.FOR.rawValue)
		 			setState(5850)
		 			try userName()

		 		}


		 		break
		 	case 15:
		 		_localctx =  ShowIndexesContext(_localctx);
		 		try enterOuterAlt(_localctx, 15)
		 		setState(5853)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5854)
		 		_localctx.castdown(ShowIndexesContext.self).indexFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEYS.rawValue || _la == MySqlParser.Tokens.INDEXES.rawValue)) {
		 			_localctx.castdown(ShowIndexesContext.self).indexFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5855)
		 		_localctx.castdown(ShowIndexesContext.self).tableFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FROM.rawValue || _la == MySqlParser.Tokens.IN.rawValue)) {
		 			_localctx.castdown(ShowIndexesContext.self).tableFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(5856)
		 		try tableName()
		 		setState(5859)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FROM.rawValue || _la == MySqlParser.Tokens.IN.rawValue) {
		 			setState(5857)
		 			_localctx.castdown(ShowIndexesContext.self).schemaFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.FROM.rawValue || _la == MySqlParser.Tokens.IN.rawValue)) {
		 				_localctx.castdown(ShowIndexesContext.self).schemaFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(5858)
		 			try uid()

		 		}

		 		setState(5863)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.WHERE.rawValue) {
		 			setState(5861)
		 			try match(MySqlParser.Tokens.WHERE.rawValue)
		 			setState(5862)
		 			try expression(0)

		 		}


		 		break
		 	case 16:
		 		_localctx =  ShowOpenTablesContext(_localctx);
		 		try enterOuterAlt(_localctx, 16)
		 		setState(5865)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5866)
		 		try match(MySqlParser.Tokens.OPEN.rawValue)
		 		setState(5867)
		 		try match(MySqlParser.Tokens.TABLES.rawValue)
		 		setState(5870)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FROM.rawValue || _la == MySqlParser.Tokens.IN.rawValue) {
		 			setState(5868)
		 			_localctx.castdown(ShowOpenTablesContext.self).schemaFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.FROM.rawValue || _la == MySqlParser.Tokens.IN.rawValue)) {
		 				_localctx.castdown(ShowOpenTablesContext.self).schemaFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(5869)
		 			try uid()

		 		}

		 		setState(5873)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LIKE.rawValue || _la == MySqlParser.Tokens.WHERE.rawValue) {
		 			setState(5872)
		 			try showFilter()

		 		}


		 		break
		 	case 17:
		 		_localctx =  ShowProfileContext(_localctx);
		 		try enterOuterAlt(_localctx, 17)
		 		setState(5875)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5876)
		 		try match(MySqlParser.Tokens.PROFILE.rawValue)
		 		setState(5877)
		 		try showProfileType()
		 		setState(5882)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(5878)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(5879)
		 			try showProfileType()


		 			setState(5884)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}
		 		setState(5888)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FOR.rawValue) {
		 			setState(5885)
		 			try match(MySqlParser.Tokens.FOR.rawValue)
		 			setState(5886)
		 			try match(MySqlParser.Tokens.QUERY.rawValue)
		 			setState(5887)
		 			try {
		 					let assignmentValue = try decimalLiteral()
		 					_localctx.castdown(ShowProfileContext.self).queryCount = assignmentValue
		 			     }()


		 		}

		 		setState(5890)
		 		try match(MySqlParser.Tokens.LIMIT.rawValue)
		 		setState(5894)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,856,_ctx)) {
		 		case 1:
		 			setState(5891)
		 			try {
		 					let assignmentValue = try decimalLiteral()
		 					_localctx.castdown(ShowProfileContext.self).offset = assignmentValue
		 			     }()

		 			setState(5892)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(5896)
		 		try {
		 				let assignmentValue = try decimalLiteral()
		 				_localctx.castdown(ShowProfileContext.self).rowCount = assignmentValue
		 		     }()



		 		break
		 	case 18:
		 		_localctx =  ShowSlaveStatusContext(_localctx);
		 		try enterOuterAlt(_localctx, 18)
		 		setState(5898)
		 		try match(MySqlParser.Tokens.SHOW.rawValue)
		 		setState(5899)
		 		try match(MySqlParser.Tokens.SLAVE.rawValue)
		 		setState(5900)
		 		try match(MySqlParser.Tokens.STATUS.rawValue)
		 		setState(5904)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FOR.rawValue) {
		 			setState(5901)
		 			try match(MySqlParser.Tokens.FOR.rawValue)
		 			setState(5902)
		 			try match(MySqlParser.Tokens.CHANNEL.rawValue)
		 			setState(5903)
		 			try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		}


		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class VariableClauseContext: ParserRuleContext {
			open
			func LOCAL_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL_ID.rawValue, 0)
			}
			open
			func GLOBAL_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GLOBAL_ID.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func GLOBAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GLOBAL.rawValue, 0)
			}
			open
			func SESSION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SESSION.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL.rawValue, 0)
			}
			open
			func AT_SIGN() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.AT_SIGN.rawValue)
			}
			open
			func AT_SIGN(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AT_SIGN.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_variableClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterVariableClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitVariableClause(self)
			}
		}
	}
	@discardableResult
	 open func variableClause() throws -> VariableClauseContext {
		var _localctx: VariableClauseContext
		_localctx = VariableClauseContext(_ctx, getState())
		try enterRule(_localctx, 492, MySqlParser.RULE_variableClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5918)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LOCAL_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5908)
		 		try match(MySqlParser.Tokens.LOCAL_ID.rawValue)

		 		break

		 	case .GLOBAL_ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5909)
		 		try match(MySqlParser.Tokens.GLOBAL_ID.rawValue)

		 		break
		 	case .ARRAY:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .BUCKETS:fallthrough
		 	case .CONDITION:fallthrough
		 	case .CURRENT:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DIAGNOSTICS:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENFORCED:fallthrough
		 	case .EXCEPT:fallthrough
		 	case .GROUP:fallthrough
		 	case .IF:fallthrough
		 	case .IGNORED:fallthrough
		 	case .INSERT:fallthrough
		 	case .LATERAL:fallthrough
		 	case .LEFT:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OPTIONAL:fallthrough
		 	case .ORDER:fallthrough
		 	case .PRIMARY:fallthrough
		 	case .REPEAT:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SKIP_QUERY_REWRITE:fallthrough
		 	case .STACKED:fallthrough
		 	case .DATE:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .DATETIME:fallthrough
		 	case .YEAR:fallthrough
		 	case .BINARY:fallthrough
		 	case .TEXT:fallthrough
		 	case .ENUM:fallthrough
		 	case .SERIAL:fallthrough
		 	case .JSON_ARRAY:fallthrough
		 	case .JSON_ARRAYAGG:fallthrough
		 	case .JSON_ARRAY_APPEND:fallthrough
		 	case .JSON_ARRAY_INSERT:fallthrough
		 	case .JSON_CONTAINS:fallthrough
		 	case .JSON_CONTAINS_PATH:fallthrough
		 	case .JSON_DEPTH:fallthrough
		 	case .JSON_EXTRACT:fallthrough
		 	case .JSON_INSERT:fallthrough
		 	case .JSON_KEYS:fallthrough
		 	case .JSON_LENGTH:fallthrough
		 	case .JSON_MERGE:fallthrough
		 	case .JSON_MERGE_PATCH:fallthrough
		 	case .JSON_MERGE_PRESERVE:fallthrough
		 	case .JSON_OBJECT:fallthrough
		 	case .JSON_OBJECTAGG:fallthrough
		 	case .JSON_OVERLAPS:fallthrough
		 	case .JSON_PRETTY:fallthrough
		 	case .JSON_QUOTE:fallthrough
		 	case .JSON_REMOVE:fallthrough
		 	case .JSON_REPLACE:fallthrough
		 	case .JSON_SCHEMA_VALID:fallthrough
		 	case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 	case .JSON_SEARCH:fallthrough
		 	case .JSON_SET:fallthrough
		 	case .JSON_STORAGE_FREE:fallthrough
		 	case .JSON_STORAGE_SIZE:fallthrough
		 	case .JSON_TABLE:fallthrough
		 	case .JSON_TYPE:fallthrough
		 	case .JSON_UNQUOTE:fallthrough
		 	case .JSON_VALID:fallthrough
		 	case .JSON_VALUE:fallthrough
		 	case .NESTED:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .PATH:fallthrough
		 	case .AVG:fallthrough
		 	case .BIT_AND:fallthrough
		 	case .BIT_OR:fallthrough
		 	case .BIT_XOR:fallthrough
		 	case .COUNT:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .GROUP_CONCAT:fallthrough
		 	case .LAG:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NTH_VALUE:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .STD:fallthrough
		 	case .STDDEV:fallthrough
		 	case .STDDEV_POP:fallthrough
		 	case .STDDEV_SAMP:fallthrough
		 	case .SUM:fallthrough
		 	case .VAR_POP:fallthrough
		 	case .VAR_SAMP:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .CURRENT_DATE:fallthrough
		 	case .CURRENT_TIME:fallthrough
		 	case .CURRENT_TIMESTAMP:fallthrough
		 	case .LOCALTIME:fallthrough
		 	case .CURDATE:fallthrough
		 	case .CURTIME:fallthrough
		 	case .DATE_ADD:fallthrough
		 	case .DATE_SUB:fallthrough
		 	case .LOCALTIMESTAMP:fallthrough
		 	case .NOW:fallthrough
		 	case .POSITION:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .SUBSTRING:fallthrough
		 	case .SYSDATE:fallthrough
		 	case .TRIM:fallthrough
		 	case .UTC_DATE:fallthrough
		 	case .UTC_TIME:fallthrough
		 	case .UTC_TIMESTAMP:fallthrough
		 	case .ACCOUNT:fallthrough
		 	case .ACTION:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALGORITHM:fallthrough
		 	case .ANY:fallthrough
		 	case .AT:fallthrough
		 	case .AUTHORS:fallthrough
		 	case .AUTOCOMMIT:fallthrough
		 	case .AUTOEXTEND_SIZE:fallthrough
		 	case .AUTO_INCREMENT:fallthrough
		 	case .AVG_ROW_LENGTH:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BINLOG:fallthrough
		 	case .BIT:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BOOL:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BTREE:fallthrough
		 	case .CACHE:fallthrough
		 	case .CASCADED:fallthrough
		 	case .CHAIN:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CHECKSUM:fallthrough
		 	case .PAGE_CHECKSUM:fallthrough
		 	case .CIPHER:fallthrough
		 	case .CLASS_ORIGIN:fallthrough
		 	case .CLIENT:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTERING:fallthrough
		 	case .COALESCE:fallthrough
		 	case .CODE:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COLUMN_FORMAT:fallthrough
		 	case .COLUMN_NAME:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMPACT:fallthrough
		 	case .COMPLETION:fallthrough
		 	case .COMPRESSED:fallthrough
		 	case .COMPRESSION:fallthrough
		 	case .CONCURRENT:fallthrough
		 	case .CONNECT:fallthrough
		 	case .CONNECTION:fallthrough
		 	case .CONSISTENT:fallthrough
		 	case .CONSTRAINT_CATALOG:fallthrough
		 	case .CONSTRAINT_SCHEMA:fallthrough
		 	case .CONSTRAINT_NAME:fallthrough
		 	case .CONTAINS:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTRIBUTORS:fallthrough
		 	case .COPY:fallthrough
		 	case .CPU:fallthrough
		 	case .CURSOR_NAME:fallthrough
		 	case .DATA:fallthrough
		 	case .DATAFILE:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DEFAULT_AUTH:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DELAY_KEY_WRITE:fallthrough
		 	case .DES_KEY_FILE:fallthrough
		 	case .DIRECTORY:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISCARD:fallthrough
		 	case .DISK:fallthrough
		 	case .DO:fallthrough
		 	case .DUMPFILE:fallthrough
		 	case .DUPLICATE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .END:fallthrough
		 	case .ENDS:fallthrough
		 	case .ENGINE:fallthrough
		 	case .ENGINES:fallthrough
		 	case .ERROR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVEN:fallthrough
		 	case .EVENT:fallthrough
		 	case .EVENTS:fallthrough
		 	case .EVERY:fallthrough
		 	case .EXCHANGE:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPIRE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .EXTENT_SIZE:fallthrough
		 	case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 	case .FAST:fallthrough
		 	case .FAULTS:fallthrough
		 	case .FIELDS:fallthrough
		 	case .FILE_BLOCK_SIZE:fallthrough
		 	case .FILTER:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIXED:fallthrough
		 	case .FLUSH:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FOUND:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GENERAL:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GRANTS:fallthrough
		 	case .GROUP_REPLICATION:fallthrough
		 	case .HANDLER:fallthrough
		 	case .HASH:fallthrough
		 	case .HELP:fallthrough
		 	case .HISTORY:fallthrough
		 	case .HOST:fallthrough
		 	case .HOSTS:fallthrough
		 	case .IDENTIFIED:fallthrough
		 	case .IGNORE_SERVER_IDS:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INDEXES:fallthrough
		 	case .INITIAL_SIZE:fallthrough
		 	case .INPLACE:fallthrough
		 	case .INSERT_METHOD:fallthrough
		 	case .INSTALL:fallthrough
		 	case .INSTANCE:fallthrough
		 	case .INSTANT:fallthrough
		 	case .INVISIBLE:fallthrough
		 	case .INVOKER:fallthrough
		 	case .IO:fallthrough
		 	case .IO_THREAD:fallthrough
		 	case .IPC:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ISSUER:fallthrough
		 	case .JSON:fallthrough
		 	case .KEY_BLOCK_SIZE:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LEAVES:fallthrough
		 	case .LESS:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOGFILE:fallthrough
		 	case .LOGS:fallthrough
		 	case .MASTER:fallthrough
		 	case .MASTER_AUTO_POSITION:fallthrough
		 	case .MASTER_CONNECT_RETRY:fallthrough
		 	case .MASTER_DELAY:fallthrough
		 	case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 	case .MASTER_HOST:fallthrough
		 	case .MASTER_LOG_FILE:fallthrough
		 	case .MASTER_LOG_POS:fallthrough
		 	case .MASTER_PASSWORD:fallthrough
		 	case .MASTER_PORT:fallthrough
		 	case .MASTER_RETRY_COUNT:fallthrough
		 	case .MASTER_SSL:fallthrough
		 	case .MASTER_SSL_CA:fallthrough
		 	case .MASTER_SSL_CAPATH:fallthrough
		 	case .MASTER_SSL_CERT:fallthrough
		 	case .MASTER_SSL_CIPHER:fallthrough
		 	case .MASTER_SSL_CRL:fallthrough
		 	case .MASTER_SSL_CRLPATH:fallthrough
		 	case .MASTER_SSL_KEY:fallthrough
		 	case .MASTER_TLS_VERSION:fallthrough
		 	case .MASTER_USER:fallthrough
		 	case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 	case .MAX_QUERIES_PER_HOUR:fallthrough
		 	case .MAX_ROWS:fallthrough
		 	case .MAX_SIZE:fallthrough
		 	case .MAX_UPDATES_PER_HOUR:fallthrough
		 	case .MAX_USER_CONNECTIONS:fallthrough
		 	case .MEDIUM:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MESSAGE_TEXT:fallthrough
		 	case .MID:fallthrough
		 	case .MIGRATE:fallthrough
		 	case .MIN_ROWS:fallthrough
		 	case .MODE:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MUTEX:fallthrough
		 	case .MYSQL:fallthrough
		 	case .MYSQL_ERRNO:fallthrough
		 	case .NAME:fallthrough
		 	case .NAMES:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NEVER:fallthrough
		 	case .NEXT:fallthrough
		 	case .NO:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOWAIT:fallthrough
		 	case .NODEGROUP:fallthrough
		 	case .NONE:fallthrough
		 	case .ODBC:fallthrough
		 	case .OFFLINE:fallthrough
		 	case .OFFSET:fallthrough
		 	case .OF:fallthrough
		 	case .OJ:fallthrough
		 	case .OLD_PASSWORD:fallthrough
		 	case .ONE:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .OPTIMIZER_COSTS:fallthrough
		 	case .OPTIONS:fallthrough
		 	case .OWNER:fallthrough
		 	case .PACK_KEYS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PARSER:fallthrough
		 	case .PARTIAL:fallthrough
		 	case .PARTITIONING:fallthrough
		 	case .PARTITIONS:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PASSWORD_LOCK_TIME:fallthrough
		 	case .PHASE:fallthrough
		 	case .PLUGIN:fallthrough
		 	case .PLUGIN_DIR:fallthrough
		 	case .PLUGINS:fallthrough
		 	case .PORT:fallthrough
		 	case .PRECEDES:fallthrough
		 	case .PREPARE:fallthrough
		 	case .PRESERVE:fallthrough
		 	case .PREV:fallthrough
		 	case .PROCESSLIST:fallthrough
		 	case .PROFILE:fallthrough
		 	case .PROFILES:fallthrough
		 	case .PROXY:fallthrough
		 	case .QUERY:fallthrough
		 	case .QUICK:fallthrough
		 	case .REBUILD:fallthrough
		 	case .RECOVER:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REDO_BUFFER_SIZE:fallthrough
		 	case .REDUNDANT:fallthrough
		 	case .RELAY:fallthrough
		 	case .RELAY_LOG_FILE:fallthrough
		 	case .RELAY_LOG_POS:fallthrough
		 	case .RELAYLOG:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REORGANIZE:fallthrough
		 	case .REPAIR:fallthrough
		 	case .REPLICATE_DO_DB:fallthrough
		 	case .REPLICATE_DO_TABLE:fallthrough
		 	case .REPLICATE_IGNORE_DB:fallthrough
		 	case .REPLICATE_IGNORE_TABLE:fallthrough
		 	case .REPLICATE_REWRITE_DB:fallthrough
		 	case .REPLICATE_WILD_DO_TABLE:fallthrough
		 	case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 	case .REPLICATION:fallthrough
		 	case .RESET:fallthrough
		 	case .RESUME:fallthrough
		 	case .RETURNED_SQLSTATE:fallthrough
		 	case .RETURNING:fallthrough
		 	case .RETURNS:fallthrough
		 	case .REUSE:fallthrough
		 	case .ROLE:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROTATE:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_FORMAT:fallthrough
		 	case .RTREE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEDULE:fallthrough
		 	case .SECURITY:fallthrough
		 	case .SERVER:fallthrough
		 	case .SESSION:fallthrough
		 	case .SHARE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SIGNED:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SLAVE:fallthrough
		 	case .SLOW:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOCKET:fallthrough
		 	case .SOME:fallthrough
		 	case .SONAME:fallthrough
		 	case .SOUNDS:fallthrough
		 	case .SOURCE:fallthrough
		 	case .SQL_AFTER_GTIDS:fallthrough
		 	case .SQL_AFTER_MTS_GAPS:fallthrough
		 	case .SQL_BEFORE_GTIDS:fallthrough
		 	case .SQL_BUFFER_RESULT:fallthrough
		 	case .SQL_CACHE:fallthrough
		 	case .SQL_NO_CACHE:fallthrough
		 	case .SQL_THREAD:fallthrough
		 	case .START:fallthrough
		 	case .STARTS:fallthrough
		 	case .STATS_AUTO_RECALC:fallthrough
		 	case .STATS_PERSISTENT:fallthrough
		 	case .STATS_SAMPLE_PAGES:fallthrough
		 	case .STATUS:fallthrough
		 	case .STOP:fallthrough
		 	case .STORAGE:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBCLASS_ORIGIN:fallthrough
		 	case .SUBJECT:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBPARTITIONS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .SWAPS:fallthrough
		 	case .SWITCHES:fallthrough
		 	case .TABLE_NAME:fallthrough
		 	case .TABLESPACE:fallthrough
		 	case .TABLE_TYPE:fallthrough
		 	case .TEMPORARY:fallthrough
		 	case .TEMPTABLE:fallthrough
		 	case .THAN:fallthrough
		 	case .TRADITIONAL:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSACTIONAL:fallthrough
		 	case .TRIGGERS:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDEFINED:fallthrough
		 	case .UNDOFILE:fallthrough
		 	case .UNDO_BUFFER_SIZE:fallthrough
		 	case .UNINSTALL:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPGRADE:fallthrough
		 	case .USER:fallthrough
		 	case .USE_FRM:fallthrough
		 	case .USER_RESOURCES:fallthrough
		 	case .VALIDATION:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARIABLES:fallthrough
		 	case .VIEW:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .VISIBLE:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNINGS:fallthrough
		 	case .WITHOUT:fallthrough
		 	case .WORK:fallthrough
		 	case .WRAPPER:fallthrough
		 	case .X509:fallthrough
		 	case .XA:fallthrough
		 	case .XML:fallthrough
		 	case .EUR:fallthrough
		 	case .USA:fallthrough
		 	case .JIS:fallthrough
		 	case .ISO:fallthrough
		 	case .INTERNAL:fallthrough
		 	case .QUARTER:fallthrough
		 	case .MONTH:fallthrough
		 	case .DAY:fallthrough
		 	case .HOUR:fallthrough
		 	case .MINUTE:fallthrough
		 	case .WEEK:fallthrough
		 	case .SECOND:fallthrough
		 	case .MICROSECOND:fallthrough
		 	case .ADMIN:fallthrough
		 	case .AUDIT_ABORT_EXEMPT:fallthrough
		 	case .AUDIT_ADMIN:fallthrough
		 	case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 	case .BACKUP_ADMIN:fallthrough
		 	case .BINLOG_ADMIN:fallthrough
		 	case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 	case .CLONE_ADMIN:fallthrough
		 	case .CONNECTION_ADMIN:fallthrough
		 	case .ENCRYPTION_KEY_ADMIN:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .FILE:fallthrough
		 	case .FIREWALL_ADMIN:fallthrough
		 	case .FIREWALL_EXEMPT:fallthrough
		 	case .FIREWALL_USER:fallthrough
		 	case .GROUP_REPLICATION_ADMIN:fallthrough
		 	case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 	case .INVOKE:fallthrough
		 	case .LAMBDA:fallthrough
		 	case .NDB_STORED_USER:fallthrough
		 	case .PASSWORDLESS_USER_ADMIN:fallthrough
		 	case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .PROCESS:fallthrough
		 	case .RELOAD:fallthrough
		 	case .REPLICATION_APPLIER:fallthrough
		 	case .REPLICATION_SLAVE_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_USER:fallthrough
		 	case .ROLE_ADMIN:fallthrough
		 	case .ROUTINE:fallthrough
		 	case .S3:fallthrough
		 	case .SESSION_VARIABLES_ADMIN:fallthrough
		 	case .SET_USER_ID:fallthrough
		 	case .SHOW_ROUTINE:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SUPER:fallthrough
		 	case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 	case .TABLES:fallthrough
		 	case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 	case .VERSION_TOKEN_ADMIN:fallthrough
		 	case .XA_RECOVER_ADMIN:fallthrough
		 	case .ARMSCII8:fallthrough
		 	case .ASCII:fallthrough
		 	case .BIG5:fallthrough
		 	case .CP1250:fallthrough
		 	case .CP1251:fallthrough
		 	case .CP1256:fallthrough
		 	case .CP1257:fallthrough
		 	case .CP850:fallthrough
		 	case .CP852:fallthrough
		 	case .CP866:fallthrough
		 	case .CP932:fallthrough
		 	case .DEC8:fallthrough
		 	case .EUCJPMS:fallthrough
		 	case .EUCKR:fallthrough
		 	case .GB18030:fallthrough
		 	case .GB2312:fallthrough
		 	case .GBK:fallthrough
		 	case .GEOSTD8:fallthrough
		 	case .GREEK:fallthrough
		 	case .HEBREW:fallthrough
		 	case .HP8:fallthrough
		 	case .KEYBCS2:fallthrough
		 	case .KOI8R:fallthrough
		 	case .KOI8U:fallthrough
		 	case .LATIN1:fallthrough
		 	case .LATIN2:fallthrough
		 	case .LATIN5:fallthrough
		 	case .LATIN7:fallthrough
		 	case .MACCE:fallthrough
		 	case .MACROMAN:fallthrough
		 	case .SJIS:fallthrough
		 	case .SWE7:fallthrough
		 	case .TIS620:fallthrough
		 	case .UCS2:fallthrough
		 	case .UJIS:fallthrough
		 	case .UTF16:fallthrough
		 	case .UTF16LE:fallthrough
		 	case .UTF32:fallthrough
		 	case .UTF8:fallthrough
		 	case .UTF8MB3:fallthrough
		 	case .UTF8MB4:fallthrough
		 	case .ARCHIVE:fallthrough
		 	case .BLACKHOLE:fallthrough
		 	case .CSV:fallthrough
		 	case .FEDERATED:fallthrough
		 	case .INNODB:fallthrough
		 	case .MEMORY:fallthrough
		 	case .MRG_MYISAM:fallthrough
		 	case .MYISAM:fallthrough
		 	case .NDB:fallthrough
		 	case .NDBCLUSTER:fallthrough
		 	case .PERFORMANCE_SCHEMA:fallthrough
		 	case .TOKUDB:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .GEOMETRYCOLLECTION:fallthrough
		 	case .LINESTRING:fallthrough
		 	case .MULTILINESTRING:fallthrough
		 	case .MULTIPOINT:fallthrough
		 	case .MULTIPOLYGON:fallthrough
		 	case .POINT:fallthrough
		 	case .POLYGON:fallthrough
		 	case .ABS:fallthrough
		 	case .ACOS:fallthrough
		 	case .ADDDATE:fallthrough
		 	case .ADDTIME:fallthrough
		 	case .AES_DECRYPT:fallthrough
		 	case .AES_ENCRYPT:fallthrough
		 	case .AREA:fallthrough
		 	case .ASBINARY:fallthrough
		 	case .ASIN:fallthrough
		 	case .ASTEXT:fallthrough
		 	case .ASWKB:fallthrough
		 	case .ASWKT:fallthrough
		 	case .ASYMMETRIC_DECRYPT:fallthrough
		 	case .ASYMMETRIC_DERIVE:fallthrough
		 	case .ASYMMETRIC_ENCRYPT:fallthrough
		 	case .ASYMMETRIC_SIGN:fallthrough
		 	case .ASYMMETRIC_VERIFY:fallthrough
		 	case .ATAN:fallthrough
		 	case .ATAN2:fallthrough
		 	case .BENCHMARK:fallthrough
		 	case .BIN:fallthrough
		 	case .BIT_COUNT:fallthrough
		 	case .BIT_LENGTH:fallthrough
		 	case .BUFFER:fallthrough
		 	case .CATALOG_NAME:fallthrough
		 	case .CEIL:fallthrough
		 	case .CEILING:fallthrough
		 	case .CENTROID:fallthrough
		 	case .CHARACTER_LENGTH:fallthrough
		 	case .CHARSET:fallthrough
		 	case .CHAR_LENGTH:fallthrough
		 	case .COERCIBILITY:fallthrough
		 	case .COLLATION:fallthrough
		 	case .COMPRESS:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_WS:fallthrough
		 	case .CONNECTION_ID:fallthrough
		 	case .CONV:fallthrough
		 	case .CONVERT_TZ:fallthrough
		 	case .COS:fallthrough
		 	case .COT:fallthrough
		 	case .CRC32:fallthrough
		 	case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 	case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 	case .CREATE_DH_PARAMETERS:fallthrough
		 	case .CREATE_DIGEST:fallthrough
		 	case .CROSSES:fallthrough
		 	case .DATEDIFF:fallthrough
		 	case .DATE_FORMAT:fallthrough
		 	case .DAYNAME:fallthrough
		 	case .DAYOFMONTH:fallthrough
		 	case .DAYOFWEEK:fallthrough
		 	case .DAYOFYEAR:fallthrough
		 	case .DECODE:fallthrough
		 	case .DEGREES:fallthrough
		 	case .DES_DECRYPT:fallthrough
		 	case .DES_ENCRYPT:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISJOINT:fallthrough
		 	case .ELT:fallthrough
		 	case .ENCODE:fallthrough
		 	case .ENCRYPT:fallthrough
		 	case .ENDPOINT:fallthrough
		 	case .ENGINE_ATTRIBUTE:fallthrough
		 	case .ENVELOPE:fallthrough
		 	case .EQUALS:fallthrough
		 	case .EXP:fallthrough
		 	case .EXPORT_SET:fallthrough
		 	case .EXTERIORRING:fallthrough
		 	case .EXTRACTVALUE:fallthrough
		 	case .FIELD:fallthrough
		 	case .FIND_IN_SET:fallthrough
		 	case .FLOOR:fallthrough
		 	case .FORMAT:fallthrough
		 	case .FOUND_ROWS:fallthrough
		 	case .FROM_BASE64:fallthrough
		 	case .FROM_DAYS:fallthrough
		 	case .FROM_UNIXTIME:fallthrough
		 	case .GEOMCOLLFROMTEXT:fallthrough
		 	case .GEOMCOLLFROMWKB:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .GEOMETRYFROMTEXT:fallthrough
		 	case .GEOMETRYFROMWKB:fallthrough
		 	case .GEOMETRYN:fallthrough
		 	case .GEOMETRYTYPE:fallthrough
		 	case .GEOMFROMTEXT:fallthrough
		 	case .GEOMFROMWKB:fallthrough
		 	case .GET_FORMAT:fallthrough
		 	case .GET_LOCK:fallthrough
		 	case .GLENGTH:fallthrough
		 	case .GREATEST:fallthrough
		 	case .GTID_SUBSET:fallthrough
		 	case .GTID_SUBTRACT:fallthrough
		 	case .HEX:fallthrough
		 	case .IFNULL:fallthrough
		 	case .INET6_ATON:fallthrough
		 	case .INET6_NTOA:fallthrough
		 	case .INET_ATON:fallthrough
		 	case .INET_NTOA:fallthrough
		 	case .INSTR:fallthrough
		 	case .INTERIORRINGN:fallthrough
		 	case .INTERSECTS:fallthrough
		 	case .ISCLOSED:fallthrough
		 	case .ISEMPTY:fallthrough
		 	case .ISNULL:fallthrough
		 	case .ISSIMPLE:fallthrough
		 	case .IS_FREE_LOCK:fallthrough
		 	case .IS_IPV4:fallthrough
		 	case .IS_IPV4_COMPAT:fallthrough
		 	case .IS_IPV4_MAPPED:fallthrough
		 	case .IS_IPV6:fallthrough
		 	case .IS_USED_LOCK:fallthrough
		 	case .LAST_INSERT_ID:fallthrough
		 	case .LCASE:fallthrough
		 	case .LEAST:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LINEFROMTEXT:fallthrough
		 	case .LINEFROMWKB:fallthrough
		 	case .LINESTRINGFROMTEXT:fallthrough
		 	case .LINESTRINGFROMWKB:fallthrough
		 	case .LN:fallthrough
		 	case .LOAD_FILE:fallthrough
		 	case .LOCATE:fallthrough
		 	case .LOG:fallthrough
		 	case .LOG10:fallthrough
		 	case .LOG2:fallthrough
		 	case .LOWER:fallthrough
		 	case .LPAD:fallthrough
		 	case .LTRIM:fallthrough
		 	case .MAKEDATE:fallthrough
		 	case .MAKETIME:fallthrough
		 	case .MAKE_SET:fallthrough
		 	case .MASTER_POS_WAIT:fallthrough
		 	case .MBRCONTAINS:fallthrough
		 	case .MBRDISJOINT:fallthrough
		 	case .MBREQUAL:fallthrough
		 	case .MBRINTERSECTS:fallthrough
		 	case .MBROVERLAPS:fallthrough
		 	case .MBRTOUCHES:fallthrough
		 	case .MBRWITHIN:fallthrough
		 	case .MD5:fallthrough
		 	case .MLINEFROMTEXT:fallthrough
		 	case .MLINEFROMWKB:fallthrough
		 	case .MONTHNAME:fallthrough
		 	case .MPOINTFROMTEXT:fallthrough
		 	case .MPOINTFROMWKB:fallthrough
		 	case .MPOLYFROMTEXT:fallthrough
		 	case .MPOLYFROMWKB:fallthrough
		 	case .MULTILINESTRINGFROMTEXT:fallthrough
		 	case .MULTILINESTRINGFROMWKB:fallthrough
		 	case .MULTIPOINTFROMTEXT:fallthrough
		 	case .MULTIPOINTFROMWKB:fallthrough
		 	case .MULTIPOLYGONFROMTEXT:fallthrough
		 	case .MULTIPOLYGONFROMWKB:fallthrough
		 	case .NAME_CONST:fallthrough
		 	case .NULLIF:fallthrough
		 	case .NUMGEOMETRIES:fallthrough
		 	case .NUMINTERIORRINGS:fallthrough
		 	case .NUMPOINTS:fallthrough
		 	case .OCT:fallthrough
		 	case .OCTET_LENGTH:fallthrough
		 	case .ORD:fallthrough
		 	case .OVERLAPS:fallthrough
		 	case .PERIOD_ADD:fallthrough
		 	case .PERIOD_DIFF:fallthrough
		 	case .PI:fallthrough
		 	case .POINTFROMTEXT:fallthrough
		 	case .POINTFROMWKB:fallthrough
		 	case .POINTN:fallthrough
		 	case .POLYFROMTEXT:fallthrough
		 	case .POLYFROMWKB:fallthrough
		 	case .POLYGONFROMTEXT:fallthrough
		 	case .POLYGONFROMWKB:fallthrough
		 	case .POW:fallthrough
		 	case .POWER:fallthrough
		 	case .QUOTE:fallthrough
		 	case .RADIANS:fallthrough
		 	case .RAND:fallthrough
		 	case .RANDOM:fallthrough
		 	case .RANDOM_BYTES:fallthrough
		 	case .RELEASE_LOCK:fallthrough
		 	case .REVERSE:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_COUNT:fallthrough
		 	case .RPAD:fallthrough
		 	case .RTRIM:fallthrough
		 	case .SEC_TO_TIME:fallthrough
		 	case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 	case .SESSION_USER:fallthrough
		 	case .SHA:fallthrough
		 	case .SHA1:fallthrough
		 	case .SHA2:fallthrough
		 	case .SCHEMA_NAME:fallthrough
		 	case .SIGN:fallthrough
		 	case .SIN:fallthrough
		 	case .SLEEP:fallthrough
		 	case .SOUNDEX:fallthrough
		 	case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 	case .SQRT:fallthrough
		 	case .SRID:fallthrough
		 	case .STARTPOINT:fallthrough
		 	case .STRCMP:fallthrough
		 	case .STR_TO_DATE:fallthrough
		 	case .ST_AREA:fallthrough
		 	case .ST_ASBINARY:fallthrough
		 	case .ST_ASTEXT:fallthrough
		 	case .ST_ASWKB:fallthrough
		 	case .ST_ASWKT:fallthrough
		 	case .ST_BUFFER:fallthrough
		 	case .ST_CENTROID:fallthrough
		 	case .ST_CONTAINS:fallthrough
		 	case .ST_CROSSES:fallthrough
		 	case .ST_DIFFERENCE:fallthrough
		 	case .ST_DIMENSION:fallthrough
		 	case .ST_DISJOINT:fallthrough
		 	case .ST_DISTANCE:fallthrough
		 	case .ST_ENDPOINT:fallthrough
		 	case .ST_ENVELOPE:fallthrough
		 	case .ST_EQUALS:fallthrough
		 	case .ST_EXTERIORRING:fallthrough
		 	case .ST_GEOMCOLLFROMTEXT:fallthrough
		 	case .ST_GEOMCOLLFROMTXT:fallthrough
		 	case .ST_GEOMCOLLFROMWKB:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .ST_GEOMETRYFROMTEXT:fallthrough
		 	case .ST_GEOMETRYFROMWKB:fallthrough
		 	case .ST_GEOMETRYN:fallthrough
		 	case .ST_GEOMETRYTYPE:fallthrough
		 	case .ST_GEOMFROMTEXT:fallthrough
		 	case .ST_GEOMFROMWKB:fallthrough
		 	case .ST_INTERIORRINGN:fallthrough
		 	case .ST_INTERSECTION:fallthrough
		 	case .ST_INTERSECTS:fallthrough
		 	case .ST_ISCLOSED:fallthrough
		 	case .ST_ISEMPTY:fallthrough
		 	case .ST_ISSIMPLE:fallthrough
		 	case .ST_LINEFROMTEXT:fallthrough
		 	case .ST_LINEFROMWKB:fallthrough
		 	case .ST_LINESTRINGFROMTEXT:fallthrough
		 	case .ST_LINESTRINGFROMWKB:fallthrough
		 	case .ST_NUMGEOMETRIES:fallthrough
		 	case .ST_NUMINTERIORRING:fallthrough
		 	case .ST_NUMINTERIORRINGS:fallthrough
		 	case .ST_NUMPOINTS:fallthrough
		 	case .ST_OVERLAPS:fallthrough
		 	case .ST_POINTFROMTEXT:fallthrough
		 	case .ST_POINTFROMWKB:fallthrough
		 	case .ST_POINTN:fallthrough
		 	case .ST_POLYFROMTEXT:fallthrough
		 	case .ST_POLYFROMWKB:fallthrough
		 	case .ST_POLYGONFROMTEXT:fallthrough
		 	case .ST_POLYGONFROMWKB:fallthrough
		 	case .ST_SRID:fallthrough
		 	case .ST_STARTPOINT:fallthrough
		 	case .ST_SYMDIFFERENCE:fallthrough
		 	case .ST_TOUCHES:fallthrough
		 	case .ST_UNION:fallthrough
		 	case .ST_WITHIN:fallthrough
		 	case .ST_X:fallthrough
		 	case .ST_Y:fallthrough
		 	case .SUBDATE:fallthrough
		 	case .SUBSTRING_INDEX:fallthrough
		 	case .SUBTIME:fallthrough
		 	case .SYSTEM_USER:fallthrough
		 	case .TAN:fallthrough
		 	case .TIMEDIFF:fallthrough
		 	case .TIMESTAMPADD:fallthrough
		 	case .TIMESTAMPDIFF:fallthrough
		 	case .TIME_FORMAT:fallthrough
		 	case .TIME_TO_SEC:fallthrough
		 	case .TOUCHES:fallthrough
		 	case .TO_BASE64:fallthrough
		 	case .TO_DAYS:fallthrough
		 	case .TO_SECONDS:fallthrough
		 	case .TP_CONNECTION_ADMIN:fallthrough
		 	case .UCASE:fallthrough
		 	case .UNCOMPRESS:fallthrough
		 	case .UNCOMPRESSED_LENGTH:fallthrough
		 	case .UNHEX:fallthrough
		 	case .UNIX_TIMESTAMP:fallthrough
		 	case .UPDATEXML:fallthrough
		 	case .UPPER:fallthrough
		 	case .UUID:fallthrough
		 	case .UUID_SHORT:fallthrough
		 	case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 	case .VERSION:fallthrough
		 	case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 	case .WEEKDAY:fallthrough
		 	case .WEEKOFYEAR:fallthrough
		 	case .WEIGHT_STRING:fallthrough
		 	case .WITHIN:fallthrough
		 	case .YEARWEEK:fallthrough
		 	case .Y_FUNCTION:fallthrough
		 	case .X_FUNCTION:fallthrough
		 	case .MOD:fallthrough
		 	case .AT_SIGN:fallthrough
		 	case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 	case .STRING_LITERAL:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5915)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,860,_ctx)) {
		 		case 1:
		 			setState(5912)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.AT_SIGN.rawValue) {
		 				setState(5910)
		 				try match(MySqlParser.Tokens.AT_SIGN.rawValue)
		 				setState(5911)
		 				try match(MySqlParser.Tokens.AT_SIGN.rawValue)

		 			}

		 			setState(5914)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.GLOBAL.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue || _la == MySqlParser.Tokens.SESSION.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(5917)
		 		try uid()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ShowCommonEntityContext: ParserRuleContext {
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func COLLATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATION.rawValue, 0)
			}
			open
			func DATABASES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATABASES.rawValue, 0)
			}
			open
			func SCHEMAS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEMAS.rawValue, 0)
			}
			open
			func FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FUNCTION.rawValue, 0)
			}
			open
			func STATUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATUS.rawValue, 0)
			}
			open
			func PROCEDURE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCEDURE.rawValue, 0)
			}
			open
			func VARIABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VARIABLES.rawValue, 0)
			}
			open
			func GLOBAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GLOBAL.rawValue, 0)
			}
			open
			func SESSION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SESSION.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_showCommonEntity
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowCommonEntity(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowCommonEntity(self)
			}
		}
	}
	@discardableResult
	 open func showCommonEntity() throws -> ShowCommonEntityContext {
		var _localctx: ShowCommonEntityContext
		_localctx = ShowCommonEntityContext(_ctx, getState())
		try enterRule(_localctx, 494, MySqlParser.RULE_showCommonEntity)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5933)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CHARACTER:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5920)
		 		try match(MySqlParser.Tokens.CHARACTER.rawValue)
		 		setState(5921)
		 		try match(MySqlParser.Tokens.SET.rawValue)

		 		break

		 	case .COLLATION:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5922)
		 		try match(MySqlParser.Tokens.COLLATION.rawValue)

		 		break

		 	case .DATABASES:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5923)
		 		try match(MySqlParser.Tokens.DATABASES.rawValue)

		 		break

		 	case .SCHEMAS:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5924)
		 		try match(MySqlParser.Tokens.SCHEMAS.rawValue)

		 		break

		 	case .FUNCTION:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5925)
		 		try match(MySqlParser.Tokens.FUNCTION.rawValue)
		 		setState(5926)
		 		try match(MySqlParser.Tokens.STATUS.rawValue)

		 		break

		 	case .PROCEDURE:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5927)
		 		try match(MySqlParser.Tokens.PROCEDURE.rawValue)
		 		setState(5928)
		 		try match(MySqlParser.Tokens.STATUS.rawValue)

		 		break
		 	case .GLOBAL:fallthrough
		 	case .SESSION:fallthrough
		 	case .STATUS:fallthrough
		 	case .VARIABLES:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(5930)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.GLOBAL.rawValue || _la == MySqlParser.Tokens.SESSION.rawValue) {
		 			setState(5929)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.GLOBAL.rawValue || _la == MySqlParser.Tokens.SESSION.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(5932)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.STATUS.rawValue || _la == MySqlParser.Tokens.VARIABLES.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ShowFilterContext: ParserRuleContext {
			open
			func LIKE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIKE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func WHERE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHERE.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_showFilter
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowFilter(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowFilter(self)
			}
		}
	}
	@discardableResult
	 open func showFilter() throws -> ShowFilterContext {
		var _localctx: ShowFilterContext
		_localctx = ShowFilterContext(_ctx, getState())
		try enterRule(_localctx, 496, MySqlParser.RULE_showFilter)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5939)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LIKE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5935)
		 		try match(MySqlParser.Tokens.LIKE.rawValue)
		 		setState(5936)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .WHERE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5937)
		 		try match(MySqlParser.Tokens.WHERE.rawValue)
		 		setState(5938)
		 		try expression(0)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ShowGlobalInfoClauseContext: ParserRuleContext {
			open
			func ENGINES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINES.rawValue, 0)
			}
			open
			func STORAGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STORAGE.rawValue, 0)
			}
			open
			func MASTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER.rawValue, 0)
			}
			open
			func STATUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATUS.rawValue, 0)
			}
			open
			func PLUGINS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PLUGINS.rawValue, 0)
			}
			open
			func PRIVILEGES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRIVILEGES.rawValue, 0)
			}
			open
			func PROCESSLIST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCESSLIST.rawValue, 0)
			}
			open
			func FULL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FULL.rawValue, 0)
			}
			open
			func PROFILES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROFILES.rawValue, 0)
			}
			open
			func SLAVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SLAVE.rawValue, 0)
			}
			open
			func HOSTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HOSTS.rawValue, 0)
			}
			open
			func AUTHORS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTHORS.rawValue, 0)
			}
			open
			func CONTRIBUTORS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONTRIBUTORS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_showGlobalInfoClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowGlobalInfoClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowGlobalInfoClause(self)
			}
		}
	}
	@discardableResult
	 open func showGlobalInfoClause() throws -> ShowGlobalInfoClauseContext {
		var _localctx: ShowGlobalInfoClauseContext
		_localctx = ShowGlobalInfoClauseContext(_ctx, getState())
		try enterRule(_localctx, 498, MySqlParser.RULE_showGlobalInfoClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5958)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ENGINES:fallthrough
		 	case .STORAGE:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5942)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.STORAGE.rawValue) {
		 			setState(5941)
		 			try match(MySqlParser.Tokens.STORAGE.rawValue)

		 		}

		 		setState(5944)
		 		try match(MySqlParser.Tokens.ENGINES.rawValue)

		 		break

		 	case .MASTER:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5945)
		 		try match(MySqlParser.Tokens.MASTER.rawValue)
		 		setState(5946)
		 		try match(MySqlParser.Tokens.STATUS.rawValue)

		 		break

		 	case .PLUGINS:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5947)
		 		try match(MySqlParser.Tokens.PLUGINS.rawValue)

		 		break

		 	case .PRIVILEGES:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5948)
		 		try match(MySqlParser.Tokens.PRIVILEGES.rawValue)

		 		break
		 	case .FULL:fallthrough
		 	case .PROCESSLIST:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5950)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FULL.rawValue) {
		 			setState(5949)
		 			try match(MySqlParser.Tokens.FULL.rawValue)

		 		}

		 		setState(5952)
		 		try match(MySqlParser.Tokens.PROCESSLIST.rawValue)

		 		break

		 	case .PROFILES:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5953)
		 		try match(MySqlParser.Tokens.PROFILES.rawValue)

		 		break

		 	case .SLAVE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(5954)
		 		try match(MySqlParser.Tokens.SLAVE.rawValue)
		 		setState(5955)
		 		try match(MySqlParser.Tokens.HOSTS.rawValue)

		 		break

		 	case .AUTHORS:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(5956)
		 		try match(MySqlParser.Tokens.AUTHORS.rawValue)

		 		break

		 	case .CONTRIBUTORS:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(5957)
		 		try match(MySqlParser.Tokens.CONTRIBUTORS.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ShowSchemaEntityContext: ParserRuleContext {
			open
			func EVENTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVENTS.rawValue, 0)
			}
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func STATUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATUS.rawValue, 0)
			}
			open
			func TABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLES.rawValue, 0)
			}
			open
			func FULL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FULL.rawValue, 0)
			}
			open
			func TRIGGERS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRIGGERS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_showSchemaEntity
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowSchemaEntity(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowSchemaEntity(self)
			}
		}
	}
	@discardableResult
	 open func showSchemaEntity() throws -> ShowSchemaEntityContext {
		var _localctx: ShowSchemaEntityContext
		_localctx = ShowSchemaEntityContext(_ctx, getState())
		try enterRule(_localctx, 500, MySqlParser.RULE_showSchemaEntity)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5968)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .EVENTS:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5960)
		 		try match(MySqlParser.Tokens.EVENTS.rawValue)

		 		break

		 	case .TABLE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5961)
		 		try match(MySqlParser.Tokens.TABLE.rawValue)
		 		setState(5962)
		 		try match(MySqlParser.Tokens.STATUS.rawValue)

		 		break
		 	case .FULL:fallthrough
		 	case .TABLES:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5964)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FULL.rawValue) {
		 			setState(5963)
		 			try match(MySqlParser.Tokens.FULL.rawValue)

		 		}

		 		setState(5966)
		 		try match(MySqlParser.Tokens.TABLES.rawValue)

		 		break

		 	case .TRIGGERS:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5967)
		 		try match(MySqlParser.Tokens.TRIGGERS.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ShowProfileTypeContext: ParserRuleContext {
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func BLOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BLOCK.rawValue, 0)
			}
			open
			func IO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IO.rawValue, 0)
			}
			open
			func CONTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONTEXT.rawValue, 0)
			}
			open
			func SWITCHES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SWITCHES.rawValue, 0)
			}
			open
			func CPU() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CPU.rawValue, 0)
			}
			open
			func IPC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IPC.rawValue, 0)
			}
			open
			func MEMORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEMORY.rawValue, 0)
			}
			open
			func PAGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PAGE.rawValue, 0)
			}
			open
			func FAULTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FAULTS.rawValue, 0)
			}
			open
			func SOURCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SOURCE.rawValue, 0)
			}
			open
			func SWAPS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SWAPS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_showProfileType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShowProfileType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShowProfileType(self)
			}
		}
	}
	@discardableResult
	 open func showProfileType() throws -> ShowProfileTypeContext {
		var _localctx: ShowProfileTypeContext
		_localctx = ShowProfileTypeContext(_ctx, getState())
		try enterRule(_localctx, 502, MySqlParser.RULE_showProfileType)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(5982)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ALL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(5970)
		 		try match(MySqlParser.Tokens.ALL.rawValue)

		 		break

		 	case .BLOCK:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(5971)
		 		try match(MySqlParser.Tokens.BLOCK.rawValue)
		 		setState(5972)
		 		try match(MySqlParser.Tokens.IO.rawValue)

		 		break

		 	case .CONTEXT:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(5973)
		 		try match(MySqlParser.Tokens.CONTEXT.rawValue)
		 		setState(5974)
		 		try match(MySqlParser.Tokens.SWITCHES.rawValue)

		 		break

		 	case .CPU:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(5975)
		 		try match(MySqlParser.Tokens.CPU.rawValue)

		 		break

		 	case .IPC:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(5976)
		 		try match(MySqlParser.Tokens.IPC.rawValue)

		 		break

		 	case .MEMORY:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(5977)
		 		try match(MySqlParser.Tokens.MEMORY.rawValue)

		 		break

		 	case .PAGE:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(5978)
		 		try match(MySqlParser.Tokens.PAGE.rawValue)
		 		setState(5979)
		 		try match(MySqlParser.Tokens.FAULTS.rawValue)

		 		break

		 	case .SOURCE:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(5980)
		 		try match(MySqlParser.Tokens.SOURCE.rawValue)

		 		break

		 	case .SWAPS:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(5981)
		 		try match(MySqlParser.Tokens.SWAPS.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BinlogStatementContext: ParserRuleContext {
			open
			func BINLOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINLOG.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_binlogStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterBinlogStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitBinlogStatement(self)
			}
		}
	}
	@discardableResult
	 open func binlogStatement() throws -> BinlogStatementContext {
		var _localctx: BinlogStatementContext
		_localctx = BinlogStatementContext(_ctx, getState())
		try enterRule(_localctx, 504, MySqlParser.RULE_binlogStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5984)
		 	try match(MySqlParser.Tokens.BINLOG.rawValue)
		 	setState(5985)
		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CacheIndexStatementContext: ParserRuleContext {
		open var schema: UidContext!
			open
			func CACHE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CACHE.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func tableIndexes() -> [TableIndexesContext] {
				return getRuleContexts(TableIndexesContext.self)
			}
			open
			func tableIndexes(_ i: Int) -> TableIndexesContext? {
				return getRuleContext(TableIndexesContext.self, i)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_cacheIndexStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCacheIndexStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCacheIndexStatement(self)
			}
		}
	}
	@discardableResult
	 open func cacheIndexStatement() throws -> CacheIndexStatementContext {
		var _localctx: CacheIndexStatementContext
		_localctx = CacheIndexStatementContext(_ctx, getState())
		try enterRule(_localctx, 506, MySqlParser.RULE_cacheIndexStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(5987)
		 	try match(MySqlParser.Tokens.CACHE.rawValue)
		 	setState(5988)
		 	try match(MySqlParser.Tokens.INDEX.rawValue)
		 	setState(5989)
		 	try tableIndexes()
		 	setState(5994)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(5990)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(5991)
		 		try tableIndexes()


		 		setState(5996)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6004)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.PARTITION.rawValue) {
		 		setState(5997)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(5998)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6001)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ARRAY:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .BUCKETS:fallthrough
		 		case .CONDITION:fallthrough
		 		case .CURRENT:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DIAGNOSTICS:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENFORCED:fallthrough
		 		case .EXCEPT:fallthrough
		 		case .GROUP:fallthrough
		 		case .IF:fallthrough
		 		case .IGNORED:fallthrough
		 		case .INSERT:fallthrough
		 		case .LATERAL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OPTIONAL:fallthrough
		 		case .ORDER:fallthrough
		 		case .PRIMARY:fallthrough
		 		case .REPEAT:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SKIP_QUERY_REWRITE:fallthrough
		 		case .STACKED:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .BINARY:fallthrough
		 		case .TEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .JSON_ARRAY:fallthrough
		 		case .JSON_ARRAYAGG:fallthrough
		 		case .JSON_ARRAY_APPEND:fallthrough
		 		case .JSON_ARRAY_INSERT:fallthrough
		 		case .JSON_CONTAINS:fallthrough
		 		case .JSON_CONTAINS_PATH:fallthrough
		 		case .JSON_DEPTH:fallthrough
		 		case .JSON_EXTRACT:fallthrough
		 		case .JSON_INSERT:fallthrough
		 		case .JSON_KEYS:fallthrough
		 		case .JSON_LENGTH:fallthrough
		 		case .JSON_MERGE:fallthrough
		 		case .JSON_MERGE_PATCH:fallthrough
		 		case .JSON_MERGE_PRESERVE:fallthrough
		 		case .JSON_OBJECT:fallthrough
		 		case .JSON_OBJECTAGG:fallthrough
		 		case .JSON_OVERLAPS:fallthrough
		 		case .JSON_PRETTY:fallthrough
		 		case .JSON_QUOTE:fallthrough
		 		case .JSON_REMOVE:fallthrough
		 		case .JSON_REPLACE:fallthrough
		 		case .JSON_SCHEMA_VALID:fallthrough
		 		case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 		case .JSON_SEARCH:fallthrough
		 		case .JSON_SET:fallthrough
		 		case .JSON_STORAGE_FREE:fallthrough
		 		case .JSON_STORAGE_SIZE:fallthrough
		 		case .JSON_TABLE:fallthrough
		 		case .JSON_TYPE:fallthrough
		 		case .JSON_UNQUOTE:fallthrough
		 		case .JSON_VALID:fallthrough
		 		case .JSON_VALUE:fallthrough
		 		case .NESTED:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .PATH:fallthrough
		 		case .AVG:fallthrough
		 		case .BIT_AND:fallthrough
		 		case .BIT_OR:fallthrough
		 		case .BIT_XOR:fallthrough
		 		case .COUNT:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .GROUP_CONCAT:fallthrough
		 		case .LAG:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NTH_VALUE:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .RANK:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .STD:fallthrough
		 		case .STDDEV:fallthrough
		 		case .STDDEV_POP:fallthrough
		 		case .STDDEV_SAMP:fallthrough
		 		case .SUM:fallthrough
		 		case .VAR_POP:fallthrough
		 		case .VAR_SAMP:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .CURRENT_DATE:fallthrough
		 		case .CURRENT_TIME:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .LOCALTIME:fallthrough
		 		case .CURDATE:fallthrough
		 		case .CURTIME:fallthrough
		 		case .DATE_ADD:fallthrough
		 		case .DATE_SUB:fallthrough
		 		case .LOCALTIMESTAMP:fallthrough
		 		case .NOW:fallthrough
		 		case .POSITION:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .SUBSTRING:fallthrough
		 		case .SYSDATE:fallthrough
		 		case .TRIM:fallthrough
		 		case .UTC_DATE:fallthrough
		 		case .UTC_TIME:fallthrough
		 		case .UTC_TIMESTAMP:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .ACTION:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALGORITHM:fallthrough
		 		case .ANY:fallthrough
		 		case .AT:fallthrough
		 		case .AUTHORS:fallthrough
		 		case .AUTOCOMMIT:fallthrough
		 		case .AUTOEXTEND_SIZE:fallthrough
		 		case .AUTO_INCREMENT:fallthrough
		 		case .AVG_ROW_LENGTH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .BIT:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BTREE:fallthrough
		 		case .CACHE:fallthrough
		 		case .CASCADED:fallthrough
		 		case .CHAIN:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .PAGE_CHECKSUM:fallthrough
		 		case .CIPHER:fallthrough
		 		case .CLASS_ORIGIN:fallthrough
		 		case .CLIENT:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTERING:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CODE:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COLUMN_FORMAT:fallthrough
		 		case .COLUMN_NAME:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMPACT:fallthrough
		 		case .COMPLETION:fallthrough
		 		case .COMPRESSED:fallthrough
		 		case .COMPRESSION:fallthrough
		 		case .CONCURRENT:fallthrough
		 		case .CONNECT:fallthrough
		 		case .CONNECTION:fallthrough
		 		case .CONSISTENT:fallthrough
		 		case .CONSTRAINT_CATALOG:fallthrough
		 		case .CONSTRAINT_SCHEMA:fallthrough
		 		case .CONSTRAINT_NAME:fallthrough
		 		case .CONTAINS:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTRIBUTORS:fallthrough
		 		case .COPY:fallthrough
		 		case .CPU:fallthrough
		 		case .CURSOR_NAME:fallthrough
		 		case .DATA:fallthrough
		 		case .DATAFILE:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DEFAULT_AUTH:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DELAY_KEY_WRITE:fallthrough
		 		case .DES_KEY_FILE:fallthrough
		 		case .DIRECTORY:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISCARD:fallthrough
		 		case .DISK:fallthrough
		 		case .DO:fallthrough
		 		case .DUMPFILE:fallthrough
		 		case .DUPLICATE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .END:fallthrough
		 		case .ENDS:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ENGINES:fallthrough
		 		case .ERROR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVEN:fallthrough
		 		case .EVENT:fallthrough
		 		case .EVENTS:fallthrough
		 		case .EVERY:fallthrough
		 		case .EXCHANGE:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPIRE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .EXTENT_SIZE:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FAST:fallthrough
		 		case .FAULTS:fallthrough
		 		case .FIELDS:fallthrough
		 		case .FILE_BLOCK_SIZE:fallthrough
		 		case .FILTER:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIXED:fallthrough
		 		case .FLUSH:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FOUND:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GENERAL:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GRANTS:fallthrough
		 		case .GROUP_REPLICATION:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HASH:fallthrough
		 		case .HELP:fallthrough
		 		case .HISTORY:fallthrough
		 		case .HOST:fallthrough
		 		case .HOSTS:fallthrough
		 		case .IDENTIFIED:fallthrough
		 		case .IGNORE_SERVER_IDS:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INDEXES:fallthrough
		 		case .INITIAL_SIZE:fallthrough
		 		case .INPLACE:fallthrough
		 		case .INSERT_METHOD:fallthrough
		 		case .INSTALL:fallthrough
		 		case .INSTANCE:fallthrough
		 		case .INSTANT:fallthrough
		 		case .INVISIBLE:fallthrough
		 		case .INVOKER:fallthrough
		 		case .IO:fallthrough
		 		case .IO_THREAD:fallthrough
		 		case .IPC:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ISSUER:fallthrough
		 		case .JSON:fallthrough
		 		case .KEY_BLOCK_SIZE:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LEAVES:fallthrough
		 		case .LESS:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOGFILE:fallthrough
		 		case .LOGS:fallthrough
		 		case .MASTER:fallthrough
		 		case .MASTER_AUTO_POSITION:fallthrough
		 		case .MASTER_CONNECT_RETRY:fallthrough
		 		case .MASTER_DELAY:fallthrough
		 		case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 		case .MASTER_HOST:fallthrough
		 		case .MASTER_LOG_FILE:fallthrough
		 		case .MASTER_LOG_POS:fallthrough
		 		case .MASTER_PASSWORD:fallthrough
		 		case .MASTER_PORT:fallthrough
		 		case .MASTER_RETRY_COUNT:fallthrough
		 		case .MASTER_SSL:fallthrough
		 		case .MASTER_SSL_CA:fallthrough
		 		case .MASTER_SSL_CAPATH:fallthrough
		 		case .MASTER_SSL_CERT:fallthrough
		 		case .MASTER_SSL_CIPHER:fallthrough
		 		case .MASTER_SSL_CRL:fallthrough
		 		case .MASTER_SSL_CRLPATH:fallthrough
		 		case .MASTER_SSL_KEY:fallthrough
		 		case .MASTER_TLS_VERSION:fallthrough
		 		case .MASTER_USER:fallthrough
		 		case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 		case .MAX_QUERIES_PER_HOUR:fallthrough
		 		case .MAX_ROWS:fallthrough
		 		case .MAX_SIZE:fallthrough
		 		case .MAX_UPDATES_PER_HOUR:fallthrough
		 		case .MAX_USER_CONNECTIONS:fallthrough
		 		case .MEDIUM:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MESSAGE_TEXT:fallthrough
		 		case .MID:fallthrough
		 		case .MIGRATE:fallthrough
		 		case .MIN_ROWS:fallthrough
		 		case .MODE:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MUTEX:fallthrough
		 		case .MYSQL:fallthrough
		 		case .MYSQL_ERRNO:fallthrough
		 		case .NAME:fallthrough
		 		case .NAMES:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NEVER:fallthrough
		 		case .NEXT:fallthrough
		 		case .NO:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOWAIT:fallthrough
		 		case .NODEGROUP:fallthrough
		 		case .NONE:fallthrough
		 		case .ODBC:fallthrough
		 		case .OFFLINE:fallthrough
		 		case .OFFSET:fallthrough
		 		case .OF:fallthrough
		 		case .OJ:fallthrough
		 		case .OLD_PASSWORD:fallthrough
		 		case .ONE:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .OPTIMIZER_COSTS:fallthrough
		 		case .OPTIONS:fallthrough
		 		case .OWNER:fallthrough
		 		case .PACK_KEYS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PARSER:fallthrough
		 		case .PARTIAL:fallthrough
		 		case .PARTITIONING:fallthrough
		 		case .PARTITIONS:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PHASE:fallthrough
		 		case .PLUGIN:fallthrough
		 		case .PLUGIN_DIR:fallthrough
		 		case .PLUGINS:fallthrough
		 		case .PORT:fallthrough
		 		case .PRECEDES:fallthrough
		 		case .PREPARE:fallthrough
		 		case .PRESERVE:fallthrough
		 		case .PREV:fallthrough
		 		case .PROCESSLIST:fallthrough
		 		case .PROFILE:fallthrough
		 		case .PROFILES:fallthrough
		 		case .PROXY:fallthrough
		 		case .QUERY:fallthrough
		 		case .QUICK:fallthrough
		 		case .REBUILD:fallthrough
		 		case .RECOVER:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REDO_BUFFER_SIZE:fallthrough
		 		case .REDUNDANT:fallthrough
		 		case .RELAY:fallthrough
		 		case .RELAY_LOG_FILE:fallthrough
		 		case .RELAY_LOG_POS:fallthrough
		 		case .RELAYLOG:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REORGANIZE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .REPLICATE_DO_DB:fallthrough
		 		case .REPLICATE_DO_TABLE:fallthrough
		 		case .REPLICATE_IGNORE_DB:fallthrough
		 		case .REPLICATE_IGNORE_TABLE:fallthrough
		 		case .REPLICATE_REWRITE_DB:fallthrough
		 		case .REPLICATE_WILD_DO_TABLE:fallthrough
		 		case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 		case .REPLICATION:fallthrough
		 		case .RESET:fallthrough
		 		case .RESUME:fallthrough
		 		case .RETURNED_SQLSTATE:fallthrough
		 		case .RETURNING:fallthrough
		 		case .RETURNS:fallthrough
		 		case .REUSE:fallthrough
		 		case .ROLE:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROTATE:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_FORMAT:fallthrough
		 		case .RTREE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEDULE:fallthrough
		 		case .SECURITY:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION:fallthrough
		 		case .SHARE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SIGNED:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SLAVE:fallthrough
		 		case .SLOW:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOCKET:fallthrough
		 		case .SOME:fallthrough
		 		case .SONAME:fallthrough
		 		case .SOUNDS:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SQL_AFTER_GTIDS:fallthrough
		 		case .SQL_AFTER_MTS_GAPS:fallthrough
		 		case .SQL_BEFORE_GTIDS:fallthrough
		 		case .SQL_BUFFER_RESULT:fallthrough
		 		case .SQL_CACHE:fallthrough
		 		case .SQL_NO_CACHE:fallthrough
		 		case .SQL_THREAD:fallthrough
		 		case .START:fallthrough
		 		case .STARTS:fallthrough
		 		case .STATS_AUTO_RECALC:fallthrough
		 		case .STATS_PERSISTENT:fallthrough
		 		case .STATS_SAMPLE_PAGES:fallthrough
		 		case .STATUS:fallthrough
		 		case .STOP:fallthrough
		 		case .STORAGE:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBCLASS_ORIGIN:fallthrough
		 		case .SUBJECT:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBPARTITIONS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .SWAPS:fallthrough
		 		case .SWITCHES:fallthrough
		 		case .TABLE_NAME:fallthrough
		 		case .TABLESPACE:fallthrough
		 		case .TABLE_TYPE:fallthrough
		 		case .TEMPORARY:fallthrough
		 		case .TEMPTABLE:fallthrough
		 		case .THAN:fallthrough
		 		case .TRADITIONAL:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSACTIONAL:fallthrough
		 		case .TRIGGERS:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDEFINED:fallthrough
		 		case .UNDOFILE:fallthrough
		 		case .UNDO_BUFFER_SIZE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPGRADE:fallthrough
		 		case .USER:fallthrough
		 		case .USE_FRM:fallthrough
		 		case .USER_RESOURCES:fallthrough
		 		case .VALIDATION:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARIABLES:fallthrough
		 		case .VIEW:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .VISIBLE:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNINGS:fallthrough
		 		case .WITHOUT:fallthrough
		 		case .WORK:fallthrough
		 		case .WRAPPER:fallthrough
		 		case .X509:fallthrough
		 		case .XA:fallthrough
		 		case .XML:fallthrough
		 		case .EUR:fallthrough
		 		case .USA:fallthrough
		 		case .JIS:fallthrough
		 		case .ISO:fallthrough
		 		case .INTERNAL:fallthrough
		 		case .QUARTER:fallthrough
		 		case .MONTH:fallthrough
		 		case .DAY:fallthrough
		 		case .HOUR:fallthrough
		 		case .MINUTE:fallthrough
		 		case .WEEK:fallthrough
		 		case .SECOND:fallthrough
		 		case .MICROSECOND:fallthrough
		 		case .ADMIN:fallthrough
		 		case .AUDIT_ABORT_EXEMPT:fallthrough
		 		case .AUDIT_ADMIN:fallthrough
		 		case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 		case .BACKUP_ADMIN:fallthrough
		 		case .BINLOG_ADMIN:fallthrough
		 		case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 		case .CLONE_ADMIN:fallthrough
		 		case .CONNECTION_ADMIN:fallthrough
		 		case .ENCRYPTION_KEY_ADMIN:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .FILE:fallthrough
		 		case .FIREWALL_ADMIN:fallthrough
		 		case .FIREWALL_EXEMPT:fallthrough
		 		case .FIREWALL_USER:fallthrough
		 		case .GROUP_REPLICATION_ADMIN:fallthrough
		 		case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 		case .INVOKE:fallthrough
		 		case .LAMBDA:fallthrough
		 		case .NDB_STORED_USER:fallthrough
		 		case .PASSWORDLESS_USER_ADMIN:fallthrough
		 		case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .PROCESS:fallthrough
		 		case .RELOAD:fallthrough
		 		case .REPLICATION_APPLIER:fallthrough
		 		case .REPLICATION_SLAVE_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_USER:fallthrough
		 		case .ROLE_ADMIN:fallthrough
		 		case .ROUTINE:fallthrough
		 		case .S3:fallthrough
		 		case .SESSION_VARIABLES_ADMIN:fallthrough
		 		case .SET_USER_ID:fallthrough
		 		case .SHOW_ROUTINE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SUPER:fallthrough
		 		case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 		case .TABLES:fallthrough
		 		case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 		case .VERSION_TOKEN_ADMIN:fallthrough
		 		case .XA_RECOVER_ADMIN:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .ARCHIVE:fallthrough
		 		case .BLACKHOLE:fallthrough
		 		case .CSV:fallthrough
		 		case .FEDERATED:fallthrough
		 		case .INNODB:fallthrough
		 		case .MEMORY:fallthrough
		 		case .MRG_MYISAM:fallthrough
		 		case .MYISAM:fallthrough
		 		case .NDB:fallthrough
		 		case .NDBCLUSTER:fallthrough
		 		case .PERFORMANCE_SCHEMA:fallthrough
		 		case .TOKUDB:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:fallthrough
		 		case .ABS:fallthrough
		 		case .ACOS:fallthrough
		 		case .ADDDATE:fallthrough
		 		case .ADDTIME:fallthrough
		 		case .AES_DECRYPT:fallthrough
		 		case .AES_ENCRYPT:fallthrough
		 		case .AREA:fallthrough
		 		case .ASBINARY:fallthrough
		 		case .ASIN:fallthrough
		 		case .ASTEXT:fallthrough
		 		case .ASWKB:fallthrough
		 		case .ASWKT:fallthrough
		 		case .ASYMMETRIC_DECRYPT:fallthrough
		 		case .ASYMMETRIC_DERIVE:fallthrough
		 		case .ASYMMETRIC_ENCRYPT:fallthrough
		 		case .ASYMMETRIC_SIGN:fallthrough
		 		case .ASYMMETRIC_VERIFY:fallthrough
		 		case .ATAN:fallthrough
		 		case .ATAN2:fallthrough
		 		case .BENCHMARK:fallthrough
		 		case .BIN:fallthrough
		 		case .BIT_COUNT:fallthrough
		 		case .BIT_LENGTH:fallthrough
		 		case .BUFFER:fallthrough
		 		case .CATALOG_NAME:fallthrough
		 		case .CEIL:fallthrough
		 		case .CEILING:fallthrough
		 		case .CENTROID:fallthrough
		 		case .CHARACTER_LENGTH:fallthrough
		 		case .CHARSET:fallthrough
		 		case .CHAR_LENGTH:fallthrough
		 		case .COERCIBILITY:fallthrough
		 		case .COLLATION:fallthrough
		 		case .COMPRESS:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_WS:fallthrough
		 		case .CONNECTION_ID:fallthrough
		 		case .CONV:fallthrough
		 		case .CONVERT_TZ:fallthrough
		 		case .COS:fallthrough
		 		case .COT:fallthrough
		 		case .CRC32:fallthrough
		 		case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 		case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 		case .CREATE_DH_PARAMETERS:fallthrough
		 		case .CREATE_DIGEST:fallthrough
		 		case .CROSSES:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATE_FORMAT:fallthrough
		 		case .DAYNAME:fallthrough
		 		case .DAYOFMONTH:fallthrough
		 		case .DAYOFWEEK:fallthrough
		 		case .DAYOFYEAR:fallthrough
		 		case .DECODE:fallthrough
		 		case .DEGREES:fallthrough
		 		case .DES_DECRYPT:fallthrough
		 		case .DES_ENCRYPT:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISJOINT:fallthrough
		 		case .ELT:fallthrough
		 		case .ENCODE:fallthrough
		 		case .ENCRYPT:fallthrough
		 		case .ENDPOINT:fallthrough
		 		case .ENGINE_ATTRIBUTE:fallthrough
		 		case .ENVELOPE:fallthrough
		 		case .EQUALS:fallthrough
		 		case .EXP:fallthrough
		 		case .EXPORT_SET:fallthrough
		 		case .EXTERIORRING:fallthrough
		 		case .EXTRACTVALUE:fallthrough
		 		case .FIELD:fallthrough
		 		case .FIND_IN_SET:fallthrough
		 		case .FLOOR:fallthrough
		 		case .FORMAT:fallthrough
		 		case .FOUND_ROWS:fallthrough
		 		case .FROM_BASE64:fallthrough
		 		case .FROM_DAYS:fallthrough
		 		case .FROM_UNIXTIME:fallthrough
		 		case .GEOMCOLLFROMTEXT:fallthrough
		 		case .GEOMCOLLFROMWKB:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .GEOMETRYFROMTEXT:fallthrough
		 		case .GEOMETRYFROMWKB:fallthrough
		 		case .GEOMETRYN:fallthrough
		 		case .GEOMETRYTYPE:fallthrough
		 		case .GEOMFROMTEXT:fallthrough
		 		case .GEOMFROMWKB:fallthrough
		 		case .GET_FORMAT:fallthrough
		 		case .GET_LOCK:fallthrough
		 		case .GLENGTH:fallthrough
		 		case .GREATEST:fallthrough
		 		case .GTID_SUBSET:fallthrough
		 		case .GTID_SUBTRACT:fallthrough
		 		case .HEX:fallthrough
		 		case .IFNULL:fallthrough
		 		case .INET6_ATON:fallthrough
		 		case .INET6_NTOA:fallthrough
		 		case .INET_ATON:fallthrough
		 		case .INET_NTOA:fallthrough
		 		case .INSTR:fallthrough
		 		case .INTERIORRINGN:fallthrough
		 		case .INTERSECTS:fallthrough
		 		case .ISCLOSED:fallthrough
		 		case .ISEMPTY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .ISSIMPLE:fallthrough
		 		case .IS_FREE_LOCK:fallthrough
		 		case .IS_IPV4:fallthrough
		 		case .IS_IPV4_COMPAT:fallthrough
		 		case .IS_IPV4_MAPPED:fallthrough
		 		case .IS_IPV6:fallthrough
		 		case .IS_USED_LOCK:fallthrough
		 		case .LAST_INSERT_ID:fallthrough
		 		case .LCASE:fallthrough
		 		case .LEAST:fallthrough
		 		case .LENGTH:fallthrough
		 		case .LINEFROMTEXT:fallthrough
		 		case .LINEFROMWKB:fallthrough
		 		case .LINESTRINGFROMTEXT:fallthrough
		 		case .LINESTRINGFROMWKB:fallthrough
		 		case .LN:fallthrough
		 		case .LOAD_FILE:fallthrough
		 		case .LOCATE:fallthrough
		 		case .LOG:fallthrough
		 		case .LOG10:fallthrough
		 		case .LOG2:fallthrough
		 		case .LOWER:fallthrough
		 		case .LPAD:fallthrough
		 		case .LTRIM:fallthrough
		 		case .MAKEDATE:fallthrough
		 		case .MAKETIME:fallthrough
		 		case .MAKE_SET:fallthrough
		 		case .MASTER_POS_WAIT:fallthrough
		 		case .MBRCONTAINS:fallthrough
		 		case .MBRDISJOINT:fallthrough
		 		case .MBREQUAL:fallthrough
		 		case .MBRINTERSECTS:fallthrough
		 		case .MBROVERLAPS:fallthrough
		 		case .MBRTOUCHES:fallthrough
		 		case .MBRWITHIN:fallthrough
		 		case .MD5:fallthrough
		 		case .MLINEFROMTEXT:fallthrough
		 		case .MLINEFROMWKB:fallthrough
		 		case .MONTHNAME:fallthrough
		 		case .MPOINTFROMTEXT:fallthrough
		 		case .MPOINTFROMWKB:fallthrough
		 		case .MPOLYFROMTEXT:fallthrough
		 		case .MPOLYFROMWKB:fallthrough
		 		case .MULTILINESTRINGFROMTEXT:fallthrough
		 		case .MULTILINESTRINGFROMWKB:fallthrough
		 		case .MULTIPOINTFROMTEXT:fallthrough
		 		case .MULTIPOINTFROMWKB:fallthrough
		 		case .MULTIPOLYGONFROMTEXT:fallthrough
		 		case .MULTIPOLYGONFROMWKB:fallthrough
		 		case .NAME_CONST:fallthrough
		 		case .NULLIF:fallthrough
		 		case .NUMGEOMETRIES:fallthrough
		 		case .NUMINTERIORRINGS:fallthrough
		 		case .NUMPOINTS:fallthrough
		 		case .OCT:fallthrough
		 		case .OCTET_LENGTH:fallthrough
		 		case .ORD:fallthrough
		 		case .OVERLAPS:fallthrough
		 		case .PERIOD_ADD:fallthrough
		 		case .PERIOD_DIFF:fallthrough
		 		case .PI:fallthrough
		 		case .POINTFROMTEXT:fallthrough
		 		case .POINTFROMWKB:fallthrough
		 		case .POINTN:fallthrough
		 		case .POLYFROMTEXT:fallthrough
		 		case .POLYFROMWKB:fallthrough
		 		case .POLYGONFROMTEXT:fallthrough
		 		case .POLYGONFROMWKB:fallthrough
		 		case .POW:fallthrough
		 		case .POWER:fallthrough
		 		case .QUOTE:fallthrough
		 		case .RADIANS:fallthrough
		 		case .RAND:fallthrough
		 		case .RANDOM:fallthrough
		 		case .RANDOM_BYTES:fallthrough
		 		case .RELEASE_LOCK:fallthrough
		 		case .REVERSE:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_COUNT:fallthrough
		 		case .RPAD:fallthrough
		 		case .RTRIM:fallthrough
		 		case .SEC_TO_TIME:fallthrough
		 		case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SHA:fallthrough
		 		case .SHA1:fallthrough
		 		case .SHA2:fallthrough
		 		case .SCHEMA_NAME:fallthrough
		 		case .SIGN:fallthrough
		 		case .SIN:fallthrough
		 		case .SLEEP:fallthrough
		 		case .SOUNDEX:fallthrough
		 		case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 		case .SQRT:fallthrough
		 		case .SRID:fallthrough
		 		case .STARTPOINT:fallthrough
		 		case .STRCMP:fallthrough
		 		case .STR_TO_DATE:fallthrough
		 		case .ST_AREA:fallthrough
		 		case .ST_ASBINARY:fallthrough
		 		case .ST_ASTEXT:fallthrough
		 		case .ST_ASWKB:fallthrough
		 		case .ST_ASWKT:fallthrough
		 		case .ST_BUFFER:fallthrough
		 		case .ST_CENTROID:fallthrough
		 		case .ST_CONTAINS:fallthrough
		 		case .ST_CROSSES:fallthrough
		 		case .ST_DIFFERENCE:fallthrough
		 		case .ST_DIMENSION:fallthrough
		 		case .ST_DISJOINT:fallthrough
		 		case .ST_DISTANCE:fallthrough
		 		case .ST_ENDPOINT:fallthrough
		 		case .ST_ENVELOPE:fallthrough
		 		case .ST_EQUALS:fallthrough
		 		case .ST_EXTERIORRING:fallthrough
		 		case .ST_GEOMCOLLFROMTEXT:fallthrough
		 		case .ST_GEOMCOLLFROMTXT:fallthrough
		 		case .ST_GEOMCOLLFROMWKB:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .ST_GEOMETRYFROMTEXT:fallthrough
		 		case .ST_GEOMETRYFROMWKB:fallthrough
		 		case .ST_GEOMETRYN:fallthrough
		 		case .ST_GEOMETRYTYPE:fallthrough
		 		case .ST_GEOMFROMTEXT:fallthrough
		 		case .ST_GEOMFROMWKB:fallthrough
		 		case .ST_INTERIORRINGN:fallthrough
		 		case .ST_INTERSECTION:fallthrough
		 		case .ST_INTERSECTS:fallthrough
		 		case .ST_ISCLOSED:fallthrough
		 		case .ST_ISEMPTY:fallthrough
		 		case .ST_ISSIMPLE:fallthrough
		 		case .ST_LINEFROMTEXT:fallthrough
		 		case .ST_LINEFROMWKB:fallthrough
		 		case .ST_LINESTRINGFROMTEXT:fallthrough
		 		case .ST_LINESTRINGFROMWKB:fallthrough
		 		case .ST_NUMGEOMETRIES:fallthrough
		 		case .ST_NUMINTERIORRING:fallthrough
		 		case .ST_NUMINTERIORRINGS:fallthrough
		 		case .ST_NUMPOINTS:fallthrough
		 		case .ST_OVERLAPS:fallthrough
		 		case .ST_POINTFROMTEXT:fallthrough
		 		case .ST_POINTFROMWKB:fallthrough
		 		case .ST_POINTN:fallthrough
		 		case .ST_POLYFROMTEXT:fallthrough
		 		case .ST_POLYFROMWKB:fallthrough
		 		case .ST_POLYGONFROMTEXT:fallthrough
		 		case .ST_POLYGONFROMWKB:fallthrough
		 		case .ST_SRID:fallthrough
		 		case .ST_STARTPOINT:fallthrough
		 		case .ST_SYMDIFFERENCE:fallthrough
		 		case .ST_TOUCHES:fallthrough
		 		case .ST_UNION:fallthrough
		 		case .ST_WITHIN:fallthrough
		 		case .ST_X:fallthrough
		 		case .ST_Y:fallthrough
		 		case .SUBDATE:fallthrough
		 		case .SUBSTRING_INDEX:fallthrough
		 		case .SUBTIME:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TAN:fallthrough
		 		case .TIMEDIFF:fallthrough
		 		case .TIMESTAMPADD:fallthrough
		 		case .TIMESTAMPDIFF:fallthrough
		 		case .TIME_FORMAT:fallthrough
		 		case .TIME_TO_SEC:fallthrough
		 		case .TOUCHES:fallthrough
		 		case .TO_BASE64:fallthrough
		 		case .TO_DAYS:fallthrough
		 		case .TO_SECONDS:fallthrough
		 		case .TP_CONNECTION_ADMIN:fallthrough
		 		case .UCASE:fallthrough
		 		case .UNCOMPRESS:fallthrough
		 		case .UNCOMPRESSED_LENGTH:fallthrough
		 		case .UNHEX:fallthrough
		 		case .UNIX_TIMESTAMP:fallthrough
		 		case .UPDATEXML:fallthrough
		 		case .UPPER:fallthrough
		 		case .UUID:fallthrough
		 		case .UUID_SHORT:fallthrough
		 		case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 		case .VERSION:fallthrough
		 		case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 		case .WEEKDAY:fallthrough
		 		case .WEEKOFYEAR:fallthrough
		 		case .WEIGHT_STRING:fallthrough
		 		case .WITHIN:fallthrough
		 		case .YEARWEEK:fallthrough
		 		case .Y_FUNCTION:fallthrough
		 		case .X_FUNCTION:fallthrough
		 		case .MOD:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:fallthrough
		 		case .ID:
		 			setState(5999)
		 			try uidList()

		 			break

		 		case .ALL:
		 			setState(6000)
		 			try match(MySqlParser.Tokens.ALL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(6003)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(6006)
		 	try match(MySqlParser.Tokens.IN.rawValue)
		 	setState(6007)
		 	try {
		 			let assignmentValue = try uid()
		 			_localctx.castdown(CacheIndexStatementContext.self).schema = assignmentValue
		 	     }()


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FlushStatementContext: ParserRuleContext {
		open var flushFormat: Token!
			open
			func FLUSH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FLUSH.rawValue, 0)
			}
			open
			func flushOption() -> [FlushOptionContext] {
				return getRuleContexts(FlushOptionContext.self)
			}
			open
			func flushOption(_ i: Int) -> FlushOptionContext? {
				return getRuleContext(FlushOptionContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func NO_WRITE_TO_BINLOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_flushStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFlushStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFlushStatement(self)
			}
		}
	}
	@discardableResult
	 open func flushStatement() throws -> FlushStatementContext {
		var _localctx: FlushStatementContext
		_localctx = FlushStatementContext(_ctx, getState())
		try enterRule(_localctx, 508, MySqlParser.RULE_flushStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6009)
		 	try match(MySqlParser.Tokens.FLUSH.rawValue)
		 	setState(6011)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue) {
		 		setState(6010)
		 		_localctx.castdown(FlushStatementContext.self).flushFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.NO_WRITE_TO_BINLOG.rawValue || _la == MySqlParser.Tokens.LOCAL.rawValue)) {
		 			_localctx.castdown(FlushStatementContext.self).flushFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(6013)
		 	try flushOption()
		 	setState(6018)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6014)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6015)
		 		try flushOption()


		 		setState(6020)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class KillStatementContext: ParserRuleContext {
		open var connectionFormat: Token!
			open
			func KILL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KILL.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func CONNECTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONNECTION.rawValue, 0)
			}
			open
			func QUERY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUERY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_killStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterKillStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitKillStatement(self)
			}
		}
	}
	@discardableResult
	 open func killStatement() throws -> KillStatementContext {
		var _localctx: KillStatementContext
		_localctx = KillStatementContext(_ctx, getState())
		try enterRule(_localctx, 510, MySqlParser.RULE_killStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6021)
		 	try match(MySqlParser.Tokens.KILL.rawValue)
		 	setState(6023)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,876,_ctx)) {
		 	case 1:
		 		setState(6022)
		 		_localctx.castdown(KillStatementContext.self).connectionFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.CONNECTION.rawValue || _la == MySqlParser.Tokens.QUERY.rawValue)) {
		 			_localctx.castdown(KillStatementContext.self).connectionFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		 	setState(6025)
		 	try expression(0)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LoadIndexIntoCacheContext: ParserRuleContext {
			open
			func LOAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOAD.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func INTO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTO.rawValue, 0)
			}
			open
			func CACHE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CACHE.rawValue, 0)
			}
			open
			func loadedTableIndexes() -> [LoadedTableIndexesContext] {
				return getRuleContexts(LoadedTableIndexesContext.self)
			}
			open
			func loadedTableIndexes(_ i: Int) -> LoadedTableIndexesContext? {
				return getRuleContext(LoadedTableIndexesContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_loadIndexIntoCache
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLoadIndexIntoCache(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLoadIndexIntoCache(self)
			}
		}
	}
	@discardableResult
	 open func loadIndexIntoCache() throws -> LoadIndexIntoCacheContext {
		var _localctx: LoadIndexIntoCacheContext
		_localctx = LoadIndexIntoCacheContext(_ctx, getState())
		try enterRule(_localctx, 512, MySqlParser.RULE_loadIndexIntoCache)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6027)
		 	try match(MySqlParser.Tokens.LOAD.rawValue)
		 	setState(6028)
		 	try match(MySqlParser.Tokens.INDEX.rawValue)
		 	setState(6029)
		 	try match(MySqlParser.Tokens.INTO.rawValue)
		 	setState(6030)
		 	try match(MySqlParser.Tokens.CACHE.rawValue)
		 	setState(6031)
		 	try loadedTableIndexes()
		 	setState(6036)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6032)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6033)
		 		try loadedTableIndexes()


		 		setState(6038)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ResetStatementContext: ParserRuleContext {
			open
			func RESET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESET.rawValue, 0)
			}
			open
			func QUERY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUERY.rawValue, 0)
			}
			open
			func CACHE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CACHE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_resetStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterResetStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitResetStatement(self)
			}
		}
	}
	@discardableResult
	 open func resetStatement() throws -> ResetStatementContext {
		var _localctx: ResetStatementContext
		_localctx = ResetStatementContext(_ctx, getState())
		try enterRule(_localctx, 514, MySqlParser.RULE_resetStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6039)
		 	try match(MySqlParser.Tokens.RESET.rawValue)
		 	setState(6040)
		 	try match(MySqlParser.Tokens.QUERY.rawValue)
		 	setState(6041)
		 	try match(MySqlParser.Tokens.CACHE.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ShutdownStatementContext: ParserRuleContext {
			open
			func SHUTDOWN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHUTDOWN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_shutdownStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterShutdownStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitShutdownStatement(self)
			}
		}
	}
	@discardableResult
	 open func shutdownStatement() throws -> ShutdownStatementContext {
		var _localctx: ShutdownStatementContext
		_localctx = ShutdownStatementContext(_ctx, getState())
		try enterRule(_localctx, 516, MySqlParser.RULE_shutdownStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6043)
		 	try match(MySqlParser.Tokens.SHUTDOWN.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TableIndexesContext: ParserRuleContext {
		open var indexFormat: Token!
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func uidList() -> UidListContext? {
				return getRuleContext(UidListContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tableIndexes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableIndexes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableIndexes(self)
			}
		}
	}
	@discardableResult
	 open func tableIndexes() throws -> TableIndexesContext {
		var _localctx: TableIndexesContext
		_localctx = TableIndexesContext(_ctx, getState())
		try enterRule(_localctx, 518, MySqlParser.RULE_tableIndexes)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6045)
		 	try tableName()
		 	setState(6053)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue || _la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 		setState(6047)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue) {
		 			setState(6046)
		 			_localctx.castdown(TableIndexesContext.self).indexFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue)) {
		 				_localctx.castdown(TableIndexesContext.self).indexFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(6049)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6050)
		 		try uidList()
		 		setState(6051)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FlushOptionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_flushOption
		}
	}
	public class TableFlushOptionContext: FlushOptionContext {
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func TABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLES.rawValue, 0)
			}
			open
			func tables() -> TablesContext? {
				return getRuleContext(TablesContext.self, 0)
			}
			open
			func flushTableOption() -> FlushTableOptionContext? {
				return getRuleContext(FlushTableOptionContext.self, 0)
			}

		public
		init(_ ctx: FlushOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableFlushOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableFlushOption(self)
			}
		}
	}
	public class ChannelFlushOptionContext: FlushOptionContext {
			open
			func RELAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELAY.rawValue, 0)
			}
			open
			func LOGS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOGS.rawValue, 0)
			}
			open
			func channelOption() -> ChannelOptionContext? {
				return getRuleContext(ChannelOptionContext.self, 0)
			}

		public
		init(_ ctx: FlushOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterChannelFlushOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitChannelFlushOption(self)
			}
		}
	}
	public class SimpleFlushOptionContext: FlushOptionContext {
			open
			func DES_KEY_FILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DES_KEY_FILE.rawValue, 0)
			}
			open
			func HOSTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HOSTS.rawValue, 0)
			}
			open
			func LOGS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOGS.rawValue, 0)
			}
			open
			func OPTIMIZER_COSTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTIMIZER_COSTS.rawValue, 0)
			}
			open
			func PRIVILEGES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRIVILEGES.rawValue, 0)
			}
			open
			func QUERY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUERY.rawValue, 0)
			}
			open
			func CACHE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CACHE.rawValue, 0)
			}
			open
			func STATUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATUS.rawValue, 0)
			}
			open
			func USER_RESOURCES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER_RESOURCES.rawValue, 0)
			}
			open
			func TABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLES.rawValue, 0)
			}
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func READ() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.READ.rawValue, 0)
			}
			open
			func LOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCK.rawValue, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func ERROR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ERROR.rawValue, 0)
			}
			open
			func GENERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GENERAL.rawValue, 0)
			}
			open
			func RELAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELAY.rawValue, 0)
			}
			open
			func SLOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SLOW.rawValue, 0)
			}

		public
		init(_ ctx: FlushOptionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSimpleFlushOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSimpleFlushOption(self)
			}
		}
	}
	@discardableResult
	 open func flushOption() throws -> FlushOptionContext {
		var _localctx: FlushOptionContext
		_localctx = FlushOptionContext(_ctx, getState())
		try enterRule(_localctx, 520, MySqlParser.RULE_flushOption)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6087)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,886, _ctx)) {
		 	case 1:
		 		_localctx =  SimpleFlushOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6073)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .DES_KEY_FILE:
		 			setState(6055)
		 			try match(MySqlParser.Tokens.DES_KEY_FILE.rawValue)

		 			break

		 		case .HOSTS:
		 			setState(6056)
		 			try match(MySqlParser.Tokens.HOSTS.rawValue)

		 			break
		 		case .BINARY:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ERROR:fallthrough
		 		case .GENERAL:fallthrough
		 		case .LOGS:fallthrough
		 		case .RELAY:fallthrough
		 		case .SLOW:
		 			setState(6058)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.BINARY.rawValue || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & 536870917) != 0) || _la == MySqlParser.Tokens.RELAY.rawValue || _la == MySqlParser.Tokens.SLOW.rawValue) {
		 				setState(6057)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.BINARY.rawValue || ((Int64((_la - 409)) & ~0x3f) == 0 && ((Int64(1) << (_la - 409)) & 536870917) != 0) || _la == MySqlParser.Tokens.RELAY.rawValue || _la == MySqlParser.Tokens.SLOW.rawValue)) {
		 				try _errHandler.recoverInline(self)
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 			}

		 			setState(6060)
		 			try match(MySqlParser.Tokens.LOGS.rawValue)

		 			break

		 		case .OPTIMIZER_COSTS:
		 			setState(6061)
		 			try match(MySqlParser.Tokens.OPTIMIZER_COSTS.rawValue)

		 			break

		 		case .PRIVILEGES:
		 			setState(6062)
		 			try match(MySqlParser.Tokens.PRIVILEGES.rawValue)

		 			break

		 		case .QUERY:
		 			setState(6063)
		 			try match(MySqlParser.Tokens.QUERY.rawValue)
		 			setState(6064)
		 			try match(MySqlParser.Tokens.CACHE.rawValue)

		 			break

		 		case .STATUS:
		 			setState(6065)
		 			try match(MySqlParser.Tokens.STATUS.rawValue)

		 			break

		 		case .USER_RESOURCES:
		 			setState(6066)
		 			try match(MySqlParser.Tokens.USER_RESOURCES.rawValue)

		 			break

		 		case .TABLES:
		 			setState(6067)
		 			try match(MySqlParser.Tokens.TABLES.rawValue)
		 			setState(6071)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,881,_ctx)) {
		 			case 1:
		 				setState(6068)
		 				try match(MySqlParser.Tokens.WITH.rawValue)
		 				setState(6069)
		 				try match(MySqlParser.Tokens.READ.rawValue)
		 				setState(6070)
		 				try match(MySqlParser.Tokens.LOCK.rawValue)

		 				break
		 			default: break
		 			}

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break
		 	case 2:
		 		_localctx =  ChannelFlushOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6075)
		 		try match(MySqlParser.Tokens.RELAY.rawValue)
		 		setState(6076)
		 		try match(MySqlParser.Tokens.LOGS.rawValue)
		 		setState(6078)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FOR.rawValue) {
		 			setState(6077)
		 			try channelOption()

		 		}


		 		break
		 	case 3:
		 		_localctx =  TableFlushOptionContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6080)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.TABLE.rawValue || _la == MySqlParser.Tokens.TABLES.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6082)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,884,_ctx)) {
		 		case 1:
		 			setState(6081)
		 			try tables()

		 			break
		 		default: break
		 		}
		 		setState(6085)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,885,_ctx)) {
		 		case 1:
		 			setState(6084)
		 			try flushTableOption()

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FlushTableOptionContext: ParserRuleContext {
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func READ() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.READ.rawValue, 0)
			}
			open
			func LOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCK.rawValue, 0)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func EXPORT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXPORT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_flushTableOption
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFlushTableOption(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFlushTableOption(self)
			}
		}
	}
	@discardableResult
	 open func flushTableOption() throws -> FlushTableOptionContext {
		var _localctx: FlushTableOptionContext
		_localctx = FlushTableOptionContext(_ctx, getState())
		try enterRule(_localctx, 522, MySqlParser.RULE_flushTableOption)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6094)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .WITH:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6089)
		 		try match(MySqlParser.Tokens.WITH.rawValue)
		 		setState(6090)
		 		try match(MySqlParser.Tokens.READ.rawValue)
		 		setState(6091)
		 		try match(MySqlParser.Tokens.LOCK.rawValue)

		 		break

		 	case .FOR:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6092)
		 		try match(MySqlParser.Tokens.FOR.rawValue)
		 		setState(6093)
		 		try match(MySqlParser.Tokens.EXPORT.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LoadedTableIndexesContext: ParserRuleContext {
		open var partitionList: UidListContext!
		open var indexFormat: Token!
		open var indexList: UidListContext!
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func IGNORE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE.rawValue, 0)
			}
			open
			func LEAVES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEAVES.rawValue, 0)
			}
			open
			func uidList() -> [UidListContext] {
				return getRuleContexts(UidListContext.self)
			}
			open
			func uidList(_ i: Int) -> UidListContext? {
				return getRuleContext(UidListContext.self, i)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEX.rawValue, 0)
			}
			open
			func KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_loadedTableIndexes
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLoadedTableIndexes(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLoadedTableIndexes(self)
			}
		}
	}
	@discardableResult
	 open func loadedTableIndexes() throws -> LoadedTableIndexesContext {
		var _localctx: LoadedTableIndexesContext
		_localctx = LoadedTableIndexesContext(_ctx, getState())
		try enterRule(_localctx, 524, MySqlParser.RULE_loadedTableIndexes)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6096)
		 	try tableName()
		 	setState(6104)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.PARTITION.rawValue) {
		 		setState(6097)
		 		try match(MySqlParser.Tokens.PARTITION.rawValue)
		 		setState(6098)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6101)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ARRAY:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .BUCKETS:fallthrough
		 		case .CONDITION:fallthrough
		 		case .CURRENT:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DIAGNOSTICS:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENFORCED:fallthrough
		 		case .EXCEPT:fallthrough
		 		case .GROUP:fallthrough
		 		case .IF:fallthrough
		 		case .IGNORED:fallthrough
		 		case .INSERT:fallthrough
		 		case .LATERAL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OPTIONAL:fallthrough
		 		case .ORDER:fallthrough
		 		case .PRIMARY:fallthrough
		 		case .REPEAT:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SKIP_QUERY_REWRITE:fallthrough
		 		case .STACKED:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .BINARY:fallthrough
		 		case .TEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .JSON_ARRAY:fallthrough
		 		case .JSON_ARRAYAGG:fallthrough
		 		case .JSON_ARRAY_APPEND:fallthrough
		 		case .JSON_ARRAY_INSERT:fallthrough
		 		case .JSON_CONTAINS:fallthrough
		 		case .JSON_CONTAINS_PATH:fallthrough
		 		case .JSON_DEPTH:fallthrough
		 		case .JSON_EXTRACT:fallthrough
		 		case .JSON_INSERT:fallthrough
		 		case .JSON_KEYS:fallthrough
		 		case .JSON_LENGTH:fallthrough
		 		case .JSON_MERGE:fallthrough
		 		case .JSON_MERGE_PATCH:fallthrough
		 		case .JSON_MERGE_PRESERVE:fallthrough
		 		case .JSON_OBJECT:fallthrough
		 		case .JSON_OBJECTAGG:fallthrough
		 		case .JSON_OVERLAPS:fallthrough
		 		case .JSON_PRETTY:fallthrough
		 		case .JSON_QUOTE:fallthrough
		 		case .JSON_REMOVE:fallthrough
		 		case .JSON_REPLACE:fallthrough
		 		case .JSON_SCHEMA_VALID:fallthrough
		 		case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 		case .JSON_SEARCH:fallthrough
		 		case .JSON_SET:fallthrough
		 		case .JSON_STORAGE_FREE:fallthrough
		 		case .JSON_STORAGE_SIZE:fallthrough
		 		case .JSON_TABLE:fallthrough
		 		case .JSON_TYPE:fallthrough
		 		case .JSON_UNQUOTE:fallthrough
		 		case .JSON_VALID:fallthrough
		 		case .JSON_VALUE:fallthrough
		 		case .NESTED:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .PATH:fallthrough
		 		case .AVG:fallthrough
		 		case .BIT_AND:fallthrough
		 		case .BIT_OR:fallthrough
		 		case .BIT_XOR:fallthrough
		 		case .COUNT:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .GROUP_CONCAT:fallthrough
		 		case .LAG:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NTH_VALUE:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .RANK:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .STD:fallthrough
		 		case .STDDEV:fallthrough
		 		case .STDDEV_POP:fallthrough
		 		case .STDDEV_SAMP:fallthrough
		 		case .SUM:fallthrough
		 		case .VAR_POP:fallthrough
		 		case .VAR_SAMP:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .CURRENT_DATE:fallthrough
		 		case .CURRENT_TIME:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .LOCALTIME:fallthrough
		 		case .CURDATE:fallthrough
		 		case .CURTIME:fallthrough
		 		case .DATE_ADD:fallthrough
		 		case .DATE_SUB:fallthrough
		 		case .LOCALTIMESTAMP:fallthrough
		 		case .NOW:fallthrough
		 		case .POSITION:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .SUBSTRING:fallthrough
		 		case .SYSDATE:fallthrough
		 		case .TRIM:fallthrough
		 		case .UTC_DATE:fallthrough
		 		case .UTC_TIME:fallthrough
		 		case .UTC_TIMESTAMP:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .ACTION:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALGORITHM:fallthrough
		 		case .ANY:fallthrough
		 		case .AT:fallthrough
		 		case .AUTHORS:fallthrough
		 		case .AUTOCOMMIT:fallthrough
		 		case .AUTOEXTEND_SIZE:fallthrough
		 		case .AUTO_INCREMENT:fallthrough
		 		case .AVG_ROW_LENGTH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .BIT:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BTREE:fallthrough
		 		case .CACHE:fallthrough
		 		case .CASCADED:fallthrough
		 		case .CHAIN:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .PAGE_CHECKSUM:fallthrough
		 		case .CIPHER:fallthrough
		 		case .CLASS_ORIGIN:fallthrough
		 		case .CLIENT:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTERING:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CODE:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COLUMN_FORMAT:fallthrough
		 		case .COLUMN_NAME:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMPACT:fallthrough
		 		case .COMPLETION:fallthrough
		 		case .COMPRESSED:fallthrough
		 		case .COMPRESSION:fallthrough
		 		case .CONCURRENT:fallthrough
		 		case .CONNECT:fallthrough
		 		case .CONNECTION:fallthrough
		 		case .CONSISTENT:fallthrough
		 		case .CONSTRAINT_CATALOG:fallthrough
		 		case .CONSTRAINT_SCHEMA:fallthrough
		 		case .CONSTRAINT_NAME:fallthrough
		 		case .CONTAINS:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTRIBUTORS:fallthrough
		 		case .COPY:fallthrough
		 		case .CPU:fallthrough
		 		case .CURSOR_NAME:fallthrough
		 		case .DATA:fallthrough
		 		case .DATAFILE:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DEFAULT_AUTH:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DELAY_KEY_WRITE:fallthrough
		 		case .DES_KEY_FILE:fallthrough
		 		case .DIRECTORY:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISCARD:fallthrough
		 		case .DISK:fallthrough
		 		case .DO:fallthrough
		 		case .DUMPFILE:fallthrough
		 		case .DUPLICATE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .END:fallthrough
		 		case .ENDS:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ENGINES:fallthrough
		 		case .ERROR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVEN:fallthrough
		 		case .EVENT:fallthrough
		 		case .EVENTS:fallthrough
		 		case .EVERY:fallthrough
		 		case .EXCHANGE:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPIRE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .EXTENT_SIZE:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FAST:fallthrough
		 		case .FAULTS:fallthrough
		 		case .FIELDS:fallthrough
		 		case .FILE_BLOCK_SIZE:fallthrough
		 		case .FILTER:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIXED:fallthrough
		 		case .FLUSH:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FOUND:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GENERAL:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GRANTS:fallthrough
		 		case .GROUP_REPLICATION:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HASH:fallthrough
		 		case .HELP:fallthrough
		 		case .HISTORY:fallthrough
		 		case .HOST:fallthrough
		 		case .HOSTS:fallthrough
		 		case .IDENTIFIED:fallthrough
		 		case .IGNORE_SERVER_IDS:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INDEXES:fallthrough
		 		case .INITIAL_SIZE:fallthrough
		 		case .INPLACE:fallthrough
		 		case .INSERT_METHOD:fallthrough
		 		case .INSTALL:fallthrough
		 		case .INSTANCE:fallthrough
		 		case .INSTANT:fallthrough
		 		case .INVISIBLE:fallthrough
		 		case .INVOKER:fallthrough
		 		case .IO:fallthrough
		 		case .IO_THREAD:fallthrough
		 		case .IPC:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ISSUER:fallthrough
		 		case .JSON:fallthrough
		 		case .KEY_BLOCK_SIZE:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LEAVES:fallthrough
		 		case .LESS:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOGFILE:fallthrough
		 		case .LOGS:fallthrough
		 		case .MASTER:fallthrough
		 		case .MASTER_AUTO_POSITION:fallthrough
		 		case .MASTER_CONNECT_RETRY:fallthrough
		 		case .MASTER_DELAY:fallthrough
		 		case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 		case .MASTER_HOST:fallthrough
		 		case .MASTER_LOG_FILE:fallthrough
		 		case .MASTER_LOG_POS:fallthrough
		 		case .MASTER_PASSWORD:fallthrough
		 		case .MASTER_PORT:fallthrough
		 		case .MASTER_RETRY_COUNT:fallthrough
		 		case .MASTER_SSL:fallthrough
		 		case .MASTER_SSL_CA:fallthrough
		 		case .MASTER_SSL_CAPATH:fallthrough
		 		case .MASTER_SSL_CERT:fallthrough
		 		case .MASTER_SSL_CIPHER:fallthrough
		 		case .MASTER_SSL_CRL:fallthrough
		 		case .MASTER_SSL_CRLPATH:fallthrough
		 		case .MASTER_SSL_KEY:fallthrough
		 		case .MASTER_TLS_VERSION:fallthrough
		 		case .MASTER_USER:fallthrough
		 		case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 		case .MAX_QUERIES_PER_HOUR:fallthrough
		 		case .MAX_ROWS:fallthrough
		 		case .MAX_SIZE:fallthrough
		 		case .MAX_UPDATES_PER_HOUR:fallthrough
		 		case .MAX_USER_CONNECTIONS:fallthrough
		 		case .MEDIUM:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MESSAGE_TEXT:fallthrough
		 		case .MID:fallthrough
		 		case .MIGRATE:fallthrough
		 		case .MIN_ROWS:fallthrough
		 		case .MODE:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MUTEX:fallthrough
		 		case .MYSQL:fallthrough
		 		case .MYSQL_ERRNO:fallthrough
		 		case .NAME:fallthrough
		 		case .NAMES:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NEVER:fallthrough
		 		case .NEXT:fallthrough
		 		case .NO:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOWAIT:fallthrough
		 		case .NODEGROUP:fallthrough
		 		case .NONE:fallthrough
		 		case .ODBC:fallthrough
		 		case .OFFLINE:fallthrough
		 		case .OFFSET:fallthrough
		 		case .OF:fallthrough
		 		case .OJ:fallthrough
		 		case .OLD_PASSWORD:fallthrough
		 		case .ONE:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .OPTIMIZER_COSTS:fallthrough
		 		case .OPTIONS:fallthrough
		 		case .OWNER:fallthrough
		 		case .PACK_KEYS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PARSER:fallthrough
		 		case .PARTIAL:fallthrough
		 		case .PARTITIONING:fallthrough
		 		case .PARTITIONS:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PHASE:fallthrough
		 		case .PLUGIN:fallthrough
		 		case .PLUGIN_DIR:fallthrough
		 		case .PLUGINS:fallthrough
		 		case .PORT:fallthrough
		 		case .PRECEDES:fallthrough
		 		case .PREPARE:fallthrough
		 		case .PRESERVE:fallthrough
		 		case .PREV:fallthrough
		 		case .PROCESSLIST:fallthrough
		 		case .PROFILE:fallthrough
		 		case .PROFILES:fallthrough
		 		case .PROXY:fallthrough
		 		case .QUERY:fallthrough
		 		case .QUICK:fallthrough
		 		case .REBUILD:fallthrough
		 		case .RECOVER:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REDO_BUFFER_SIZE:fallthrough
		 		case .REDUNDANT:fallthrough
		 		case .RELAY:fallthrough
		 		case .RELAY_LOG_FILE:fallthrough
		 		case .RELAY_LOG_POS:fallthrough
		 		case .RELAYLOG:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REORGANIZE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .REPLICATE_DO_DB:fallthrough
		 		case .REPLICATE_DO_TABLE:fallthrough
		 		case .REPLICATE_IGNORE_DB:fallthrough
		 		case .REPLICATE_IGNORE_TABLE:fallthrough
		 		case .REPLICATE_REWRITE_DB:fallthrough
		 		case .REPLICATE_WILD_DO_TABLE:fallthrough
		 		case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 		case .REPLICATION:fallthrough
		 		case .RESET:fallthrough
		 		case .RESUME:fallthrough
		 		case .RETURNED_SQLSTATE:fallthrough
		 		case .RETURNING:fallthrough
		 		case .RETURNS:fallthrough
		 		case .REUSE:fallthrough
		 		case .ROLE:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROTATE:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_FORMAT:fallthrough
		 		case .RTREE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEDULE:fallthrough
		 		case .SECURITY:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION:fallthrough
		 		case .SHARE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SIGNED:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SLAVE:fallthrough
		 		case .SLOW:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOCKET:fallthrough
		 		case .SOME:fallthrough
		 		case .SONAME:fallthrough
		 		case .SOUNDS:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SQL_AFTER_GTIDS:fallthrough
		 		case .SQL_AFTER_MTS_GAPS:fallthrough
		 		case .SQL_BEFORE_GTIDS:fallthrough
		 		case .SQL_BUFFER_RESULT:fallthrough
		 		case .SQL_CACHE:fallthrough
		 		case .SQL_NO_CACHE:fallthrough
		 		case .SQL_THREAD:fallthrough
		 		case .START:fallthrough
		 		case .STARTS:fallthrough
		 		case .STATS_AUTO_RECALC:fallthrough
		 		case .STATS_PERSISTENT:fallthrough
		 		case .STATS_SAMPLE_PAGES:fallthrough
		 		case .STATUS:fallthrough
		 		case .STOP:fallthrough
		 		case .STORAGE:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBCLASS_ORIGIN:fallthrough
		 		case .SUBJECT:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBPARTITIONS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .SWAPS:fallthrough
		 		case .SWITCHES:fallthrough
		 		case .TABLE_NAME:fallthrough
		 		case .TABLESPACE:fallthrough
		 		case .TABLE_TYPE:fallthrough
		 		case .TEMPORARY:fallthrough
		 		case .TEMPTABLE:fallthrough
		 		case .THAN:fallthrough
		 		case .TRADITIONAL:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSACTIONAL:fallthrough
		 		case .TRIGGERS:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDEFINED:fallthrough
		 		case .UNDOFILE:fallthrough
		 		case .UNDO_BUFFER_SIZE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPGRADE:fallthrough
		 		case .USER:fallthrough
		 		case .USE_FRM:fallthrough
		 		case .USER_RESOURCES:fallthrough
		 		case .VALIDATION:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARIABLES:fallthrough
		 		case .VIEW:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .VISIBLE:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNINGS:fallthrough
		 		case .WITHOUT:fallthrough
		 		case .WORK:fallthrough
		 		case .WRAPPER:fallthrough
		 		case .X509:fallthrough
		 		case .XA:fallthrough
		 		case .XML:fallthrough
		 		case .EUR:fallthrough
		 		case .USA:fallthrough
		 		case .JIS:fallthrough
		 		case .ISO:fallthrough
		 		case .INTERNAL:fallthrough
		 		case .QUARTER:fallthrough
		 		case .MONTH:fallthrough
		 		case .DAY:fallthrough
		 		case .HOUR:fallthrough
		 		case .MINUTE:fallthrough
		 		case .WEEK:fallthrough
		 		case .SECOND:fallthrough
		 		case .MICROSECOND:fallthrough
		 		case .ADMIN:fallthrough
		 		case .AUDIT_ABORT_EXEMPT:fallthrough
		 		case .AUDIT_ADMIN:fallthrough
		 		case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 		case .BACKUP_ADMIN:fallthrough
		 		case .BINLOG_ADMIN:fallthrough
		 		case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 		case .CLONE_ADMIN:fallthrough
		 		case .CONNECTION_ADMIN:fallthrough
		 		case .ENCRYPTION_KEY_ADMIN:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .FILE:fallthrough
		 		case .FIREWALL_ADMIN:fallthrough
		 		case .FIREWALL_EXEMPT:fallthrough
		 		case .FIREWALL_USER:fallthrough
		 		case .GROUP_REPLICATION_ADMIN:fallthrough
		 		case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 		case .INVOKE:fallthrough
		 		case .LAMBDA:fallthrough
		 		case .NDB_STORED_USER:fallthrough
		 		case .PASSWORDLESS_USER_ADMIN:fallthrough
		 		case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .PROCESS:fallthrough
		 		case .RELOAD:fallthrough
		 		case .REPLICATION_APPLIER:fallthrough
		 		case .REPLICATION_SLAVE_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_USER:fallthrough
		 		case .ROLE_ADMIN:fallthrough
		 		case .ROUTINE:fallthrough
		 		case .S3:fallthrough
		 		case .SESSION_VARIABLES_ADMIN:fallthrough
		 		case .SET_USER_ID:fallthrough
		 		case .SHOW_ROUTINE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SUPER:fallthrough
		 		case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 		case .TABLES:fallthrough
		 		case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 		case .VERSION_TOKEN_ADMIN:fallthrough
		 		case .XA_RECOVER_ADMIN:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .ARCHIVE:fallthrough
		 		case .BLACKHOLE:fallthrough
		 		case .CSV:fallthrough
		 		case .FEDERATED:fallthrough
		 		case .INNODB:fallthrough
		 		case .MEMORY:fallthrough
		 		case .MRG_MYISAM:fallthrough
		 		case .MYISAM:fallthrough
		 		case .NDB:fallthrough
		 		case .NDBCLUSTER:fallthrough
		 		case .PERFORMANCE_SCHEMA:fallthrough
		 		case .TOKUDB:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:fallthrough
		 		case .ABS:fallthrough
		 		case .ACOS:fallthrough
		 		case .ADDDATE:fallthrough
		 		case .ADDTIME:fallthrough
		 		case .AES_DECRYPT:fallthrough
		 		case .AES_ENCRYPT:fallthrough
		 		case .AREA:fallthrough
		 		case .ASBINARY:fallthrough
		 		case .ASIN:fallthrough
		 		case .ASTEXT:fallthrough
		 		case .ASWKB:fallthrough
		 		case .ASWKT:fallthrough
		 		case .ASYMMETRIC_DECRYPT:fallthrough
		 		case .ASYMMETRIC_DERIVE:fallthrough
		 		case .ASYMMETRIC_ENCRYPT:fallthrough
		 		case .ASYMMETRIC_SIGN:fallthrough
		 		case .ASYMMETRIC_VERIFY:fallthrough
		 		case .ATAN:fallthrough
		 		case .ATAN2:fallthrough
		 		case .BENCHMARK:fallthrough
		 		case .BIN:fallthrough
		 		case .BIT_COUNT:fallthrough
		 		case .BIT_LENGTH:fallthrough
		 		case .BUFFER:fallthrough
		 		case .CATALOG_NAME:fallthrough
		 		case .CEIL:fallthrough
		 		case .CEILING:fallthrough
		 		case .CENTROID:fallthrough
		 		case .CHARACTER_LENGTH:fallthrough
		 		case .CHARSET:fallthrough
		 		case .CHAR_LENGTH:fallthrough
		 		case .COERCIBILITY:fallthrough
		 		case .COLLATION:fallthrough
		 		case .COMPRESS:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_WS:fallthrough
		 		case .CONNECTION_ID:fallthrough
		 		case .CONV:fallthrough
		 		case .CONVERT_TZ:fallthrough
		 		case .COS:fallthrough
		 		case .COT:fallthrough
		 		case .CRC32:fallthrough
		 		case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 		case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 		case .CREATE_DH_PARAMETERS:fallthrough
		 		case .CREATE_DIGEST:fallthrough
		 		case .CROSSES:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATE_FORMAT:fallthrough
		 		case .DAYNAME:fallthrough
		 		case .DAYOFMONTH:fallthrough
		 		case .DAYOFWEEK:fallthrough
		 		case .DAYOFYEAR:fallthrough
		 		case .DECODE:fallthrough
		 		case .DEGREES:fallthrough
		 		case .DES_DECRYPT:fallthrough
		 		case .DES_ENCRYPT:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISJOINT:fallthrough
		 		case .ELT:fallthrough
		 		case .ENCODE:fallthrough
		 		case .ENCRYPT:fallthrough
		 		case .ENDPOINT:fallthrough
		 		case .ENGINE_ATTRIBUTE:fallthrough
		 		case .ENVELOPE:fallthrough
		 		case .EQUALS:fallthrough
		 		case .EXP:fallthrough
		 		case .EXPORT_SET:fallthrough
		 		case .EXTERIORRING:fallthrough
		 		case .EXTRACTVALUE:fallthrough
		 		case .FIELD:fallthrough
		 		case .FIND_IN_SET:fallthrough
		 		case .FLOOR:fallthrough
		 		case .FORMAT:fallthrough
		 		case .FOUND_ROWS:fallthrough
		 		case .FROM_BASE64:fallthrough
		 		case .FROM_DAYS:fallthrough
		 		case .FROM_UNIXTIME:fallthrough
		 		case .GEOMCOLLFROMTEXT:fallthrough
		 		case .GEOMCOLLFROMWKB:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .GEOMETRYFROMTEXT:fallthrough
		 		case .GEOMETRYFROMWKB:fallthrough
		 		case .GEOMETRYN:fallthrough
		 		case .GEOMETRYTYPE:fallthrough
		 		case .GEOMFROMTEXT:fallthrough
		 		case .GEOMFROMWKB:fallthrough
		 		case .GET_FORMAT:fallthrough
		 		case .GET_LOCK:fallthrough
		 		case .GLENGTH:fallthrough
		 		case .GREATEST:fallthrough
		 		case .GTID_SUBSET:fallthrough
		 		case .GTID_SUBTRACT:fallthrough
		 		case .HEX:fallthrough
		 		case .IFNULL:fallthrough
		 		case .INET6_ATON:fallthrough
		 		case .INET6_NTOA:fallthrough
		 		case .INET_ATON:fallthrough
		 		case .INET_NTOA:fallthrough
		 		case .INSTR:fallthrough
		 		case .INTERIORRINGN:fallthrough
		 		case .INTERSECTS:fallthrough
		 		case .ISCLOSED:fallthrough
		 		case .ISEMPTY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .ISSIMPLE:fallthrough
		 		case .IS_FREE_LOCK:fallthrough
		 		case .IS_IPV4:fallthrough
		 		case .IS_IPV4_COMPAT:fallthrough
		 		case .IS_IPV4_MAPPED:fallthrough
		 		case .IS_IPV6:fallthrough
		 		case .IS_USED_LOCK:fallthrough
		 		case .LAST_INSERT_ID:fallthrough
		 		case .LCASE:fallthrough
		 		case .LEAST:fallthrough
		 		case .LENGTH:fallthrough
		 		case .LINEFROMTEXT:fallthrough
		 		case .LINEFROMWKB:fallthrough
		 		case .LINESTRINGFROMTEXT:fallthrough
		 		case .LINESTRINGFROMWKB:fallthrough
		 		case .LN:fallthrough
		 		case .LOAD_FILE:fallthrough
		 		case .LOCATE:fallthrough
		 		case .LOG:fallthrough
		 		case .LOG10:fallthrough
		 		case .LOG2:fallthrough
		 		case .LOWER:fallthrough
		 		case .LPAD:fallthrough
		 		case .LTRIM:fallthrough
		 		case .MAKEDATE:fallthrough
		 		case .MAKETIME:fallthrough
		 		case .MAKE_SET:fallthrough
		 		case .MASTER_POS_WAIT:fallthrough
		 		case .MBRCONTAINS:fallthrough
		 		case .MBRDISJOINT:fallthrough
		 		case .MBREQUAL:fallthrough
		 		case .MBRINTERSECTS:fallthrough
		 		case .MBROVERLAPS:fallthrough
		 		case .MBRTOUCHES:fallthrough
		 		case .MBRWITHIN:fallthrough
		 		case .MD5:fallthrough
		 		case .MLINEFROMTEXT:fallthrough
		 		case .MLINEFROMWKB:fallthrough
		 		case .MONTHNAME:fallthrough
		 		case .MPOINTFROMTEXT:fallthrough
		 		case .MPOINTFROMWKB:fallthrough
		 		case .MPOLYFROMTEXT:fallthrough
		 		case .MPOLYFROMWKB:fallthrough
		 		case .MULTILINESTRINGFROMTEXT:fallthrough
		 		case .MULTILINESTRINGFROMWKB:fallthrough
		 		case .MULTIPOINTFROMTEXT:fallthrough
		 		case .MULTIPOINTFROMWKB:fallthrough
		 		case .MULTIPOLYGONFROMTEXT:fallthrough
		 		case .MULTIPOLYGONFROMWKB:fallthrough
		 		case .NAME_CONST:fallthrough
		 		case .NULLIF:fallthrough
		 		case .NUMGEOMETRIES:fallthrough
		 		case .NUMINTERIORRINGS:fallthrough
		 		case .NUMPOINTS:fallthrough
		 		case .OCT:fallthrough
		 		case .OCTET_LENGTH:fallthrough
		 		case .ORD:fallthrough
		 		case .OVERLAPS:fallthrough
		 		case .PERIOD_ADD:fallthrough
		 		case .PERIOD_DIFF:fallthrough
		 		case .PI:fallthrough
		 		case .POINTFROMTEXT:fallthrough
		 		case .POINTFROMWKB:fallthrough
		 		case .POINTN:fallthrough
		 		case .POLYFROMTEXT:fallthrough
		 		case .POLYFROMWKB:fallthrough
		 		case .POLYGONFROMTEXT:fallthrough
		 		case .POLYGONFROMWKB:fallthrough
		 		case .POW:fallthrough
		 		case .POWER:fallthrough
		 		case .QUOTE:fallthrough
		 		case .RADIANS:fallthrough
		 		case .RAND:fallthrough
		 		case .RANDOM:fallthrough
		 		case .RANDOM_BYTES:fallthrough
		 		case .RELEASE_LOCK:fallthrough
		 		case .REVERSE:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_COUNT:fallthrough
		 		case .RPAD:fallthrough
		 		case .RTRIM:fallthrough
		 		case .SEC_TO_TIME:fallthrough
		 		case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SHA:fallthrough
		 		case .SHA1:fallthrough
		 		case .SHA2:fallthrough
		 		case .SCHEMA_NAME:fallthrough
		 		case .SIGN:fallthrough
		 		case .SIN:fallthrough
		 		case .SLEEP:fallthrough
		 		case .SOUNDEX:fallthrough
		 		case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 		case .SQRT:fallthrough
		 		case .SRID:fallthrough
		 		case .STARTPOINT:fallthrough
		 		case .STRCMP:fallthrough
		 		case .STR_TO_DATE:fallthrough
		 		case .ST_AREA:fallthrough
		 		case .ST_ASBINARY:fallthrough
		 		case .ST_ASTEXT:fallthrough
		 		case .ST_ASWKB:fallthrough
		 		case .ST_ASWKT:fallthrough
		 		case .ST_BUFFER:fallthrough
		 		case .ST_CENTROID:fallthrough
		 		case .ST_CONTAINS:fallthrough
		 		case .ST_CROSSES:fallthrough
		 		case .ST_DIFFERENCE:fallthrough
		 		case .ST_DIMENSION:fallthrough
		 		case .ST_DISJOINT:fallthrough
		 		case .ST_DISTANCE:fallthrough
		 		case .ST_ENDPOINT:fallthrough
		 		case .ST_ENVELOPE:fallthrough
		 		case .ST_EQUALS:fallthrough
		 		case .ST_EXTERIORRING:fallthrough
		 		case .ST_GEOMCOLLFROMTEXT:fallthrough
		 		case .ST_GEOMCOLLFROMTXT:fallthrough
		 		case .ST_GEOMCOLLFROMWKB:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .ST_GEOMETRYFROMTEXT:fallthrough
		 		case .ST_GEOMETRYFROMWKB:fallthrough
		 		case .ST_GEOMETRYN:fallthrough
		 		case .ST_GEOMETRYTYPE:fallthrough
		 		case .ST_GEOMFROMTEXT:fallthrough
		 		case .ST_GEOMFROMWKB:fallthrough
		 		case .ST_INTERIORRINGN:fallthrough
		 		case .ST_INTERSECTION:fallthrough
		 		case .ST_INTERSECTS:fallthrough
		 		case .ST_ISCLOSED:fallthrough
		 		case .ST_ISEMPTY:fallthrough
		 		case .ST_ISSIMPLE:fallthrough
		 		case .ST_LINEFROMTEXT:fallthrough
		 		case .ST_LINEFROMWKB:fallthrough
		 		case .ST_LINESTRINGFROMTEXT:fallthrough
		 		case .ST_LINESTRINGFROMWKB:fallthrough
		 		case .ST_NUMGEOMETRIES:fallthrough
		 		case .ST_NUMINTERIORRING:fallthrough
		 		case .ST_NUMINTERIORRINGS:fallthrough
		 		case .ST_NUMPOINTS:fallthrough
		 		case .ST_OVERLAPS:fallthrough
		 		case .ST_POINTFROMTEXT:fallthrough
		 		case .ST_POINTFROMWKB:fallthrough
		 		case .ST_POINTN:fallthrough
		 		case .ST_POLYFROMTEXT:fallthrough
		 		case .ST_POLYFROMWKB:fallthrough
		 		case .ST_POLYGONFROMTEXT:fallthrough
		 		case .ST_POLYGONFROMWKB:fallthrough
		 		case .ST_SRID:fallthrough
		 		case .ST_STARTPOINT:fallthrough
		 		case .ST_SYMDIFFERENCE:fallthrough
		 		case .ST_TOUCHES:fallthrough
		 		case .ST_UNION:fallthrough
		 		case .ST_WITHIN:fallthrough
		 		case .ST_X:fallthrough
		 		case .ST_Y:fallthrough
		 		case .SUBDATE:fallthrough
		 		case .SUBSTRING_INDEX:fallthrough
		 		case .SUBTIME:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TAN:fallthrough
		 		case .TIMEDIFF:fallthrough
		 		case .TIMESTAMPADD:fallthrough
		 		case .TIMESTAMPDIFF:fallthrough
		 		case .TIME_FORMAT:fallthrough
		 		case .TIME_TO_SEC:fallthrough
		 		case .TOUCHES:fallthrough
		 		case .TO_BASE64:fallthrough
		 		case .TO_DAYS:fallthrough
		 		case .TO_SECONDS:fallthrough
		 		case .TP_CONNECTION_ADMIN:fallthrough
		 		case .UCASE:fallthrough
		 		case .UNCOMPRESS:fallthrough
		 		case .UNCOMPRESSED_LENGTH:fallthrough
		 		case .UNHEX:fallthrough
		 		case .UNIX_TIMESTAMP:fallthrough
		 		case .UPDATEXML:fallthrough
		 		case .UPPER:fallthrough
		 		case .UUID:fallthrough
		 		case .UUID_SHORT:fallthrough
		 		case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 		case .VERSION:fallthrough
		 		case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 		case .WEEKDAY:fallthrough
		 		case .WEEKOFYEAR:fallthrough
		 		case .WEIGHT_STRING:fallthrough
		 		case .WITHIN:fallthrough
		 		case .YEARWEEK:fallthrough
		 		case .Y_FUNCTION:fallthrough
		 		case .X_FUNCTION:fallthrough
		 		case .MOD:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:fallthrough
		 		case .ID:
		 			setState(6099)
		 			try {
		 					let assignmentValue = try uidList()
		 					_localctx.castdown(LoadedTableIndexesContext.self).partitionList = assignmentValue
		 			     }()


		 			break

		 		case .ALL:
		 			setState(6100)
		 			try match(MySqlParser.Tokens.ALL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(6103)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 	}

		 	setState(6113)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,891,_ctx)) {
		 	case 1:
		 		setState(6107)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue) {
		 			setState(6106)
		 			_localctx.castdown(LoadedTableIndexesContext.self).indexFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.INDEX.rawValue || _la == MySqlParser.Tokens.KEY.rawValue)) {
		 				_localctx.castdown(LoadedTableIndexesContext.self).indexFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}

		 		setState(6109)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6110)
		 		try {
		 				let assignmentValue = try uidList()
		 				_localctx.castdown(LoadedTableIndexesContext.self).indexList = assignmentValue
		 		     }()

		 		setState(6111)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(6117)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.IGNORE.rawValue) {
		 		setState(6115)
		 		try match(MySqlParser.Tokens.IGNORE.rawValue)
		 		setState(6116)
		 		try match(MySqlParser.Tokens.LEAVES.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SimpleDescribeStatementContext: ParserRuleContext {
		open var command: Token!
		open var column: UidContext!
		open var pattern: Token!
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func EXPLAIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXPLAIN.rawValue, 0)
			}
			open
			func DESCRIBE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DESCRIBE.rawValue, 0)
			}
			open
			func DESC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DESC.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_simpleDescribeStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSimpleDescribeStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSimpleDescribeStatement(self)
			}
		}
	}
	@discardableResult
	 open func simpleDescribeStatement() throws -> SimpleDescribeStatementContext {
		var _localctx: SimpleDescribeStatementContext
		_localctx = SimpleDescribeStatementContext(_ctx, getState())
		try enterRule(_localctx, 526, MySqlParser.RULE_simpleDescribeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6119)
		 	_localctx.castdown(SimpleDescribeStatementContext.self).command = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 4611791571543654400) != 0))) {
		 		_localctx.castdown(SimpleDescribeStatementContext.self).command = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(6120)
		 	try tableName()
		 	setState(6123)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,893,_ctx)) {
		 	case 1:
		 		setState(6121)
		 		try {
		 				let assignmentValue = try uid()
		 				_localctx.castdown(SimpleDescribeStatementContext.self).column = assignmentValue
		 		     }()


		 		break
		 	case 2:
		 		setState(6122)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 				_localctx.castdown(SimpleDescribeStatementContext.self).pattern = assignmentValue
		 		     }()


		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FullDescribeStatementContext: ParserRuleContext {
		open var command: Token!
		open var formatType: Token!
		open var formatValue: Token!
			open
			func describeObjectClause() -> DescribeObjectClauseContext? {
				return getRuleContext(DescribeObjectClauseContext.self, 0)
			}
			open
			func EXPLAIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXPLAIN.rawValue, 0)
			}
			open
			func DESCRIBE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DESCRIBE.rawValue, 0)
			}
			open
			func DESC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DESC.rawValue, 0)
			}
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func EXTENDED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXTENDED.rawValue, 0)
			}
			open
			func PARTITIONS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITIONS.rawValue, 0)
			}
			open
			func FORMAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FORMAT.rawValue, 0)
			}
			open
			func TRADITIONAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRADITIONAL.rawValue, 0)
			}
			open
			func JSON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_fullDescribeStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFullDescribeStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFullDescribeStatement(self)
			}
		}
	}
	@discardableResult
	 open func fullDescribeStatement() throws -> FullDescribeStatementContext {
		var _localctx: FullDescribeStatementContext
		_localctx = FullDescribeStatementContext(_ctx, getState())
		try enterRule(_localctx, 528, MySqlParser.RULE_fullDescribeStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6125)
		 	_localctx.castdown(FullDescribeStatementContext.self).command = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 4611791571543654400) != 0))) {
		 		_localctx.castdown(FullDescribeStatementContext.self).command = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(6129)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.EXTENDED.rawValue || _la == MySqlParser.Tokens.PARTITIONS.rawValue || _la == MySqlParser.Tokens.FORMAT.rawValue) {
		 		setState(6126)
		 		_localctx.castdown(FullDescribeStatementContext.self).formatType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.EXTENDED.rawValue || _la == MySqlParser.Tokens.PARTITIONS.rawValue || _la == MySqlParser.Tokens.FORMAT.rawValue)) {
		 			_localctx.castdown(FullDescribeStatementContext.self).formatType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6127)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(6128)
		 		_localctx.castdown(FullDescribeStatementContext.self).formatValue = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.JSON.rawValue || _la == MySqlParser.Tokens.TRADITIONAL.rawValue)) {
		 			_localctx.castdown(FullDescribeStatementContext.self).formatValue = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(6131)
		 	try describeObjectClause()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HelpStatementContext: ParserRuleContext {
			open
			func HELP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HELP.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_helpStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHelpStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHelpStatement(self)
			}
		}
	}
	@discardableResult
	 open func helpStatement() throws -> HelpStatementContext {
		var _localctx: HelpStatementContext
		_localctx = HelpStatementContext(_ctx, getState())
		try enterRule(_localctx, 530, MySqlParser.RULE_helpStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6133)
		 	try match(MySqlParser.Tokens.HELP.rawValue)
		 	setState(6134)
		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UseStatementContext: ParserRuleContext {
			open
			func USE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USE.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_useStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUseStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUseStatement(self)
			}
		}
	}
	@discardableResult
	 open func useStatement() throws -> UseStatementContext {
		var _localctx: UseStatementContext
		_localctx = UseStatementContext(_ctx, getState())
		try enterRule(_localctx, 532, MySqlParser.RULE_useStatement)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6136)
		 	try match(MySqlParser.Tokens.USE.rawValue)
		 	setState(6137)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalStatementContext: ParserRuleContext {
			open
			func SIGNAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SIGNAL.rawValue, 0)
			}
			open
			func ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ID.rawValue, 0)
			}
			open
			func REVERSE_QUOTE_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REVERSE_QUOTE_ID.rawValue, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func signalConditionInformation() -> [SignalConditionInformationContext] {
				return getRuleContexts(SignalConditionInformationContext.self)
			}
			open
			func signalConditionInformation(_ i: Int) -> SignalConditionInformationContext? {
				return getRuleContext(SignalConditionInformationContext.self, i)
			}
			open
			func SQLSTATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQLSTATE.rawValue, 0)
			}
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_signalStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSignalStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSignalStatement(self)
			}
		}
	}
	@discardableResult
	 open func signalStatement() throws -> SignalStatementContext {
		var _localctx: SignalStatementContext
		_localctx = SignalStatementContext(_ctx, getState())
		try enterRule(_localctx, 534, MySqlParser.RULE_signalStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6139)
		 	try match(MySqlParser.Tokens.SIGNAL.rawValue)
		 	setState(6147)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SQLSTATE:
		 		setState(6140)
		 		try match(MySqlParser.Tokens.SQLSTATE.rawValue)
		 		setState(6142)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.VALUE.rawValue) {
		 			setState(6141)
		 			try match(MySqlParser.Tokens.VALUE.rawValue)

		 		}

		 		setState(6144)
		 		try stringLiteral()


		 		break

		 	case .ID:
		 		setState(6145)
		 		try match(MySqlParser.Tokens.ID.rawValue)

		 		break

		 	case .REVERSE_QUOTE_ID:
		 		setState(6146)
		 		try match(MySqlParser.Tokens.REVERSE_QUOTE_ID.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(6158)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,898,_ctx)) {
		 	case 1:
		 		setState(6149)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(6150)
		 		try signalConditionInformation()
		 		setState(6155)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(6151)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(6152)
		 			try signalConditionInformation()


		 			setState(6157)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ResignalStatementContext: ParserRuleContext {
			open
			func RESIGNAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESIGNAL.rawValue, 0)
			}
			open
			func ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ID.rawValue, 0)
			}
			open
			func REVERSE_QUOTE_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REVERSE_QUOTE_ID.rawValue, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func signalConditionInformation() -> [SignalConditionInformationContext] {
				return getRuleContexts(SignalConditionInformationContext.self)
			}
			open
			func signalConditionInformation(_ i: Int) -> SignalConditionInformationContext? {
				return getRuleContext(SignalConditionInformationContext.self, i)
			}
			open
			func SQLSTATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQLSTATE.rawValue, 0)
			}
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_resignalStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterResignalStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitResignalStatement(self)
			}
		}
	}
	@discardableResult
	 open func resignalStatement() throws -> ResignalStatementContext {
		var _localctx: ResignalStatementContext
		_localctx = ResignalStatementContext(_ctx, getState())
		try enterRule(_localctx, 536, MySqlParser.RULE_resignalStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6160)
		 	try match(MySqlParser.Tokens.RESIGNAL.rawValue)
		 	setState(6168)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .SQLSTATE:
		 	 	setState(6161)
		 	 	try match(MySqlParser.Tokens.SQLSTATE.rawValue)
		 	 	setState(6163)
		 	 	try _errHandler.sync(self)
		 	 	_la = try _input.LA(1)
		 	 	if (_la == MySqlParser.Tokens.VALUE.rawValue) {
		 	 		setState(6162)
		 	 		try match(MySqlParser.Tokens.VALUE.rawValue)

		 	 	}

		 	 	setState(6165)
		 	 	try stringLiteral()


		 		break

		 	case .ID:
		 	 	setState(6166)
		 	 	try match(MySqlParser.Tokens.ID.rawValue)

		 		break

		 	case .REVERSE_QUOTE_ID:
		 	 	setState(6167)
		 	 	try match(MySqlParser.Tokens.REVERSE_QUOTE_ID.rawValue)

		 		break
		 	case .EOF:fallthrough
		 	case .ALTER:fallthrough
		 	case .ANALYZE:fallthrough
		 	case .CALL:fallthrough
		 	case .CHANGE:fallthrough
		 	case .CHECK:fallthrough
		 	case .CREATE:fallthrough
		 	case .DELETE:fallthrough
		 	case .DESC:fallthrough
		 	case .DESCRIBE:fallthrough
		 	case .DROP:fallthrough
		 	case .EXPLAIN:fallthrough
		 	case .GET:fallthrough
		 	case .GRANT:fallthrough
		 	case .INSERT:fallthrough
		 	case .KILL:fallthrough
		 	case .LOAD:fallthrough
		 	case .LOCK:fallthrough
		 	case .OPTIMIZE:fallthrough
		 	case .PURGE:fallthrough
		 	case .RELEASE:fallthrough
		 	case .RENAME:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RESIGNAL:fallthrough
		 	case .REVOKE:fallthrough
		 	case .SELECT:fallthrough
		 	case .SET:fallthrough
		 	case .SHOW:fallthrough
		 	case .SIGNAL:fallthrough
		 	case .TABLE:fallthrough
		 	case .UNLOCK:fallthrough
		 	case .UPDATE:fallthrough
		 	case .USE:fallthrough
		 	case .VALUES:fallthrough
		 	case .WITH:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BINLOG:fallthrough
		 	case .CACHE:fallthrough
		 	case .CHECKSUM:fallthrough
		 	case .COMMIT:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DO:fallthrough
		 	case .FLUSH:fallthrough
		 	case .HANDLER:fallthrough
		 	case .HELP:fallthrough
		 	case .INSTALL:fallthrough
		 	case .PREPARE:fallthrough
		 	case .REPAIR:fallthrough
		 	case .RESET:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .START:fallthrough
		 	case .STOP:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .UNINSTALL:fallthrough
		 	case .XA:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .MINUS:fallthrough
		 	case .LR_BRACKET:fallthrough
		 	case .SEMI:
		 		break
		 	default:
		 		break
		 	}
		 	setState(6179)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,902,_ctx)) {
		 	case 1:
		 		setState(6170)
		 		try match(MySqlParser.Tokens.SET.rawValue)
		 		setState(6171)
		 		try signalConditionInformation()
		 		setState(6176)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(6172)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(6173)
		 			try signalConditionInformation()


		 			setState(6178)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SignalConditionInformationContext: ParserRuleContext {
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func CLASS_ORIGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CLASS_ORIGIN.rawValue, 0)
			}
			open
			func SUBCLASS_ORIGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBCLASS_ORIGIN.rawValue, 0)
			}
			open
			func MESSAGE_TEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MESSAGE_TEXT.rawValue, 0)
			}
			open
			func MYSQL_ERRNO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MYSQL_ERRNO.rawValue, 0)
			}
			open
			func CONSTRAINT_CATALOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT_CATALOG.rawValue, 0)
			}
			open
			func CONSTRAINT_SCHEMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT_SCHEMA.rawValue, 0)
			}
			open
			func CONSTRAINT_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT_NAME.rawValue, 0)
			}
			open
			func CATALOG_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CATALOG_NAME.rawValue, 0)
			}
			open
			func SCHEMA_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEMA_NAME.rawValue, 0)
			}
			open
			func TABLE_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE_NAME.rawValue, 0)
			}
			open
			func COLUMN_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN_NAME.rawValue, 0)
			}
			open
			func CURSOR_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURSOR_NAME.rawValue, 0)
			}
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func DECIMAL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DECIMAL_LITERAL.rawValue, 0)
			}
			open
			func mysqlVariable() -> MysqlVariableContext? {
				return getRuleContext(MysqlVariableContext.self, 0)
			}
			open
			func simpleId() -> SimpleIdContext? {
				return getRuleContext(SimpleIdContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_signalConditionInformation
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSignalConditionInformation(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSignalConditionInformation(self)
			}
		}
	}
	@discardableResult
	 open func signalConditionInformation() throws -> SignalConditionInformationContext {
		var _localctx: SignalConditionInformationContext
		_localctx = SignalConditionInformationContext(_ctx, getState())
		try enterRule(_localctx, 538, MySqlParser.RULE_signalConditionInformation)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6181)
		 	_la = try _input.LA(1)
		 	if (!(((Int64((_la - 359)) & ~0x3f) == 0 && ((Int64(1) << (_la - 359)) & 272105729) != 0) || _la == MySqlParser.Tokens.MESSAGE_TEXT.rawValue || _la == MySqlParser.Tokens.MYSQL_ERRNO.rawValue || _la == MySqlParser.Tokens.SUBCLASS_ORIGIN.rawValue || _la == MySqlParser.Tokens.TABLE_NAME.rawValue || _la == MySqlParser.Tokens.CATALOG_NAME.rawValue || _la == MySqlParser.Tokens.SCHEMA_NAME.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(6182)
		 	try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 	setState(6187)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .START_NATIONAL_STRING_LITERAL:fallthrough
		 	case .STRING_LITERAL:fallthrough
		 	case .STRING_CHARSET_NAME:
		 		setState(6183)
		 		try stringLiteral()

		 		break

		 	case .DECIMAL_LITERAL:
		 		setState(6184)
		 		try match(MySqlParser.Tokens.DECIMAL_LITERAL.rawValue)

		 		break
		 	case .LOCAL_ID:fallthrough
		 	case .GLOBAL_ID:
		 		setState(6185)
		 		try mysqlVariable()

		 		break
		 	case .ARRAY:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .BUCKETS:fallthrough
		 	case .CONDITION:fallthrough
		 	case .CURRENT:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DIAGNOSTICS:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENFORCED:fallthrough
		 	case .EXCEPT:fallthrough
		 	case .GROUP:fallthrough
		 	case .IF:fallthrough
		 	case .IGNORED:fallthrough
		 	case .INSERT:fallthrough
		 	case .LATERAL:fallthrough
		 	case .LEFT:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OPTIONAL:fallthrough
		 	case .ORDER:fallthrough
		 	case .PRIMARY:fallthrough
		 	case .REPEAT:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SKIP_QUERY_REWRITE:fallthrough
		 	case .STACKED:fallthrough
		 	case .DATE:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .DATETIME:fallthrough
		 	case .YEAR:fallthrough
		 	case .BINARY:fallthrough
		 	case .TEXT:fallthrough
		 	case .ENUM:fallthrough
		 	case .SERIAL:fallthrough
		 	case .JSON_ARRAY:fallthrough
		 	case .JSON_ARRAYAGG:fallthrough
		 	case .JSON_ARRAY_APPEND:fallthrough
		 	case .JSON_ARRAY_INSERT:fallthrough
		 	case .JSON_CONTAINS:fallthrough
		 	case .JSON_CONTAINS_PATH:fallthrough
		 	case .JSON_DEPTH:fallthrough
		 	case .JSON_EXTRACT:fallthrough
		 	case .JSON_INSERT:fallthrough
		 	case .JSON_KEYS:fallthrough
		 	case .JSON_LENGTH:fallthrough
		 	case .JSON_MERGE:fallthrough
		 	case .JSON_MERGE_PATCH:fallthrough
		 	case .JSON_MERGE_PRESERVE:fallthrough
		 	case .JSON_OBJECT:fallthrough
		 	case .JSON_OBJECTAGG:fallthrough
		 	case .JSON_OVERLAPS:fallthrough
		 	case .JSON_PRETTY:fallthrough
		 	case .JSON_QUOTE:fallthrough
		 	case .JSON_REMOVE:fallthrough
		 	case .JSON_REPLACE:fallthrough
		 	case .JSON_SCHEMA_VALID:fallthrough
		 	case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 	case .JSON_SEARCH:fallthrough
		 	case .JSON_SET:fallthrough
		 	case .JSON_STORAGE_FREE:fallthrough
		 	case .JSON_STORAGE_SIZE:fallthrough
		 	case .JSON_TABLE:fallthrough
		 	case .JSON_TYPE:fallthrough
		 	case .JSON_UNQUOTE:fallthrough
		 	case .JSON_VALID:fallthrough
		 	case .JSON_VALUE:fallthrough
		 	case .NESTED:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .PATH:fallthrough
		 	case .AVG:fallthrough
		 	case .BIT_AND:fallthrough
		 	case .BIT_OR:fallthrough
		 	case .BIT_XOR:fallthrough
		 	case .COUNT:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .GROUP_CONCAT:fallthrough
		 	case .LAG:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NTH_VALUE:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .STD:fallthrough
		 	case .STDDEV:fallthrough
		 	case .STDDEV_POP:fallthrough
		 	case .STDDEV_SAMP:fallthrough
		 	case .SUM:fallthrough
		 	case .VAR_POP:fallthrough
		 	case .VAR_SAMP:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .CURRENT_DATE:fallthrough
		 	case .CURRENT_TIME:fallthrough
		 	case .CURRENT_TIMESTAMP:fallthrough
		 	case .LOCALTIME:fallthrough
		 	case .CURDATE:fallthrough
		 	case .CURTIME:fallthrough
		 	case .DATE_ADD:fallthrough
		 	case .DATE_SUB:fallthrough
		 	case .LOCALTIMESTAMP:fallthrough
		 	case .NOW:fallthrough
		 	case .POSITION:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .SUBSTRING:fallthrough
		 	case .SYSDATE:fallthrough
		 	case .TRIM:fallthrough
		 	case .UTC_DATE:fallthrough
		 	case .UTC_TIME:fallthrough
		 	case .UTC_TIMESTAMP:fallthrough
		 	case .ACCOUNT:fallthrough
		 	case .ACTION:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALGORITHM:fallthrough
		 	case .ANY:fallthrough
		 	case .AT:fallthrough
		 	case .AUTHORS:fallthrough
		 	case .AUTOCOMMIT:fallthrough
		 	case .AUTOEXTEND_SIZE:fallthrough
		 	case .AUTO_INCREMENT:fallthrough
		 	case .AVG_ROW_LENGTH:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BINLOG:fallthrough
		 	case .BIT:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BOOL:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BTREE:fallthrough
		 	case .CACHE:fallthrough
		 	case .CASCADED:fallthrough
		 	case .CHAIN:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CHECKSUM:fallthrough
		 	case .PAGE_CHECKSUM:fallthrough
		 	case .CIPHER:fallthrough
		 	case .CLASS_ORIGIN:fallthrough
		 	case .CLIENT:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTERING:fallthrough
		 	case .COALESCE:fallthrough
		 	case .CODE:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COLUMN_FORMAT:fallthrough
		 	case .COLUMN_NAME:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMPACT:fallthrough
		 	case .COMPLETION:fallthrough
		 	case .COMPRESSED:fallthrough
		 	case .COMPRESSION:fallthrough
		 	case .CONCURRENT:fallthrough
		 	case .CONNECT:fallthrough
		 	case .CONNECTION:fallthrough
		 	case .CONSISTENT:fallthrough
		 	case .CONSTRAINT_CATALOG:fallthrough
		 	case .CONSTRAINT_SCHEMA:fallthrough
		 	case .CONSTRAINT_NAME:fallthrough
		 	case .CONTAINS:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTRIBUTORS:fallthrough
		 	case .COPY:fallthrough
		 	case .CPU:fallthrough
		 	case .CURSOR_NAME:fallthrough
		 	case .DATA:fallthrough
		 	case .DATAFILE:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DEFAULT_AUTH:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DELAY_KEY_WRITE:fallthrough
		 	case .DES_KEY_FILE:fallthrough
		 	case .DIRECTORY:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISCARD:fallthrough
		 	case .DISK:fallthrough
		 	case .DO:fallthrough
		 	case .DUMPFILE:fallthrough
		 	case .DUPLICATE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .END:fallthrough
		 	case .ENDS:fallthrough
		 	case .ENGINE:fallthrough
		 	case .ENGINES:fallthrough
		 	case .ERROR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVEN:fallthrough
		 	case .EVENT:fallthrough
		 	case .EVENTS:fallthrough
		 	case .EVERY:fallthrough
		 	case .EXCHANGE:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPIRE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .EXTENT_SIZE:fallthrough
		 	case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 	case .FAST:fallthrough
		 	case .FAULTS:fallthrough
		 	case .FIELDS:fallthrough
		 	case .FILE_BLOCK_SIZE:fallthrough
		 	case .FILTER:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIXED:fallthrough
		 	case .FLUSH:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FOUND:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GENERAL:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GRANTS:fallthrough
		 	case .GROUP_REPLICATION:fallthrough
		 	case .HANDLER:fallthrough
		 	case .HASH:fallthrough
		 	case .HELP:fallthrough
		 	case .HISTORY:fallthrough
		 	case .HOST:fallthrough
		 	case .HOSTS:fallthrough
		 	case .IDENTIFIED:fallthrough
		 	case .IGNORE_SERVER_IDS:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INDEXES:fallthrough
		 	case .INITIAL_SIZE:fallthrough
		 	case .INPLACE:fallthrough
		 	case .INSERT_METHOD:fallthrough
		 	case .INSTALL:fallthrough
		 	case .INSTANCE:fallthrough
		 	case .INSTANT:fallthrough
		 	case .INVISIBLE:fallthrough
		 	case .INVOKER:fallthrough
		 	case .IO:fallthrough
		 	case .IO_THREAD:fallthrough
		 	case .IPC:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ISSUER:fallthrough
		 	case .JSON:fallthrough
		 	case .KEY_BLOCK_SIZE:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LEAVES:fallthrough
		 	case .LESS:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOGFILE:fallthrough
		 	case .LOGS:fallthrough
		 	case .MASTER:fallthrough
		 	case .MASTER_AUTO_POSITION:fallthrough
		 	case .MASTER_CONNECT_RETRY:fallthrough
		 	case .MASTER_DELAY:fallthrough
		 	case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 	case .MASTER_HOST:fallthrough
		 	case .MASTER_LOG_FILE:fallthrough
		 	case .MASTER_LOG_POS:fallthrough
		 	case .MASTER_PASSWORD:fallthrough
		 	case .MASTER_PORT:fallthrough
		 	case .MASTER_RETRY_COUNT:fallthrough
		 	case .MASTER_SSL:fallthrough
		 	case .MASTER_SSL_CA:fallthrough
		 	case .MASTER_SSL_CAPATH:fallthrough
		 	case .MASTER_SSL_CERT:fallthrough
		 	case .MASTER_SSL_CIPHER:fallthrough
		 	case .MASTER_SSL_CRL:fallthrough
		 	case .MASTER_SSL_CRLPATH:fallthrough
		 	case .MASTER_SSL_KEY:fallthrough
		 	case .MASTER_TLS_VERSION:fallthrough
		 	case .MASTER_USER:fallthrough
		 	case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 	case .MAX_QUERIES_PER_HOUR:fallthrough
		 	case .MAX_ROWS:fallthrough
		 	case .MAX_SIZE:fallthrough
		 	case .MAX_UPDATES_PER_HOUR:fallthrough
		 	case .MAX_USER_CONNECTIONS:fallthrough
		 	case .MEDIUM:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MESSAGE_TEXT:fallthrough
		 	case .MID:fallthrough
		 	case .MIGRATE:fallthrough
		 	case .MIN_ROWS:fallthrough
		 	case .MODE:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MUTEX:fallthrough
		 	case .MYSQL:fallthrough
		 	case .MYSQL_ERRNO:fallthrough
		 	case .NAME:fallthrough
		 	case .NAMES:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NEVER:fallthrough
		 	case .NEXT:fallthrough
		 	case .NO:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOWAIT:fallthrough
		 	case .NODEGROUP:fallthrough
		 	case .NONE:fallthrough
		 	case .ODBC:fallthrough
		 	case .OFFLINE:fallthrough
		 	case .OFFSET:fallthrough
		 	case .OF:fallthrough
		 	case .OJ:fallthrough
		 	case .OLD_PASSWORD:fallthrough
		 	case .ONE:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .OPTIMIZER_COSTS:fallthrough
		 	case .OPTIONS:fallthrough
		 	case .OWNER:fallthrough
		 	case .PACK_KEYS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PARSER:fallthrough
		 	case .PARTIAL:fallthrough
		 	case .PARTITIONING:fallthrough
		 	case .PARTITIONS:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PASSWORD_LOCK_TIME:fallthrough
		 	case .PHASE:fallthrough
		 	case .PLUGIN:fallthrough
		 	case .PLUGIN_DIR:fallthrough
		 	case .PLUGINS:fallthrough
		 	case .PORT:fallthrough
		 	case .PRECEDES:fallthrough
		 	case .PREPARE:fallthrough
		 	case .PRESERVE:fallthrough
		 	case .PREV:fallthrough
		 	case .PROCESSLIST:fallthrough
		 	case .PROFILE:fallthrough
		 	case .PROFILES:fallthrough
		 	case .PROXY:fallthrough
		 	case .QUERY:fallthrough
		 	case .QUICK:fallthrough
		 	case .REBUILD:fallthrough
		 	case .RECOVER:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REDO_BUFFER_SIZE:fallthrough
		 	case .REDUNDANT:fallthrough
		 	case .RELAY:fallthrough
		 	case .RELAY_LOG_FILE:fallthrough
		 	case .RELAY_LOG_POS:fallthrough
		 	case .RELAYLOG:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REORGANIZE:fallthrough
		 	case .REPAIR:fallthrough
		 	case .REPLICATE_DO_DB:fallthrough
		 	case .REPLICATE_DO_TABLE:fallthrough
		 	case .REPLICATE_IGNORE_DB:fallthrough
		 	case .REPLICATE_IGNORE_TABLE:fallthrough
		 	case .REPLICATE_REWRITE_DB:fallthrough
		 	case .REPLICATE_WILD_DO_TABLE:fallthrough
		 	case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 	case .REPLICATION:fallthrough
		 	case .RESET:fallthrough
		 	case .RESUME:fallthrough
		 	case .RETURNED_SQLSTATE:fallthrough
		 	case .RETURNING:fallthrough
		 	case .RETURNS:fallthrough
		 	case .REUSE:fallthrough
		 	case .ROLE:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROTATE:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_FORMAT:fallthrough
		 	case .RTREE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEDULE:fallthrough
		 	case .SECURITY:fallthrough
		 	case .SERVER:fallthrough
		 	case .SESSION:fallthrough
		 	case .SHARE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SIGNED:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SLAVE:fallthrough
		 	case .SLOW:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOCKET:fallthrough
		 	case .SOME:fallthrough
		 	case .SONAME:fallthrough
		 	case .SOUNDS:fallthrough
		 	case .SOURCE:fallthrough
		 	case .SQL_AFTER_GTIDS:fallthrough
		 	case .SQL_AFTER_MTS_GAPS:fallthrough
		 	case .SQL_BEFORE_GTIDS:fallthrough
		 	case .SQL_BUFFER_RESULT:fallthrough
		 	case .SQL_CACHE:fallthrough
		 	case .SQL_NO_CACHE:fallthrough
		 	case .SQL_THREAD:fallthrough
		 	case .START:fallthrough
		 	case .STARTS:fallthrough
		 	case .STATS_AUTO_RECALC:fallthrough
		 	case .STATS_PERSISTENT:fallthrough
		 	case .STATS_SAMPLE_PAGES:fallthrough
		 	case .STATUS:fallthrough
		 	case .STOP:fallthrough
		 	case .STORAGE:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBCLASS_ORIGIN:fallthrough
		 	case .SUBJECT:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBPARTITIONS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .SWAPS:fallthrough
		 	case .SWITCHES:fallthrough
		 	case .TABLE_NAME:fallthrough
		 	case .TABLESPACE:fallthrough
		 	case .TABLE_TYPE:fallthrough
		 	case .TEMPORARY:fallthrough
		 	case .TEMPTABLE:fallthrough
		 	case .THAN:fallthrough
		 	case .TRADITIONAL:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSACTIONAL:fallthrough
		 	case .TRIGGERS:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDEFINED:fallthrough
		 	case .UNDOFILE:fallthrough
		 	case .UNDO_BUFFER_SIZE:fallthrough
		 	case .UNINSTALL:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPGRADE:fallthrough
		 	case .USER:fallthrough
		 	case .USE_FRM:fallthrough
		 	case .USER_RESOURCES:fallthrough
		 	case .VALIDATION:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARIABLES:fallthrough
		 	case .VIEW:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .VISIBLE:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNINGS:fallthrough
		 	case .WITHOUT:fallthrough
		 	case .WORK:fallthrough
		 	case .WRAPPER:fallthrough
		 	case .X509:fallthrough
		 	case .XA:fallthrough
		 	case .XML:fallthrough
		 	case .EUR:fallthrough
		 	case .USA:fallthrough
		 	case .JIS:fallthrough
		 	case .ISO:fallthrough
		 	case .INTERNAL:fallthrough
		 	case .QUARTER:fallthrough
		 	case .MONTH:fallthrough
		 	case .DAY:fallthrough
		 	case .HOUR:fallthrough
		 	case .MINUTE:fallthrough
		 	case .WEEK:fallthrough
		 	case .SECOND:fallthrough
		 	case .MICROSECOND:fallthrough
		 	case .ADMIN:fallthrough
		 	case .AUDIT_ABORT_EXEMPT:fallthrough
		 	case .AUDIT_ADMIN:fallthrough
		 	case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 	case .BACKUP_ADMIN:fallthrough
		 	case .BINLOG_ADMIN:fallthrough
		 	case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 	case .CLONE_ADMIN:fallthrough
		 	case .CONNECTION_ADMIN:fallthrough
		 	case .ENCRYPTION_KEY_ADMIN:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .FILE:fallthrough
		 	case .FIREWALL_ADMIN:fallthrough
		 	case .FIREWALL_EXEMPT:fallthrough
		 	case .FIREWALL_USER:fallthrough
		 	case .GROUP_REPLICATION_ADMIN:fallthrough
		 	case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 	case .INVOKE:fallthrough
		 	case .LAMBDA:fallthrough
		 	case .NDB_STORED_USER:fallthrough
		 	case .PASSWORDLESS_USER_ADMIN:fallthrough
		 	case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .PROCESS:fallthrough
		 	case .RELOAD:fallthrough
		 	case .REPLICATION_APPLIER:fallthrough
		 	case .REPLICATION_SLAVE_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_USER:fallthrough
		 	case .ROLE_ADMIN:fallthrough
		 	case .ROUTINE:fallthrough
		 	case .S3:fallthrough
		 	case .SESSION_VARIABLES_ADMIN:fallthrough
		 	case .SET_USER_ID:fallthrough
		 	case .SHOW_ROUTINE:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SUPER:fallthrough
		 	case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 	case .TABLES:fallthrough
		 	case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 	case .VERSION_TOKEN_ADMIN:fallthrough
		 	case .XA_RECOVER_ADMIN:fallthrough
		 	case .ARMSCII8:fallthrough
		 	case .ASCII:fallthrough
		 	case .BIG5:fallthrough
		 	case .CP1250:fallthrough
		 	case .CP1251:fallthrough
		 	case .CP1256:fallthrough
		 	case .CP1257:fallthrough
		 	case .CP850:fallthrough
		 	case .CP852:fallthrough
		 	case .CP866:fallthrough
		 	case .CP932:fallthrough
		 	case .DEC8:fallthrough
		 	case .EUCJPMS:fallthrough
		 	case .EUCKR:fallthrough
		 	case .GB18030:fallthrough
		 	case .GB2312:fallthrough
		 	case .GBK:fallthrough
		 	case .GEOSTD8:fallthrough
		 	case .GREEK:fallthrough
		 	case .HEBREW:fallthrough
		 	case .HP8:fallthrough
		 	case .KEYBCS2:fallthrough
		 	case .KOI8R:fallthrough
		 	case .KOI8U:fallthrough
		 	case .LATIN1:fallthrough
		 	case .LATIN2:fallthrough
		 	case .LATIN5:fallthrough
		 	case .LATIN7:fallthrough
		 	case .MACCE:fallthrough
		 	case .MACROMAN:fallthrough
		 	case .SJIS:fallthrough
		 	case .SWE7:fallthrough
		 	case .TIS620:fallthrough
		 	case .UCS2:fallthrough
		 	case .UJIS:fallthrough
		 	case .UTF16:fallthrough
		 	case .UTF16LE:fallthrough
		 	case .UTF32:fallthrough
		 	case .UTF8:fallthrough
		 	case .UTF8MB3:fallthrough
		 	case .UTF8MB4:fallthrough
		 	case .ARCHIVE:fallthrough
		 	case .BLACKHOLE:fallthrough
		 	case .CSV:fallthrough
		 	case .FEDERATED:fallthrough
		 	case .INNODB:fallthrough
		 	case .MEMORY:fallthrough
		 	case .MRG_MYISAM:fallthrough
		 	case .MYISAM:fallthrough
		 	case .NDB:fallthrough
		 	case .NDBCLUSTER:fallthrough
		 	case .PERFORMANCE_SCHEMA:fallthrough
		 	case .TOKUDB:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .GEOMETRYCOLLECTION:fallthrough
		 	case .LINESTRING:fallthrough
		 	case .MULTILINESTRING:fallthrough
		 	case .MULTIPOINT:fallthrough
		 	case .MULTIPOLYGON:fallthrough
		 	case .POINT:fallthrough
		 	case .POLYGON:fallthrough
		 	case .ABS:fallthrough
		 	case .ACOS:fallthrough
		 	case .ADDDATE:fallthrough
		 	case .ADDTIME:fallthrough
		 	case .AES_DECRYPT:fallthrough
		 	case .AES_ENCRYPT:fallthrough
		 	case .AREA:fallthrough
		 	case .ASBINARY:fallthrough
		 	case .ASIN:fallthrough
		 	case .ASTEXT:fallthrough
		 	case .ASWKB:fallthrough
		 	case .ASWKT:fallthrough
		 	case .ASYMMETRIC_DECRYPT:fallthrough
		 	case .ASYMMETRIC_DERIVE:fallthrough
		 	case .ASYMMETRIC_ENCRYPT:fallthrough
		 	case .ASYMMETRIC_SIGN:fallthrough
		 	case .ASYMMETRIC_VERIFY:fallthrough
		 	case .ATAN:fallthrough
		 	case .ATAN2:fallthrough
		 	case .BENCHMARK:fallthrough
		 	case .BIN:fallthrough
		 	case .BIT_COUNT:fallthrough
		 	case .BIT_LENGTH:fallthrough
		 	case .BUFFER:fallthrough
		 	case .CATALOG_NAME:fallthrough
		 	case .CEIL:fallthrough
		 	case .CEILING:fallthrough
		 	case .CENTROID:fallthrough
		 	case .CHARACTER_LENGTH:fallthrough
		 	case .CHARSET:fallthrough
		 	case .CHAR_LENGTH:fallthrough
		 	case .COERCIBILITY:fallthrough
		 	case .COLLATION:fallthrough
		 	case .COMPRESS:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_WS:fallthrough
		 	case .CONNECTION_ID:fallthrough
		 	case .CONV:fallthrough
		 	case .CONVERT_TZ:fallthrough
		 	case .COS:fallthrough
		 	case .COT:fallthrough
		 	case .CRC32:fallthrough
		 	case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 	case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 	case .CREATE_DH_PARAMETERS:fallthrough
		 	case .CREATE_DIGEST:fallthrough
		 	case .CROSSES:fallthrough
		 	case .DATEDIFF:fallthrough
		 	case .DATE_FORMAT:fallthrough
		 	case .DAYNAME:fallthrough
		 	case .DAYOFMONTH:fallthrough
		 	case .DAYOFWEEK:fallthrough
		 	case .DAYOFYEAR:fallthrough
		 	case .DECODE:fallthrough
		 	case .DEGREES:fallthrough
		 	case .DES_DECRYPT:fallthrough
		 	case .DES_ENCRYPT:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISJOINT:fallthrough
		 	case .ELT:fallthrough
		 	case .ENCODE:fallthrough
		 	case .ENCRYPT:fallthrough
		 	case .ENDPOINT:fallthrough
		 	case .ENGINE_ATTRIBUTE:fallthrough
		 	case .ENVELOPE:fallthrough
		 	case .EQUALS:fallthrough
		 	case .EXP:fallthrough
		 	case .EXPORT_SET:fallthrough
		 	case .EXTERIORRING:fallthrough
		 	case .EXTRACTVALUE:fallthrough
		 	case .FIELD:fallthrough
		 	case .FIND_IN_SET:fallthrough
		 	case .FLOOR:fallthrough
		 	case .FORMAT:fallthrough
		 	case .FOUND_ROWS:fallthrough
		 	case .FROM_BASE64:fallthrough
		 	case .FROM_DAYS:fallthrough
		 	case .FROM_UNIXTIME:fallthrough
		 	case .GEOMCOLLFROMTEXT:fallthrough
		 	case .GEOMCOLLFROMWKB:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .GEOMETRYFROMTEXT:fallthrough
		 	case .GEOMETRYFROMWKB:fallthrough
		 	case .GEOMETRYN:fallthrough
		 	case .GEOMETRYTYPE:fallthrough
		 	case .GEOMFROMTEXT:fallthrough
		 	case .GEOMFROMWKB:fallthrough
		 	case .GET_FORMAT:fallthrough
		 	case .GET_LOCK:fallthrough
		 	case .GLENGTH:fallthrough
		 	case .GREATEST:fallthrough
		 	case .GTID_SUBSET:fallthrough
		 	case .GTID_SUBTRACT:fallthrough
		 	case .HEX:fallthrough
		 	case .IFNULL:fallthrough
		 	case .INET6_ATON:fallthrough
		 	case .INET6_NTOA:fallthrough
		 	case .INET_ATON:fallthrough
		 	case .INET_NTOA:fallthrough
		 	case .INSTR:fallthrough
		 	case .INTERIORRINGN:fallthrough
		 	case .INTERSECTS:fallthrough
		 	case .ISCLOSED:fallthrough
		 	case .ISEMPTY:fallthrough
		 	case .ISNULL:fallthrough
		 	case .ISSIMPLE:fallthrough
		 	case .IS_FREE_LOCK:fallthrough
		 	case .IS_IPV4:fallthrough
		 	case .IS_IPV4_COMPAT:fallthrough
		 	case .IS_IPV4_MAPPED:fallthrough
		 	case .IS_IPV6:fallthrough
		 	case .IS_USED_LOCK:fallthrough
		 	case .LAST_INSERT_ID:fallthrough
		 	case .LCASE:fallthrough
		 	case .LEAST:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LINEFROMTEXT:fallthrough
		 	case .LINEFROMWKB:fallthrough
		 	case .LINESTRINGFROMTEXT:fallthrough
		 	case .LINESTRINGFROMWKB:fallthrough
		 	case .LN:fallthrough
		 	case .LOAD_FILE:fallthrough
		 	case .LOCATE:fallthrough
		 	case .LOG:fallthrough
		 	case .LOG10:fallthrough
		 	case .LOG2:fallthrough
		 	case .LOWER:fallthrough
		 	case .LPAD:fallthrough
		 	case .LTRIM:fallthrough
		 	case .MAKEDATE:fallthrough
		 	case .MAKETIME:fallthrough
		 	case .MAKE_SET:fallthrough
		 	case .MASTER_POS_WAIT:fallthrough
		 	case .MBRCONTAINS:fallthrough
		 	case .MBRDISJOINT:fallthrough
		 	case .MBREQUAL:fallthrough
		 	case .MBRINTERSECTS:fallthrough
		 	case .MBROVERLAPS:fallthrough
		 	case .MBRTOUCHES:fallthrough
		 	case .MBRWITHIN:fallthrough
		 	case .MD5:fallthrough
		 	case .MLINEFROMTEXT:fallthrough
		 	case .MLINEFROMWKB:fallthrough
		 	case .MONTHNAME:fallthrough
		 	case .MPOINTFROMTEXT:fallthrough
		 	case .MPOINTFROMWKB:fallthrough
		 	case .MPOLYFROMTEXT:fallthrough
		 	case .MPOLYFROMWKB:fallthrough
		 	case .MULTILINESTRINGFROMTEXT:fallthrough
		 	case .MULTILINESTRINGFROMWKB:fallthrough
		 	case .MULTIPOINTFROMTEXT:fallthrough
		 	case .MULTIPOINTFROMWKB:fallthrough
		 	case .MULTIPOLYGONFROMTEXT:fallthrough
		 	case .MULTIPOLYGONFROMWKB:fallthrough
		 	case .NAME_CONST:fallthrough
		 	case .NULLIF:fallthrough
		 	case .NUMGEOMETRIES:fallthrough
		 	case .NUMINTERIORRINGS:fallthrough
		 	case .NUMPOINTS:fallthrough
		 	case .OCT:fallthrough
		 	case .OCTET_LENGTH:fallthrough
		 	case .ORD:fallthrough
		 	case .OVERLAPS:fallthrough
		 	case .PERIOD_ADD:fallthrough
		 	case .PERIOD_DIFF:fallthrough
		 	case .PI:fallthrough
		 	case .POINTFROMTEXT:fallthrough
		 	case .POINTFROMWKB:fallthrough
		 	case .POINTN:fallthrough
		 	case .POLYFROMTEXT:fallthrough
		 	case .POLYFROMWKB:fallthrough
		 	case .POLYGONFROMTEXT:fallthrough
		 	case .POLYGONFROMWKB:fallthrough
		 	case .POW:fallthrough
		 	case .POWER:fallthrough
		 	case .QUOTE:fallthrough
		 	case .RADIANS:fallthrough
		 	case .RAND:fallthrough
		 	case .RANDOM:fallthrough
		 	case .RANDOM_BYTES:fallthrough
		 	case .RELEASE_LOCK:fallthrough
		 	case .REVERSE:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_COUNT:fallthrough
		 	case .RPAD:fallthrough
		 	case .RTRIM:fallthrough
		 	case .SEC_TO_TIME:fallthrough
		 	case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 	case .SESSION_USER:fallthrough
		 	case .SHA:fallthrough
		 	case .SHA1:fallthrough
		 	case .SHA2:fallthrough
		 	case .SCHEMA_NAME:fallthrough
		 	case .SIGN:fallthrough
		 	case .SIN:fallthrough
		 	case .SLEEP:fallthrough
		 	case .SOUNDEX:fallthrough
		 	case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 	case .SQRT:fallthrough
		 	case .SRID:fallthrough
		 	case .STARTPOINT:fallthrough
		 	case .STRCMP:fallthrough
		 	case .STR_TO_DATE:fallthrough
		 	case .ST_AREA:fallthrough
		 	case .ST_ASBINARY:fallthrough
		 	case .ST_ASTEXT:fallthrough
		 	case .ST_ASWKB:fallthrough
		 	case .ST_ASWKT:fallthrough
		 	case .ST_BUFFER:fallthrough
		 	case .ST_CENTROID:fallthrough
		 	case .ST_CONTAINS:fallthrough
		 	case .ST_CROSSES:fallthrough
		 	case .ST_DIFFERENCE:fallthrough
		 	case .ST_DIMENSION:fallthrough
		 	case .ST_DISJOINT:fallthrough
		 	case .ST_DISTANCE:fallthrough
		 	case .ST_ENDPOINT:fallthrough
		 	case .ST_ENVELOPE:fallthrough
		 	case .ST_EQUALS:fallthrough
		 	case .ST_EXTERIORRING:fallthrough
		 	case .ST_GEOMCOLLFROMTEXT:fallthrough
		 	case .ST_GEOMCOLLFROMTXT:fallthrough
		 	case .ST_GEOMCOLLFROMWKB:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .ST_GEOMETRYFROMTEXT:fallthrough
		 	case .ST_GEOMETRYFROMWKB:fallthrough
		 	case .ST_GEOMETRYN:fallthrough
		 	case .ST_GEOMETRYTYPE:fallthrough
		 	case .ST_GEOMFROMTEXT:fallthrough
		 	case .ST_GEOMFROMWKB:fallthrough
		 	case .ST_INTERIORRINGN:fallthrough
		 	case .ST_INTERSECTION:fallthrough
		 	case .ST_INTERSECTS:fallthrough
		 	case .ST_ISCLOSED:fallthrough
		 	case .ST_ISEMPTY:fallthrough
		 	case .ST_ISSIMPLE:fallthrough
		 	case .ST_LINEFROMTEXT:fallthrough
		 	case .ST_LINEFROMWKB:fallthrough
		 	case .ST_LINESTRINGFROMTEXT:fallthrough
		 	case .ST_LINESTRINGFROMWKB:fallthrough
		 	case .ST_NUMGEOMETRIES:fallthrough
		 	case .ST_NUMINTERIORRING:fallthrough
		 	case .ST_NUMINTERIORRINGS:fallthrough
		 	case .ST_NUMPOINTS:fallthrough
		 	case .ST_OVERLAPS:fallthrough
		 	case .ST_POINTFROMTEXT:fallthrough
		 	case .ST_POINTFROMWKB:fallthrough
		 	case .ST_POINTN:fallthrough
		 	case .ST_POLYFROMTEXT:fallthrough
		 	case .ST_POLYFROMWKB:fallthrough
		 	case .ST_POLYGONFROMTEXT:fallthrough
		 	case .ST_POLYGONFROMWKB:fallthrough
		 	case .ST_SRID:fallthrough
		 	case .ST_STARTPOINT:fallthrough
		 	case .ST_SYMDIFFERENCE:fallthrough
		 	case .ST_TOUCHES:fallthrough
		 	case .ST_UNION:fallthrough
		 	case .ST_WITHIN:fallthrough
		 	case .ST_X:fallthrough
		 	case .ST_Y:fallthrough
		 	case .SUBDATE:fallthrough
		 	case .SUBSTRING_INDEX:fallthrough
		 	case .SUBTIME:fallthrough
		 	case .SYSTEM_USER:fallthrough
		 	case .TAN:fallthrough
		 	case .TIMEDIFF:fallthrough
		 	case .TIMESTAMPADD:fallthrough
		 	case .TIMESTAMPDIFF:fallthrough
		 	case .TIME_FORMAT:fallthrough
		 	case .TIME_TO_SEC:fallthrough
		 	case .TOUCHES:fallthrough
		 	case .TO_BASE64:fallthrough
		 	case .TO_DAYS:fallthrough
		 	case .TO_SECONDS:fallthrough
		 	case .TP_CONNECTION_ADMIN:fallthrough
		 	case .UCASE:fallthrough
		 	case .UNCOMPRESS:fallthrough
		 	case .UNCOMPRESSED_LENGTH:fallthrough
		 	case .UNHEX:fallthrough
		 	case .UNIX_TIMESTAMP:fallthrough
		 	case .UPDATEXML:fallthrough
		 	case .UPPER:fallthrough
		 	case .UUID:fallthrough
		 	case .UUID_SHORT:fallthrough
		 	case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 	case .VERSION:fallthrough
		 	case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 	case .WEEKDAY:fallthrough
		 	case .WEEKOFYEAR:fallthrough
		 	case .WEIGHT_STRING:fallthrough
		 	case .WITHIN:fallthrough
		 	case .YEARWEEK:fallthrough
		 	case .Y_FUNCTION:fallthrough
		 	case .X_FUNCTION:fallthrough
		 	case .MOD:fallthrough
		 	case .ID:
		 		setState(6186)
		 		try simpleId()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WithStatementContext: ParserRuleContext {
			open
			func WITH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITH.rawValue, 0)
			}
			open
			func commonTableExpressions() -> [CommonTableExpressionsContext] {
				return getRuleContexts(CommonTableExpressionsContext.self)
			}
			open
			func commonTableExpressions(_ i: Int) -> CommonTableExpressionsContext? {
				return getRuleContext(CommonTableExpressionsContext.self, i)
			}
			open
			func RECURSIVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RECURSIVE.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_withStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterWithStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitWithStatement(self)
			}
		}
	}
	@discardableResult
	 open func withStatement() throws -> WithStatementContext {
		var _localctx: WithStatementContext
		_localctx = WithStatementContext(_ctx, getState())
		try enterRule(_localctx, 540, MySqlParser.RULE_withStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6189)
		 	try match(MySqlParser.Tokens.WITH.rawValue)
		 	setState(6191)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,904,_ctx)) {
		 	case 1:
		 		setState(6190)
		 		try match(MySqlParser.Tokens.RECURSIVE.rawValue)

		 		break
		 	default: break
		 	}
		 	setState(6193)
		 	try commonTableExpressions()
		 	setState(6198)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6194)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6195)
		 		try commonTableExpressions()


		 		setState(6200)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TableStatementContext: ParserRuleContext {
			open
			func TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE.rawValue, 0)
			}
			open
			func tableName() -> TableNameContext? {
				return getRuleContext(TableNameContext.self, 0)
			}
			open
			func orderByClause() -> OrderByClauseContext? {
				return getRuleContext(OrderByClauseContext.self, 0)
			}
			open
			func limitClause() -> LimitClauseContext? {
				return getRuleContext(LimitClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tableStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableStatement(self)
			}
		}
	}
	@discardableResult
	 open func tableStatement() throws -> TableStatementContext {
		var _localctx: TableStatementContext
		_localctx = TableStatementContext(_ctx, getState())
		try enterRule(_localctx, 542, MySqlParser.RULE_tableStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6201)
		 	try match(MySqlParser.Tokens.TABLE.rawValue)
		 	setState(6202)
		 	try tableName()
		 	setState(6204)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ORDER.rawValue) {
		 		setState(6203)
		 		try orderByClause()

		 	}

		 	setState(6207)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.LIMIT.rawValue) {
		 		setState(6206)
		 		try limitClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DiagnosticsStatementContext: ParserRuleContext {
			open
			func GET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GET.rawValue, 0)
			}
			open
			func DIAGNOSTICS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DIAGNOSTICS.rawValue, 0)
			}
			open
			func CURRENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT.rawValue, 0)
			}
			open
			func STACKED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STACKED.rawValue, 0)
			}
			open
			func variableClause() -> [VariableClauseContext] {
				return getRuleContexts(VariableClauseContext.self)
			}
			open
			func variableClause(_ i: Int) -> VariableClauseContext? {
				return getRuleContext(VariableClauseContext.self, i)
			}
			open
			func EQUAL_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
			}
			open
			func EQUAL_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, i)
			}
			open
			func CONDITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONDITION.rawValue, 0)
			}
			open
			func diagnosticsConditionInformationName() -> [DiagnosticsConditionInformationNameContext] {
				return getRuleContexts(DiagnosticsConditionInformationNameContext.self)
			}
			open
			func diagnosticsConditionInformationName(_ i: Int) -> DiagnosticsConditionInformationNameContext? {
				return getRuleContext(DiagnosticsConditionInformationNameContext.self, i)
			}
			open
			func NUMBER() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.NUMBER.rawValue)
			}
			open
			func NUMBER(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NUMBER.rawValue, i)
			}
			open
			func ROW_COUNT() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ROW_COUNT.rawValue)
			}
			open
			func ROW_COUNT(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROW_COUNT.rawValue, i)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_diagnosticsStatement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDiagnosticsStatement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDiagnosticsStatement(self)
			}
		}
	}
	@discardableResult
	 open func diagnosticsStatement() throws -> DiagnosticsStatementContext {
		var _localctx: DiagnosticsStatementContext
		_localctx = DiagnosticsStatementContext(_ctx, getState())
		try enterRule(_localctx, 544, MySqlParser.RULE_diagnosticsStatement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6209)
		 	try match(MySqlParser.Tokens.GET.rawValue)
		 	setState(6211)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.CURRENT.rawValue || _la == MySqlParser.Tokens.STACKED.rawValue) {
		 		setState(6210)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.CURRENT.rawValue || _la == MySqlParser.Tokens.STACKED.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}

		 	setState(6213)
		 	try match(MySqlParser.Tokens.DIAGNOSTICS.rawValue)
		 	setState(6245)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,912, _ctx)) {
		 	case 1:
		 		setState(6214)
		 		try variableClause()
		 		setState(6215)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(6216)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.NUMBER.rawValue || _la == MySqlParser.Tokens.ROW_COUNT.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6224)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(6217)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(6218)
		 			try variableClause()
		 			setState(6219)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 			setState(6220)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.NUMBER.rawValue || _la == MySqlParser.Tokens.ROW_COUNT.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}


		 			setState(6226)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}


		 		break
		 	case 2:
		 		setState(6227)
		 		try match(MySqlParser.Tokens.CONDITION.rawValue)
		 		setState(6230)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .ZERO_DECIMAL:fallthrough
		 		case .ONE_DECIMAL:fallthrough
		 		case .TWO_DECIMAL:fallthrough
		 		case .DECIMAL_LITERAL:fallthrough
		 		case .REAL_LITERAL:
		 			setState(6228)
		 			try decimalLiteral()

		 			break
		 		case .ARRAY:fallthrough
		 		case .ATTRIBUTE:fallthrough
		 		case .BUCKETS:fallthrough
		 		case .CONDITION:fallthrough
		 		case .CURRENT:fallthrough
		 		case .CURRENT_USER:fallthrough
		 		case .DATABASE:fallthrough
		 		case .DEFAULT:fallthrough
		 		case .DIAGNOSTICS:fallthrough
		 		case .EMPTY:fallthrough
		 		case .ENFORCED:fallthrough
		 		case .EXCEPT:fallthrough
		 		case .GROUP:fallthrough
		 		case .IF:fallthrough
		 		case .IGNORED:fallthrough
		 		case .INSERT:fallthrough
		 		case .LATERAL:fallthrough
		 		case .LEFT:fallthrough
		 		case .NUMBER:fallthrough
		 		case .OPTIONAL:fallthrough
		 		case .ORDER:fallthrough
		 		case .PRIMARY:fallthrough
		 		case .REPEAT:fallthrough
		 		case .REPLACE:fallthrough
		 		case .RIGHT:fallthrough
		 		case .SCHEMA:fallthrough
		 		case .SKIP_QUERY_REWRITE:fallthrough
		 		case .STACKED:fallthrough
		 		case .DATE:fallthrough
		 		case .TIME:fallthrough
		 		case .TIMESTAMP:fallthrough
		 		case .DATETIME:fallthrough
		 		case .YEAR:fallthrough
		 		case .BINARY:fallthrough
		 		case .TEXT:fallthrough
		 		case .ENUM:fallthrough
		 		case .SERIAL:fallthrough
		 		case .JSON_ARRAY:fallthrough
		 		case .JSON_ARRAYAGG:fallthrough
		 		case .JSON_ARRAY_APPEND:fallthrough
		 		case .JSON_ARRAY_INSERT:fallthrough
		 		case .JSON_CONTAINS:fallthrough
		 		case .JSON_CONTAINS_PATH:fallthrough
		 		case .JSON_DEPTH:fallthrough
		 		case .JSON_EXTRACT:fallthrough
		 		case .JSON_INSERT:fallthrough
		 		case .JSON_KEYS:fallthrough
		 		case .JSON_LENGTH:fallthrough
		 		case .JSON_MERGE:fallthrough
		 		case .JSON_MERGE_PATCH:fallthrough
		 		case .JSON_MERGE_PRESERVE:fallthrough
		 		case .JSON_OBJECT:fallthrough
		 		case .JSON_OBJECTAGG:fallthrough
		 		case .JSON_OVERLAPS:fallthrough
		 		case .JSON_PRETTY:fallthrough
		 		case .JSON_QUOTE:fallthrough
		 		case .JSON_REMOVE:fallthrough
		 		case .JSON_REPLACE:fallthrough
		 		case .JSON_SCHEMA_VALID:fallthrough
		 		case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 		case .JSON_SEARCH:fallthrough
		 		case .JSON_SET:fallthrough
		 		case .JSON_STORAGE_FREE:fallthrough
		 		case .JSON_STORAGE_SIZE:fallthrough
		 		case .JSON_TABLE:fallthrough
		 		case .JSON_TYPE:fallthrough
		 		case .JSON_UNQUOTE:fallthrough
		 		case .JSON_VALID:fallthrough
		 		case .JSON_VALUE:fallthrough
		 		case .NESTED:fallthrough
		 		case .ORDINALITY:fallthrough
		 		case .PATH:fallthrough
		 		case .AVG:fallthrough
		 		case .BIT_AND:fallthrough
		 		case .BIT_OR:fallthrough
		 		case .BIT_XOR:fallthrough
		 		case .COUNT:fallthrough
		 		case .CUME_DIST:fallthrough
		 		case .DENSE_RANK:fallthrough
		 		case .FIRST_VALUE:fallthrough
		 		case .GROUP_CONCAT:fallthrough
		 		case .LAG:fallthrough
		 		case .LAST_VALUE:fallthrough
		 		case .LEAD:fallthrough
		 		case .MAX:fallthrough
		 		case .MIN:fallthrough
		 		case .NTILE:fallthrough
		 		case .NTH_VALUE:fallthrough
		 		case .PERCENT_RANK:fallthrough
		 		case .RANK:fallthrough
		 		case .ROW_NUMBER:fallthrough
		 		case .STD:fallthrough
		 		case .STDDEV:fallthrough
		 		case .STDDEV_POP:fallthrough
		 		case .STDDEV_SAMP:fallthrough
		 		case .SUM:fallthrough
		 		case .VAR_POP:fallthrough
		 		case .VAR_SAMP:fallthrough
		 		case .VARIANCE:fallthrough
		 		case .CURRENT_DATE:fallthrough
		 		case .CURRENT_TIME:fallthrough
		 		case .CURRENT_TIMESTAMP:fallthrough
		 		case .LOCALTIME:fallthrough
		 		case .CURDATE:fallthrough
		 		case .CURTIME:fallthrough
		 		case .DATE_ADD:fallthrough
		 		case .DATE_SUB:fallthrough
		 		case .LOCALTIMESTAMP:fallthrough
		 		case .NOW:fallthrough
		 		case .POSITION:fallthrough
		 		case .SUBSTR:fallthrough
		 		case .SUBSTRING:fallthrough
		 		case .SYSDATE:fallthrough
		 		case .TRIM:fallthrough
		 		case .UTC_DATE:fallthrough
		 		case .UTC_TIME:fallthrough
		 		case .UTC_TIMESTAMP:fallthrough
		 		case .ACCOUNT:fallthrough
		 		case .ACTION:fallthrough
		 		case .AFTER:fallthrough
		 		case .AGGREGATE:fallthrough
		 		case .ALGORITHM:fallthrough
		 		case .ANY:fallthrough
		 		case .AT:fallthrough
		 		case .AUTHORS:fallthrough
		 		case .AUTOCOMMIT:fallthrough
		 		case .AUTOEXTEND_SIZE:fallthrough
		 		case .AUTO_INCREMENT:fallthrough
		 		case .AVG_ROW_LENGTH:fallthrough
		 		case .BEGIN:fallthrough
		 		case .BINLOG:fallthrough
		 		case .BIT:fallthrough
		 		case .BLOCK:fallthrough
		 		case .BOOL:fallthrough
		 		case .BOOLEAN:fallthrough
		 		case .BTREE:fallthrough
		 		case .CACHE:fallthrough
		 		case .CASCADED:fallthrough
		 		case .CHAIN:fallthrough
		 		case .CHANGED:fallthrough
		 		case .CHANNEL:fallthrough
		 		case .CHECKSUM:fallthrough
		 		case .PAGE_CHECKSUM:fallthrough
		 		case .CIPHER:fallthrough
		 		case .CLASS_ORIGIN:fallthrough
		 		case .CLIENT:fallthrough
		 		case .CLOSE:fallthrough
		 		case .CLUSTERING:fallthrough
		 		case .COALESCE:fallthrough
		 		case .CODE:fallthrough
		 		case .COLUMNS:fallthrough
		 		case .COLUMN_FORMAT:fallthrough
		 		case .COLUMN_NAME:fallthrough
		 		case .COMMENT:fallthrough
		 		case .COMMIT:fallthrough
		 		case .COMPACT:fallthrough
		 		case .COMPLETION:fallthrough
		 		case .COMPRESSED:fallthrough
		 		case .COMPRESSION:fallthrough
		 		case .CONCURRENT:fallthrough
		 		case .CONNECT:fallthrough
		 		case .CONNECTION:fallthrough
		 		case .CONSISTENT:fallthrough
		 		case .CONSTRAINT_CATALOG:fallthrough
		 		case .CONSTRAINT_SCHEMA:fallthrough
		 		case .CONSTRAINT_NAME:fallthrough
		 		case .CONTAINS:fallthrough
		 		case .CONTEXT:fallthrough
		 		case .CONTRIBUTORS:fallthrough
		 		case .COPY:fallthrough
		 		case .CPU:fallthrough
		 		case .CURSOR_NAME:fallthrough
		 		case .DATA:fallthrough
		 		case .DATAFILE:fallthrough
		 		case .DEALLOCATE:fallthrough
		 		case .DEFAULT_AUTH:fallthrough
		 		case .DEFINER:fallthrough
		 		case .DELAY_KEY_WRITE:fallthrough
		 		case .DES_KEY_FILE:fallthrough
		 		case .DIRECTORY:fallthrough
		 		case .DISABLE:fallthrough
		 		case .DISCARD:fallthrough
		 		case .DISK:fallthrough
		 		case .DO:fallthrough
		 		case .DUMPFILE:fallthrough
		 		case .DUPLICATE:fallthrough
		 		case .DYNAMIC:fallthrough
		 		case .ENABLE:fallthrough
		 		case .ENCRYPTION:fallthrough
		 		case .END:fallthrough
		 		case .ENDS:fallthrough
		 		case .ENGINE:fallthrough
		 		case .ENGINES:fallthrough
		 		case .ERROR:fallthrough
		 		case .ERRORS:fallthrough
		 		case .ESCAPE:fallthrough
		 		case .EVEN:fallthrough
		 		case .EVENT:fallthrough
		 		case .EVENTS:fallthrough
		 		case .EVERY:fallthrough
		 		case .EXCHANGE:fallthrough
		 		case .EXCLUSIVE:fallthrough
		 		case .EXPIRE:fallthrough
		 		case .EXPORT:fallthrough
		 		case .EXTENDED:fallthrough
		 		case .EXTENT_SIZE:fallthrough
		 		case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 		case .FAST:fallthrough
		 		case .FAULTS:fallthrough
		 		case .FIELDS:fallthrough
		 		case .FILE_BLOCK_SIZE:fallthrough
		 		case .FILTER:fallthrough
		 		case .FIRST:fallthrough
		 		case .FIXED:fallthrough
		 		case .FLUSH:fallthrough
		 		case .FOLLOWS:fallthrough
		 		case .FOUND:fallthrough
		 		case .FULL:fallthrough
		 		case .FUNCTION:fallthrough
		 		case .GENERAL:fallthrough
		 		case .GLOBAL:fallthrough
		 		case .GRANTS:fallthrough
		 		case .GROUP_REPLICATION:fallthrough
		 		case .HANDLER:fallthrough
		 		case .HASH:fallthrough
		 		case .HELP:fallthrough
		 		case .HISTORY:fallthrough
		 		case .HOST:fallthrough
		 		case .HOSTS:fallthrough
		 		case .IDENTIFIED:fallthrough
		 		case .IGNORE_SERVER_IDS:fallthrough
		 		case .IMPORT:fallthrough
		 		case .INDEXES:fallthrough
		 		case .INITIAL_SIZE:fallthrough
		 		case .INPLACE:fallthrough
		 		case .INSERT_METHOD:fallthrough
		 		case .INSTALL:fallthrough
		 		case .INSTANCE:fallthrough
		 		case .INSTANT:fallthrough
		 		case .INVISIBLE:fallthrough
		 		case .INVOKER:fallthrough
		 		case .IO:fallthrough
		 		case .IO_THREAD:fallthrough
		 		case .IPC:fallthrough
		 		case .ISOLATION:fallthrough
		 		case .ISSUER:fallthrough
		 		case .JSON:fallthrough
		 		case .KEY_BLOCK_SIZE:fallthrough
		 		case .LANGUAGE:fallthrough
		 		case .LAST:fallthrough
		 		case .LEAVES:fallthrough
		 		case .LESS:fallthrough
		 		case .LEVEL:fallthrough
		 		case .LIST:fallthrough
		 		case .LOCAL:fallthrough
		 		case .LOGFILE:fallthrough
		 		case .LOGS:fallthrough
		 		case .MASTER:fallthrough
		 		case .MASTER_AUTO_POSITION:fallthrough
		 		case .MASTER_CONNECT_RETRY:fallthrough
		 		case .MASTER_DELAY:fallthrough
		 		case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 		case .MASTER_HOST:fallthrough
		 		case .MASTER_LOG_FILE:fallthrough
		 		case .MASTER_LOG_POS:fallthrough
		 		case .MASTER_PASSWORD:fallthrough
		 		case .MASTER_PORT:fallthrough
		 		case .MASTER_RETRY_COUNT:fallthrough
		 		case .MASTER_SSL:fallthrough
		 		case .MASTER_SSL_CA:fallthrough
		 		case .MASTER_SSL_CAPATH:fallthrough
		 		case .MASTER_SSL_CERT:fallthrough
		 		case .MASTER_SSL_CIPHER:fallthrough
		 		case .MASTER_SSL_CRL:fallthrough
		 		case .MASTER_SSL_CRLPATH:fallthrough
		 		case .MASTER_SSL_KEY:fallthrough
		 		case .MASTER_TLS_VERSION:fallthrough
		 		case .MASTER_USER:fallthrough
		 		case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 		case .MAX_QUERIES_PER_HOUR:fallthrough
		 		case .MAX_ROWS:fallthrough
		 		case .MAX_SIZE:fallthrough
		 		case .MAX_UPDATES_PER_HOUR:fallthrough
		 		case .MAX_USER_CONNECTIONS:fallthrough
		 		case .MEDIUM:fallthrough
		 		case .MEMBER:fallthrough
		 		case .MERGE:fallthrough
		 		case .MESSAGE_TEXT:fallthrough
		 		case .MID:fallthrough
		 		case .MIGRATE:fallthrough
		 		case .MIN_ROWS:fallthrough
		 		case .MODE:fallthrough
		 		case .MODIFY:fallthrough
		 		case .MUTEX:fallthrough
		 		case .MYSQL:fallthrough
		 		case .MYSQL_ERRNO:fallthrough
		 		case .NAME:fallthrough
		 		case .NAMES:fallthrough
		 		case .NCHAR:fallthrough
		 		case .NEVER:fallthrough
		 		case .NEXT:fallthrough
		 		case .NO:fallthrough
		 		case .NOCOPY:fallthrough
		 		case .NOWAIT:fallthrough
		 		case .NODEGROUP:fallthrough
		 		case .NONE:fallthrough
		 		case .ODBC:fallthrough
		 		case .OFFLINE:fallthrough
		 		case .OFFSET:fallthrough
		 		case .OF:fallthrough
		 		case .OJ:fallthrough
		 		case .OLD_PASSWORD:fallthrough
		 		case .ONE:fallthrough
		 		case .ONLINE:fallthrough
		 		case .ONLY:fallthrough
		 		case .OPEN:fallthrough
		 		case .OPTIMIZER_COSTS:fallthrough
		 		case .OPTIONS:fallthrough
		 		case .OWNER:fallthrough
		 		case .PACK_KEYS:fallthrough
		 		case .PAGE:fallthrough
		 		case .PARSER:fallthrough
		 		case .PARTIAL:fallthrough
		 		case .PARTITIONING:fallthrough
		 		case .PARTITIONS:fallthrough
		 		case .PASSWORD:fallthrough
		 		case .PASSWORD_LOCK_TIME:fallthrough
		 		case .PHASE:fallthrough
		 		case .PLUGIN:fallthrough
		 		case .PLUGIN_DIR:fallthrough
		 		case .PLUGINS:fallthrough
		 		case .PORT:fallthrough
		 		case .PRECEDES:fallthrough
		 		case .PREPARE:fallthrough
		 		case .PRESERVE:fallthrough
		 		case .PREV:fallthrough
		 		case .PROCESSLIST:fallthrough
		 		case .PROFILE:fallthrough
		 		case .PROFILES:fallthrough
		 		case .PROXY:fallthrough
		 		case .QUERY:fallthrough
		 		case .QUICK:fallthrough
		 		case .REBUILD:fallthrough
		 		case .RECOVER:fallthrough
		 		case .RECURSIVE:fallthrough
		 		case .REDO_BUFFER_SIZE:fallthrough
		 		case .REDUNDANT:fallthrough
		 		case .RELAY:fallthrough
		 		case .RELAY_LOG_FILE:fallthrough
		 		case .RELAY_LOG_POS:fallthrough
		 		case .RELAYLOG:fallthrough
		 		case .REMOVE:fallthrough
		 		case .REORGANIZE:fallthrough
		 		case .REPAIR:fallthrough
		 		case .REPLICATE_DO_DB:fallthrough
		 		case .REPLICATE_DO_TABLE:fallthrough
		 		case .REPLICATE_IGNORE_DB:fallthrough
		 		case .REPLICATE_IGNORE_TABLE:fallthrough
		 		case .REPLICATE_REWRITE_DB:fallthrough
		 		case .REPLICATE_WILD_DO_TABLE:fallthrough
		 		case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 		case .REPLICATION:fallthrough
		 		case .RESET:fallthrough
		 		case .RESUME:fallthrough
		 		case .RETURNED_SQLSTATE:fallthrough
		 		case .RETURNING:fallthrough
		 		case .RETURNS:fallthrough
		 		case .REUSE:fallthrough
		 		case .ROLE:fallthrough
		 		case .ROLLBACK:fallthrough
		 		case .ROLLUP:fallthrough
		 		case .ROTATE:fallthrough
		 		case .ROW:fallthrough
		 		case .ROWS:fallthrough
		 		case .ROW_FORMAT:fallthrough
		 		case .RTREE:fallthrough
		 		case .SAVEPOINT:fallthrough
		 		case .SCHEDULE:fallthrough
		 		case .SECURITY:fallthrough
		 		case .SERVER:fallthrough
		 		case .SESSION:fallthrough
		 		case .SHARE:fallthrough
		 		case .SHARED:fallthrough
		 		case .SIGNED:fallthrough
		 		case .SIMPLE:fallthrough
		 		case .SLAVE:fallthrough
		 		case .SLOW:fallthrough
		 		case .SNAPSHOT:fallthrough
		 		case .SOCKET:fallthrough
		 		case .SOME:fallthrough
		 		case .SONAME:fallthrough
		 		case .SOUNDS:fallthrough
		 		case .SOURCE:fallthrough
		 		case .SQL_AFTER_GTIDS:fallthrough
		 		case .SQL_AFTER_MTS_GAPS:fallthrough
		 		case .SQL_BEFORE_GTIDS:fallthrough
		 		case .SQL_BUFFER_RESULT:fallthrough
		 		case .SQL_CACHE:fallthrough
		 		case .SQL_NO_CACHE:fallthrough
		 		case .SQL_THREAD:fallthrough
		 		case .START:fallthrough
		 		case .STARTS:fallthrough
		 		case .STATS_AUTO_RECALC:fallthrough
		 		case .STATS_PERSISTENT:fallthrough
		 		case .STATS_SAMPLE_PAGES:fallthrough
		 		case .STATUS:fallthrough
		 		case .STOP:fallthrough
		 		case .STORAGE:fallthrough
		 		case .STRING:fallthrough
		 		case .SUBCLASS_ORIGIN:fallthrough
		 		case .SUBJECT:fallthrough
		 		case .SUBPARTITION:fallthrough
		 		case .SUBPARTITIONS:fallthrough
		 		case .SUSPEND:fallthrough
		 		case .SWAPS:fallthrough
		 		case .SWITCHES:fallthrough
		 		case .TABLE_NAME:fallthrough
		 		case .TABLESPACE:fallthrough
		 		case .TABLE_TYPE:fallthrough
		 		case .TEMPORARY:fallthrough
		 		case .TEMPTABLE:fallthrough
		 		case .THAN:fallthrough
		 		case .TRADITIONAL:fallthrough
		 		case .TRANSACTION:fallthrough
		 		case .TRANSACTIONAL:fallthrough
		 		case .TRIGGERS:fallthrough
		 		case .TRUNCATE:fallthrough
		 		case .UNBOUNDED:fallthrough
		 		case .UNDEFINED:fallthrough
		 		case .UNDOFILE:fallthrough
		 		case .UNDO_BUFFER_SIZE:fallthrough
		 		case .UNINSTALL:fallthrough
		 		case .UNKNOWN:fallthrough
		 		case .UNTIL:fallthrough
		 		case .UPGRADE:fallthrough
		 		case .USER:fallthrough
		 		case .USE_FRM:fallthrough
		 		case .USER_RESOURCES:fallthrough
		 		case .VALIDATION:fallthrough
		 		case .VALUE:fallthrough
		 		case .VARIABLES:fallthrough
		 		case .VIEW:fallthrough
		 		case .VIRTUAL:fallthrough
		 		case .VISIBLE:fallthrough
		 		case .WAIT:fallthrough
		 		case .WARNINGS:fallthrough
		 		case .WITHOUT:fallthrough
		 		case .WORK:fallthrough
		 		case .WRAPPER:fallthrough
		 		case .X509:fallthrough
		 		case .XA:fallthrough
		 		case .XML:fallthrough
		 		case .EUR:fallthrough
		 		case .USA:fallthrough
		 		case .JIS:fallthrough
		 		case .ISO:fallthrough
		 		case .INTERNAL:fallthrough
		 		case .QUARTER:fallthrough
		 		case .MONTH:fallthrough
		 		case .DAY:fallthrough
		 		case .HOUR:fallthrough
		 		case .MINUTE:fallthrough
		 		case .WEEK:fallthrough
		 		case .SECOND:fallthrough
		 		case .MICROSECOND:fallthrough
		 		case .ADMIN:fallthrough
		 		case .AUDIT_ABORT_EXEMPT:fallthrough
		 		case .AUDIT_ADMIN:fallthrough
		 		case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 		case .BACKUP_ADMIN:fallthrough
		 		case .BINLOG_ADMIN:fallthrough
		 		case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 		case .CLONE_ADMIN:fallthrough
		 		case .CONNECTION_ADMIN:fallthrough
		 		case .ENCRYPTION_KEY_ADMIN:fallthrough
		 		case .EXECUTE:fallthrough
		 		case .FILE:fallthrough
		 		case .FIREWALL_ADMIN:fallthrough
		 		case .FIREWALL_EXEMPT:fallthrough
		 		case .FIREWALL_USER:fallthrough
		 		case .GROUP_REPLICATION_ADMIN:fallthrough
		 		case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 		case .INVOKE:fallthrough
		 		case .LAMBDA:fallthrough
		 		case .NDB_STORED_USER:fallthrough
		 		case .PASSWORDLESS_USER_ADMIN:fallthrough
		 		case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 		case .PRIVILEGES:fallthrough
		 		case .PROCESS:fallthrough
		 		case .RELOAD:fallthrough
		 		case .REPLICATION_APPLIER:fallthrough
		 		case .REPLICATION_SLAVE_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_ADMIN:fallthrough
		 		case .RESOURCE_GROUP_USER:fallthrough
		 		case .ROLE_ADMIN:fallthrough
		 		case .ROUTINE:fallthrough
		 		case .S3:fallthrough
		 		case .SESSION_VARIABLES_ADMIN:fallthrough
		 		case .SET_USER_ID:fallthrough
		 		case .SHOW_ROUTINE:fallthrough
		 		case .SHUTDOWN:fallthrough
		 		case .SUPER:fallthrough
		 		case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 		case .TABLES:fallthrough
		 		case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 		case .VERSION_TOKEN_ADMIN:fallthrough
		 		case .XA_RECOVER_ADMIN:fallthrough
		 		case .ARMSCII8:fallthrough
		 		case .ASCII:fallthrough
		 		case .BIG5:fallthrough
		 		case .CP1250:fallthrough
		 		case .CP1251:fallthrough
		 		case .CP1256:fallthrough
		 		case .CP1257:fallthrough
		 		case .CP850:fallthrough
		 		case .CP852:fallthrough
		 		case .CP866:fallthrough
		 		case .CP932:fallthrough
		 		case .DEC8:fallthrough
		 		case .EUCJPMS:fallthrough
		 		case .EUCKR:fallthrough
		 		case .GB18030:fallthrough
		 		case .GB2312:fallthrough
		 		case .GBK:fallthrough
		 		case .GEOSTD8:fallthrough
		 		case .GREEK:fallthrough
		 		case .HEBREW:fallthrough
		 		case .HP8:fallthrough
		 		case .KEYBCS2:fallthrough
		 		case .KOI8R:fallthrough
		 		case .KOI8U:fallthrough
		 		case .LATIN1:fallthrough
		 		case .LATIN2:fallthrough
		 		case .LATIN5:fallthrough
		 		case .LATIN7:fallthrough
		 		case .MACCE:fallthrough
		 		case .MACROMAN:fallthrough
		 		case .SJIS:fallthrough
		 		case .SWE7:fallthrough
		 		case .TIS620:fallthrough
		 		case .UCS2:fallthrough
		 		case .UJIS:fallthrough
		 		case .UTF16:fallthrough
		 		case .UTF16LE:fallthrough
		 		case .UTF32:fallthrough
		 		case .UTF8:fallthrough
		 		case .UTF8MB3:fallthrough
		 		case .UTF8MB4:fallthrough
		 		case .ARCHIVE:fallthrough
		 		case .BLACKHOLE:fallthrough
		 		case .CSV:fallthrough
		 		case .FEDERATED:fallthrough
		 		case .INNODB:fallthrough
		 		case .MEMORY:fallthrough
		 		case .MRG_MYISAM:fallthrough
		 		case .MYISAM:fallthrough
		 		case .NDB:fallthrough
		 		case .NDBCLUSTER:fallthrough
		 		case .PERFORMANCE_SCHEMA:fallthrough
		 		case .TOKUDB:fallthrough
		 		case .REPEATABLE:fallthrough
		 		case .COMMITTED:fallthrough
		 		case .UNCOMMITTED:fallthrough
		 		case .SERIALIZABLE:fallthrough
		 		case .GEOMETRYCOLLECTION:fallthrough
		 		case .LINESTRING:fallthrough
		 		case .MULTILINESTRING:fallthrough
		 		case .MULTIPOINT:fallthrough
		 		case .MULTIPOLYGON:fallthrough
		 		case .POINT:fallthrough
		 		case .POLYGON:fallthrough
		 		case .ABS:fallthrough
		 		case .ACOS:fallthrough
		 		case .ADDDATE:fallthrough
		 		case .ADDTIME:fallthrough
		 		case .AES_DECRYPT:fallthrough
		 		case .AES_ENCRYPT:fallthrough
		 		case .AREA:fallthrough
		 		case .ASBINARY:fallthrough
		 		case .ASIN:fallthrough
		 		case .ASTEXT:fallthrough
		 		case .ASWKB:fallthrough
		 		case .ASWKT:fallthrough
		 		case .ASYMMETRIC_DECRYPT:fallthrough
		 		case .ASYMMETRIC_DERIVE:fallthrough
		 		case .ASYMMETRIC_ENCRYPT:fallthrough
		 		case .ASYMMETRIC_SIGN:fallthrough
		 		case .ASYMMETRIC_VERIFY:fallthrough
		 		case .ATAN:fallthrough
		 		case .ATAN2:fallthrough
		 		case .BENCHMARK:fallthrough
		 		case .BIN:fallthrough
		 		case .BIT_COUNT:fallthrough
		 		case .BIT_LENGTH:fallthrough
		 		case .BUFFER:fallthrough
		 		case .CATALOG_NAME:fallthrough
		 		case .CEIL:fallthrough
		 		case .CEILING:fallthrough
		 		case .CENTROID:fallthrough
		 		case .CHARACTER_LENGTH:fallthrough
		 		case .CHARSET:fallthrough
		 		case .CHAR_LENGTH:fallthrough
		 		case .COERCIBILITY:fallthrough
		 		case .COLLATION:fallthrough
		 		case .COMPRESS:fallthrough
		 		case .CONCAT:fallthrough
		 		case .CONCAT_WS:fallthrough
		 		case .CONNECTION_ID:fallthrough
		 		case .CONV:fallthrough
		 		case .CONVERT_TZ:fallthrough
		 		case .COS:fallthrough
		 		case .COT:fallthrough
		 		case .CRC32:fallthrough
		 		case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 		case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 		case .CREATE_DH_PARAMETERS:fallthrough
		 		case .CREATE_DIGEST:fallthrough
		 		case .CROSSES:fallthrough
		 		case .DATEDIFF:fallthrough
		 		case .DATE_FORMAT:fallthrough
		 		case .DAYNAME:fallthrough
		 		case .DAYOFMONTH:fallthrough
		 		case .DAYOFWEEK:fallthrough
		 		case .DAYOFYEAR:fallthrough
		 		case .DECODE:fallthrough
		 		case .DEGREES:fallthrough
		 		case .DES_DECRYPT:fallthrough
		 		case .DES_ENCRYPT:fallthrough
		 		case .DIMENSION:fallthrough
		 		case .DISJOINT:fallthrough
		 		case .ELT:fallthrough
		 		case .ENCODE:fallthrough
		 		case .ENCRYPT:fallthrough
		 		case .ENDPOINT:fallthrough
		 		case .ENGINE_ATTRIBUTE:fallthrough
		 		case .ENVELOPE:fallthrough
		 		case .EQUALS:fallthrough
		 		case .EXP:fallthrough
		 		case .EXPORT_SET:fallthrough
		 		case .EXTERIORRING:fallthrough
		 		case .EXTRACTVALUE:fallthrough
		 		case .FIELD:fallthrough
		 		case .FIND_IN_SET:fallthrough
		 		case .FLOOR:fallthrough
		 		case .FORMAT:fallthrough
		 		case .FOUND_ROWS:fallthrough
		 		case .FROM_BASE64:fallthrough
		 		case .FROM_DAYS:fallthrough
		 		case .FROM_UNIXTIME:fallthrough
		 		case .GEOMCOLLFROMTEXT:fallthrough
		 		case .GEOMCOLLFROMWKB:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .GEOMETRYFROMTEXT:fallthrough
		 		case .GEOMETRYFROMWKB:fallthrough
		 		case .GEOMETRYN:fallthrough
		 		case .GEOMETRYTYPE:fallthrough
		 		case .GEOMFROMTEXT:fallthrough
		 		case .GEOMFROMWKB:fallthrough
		 		case .GET_FORMAT:fallthrough
		 		case .GET_LOCK:fallthrough
		 		case .GLENGTH:fallthrough
		 		case .GREATEST:fallthrough
		 		case .GTID_SUBSET:fallthrough
		 		case .GTID_SUBTRACT:fallthrough
		 		case .HEX:fallthrough
		 		case .IFNULL:fallthrough
		 		case .INET6_ATON:fallthrough
		 		case .INET6_NTOA:fallthrough
		 		case .INET_ATON:fallthrough
		 		case .INET_NTOA:fallthrough
		 		case .INSTR:fallthrough
		 		case .INTERIORRINGN:fallthrough
		 		case .INTERSECTS:fallthrough
		 		case .ISCLOSED:fallthrough
		 		case .ISEMPTY:fallthrough
		 		case .ISNULL:fallthrough
		 		case .ISSIMPLE:fallthrough
		 		case .IS_FREE_LOCK:fallthrough
		 		case .IS_IPV4:fallthrough
		 		case .IS_IPV4_COMPAT:fallthrough
		 		case .IS_IPV4_MAPPED:fallthrough
		 		case .IS_IPV6:fallthrough
		 		case .IS_USED_LOCK:fallthrough
		 		case .LAST_INSERT_ID:fallthrough
		 		case .LCASE:fallthrough
		 		case .LEAST:fallthrough
		 		case .LENGTH:fallthrough
		 		case .LINEFROMTEXT:fallthrough
		 		case .LINEFROMWKB:fallthrough
		 		case .LINESTRINGFROMTEXT:fallthrough
		 		case .LINESTRINGFROMWKB:fallthrough
		 		case .LN:fallthrough
		 		case .LOAD_FILE:fallthrough
		 		case .LOCATE:fallthrough
		 		case .LOG:fallthrough
		 		case .LOG10:fallthrough
		 		case .LOG2:fallthrough
		 		case .LOWER:fallthrough
		 		case .LPAD:fallthrough
		 		case .LTRIM:fallthrough
		 		case .MAKEDATE:fallthrough
		 		case .MAKETIME:fallthrough
		 		case .MAKE_SET:fallthrough
		 		case .MASTER_POS_WAIT:fallthrough
		 		case .MBRCONTAINS:fallthrough
		 		case .MBRDISJOINT:fallthrough
		 		case .MBREQUAL:fallthrough
		 		case .MBRINTERSECTS:fallthrough
		 		case .MBROVERLAPS:fallthrough
		 		case .MBRTOUCHES:fallthrough
		 		case .MBRWITHIN:fallthrough
		 		case .MD5:fallthrough
		 		case .MLINEFROMTEXT:fallthrough
		 		case .MLINEFROMWKB:fallthrough
		 		case .MONTHNAME:fallthrough
		 		case .MPOINTFROMTEXT:fallthrough
		 		case .MPOINTFROMWKB:fallthrough
		 		case .MPOLYFROMTEXT:fallthrough
		 		case .MPOLYFROMWKB:fallthrough
		 		case .MULTILINESTRINGFROMTEXT:fallthrough
		 		case .MULTILINESTRINGFROMWKB:fallthrough
		 		case .MULTIPOINTFROMTEXT:fallthrough
		 		case .MULTIPOINTFROMWKB:fallthrough
		 		case .MULTIPOLYGONFROMTEXT:fallthrough
		 		case .MULTIPOLYGONFROMWKB:fallthrough
		 		case .NAME_CONST:fallthrough
		 		case .NULLIF:fallthrough
		 		case .NUMGEOMETRIES:fallthrough
		 		case .NUMINTERIORRINGS:fallthrough
		 		case .NUMPOINTS:fallthrough
		 		case .OCT:fallthrough
		 		case .OCTET_LENGTH:fallthrough
		 		case .ORD:fallthrough
		 		case .OVERLAPS:fallthrough
		 		case .PERIOD_ADD:fallthrough
		 		case .PERIOD_DIFF:fallthrough
		 		case .PI:fallthrough
		 		case .POINTFROMTEXT:fallthrough
		 		case .POINTFROMWKB:fallthrough
		 		case .POINTN:fallthrough
		 		case .POLYFROMTEXT:fallthrough
		 		case .POLYFROMWKB:fallthrough
		 		case .POLYGONFROMTEXT:fallthrough
		 		case .POLYGONFROMWKB:fallthrough
		 		case .POW:fallthrough
		 		case .POWER:fallthrough
		 		case .QUOTE:fallthrough
		 		case .RADIANS:fallthrough
		 		case .RAND:fallthrough
		 		case .RANDOM:fallthrough
		 		case .RANDOM_BYTES:fallthrough
		 		case .RELEASE_LOCK:fallthrough
		 		case .REVERSE:fallthrough
		 		case .ROUND:fallthrough
		 		case .ROW_COUNT:fallthrough
		 		case .RPAD:fallthrough
		 		case .RTRIM:fallthrough
		 		case .SEC_TO_TIME:fallthrough
		 		case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 		case .SESSION_USER:fallthrough
		 		case .SHA:fallthrough
		 		case .SHA1:fallthrough
		 		case .SHA2:fallthrough
		 		case .SCHEMA_NAME:fallthrough
		 		case .SIGN:fallthrough
		 		case .SIN:fallthrough
		 		case .SLEEP:fallthrough
		 		case .SOUNDEX:fallthrough
		 		case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 		case .SQRT:fallthrough
		 		case .SRID:fallthrough
		 		case .STARTPOINT:fallthrough
		 		case .STRCMP:fallthrough
		 		case .STR_TO_DATE:fallthrough
		 		case .ST_AREA:fallthrough
		 		case .ST_ASBINARY:fallthrough
		 		case .ST_ASTEXT:fallthrough
		 		case .ST_ASWKB:fallthrough
		 		case .ST_ASWKT:fallthrough
		 		case .ST_BUFFER:fallthrough
		 		case .ST_CENTROID:fallthrough
		 		case .ST_CONTAINS:fallthrough
		 		case .ST_CROSSES:fallthrough
		 		case .ST_DIFFERENCE:fallthrough
		 		case .ST_DIMENSION:fallthrough
		 		case .ST_DISJOINT:fallthrough
		 		case .ST_DISTANCE:fallthrough
		 		case .ST_ENDPOINT:fallthrough
		 		case .ST_ENVELOPE:fallthrough
		 		case .ST_EQUALS:fallthrough
		 		case .ST_EXTERIORRING:fallthrough
		 		case .ST_GEOMCOLLFROMTEXT:fallthrough
		 		case .ST_GEOMCOLLFROMTXT:fallthrough
		 		case .ST_GEOMCOLLFROMWKB:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 		case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 		case .ST_GEOMETRYFROMTEXT:fallthrough
		 		case .ST_GEOMETRYFROMWKB:fallthrough
		 		case .ST_GEOMETRYN:fallthrough
		 		case .ST_GEOMETRYTYPE:fallthrough
		 		case .ST_GEOMFROMTEXT:fallthrough
		 		case .ST_GEOMFROMWKB:fallthrough
		 		case .ST_INTERIORRINGN:fallthrough
		 		case .ST_INTERSECTION:fallthrough
		 		case .ST_INTERSECTS:fallthrough
		 		case .ST_ISCLOSED:fallthrough
		 		case .ST_ISEMPTY:fallthrough
		 		case .ST_ISSIMPLE:fallthrough
		 		case .ST_LINEFROMTEXT:fallthrough
		 		case .ST_LINEFROMWKB:fallthrough
		 		case .ST_LINESTRINGFROMTEXT:fallthrough
		 		case .ST_LINESTRINGFROMWKB:fallthrough
		 		case .ST_NUMGEOMETRIES:fallthrough
		 		case .ST_NUMINTERIORRING:fallthrough
		 		case .ST_NUMINTERIORRINGS:fallthrough
		 		case .ST_NUMPOINTS:fallthrough
		 		case .ST_OVERLAPS:fallthrough
		 		case .ST_POINTFROMTEXT:fallthrough
		 		case .ST_POINTFROMWKB:fallthrough
		 		case .ST_POINTN:fallthrough
		 		case .ST_POLYFROMTEXT:fallthrough
		 		case .ST_POLYFROMWKB:fallthrough
		 		case .ST_POLYGONFROMTEXT:fallthrough
		 		case .ST_POLYGONFROMWKB:fallthrough
		 		case .ST_SRID:fallthrough
		 		case .ST_STARTPOINT:fallthrough
		 		case .ST_SYMDIFFERENCE:fallthrough
		 		case .ST_TOUCHES:fallthrough
		 		case .ST_UNION:fallthrough
		 		case .ST_WITHIN:fallthrough
		 		case .ST_X:fallthrough
		 		case .ST_Y:fallthrough
		 		case .SUBDATE:fallthrough
		 		case .SUBSTRING_INDEX:fallthrough
		 		case .SUBTIME:fallthrough
		 		case .SYSTEM_USER:fallthrough
		 		case .TAN:fallthrough
		 		case .TIMEDIFF:fallthrough
		 		case .TIMESTAMPADD:fallthrough
		 		case .TIMESTAMPDIFF:fallthrough
		 		case .TIME_FORMAT:fallthrough
		 		case .TIME_TO_SEC:fallthrough
		 		case .TOUCHES:fallthrough
		 		case .TO_BASE64:fallthrough
		 		case .TO_DAYS:fallthrough
		 		case .TO_SECONDS:fallthrough
		 		case .TP_CONNECTION_ADMIN:fallthrough
		 		case .UCASE:fallthrough
		 		case .UNCOMPRESS:fallthrough
		 		case .UNCOMPRESSED_LENGTH:fallthrough
		 		case .UNHEX:fallthrough
		 		case .UNIX_TIMESTAMP:fallthrough
		 		case .UPDATEXML:fallthrough
		 		case .UPPER:fallthrough
		 		case .UUID:fallthrough
		 		case .UUID_SHORT:fallthrough
		 		case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 		case .VERSION:fallthrough
		 		case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 		case .WEEKDAY:fallthrough
		 		case .WEEKOFYEAR:fallthrough
		 		case .WEIGHT_STRING:fallthrough
		 		case .WITHIN:fallthrough
		 		case .YEARWEEK:fallthrough
		 		case .Y_FUNCTION:fallthrough
		 		case .X_FUNCTION:fallthrough
		 		case .MOD:fallthrough
		 		case .AT_SIGN:fallthrough
		 		case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 		case .STRING_LITERAL:fallthrough
		 		case .ID:fallthrough
		 		case .LOCAL_ID:fallthrough
		 		case .GLOBAL_ID:
		 			setState(6229)
		 			try variableClause()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(6232)
		 		try variableClause()
		 		setState(6233)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(6234)
		 		try diagnosticsConditionInformationName()
		 		setState(6242)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(6235)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(6236)
		 			try variableClause()
		 			setState(6237)
		 			try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 			setState(6238)
		 			try diagnosticsConditionInformationName()


		 			setState(6244)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}


		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DiagnosticsConditionInformationNameContext: ParserRuleContext {
			open
			func CLASS_ORIGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CLASS_ORIGIN.rawValue, 0)
			}
			open
			func SUBCLASS_ORIGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBCLASS_ORIGIN.rawValue, 0)
			}
			open
			func RETURNED_SQLSTATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RETURNED_SQLSTATE.rawValue, 0)
			}
			open
			func MESSAGE_TEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MESSAGE_TEXT.rawValue, 0)
			}
			open
			func MYSQL_ERRNO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MYSQL_ERRNO.rawValue, 0)
			}
			open
			func CONSTRAINT_CATALOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT_CATALOG.rawValue, 0)
			}
			open
			func CONSTRAINT_SCHEMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT_SCHEMA.rawValue, 0)
			}
			open
			func CONSTRAINT_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT_NAME.rawValue, 0)
			}
			open
			func CATALOG_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CATALOG_NAME.rawValue, 0)
			}
			open
			func SCHEMA_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEMA_NAME.rawValue, 0)
			}
			open
			func TABLE_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE_NAME.rawValue, 0)
			}
			open
			func COLUMN_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN_NAME.rawValue, 0)
			}
			open
			func CURSOR_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURSOR_NAME.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_diagnosticsConditionInformationName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDiagnosticsConditionInformationName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDiagnosticsConditionInformationName(self)
			}
		}
	}
	@discardableResult
	 open func diagnosticsConditionInformationName() throws -> DiagnosticsConditionInformationNameContext {
		var _localctx: DiagnosticsConditionInformationNameContext
		_localctx = DiagnosticsConditionInformationNameContext(_ctx, getState())
		try enterRule(_localctx, 546, MySqlParser.RULE_diagnosticsConditionInformationName)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6247)
		 	_la = try _input.LA(1)
		 	if (!(((Int64((_la - 359)) & ~0x3f) == 0 && ((Int64(1) << (_la - 359)) & 272105729) != 0) || _la == MySqlParser.Tokens.MESSAGE_TEXT.rawValue || _la == MySqlParser.Tokens.MYSQL_ERRNO.rawValue || ((Int64((_la - 592)) & ~0x3f) == 0 && ((Int64(1) << (_la - 592)) & 18155135997837313) != 0) || _la == MySqlParser.Tokens.CATALOG_NAME.rawValue || _la == MySqlParser.Tokens.SCHEMA_NAME.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DescribeObjectClauseContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_describeObjectClause
		}
	}
	public class DescribeStatementsContext: DescribeObjectClauseContext {
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
			open
			func deleteStatement() -> DeleteStatementContext? {
				return getRuleContext(DeleteStatementContext.self, 0)
			}
			open
			func insertStatement() -> InsertStatementContext? {
				return getRuleContext(InsertStatementContext.self, 0)
			}
			open
			func replaceStatement() -> ReplaceStatementContext? {
				return getRuleContext(ReplaceStatementContext.self, 0)
			}
			open
			func updateStatement() -> UpdateStatementContext? {
				return getRuleContext(UpdateStatementContext.self, 0)
			}

		public
		init(_ ctx: DescribeObjectClauseContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDescribeStatements(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDescribeStatements(self)
			}
		}
	}
	public class DescribeConnectionContext: DescribeObjectClauseContext {
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}
			open
			func CONNECTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONNECTION.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}

		public
		init(_ ctx: DescribeObjectClauseContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDescribeConnection(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDescribeConnection(self)
			}
		}
	}
	@discardableResult
	 open func describeObjectClause() throws -> DescribeObjectClauseContext {
		var _localctx: DescribeObjectClauseContext
		_localctx = DescribeObjectClauseContext(_ctx, getState())
		try enterRule(_localctx, 548, MySqlParser.RULE_describeObjectClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6259)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DELETE:fallthrough
		 	case .INSERT:fallthrough
		 	case .REPLACE:fallthrough
		 	case .SELECT:fallthrough
		 	case .UPDATE:fallthrough
		 	case .LR_BRACKET:
		 		_localctx =  DescribeStatementsContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6254)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .SELECT:fallthrough
		 		case .LR_BRACKET:
		 			setState(6249)
		 			try selectStatement()

		 			break

		 		case .DELETE:
		 			setState(6250)
		 			try deleteStatement()

		 			break

		 		case .INSERT:
		 			setState(6251)
		 			try insertStatement()

		 			break

		 		case .REPLACE:
		 			setState(6252)
		 			try replaceStatement()

		 			break

		 		case .UPDATE:
		 			setState(6253)
		 			try updateStatement()

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}

		 		break

		 	case .FOR:
		 		_localctx =  DescribeConnectionContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6256)
		 		try match(MySqlParser.Tokens.FOR.rawValue)
		 		setState(6257)
		 		try match(MySqlParser.Tokens.CONNECTION.rawValue)
		 		setState(6258)
		 		try uid()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FullIdContext: ParserRuleContext {
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func DOT_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DOT_ID.rawValue, 0)
			}
			open
			func DOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DOT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_fullId
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFullId(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFullId(self)
			}
		}
	}
	@discardableResult
	 open func fullId() throws -> FullIdContext {
		var _localctx: FullIdContext
		_localctx = FullIdContext(_ctx, getState())
		try enterRule(_localctx, 550, MySqlParser.RULE_fullId)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6261)
		 	try uid()
		 	setState(6265)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,915,_ctx)) {
		 	case 1:
		 		setState(6262)
		 		try match(MySqlParser.Tokens.DOT_ID.rawValue)

		 		break
		 	case 2:
		 		setState(6263)
		 		try match(MySqlParser.Tokens.DOT.rawValue)
		 		setState(6264)
		 		try uid()

		 		break
		 	default: break
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TableNameContext: ParserRuleContext {
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tableName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTableName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTableName(self)
			}
		}
	}
	@discardableResult
	 open func tableName() throws -> TableNameContext {
		var _localctx: TableNameContext
		_localctx = TableNameContext(_ctx, getState())
		try enterRule(_localctx, 552, MySqlParser.RULE_tableName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6267)
		 	try fullId()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class RoleNameContext: ParserRuleContext {
			open
			func userName() -> UserNameContext? {
				return getRuleContext(UserNameContext.self, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_roleName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRoleName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRoleName(self)
			}
		}
	}
	@discardableResult
	 open func roleName() throws -> RoleNameContext {
		var _localctx: RoleNameContext
		_localctx = RoleNameContext(_ctx, getState())
		try enterRule(_localctx, 554, MySqlParser.RULE_roleName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6271)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,916, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6269)
		 		try userName()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6270)
		 		try uid()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FullColumnNameContext: ParserRuleContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func dottedId() -> [DottedIdContext] {
				return getRuleContexts(DottedIdContext.self)
			}
			open
			func dottedId(_ i: Int) -> DottedIdContext? {
				return getRuleContext(DottedIdContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_fullColumnName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFullColumnName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFullColumnName(self)
			}
		}
	}
	@discardableResult
	 open func fullColumnName() throws -> FullColumnNameContext {
		var _localctx: FullColumnNameContext
		_localctx = FullColumnNameContext(_ctx, getState())
		try enterRule(_localctx, 556, MySqlParser.RULE_fullColumnName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6287)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,921, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6273)
		 		try uid()
		 		setState(6278)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,918,_ctx)) {
		 		case 1:
		 			setState(6274)
		 			try dottedId()
		 			setState(6276)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,917,_ctx)) {
		 			case 1:
		 				setState(6275)
		 				try dottedId()

		 				break
		 			default: break
		 			}

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6281)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,919,_ctx)) {
		 		case 1:
		 			setState(6280)
		 			try matchWildcard();

		 			break
		 		default: break
		 		}
		 		setState(6283)
		 		try dottedId()
		 		setState(6285)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,920,_ctx)) {
		 		case 1:
		 			setState(6284)
		 			try dottedId()

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexColumnNameContext: ParserRuleContext {
		open var sortType: Token!
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func ASC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASC.rawValue, 0)
			}
			open
			func DESC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DESC.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_indexColumnName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIndexColumnName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIndexColumnName(self)
			}
		}
	}
	@discardableResult
	 open func indexColumnName() throws -> IndexColumnNameContext {
		var _localctx: IndexColumnNameContext
		_localctx = IndexColumnNameContext(_ctx, getState())
		try enterRule(_localctx, 558, MySqlParser.RULE_indexColumnName)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6300)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,924, _ctx)) {
		 	case 1:
		 		setState(6291)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,922, _ctx)) {
		 		case 1:
		 			setState(6289)
		 			try uid()

		 			break
		 		case 2:
		 			setState(6290)
		 			try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(6297)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 			setState(6293)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(6294)
		 			try decimalLiteral()
		 			setState(6295)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		}


		 		break
		 	case 2:
		 		setState(6299)
		 		try expression(0)

		 		break
		 	default: break
		 	}
		 	setState(6303)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ASC.rawValue || _la == MySqlParser.Tokens.DESC.rawValue) {
		 		setState(6302)
		 		_localctx.castdown(IndexColumnNameContext.self).sortType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ASC.rawValue || _la == MySqlParser.Tokens.DESC.rawValue)) {
		 			_localctx.castdown(IndexColumnNameContext.self).sortType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SimpleUserNameContext: ParserRuleContext {
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ID.rawValue, 0)
			}
			open
			func ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADMIN.rawValue, 0)
			}
			open
			func keywordsCanBeId() -> KeywordsCanBeIdContext? {
				return getRuleContext(KeywordsCanBeIdContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_simpleUserName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSimpleUserName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSimpleUserName(self)
			}
		}
	}
	@discardableResult
	 open func simpleUserName() throws -> SimpleUserNameContext {
		var _localctx: SimpleUserNameContext
		_localctx = SimpleUserNameContext(_ctx, getState())
		try enterRule(_localctx, 560, MySqlParser.RULE_simpleUserName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6309)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,926, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6305)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6306)
		 		try match(MySqlParser.Tokens.ID.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6307)
		 		try match(MySqlParser.Tokens.ADMIN.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6308)
		 		try keywordsCanBeId()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HostNameContext: ParserRuleContext {
			open
			func LOCAL_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL_ID.rawValue, 0)
			}
			open
			func HOST_IP_ADDRESS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HOST_IP_ADDRESS.rawValue, 0)
			}
			open
			func AT_SIGN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AT_SIGN.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_hostName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHostName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHostName(self)
			}
		}
	}
	@discardableResult
	 open func hostName() throws -> HostNameContext {
		var _localctx: HostNameContext
		_localctx = HostNameContext(_ctx, getState())
		try enterRule(_localctx, 562, MySqlParser.RULE_hostName)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6311)
		 	_la = try _input.LA(1)
		 	if (!(((Int64((_la - 1137)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1137)) & 6291457) != 0))) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UserNameContext: ParserRuleContext {
			open
			func simpleUserName() -> SimpleUserNameContext? {
				return getRuleContext(SimpleUserNameContext.self, 0)
			}
			open
			func hostName() -> HostNameContext? {
				return getRuleContext(HostNameContext.self, 0)
			}
			open
			func currentUserExpression() -> CurrentUserExpressionContext? {
				return getRuleContext(CurrentUserExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_userName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUserName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUserName(self)
			}
		}
	}
	@discardableResult
	 open func userName() throws -> UserNameContext {
		var _localctx: UserNameContext
		_localctx = UserNameContext(_ctx, getState())
		try enterRule(_localctx, 564, MySqlParser.RULE_userName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6318)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,927, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6313)
		 		try simpleUserName()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6314)
		 		try simpleUserName()
		 		setState(6315)
		 		try hostName()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6317)
		 		try currentUserExpression()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MysqlVariableContext: ParserRuleContext {
			open
			func LOCAL_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL_ID.rawValue, 0)
			}
			open
			func GLOBAL_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GLOBAL_ID.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_mysqlVariable
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMysqlVariable(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMysqlVariable(self)
			}
		}
	}
	@discardableResult
	 open func mysqlVariable() throws -> MysqlVariableContext {
		var _localctx: MysqlVariableContext
		_localctx = MysqlVariableContext(_ctx, getState())
		try enterRule(_localctx, 566, MySqlParser.RULE_mysqlVariable)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6320)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.LOCAL_ID.rawValue || _la == MySqlParser.Tokens.GLOBAL_ID.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CharsetNameContext: ParserRuleContext {
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}
			open
			func charsetNameBase() -> CharsetNameBaseContext? {
				return getRuleContext(CharsetNameBaseContext.self, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func CHARSET_REVERSE_QOUTE_STRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARSET_REVERSE_QOUTE_STRING.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_charsetName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCharsetName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCharsetName(self)
			}
		}
	}
	@discardableResult
	 open func charsetName() throws -> CharsetNameContext {
		var _localctx: CharsetNameContext
		_localctx = CharsetNameContext(_ctx, getState())
		try enterRule(_localctx, 568, MySqlParser.RULE_charsetName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6326)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,928, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6322)
		 		try match(MySqlParser.Tokens.BINARY.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6323)
		 		try charsetNameBase()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6324)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6325)
		 		try match(MySqlParser.Tokens.CHARSET_REVERSE_QOUTE_STRING.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CollationNameContext: ParserRuleContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_collationName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCollationName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCollationName(self)
			}
		}
	}
	@discardableResult
	 open func collationName() throws -> CollationNameContext {
		var _localctx: CollationNameContext
		_localctx = CollationNameContext(_ctx, getState())
		try enterRule(_localctx, 570, MySqlParser.RULE_collationName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6330)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,929, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6328)
		 		try uid()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6329)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EngineNameContext: ParserRuleContext {
			open
			func engineNameBase() -> EngineNameBaseContext? {
				return getRuleContext(EngineNameBaseContext.self, 0)
			}
			open
			func ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ID.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_engineName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterEngineName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitEngineName(self)
			}
		}
	}
	@discardableResult
	 open func engineName() throws -> EngineNameContext {
		var _localctx: EngineNameContext
		_localctx = EngineNameContext(_ctx, getState())
		try enterRule(_localctx, 572, MySqlParser.RULE_engineName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6335)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CONNECT:fallthrough
		 	case .ARCHIVE:fallthrough
		 	case .BLACKHOLE:fallthrough
		 	case .CSV:fallthrough
		 	case .FEDERATED:fallthrough
		 	case .INNODB:fallthrough
		 	case .MEMORY:fallthrough
		 	case .MRG_MYISAM:fallthrough
		 	case .MYISAM:fallthrough
		 	case .NDB:fallthrough
		 	case .NDBCLUSTER:fallthrough
		 	case .PERFORMANCE_SCHEMA:fallthrough
		 	case .TOKUDB:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6332)
		 		try engineNameBase()

		 		break

		 	case .ID:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6333)
		 		try match(MySqlParser.Tokens.ID.rawValue)

		 		break

		 	case .STRING_LITERAL:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6334)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class EngineNameBaseContext: ParserRuleContext {
			open
			func ARCHIVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ARCHIVE.rawValue, 0)
			}
			open
			func BLACKHOLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BLACKHOLE.rawValue, 0)
			}
			open
			func CONNECT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONNECT.rawValue, 0)
			}
			open
			func CSV() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CSV.rawValue, 0)
			}
			open
			func FEDERATED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FEDERATED.rawValue, 0)
			}
			open
			func INNODB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INNODB.rawValue, 0)
			}
			open
			func MEMORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEMORY.rawValue, 0)
			}
			open
			func MRG_MYISAM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MRG_MYISAM.rawValue, 0)
			}
			open
			func MYISAM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MYISAM.rawValue, 0)
			}
			open
			func NDB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NDB.rawValue, 0)
			}
			open
			func NDBCLUSTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NDBCLUSTER.rawValue, 0)
			}
			open
			func PERFORMANCE_SCHEMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PERFORMANCE_SCHEMA.rawValue, 0)
			}
			open
			func TOKUDB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TOKUDB.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_engineNameBase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterEngineNameBase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitEngineNameBase(self)
			}
		}
	}
	@discardableResult
	 open func engineNameBase() throws -> EngineNameBaseContext {
		var _localctx: EngineNameBaseContext
		_localctx = EngineNameBaseContext(_ctx, getState())
		try enterRule(_localctx, 574, MySqlParser.RULE_engineNameBase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6337)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.CONNECT.rawValue || ((Int64((_la - 787)) & ~0x3f) == 0 && ((Int64(1) << (_la - 787)) & 4095) != 0))) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UuidSetContext: ParserRuleContext {
			open
			func decimalLiteral() -> [DecimalLiteralContext] {
				return getRuleContexts(DecimalLiteralContext.self)
			}
			open
			func decimalLiteral(_ i: Int) -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, i)
			}
			open
			func MINUS() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.MINUS.rawValue)
			}
			open
			func MINUS(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUS.rawValue, i)
			}
			open
			func COLON_SYMB() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COLON_SYMB.rawValue)
			}
			open
			func COLON_SYMB(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLON_SYMB.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_uuidSet
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUuidSet(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUuidSet(self)
			}
		}
	}
	@discardableResult
	 open func uuidSet() throws -> UuidSetContext {
		var _localctx: UuidSetContext
		_localctx = UuidSetContext(_ctx, getState())
		try enterRule(_localctx, 576, MySqlParser.RULE_uuidSet)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6339)
		 	try decimalLiteral()
		 	setState(6340)
		 	try match(MySqlParser.Tokens.MINUS.rawValue)
		 	setState(6341)
		 	try decimalLiteral()
		 	setState(6342)
		 	try match(MySqlParser.Tokens.MINUS.rawValue)
		 	setState(6343)
		 	try decimalLiteral()
		 	setState(6344)
		 	try match(MySqlParser.Tokens.MINUS.rawValue)
		 	setState(6345)
		 	try decimalLiteral()
		 	setState(6346)
		 	try match(MySqlParser.Tokens.MINUS.rawValue)
		 	setState(6347)
		 	try decimalLiteral()
		 	setState(6353) 
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	repeat {
		 		setState(6348)
		 		try match(MySqlParser.Tokens.COLON_SYMB.rawValue)
		 		setState(6349)
		 		try decimalLiteral()
		 		setState(6350)
		 		try match(MySqlParser.Tokens.MINUS.rawValue)
		 		setState(6351)
		 		try decimalLiteral()


		 		setState(6355); 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	} while (_la == MySqlParser.Tokens.COLON_SYMB.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class XidContext: ParserRuleContext {
		open var globalTableUid: XuidStringIdContext!
		open var qualifier: XuidStringIdContext!
		open var idFormat: DecimalLiteralContext!
			open
			func xuidStringId() -> [XuidStringIdContext] {
				return getRuleContexts(XuidStringIdContext.self)
			}
			open
			func xuidStringId(_ i: Int) -> XuidStringIdContext? {
				return getRuleContext(XuidStringIdContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_xid
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterXid(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitXid(self)
			}
		}
	}
	@discardableResult
	 open func xid() throws -> XidContext {
		var _localctx: XidContext
		_localctx = XidContext(_ctx, getState())
		try enterRule(_localctx, 578, MySqlParser.RULE_xid)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6357)
		 	try {
		 			let assignmentValue = try xuidStringId()
		 			_localctx.castdown(XidContext.self).globalTableUid = assignmentValue
		 	     }()

		 	setState(6364)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6358)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6359)
		 		try {
		 				let assignmentValue = try xuidStringId()
		 				_localctx.castdown(XidContext.self).qualifier = assignmentValue
		 		     }()

		 		setState(6362)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(6360)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(6361)
		 			try {
		 					let assignmentValue = try decimalLiteral()
		 					_localctx.castdown(XidContext.self).idFormat = assignmentValue
		 			     }()


		 		}


		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class XuidStringIdContext: ParserRuleContext {
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func BIT_STRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_STRING.rawValue, 0)
			}
			open
			func HEXADECIMAL_LITERAL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.HEXADECIMAL_LITERAL.rawValue)
			}
			open
			func HEXADECIMAL_LITERAL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HEXADECIMAL_LITERAL.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_xuidStringId
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterXuidStringId(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitXuidStringId(self)
			}
		}
	}
	@discardableResult
	 open func xuidStringId() throws -> XuidStringIdContext {
		var _localctx: XuidStringIdContext
		_localctx = XuidStringIdContext(_ctx, getState())
		try enterRule(_localctx, 580, MySqlParser.RULE_xuidStringId)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6373)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .STRING_LITERAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6366)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break

		 	case .BIT_STRING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6367)
		 		try match(MySqlParser.Tokens.BIT_STRING.rawValue)

		 		break

		 	case .HEXADECIMAL_LITERAL:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6369) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(6368)
		 			try match(MySqlParser.Tokens.HEXADECIMAL_LITERAL.rawValue)


		 			setState(6371); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (_la == MySqlParser.Tokens.HEXADECIMAL_LITERAL.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AuthPluginContext: ParserRuleContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_authPlugin
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAuthPlugin(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAuthPlugin(self)
			}
		}
	}
	@discardableResult
	 open func authPlugin() throws -> AuthPluginContext {
		var _localctx: AuthPluginContext
		_localctx = AuthPluginContext(_ctx, getState())
		try enterRule(_localctx, 582, MySqlParser.RULE_authPlugin)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6377)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,936, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6375)
		 		try uid()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6376)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UidContext: ParserRuleContext {
			open
			func simpleId() -> SimpleIdContext? {
				return getRuleContext(SimpleIdContext.self, 0)
			}
			open
			func CHARSET_REVERSE_QOUTE_STRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARSET_REVERSE_QOUTE_STRING.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_uid
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUid(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUid(self)
			}
		}
	}
	@discardableResult
	 open func uid() throws -> UidContext {
		var _localctx: UidContext
		_localctx = UidContext(_ctx, getState())
		try enterRule(_localctx, 584, MySqlParser.RULE_uid)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6382)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .ARRAY:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .BUCKETS:fallthrough
		 	case .CONDITION:fallthrough
		 	case .CURRENT:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DIAGNOSTICS:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENFORCED:fallthrough
		 	case .EXCEPT:fallthrough
		 	case .GROUP:fallthrough
		 	case .IF:fallthrough
		 	case .IGNORED:fallthrough
		 	case .INSERT:fallthrough
		 	case .LATERAL:fallthrough
		 	case .LEFT:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OPTIONAL:fallthrough
		 	case .ORDER:fallthrough
		 	case .PRIMARY:fallthrough
		 	case .REPEAT:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SKIP_QUERY_REWRITE:fallthrough
		 	case .STACKED:fallthrough
		 	case .DATE:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .DATETIME:fallthrough
		 	case .YEAR:fallthrough
		 	case .BINARY:fallthrough
		 	case .TEXT:fallthrough
		 	case .ENUM:fallthrough
		 	case .SERIAL:fallthrough
		 	case .JSON_ARRAY:fallthrough
		 	case .JSON_ARRAYAGG:fallthrough
		 	case .JSON_ARRAY_APPEND:fallthrough
		 	case .JSON_ARRAY_INSERT:fallthrough
		 	case .JSON_CONTAINS:fallthrough
		 	case .JSON_CONTAINS_PATH:fallthrough
		 	case .JSON_DEPTH:fallthrough
		 	case .JSON_EXTRACT:fallthrough
		 	case .JSON_INSERT:fallthrough
		 	case .JSON_KEYS:fallthrough
		 	case .JSON_LENGTH:fallthrough
		 	case .JSON_MERGE:fallthrough
		 	case .JSON_MERGE_PATCH:fallthrough
		 	case .JSON_MERGE_PRESERVE:fallthrough
		 	case .JSON_OBJECT:fallthrough
		 	case .JSON_OBJECTAGG:fallthrough
		 	case .JSON_OVERLAPS:fallthrough
		 	case .JSON_PRETTY:fallthrough
		 	case .JSON_QUOTE:fallthrough
		 	case .JSON_REMOVE:fallthrough
		 	case .JSON_REPLACE:fallthrough
		 	case .JSON_SCHEMA_VALID:fallthrough
		 	case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 	case .JSON_SEARCH:fallthrough
		 	case .JSON_SET:fallthrough
		 	case .JSON_STORAGE_FREE:fallthrough
		 	case .JSON_STORAGE_SIZE:fallthrough
		 	case .JSON_TABLE:fallthrough
		 	case .JSON_TYPE:fallthrough
		 	case .JSON_UNQUOTE:fallthrough
		 	case .JSON_VALID:fallthrough
		 	case .JSON_VALUE:fallthrough
		 	case .NESTED:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .PATH:fallthrough
		 	case .AVG:fallthrough
		 	case .BIT_AND:fallthrough
		 	case .BIT_OR:fallthrough
		 	case .BIT_XOR:fallthrough
		 	case .COUNT:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .GROUP_CONCAT:fallthrough
		 	case .LAG:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NTH_VALUE:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .STD:fallthrough
		 	case .STDDEV:fallthrough
		 	case .STDDEV_POP:fallthrough
		 	case .STDDEV_SAMP:fallthrough
		 	case .SUM:fallthrough
		 	case .VAR_POP:fallthrough
		 	case .VAR_SAMP:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .CURRENT_DATE:fallthrough
		 	case .CURRENT_TIME:fallthrough
		 	case .CURRENT_TIMESTAMP:fallthrough
		 	case .LOCALTIME:fallthrough
		 	case .CURDATE:fallthrough
		 	case .CURTIME:fallthrough
		 	case .DATE_ADD:fallthrough
		 	case .DATE_SUB:fallthrough
		 	case .LOCALTIMESTAMP:fallthrough
		 	case .NOW:fallthrough
		 	case .POSITION:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .SUBSTRING:fallthrough
		 	case .SYSDATE:fallthrough
		 	case .TRIM:fallthrough
		 	case .UTC_DATE:fallthrough
		 	case .UTC_TIME:fallthrough
		 	case .UTC_TIMESTAMP:fallthrough
		 	case .ACCOUNT:fallthrough
		 	case .ACTION:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALGORITHM:fallthrough
		 	case .ANY:fallthrough
		 	case .AT:fallthrough
		 	case .AUTHORS:fallthrough
		 	case .AUTOCOMMIT:fallthrough
		 	case .AUTOEXTEND_SIZE:fallthrough
		 	case .AUTO_INCREMENT:fallthrough
		 	case .AVG_ROW_LENGTH:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BINLOG:fallthrough
		 	case .BIT:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BOOL:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BTREE:fallthrough
		 	case .CACHE:fallthrough
		 	case .CASCADED:fallthrough
		 	case .CHAIN:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CHECKSUM:fallthrough
		 	case .PAGE_CHECKSUM:fallthrough
		 	case .CIPHER:fallthrough
		 	case .CLASS_ORIGIN:fallthrough
		 	case .CLIENT:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTERING:fallthrough
		 	case .COALESCE:fallthrough
		 	case .CODE:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COLUMN_FORMAT:fallthrough
		 	case .COLUMN_NAME:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMPACT:fallthrough
		 	case .COMPLETION:fallthrough
		 	case .COMPRESSED:fallthrough
		 	case .COMPRESSION:fallthrough
		 	case .CONCURRENT:fallthrough
		 	case .CONNECT:fallthrough
		 	case .CONNECTION:fallthrough
		 	case .CONSISTENT:fallthrough
		 	case .CONSTRAINT_CATALOG:fallthrough
		 	case .CONSTRAINT_SCHEMA:fallthrough
		 	case .CONSTRAINT_NAME:fallthrough
		 	case .CONTAINS:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTRIBUTORS:fallthrough
		 	case .COPY:fallthrough
		 	case .CPU:fallthrough
		 	case .CURSOR_NAME:fallthrough
		 	case .DATA:fallthrough
		 	case .DATAFILE:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DEFAULT_AUTH:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DELAY_KEY_WRITE:fallthrough
		 	case .DES_KEY_FILE:fallthrough
		 	case .DIRECTORY:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISCARD:fallthrough
		 	case .DISK:fallthrough
		 	case .DO:fallthrough
		 	case .DUMPFILE:fallthrough
		 	case .DUPLICATE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .END:fallthrough
		 	case .ENDS:fallthrough
		 	case .ENGINE:fallthrough
		 	case .ENGINES:fallthrough
		 	case .ERROR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVEN:fallthrough
		 	case .EVENT:fallthrough
		 	case .EVENTS:fallthrough
		 	case .EVERY:fallthrough
		 	case .EXCHANGE:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPIRE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .EXTENT_SIZE:fallthrough
		 	case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 	case .FAST:fallthrough
		 	case .FAULTS:fallthrough
		 	case .FIELDS:fallthrough
		 	case .FILE_BLOCK_SIZE:fallthrough
		 	case .FILTER:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIXED:fallthrough
		 	case .FLUSH:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FOUND:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GENERAL:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GRANTS:fallthrough
		 	case .GROUP_REPLICATION:fallthrough
		 	case .HANDLER:fallthrough
		 	case .HASH:fallthrough
		 	case .HELP:fallthrough
		 	case .HISTORY:fallthrough
		 	case .HOST:fallthrough
		 	case .HOSTS:fallthrough
		 	case .IDENTIFIED:fallthrough
		 	case .IGNORE_SERVER_IDS:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INDEXES:fallthrough
		 	case .INITIAL_SIZE:fallthrough
		 	case .INPLACE:fallthrough
		 	case .INSERT_METHOD:fallthrough
		 	case .INSTALL:fallthrough
		 	case .INSTANCE:fallthrough
		 	case .INSTANT:fallthrough
		 	case .INVISIBLE:fallthrough
		 	case .INVOKER:fallthrough
		 	case .IO:fallthrough
		 	case .IO_THREAD:fallthrough
		 	case .IPC:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ISSUER:fallthrough
		 	case .JSON:fallthrough
		 	case .KEY_BLOCK_SIZE:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LEAVES:fallthrough
		 	case .LESS:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOGFILE:fallthrough
		 	case .LOGS:fallthrough
		 	case .MASTER:fallthrough
		 	case .MASTER_AUTO_POSITION:fallthrough
		 	case .MASTER_CONNECT_RETRY:fallthrough
		 	case .MASTER_DELAY:fallthrough
		 	case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 	case .MASTER_HOST:fallthrough
		 	case .MASTER_LOG_FILE:fallthrough
		 	case .MASTER_LOG_POS:fallthrough
		 	case .MASTER_PASSWORD:fallthrough
		 	case .MASTER_PORT:fallthrough
		 	case .MASTER_RETRY_COUNT:fallthrough
		 	case .MASTER_SSL:fallthrough
		 	case .MASTER_SSL_CA:fallthrough
		 	case .MASTER_SSL_CAPATH:fallthrough
		 	case .MASTER_SSL_CERT:fallthrough
		 	case .MASTER_SSL_CIPHER:fallthrough
		 	case .MASTER_SSL_CRL:fallthrough
		 	case .MASTER_SSL_CRLPATH:fallthrough
		 	case .MASTER_SSL_KEY:fallthrough
		 	case .MASTER_TLS_VERSION:fallthrough
		 	case .MASTER_USER:fallthrough
		 	case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 	case .MAX_QUERIES_PER_HOUR:fallthrough
		 	case .MAX_ROWS:fallthrough
		 	case .MAX_SIZE:fallthrough
		 	case .MAX_UPDATES_PER_HOUR:fallthrough
		 	case .MAX_USER_CONNECTIONS:fallthrough
		 	case .MEDIUM:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MESSAGE_TEXT:fallthrough
		 	case .MID:fallthrough
		 	case .MIGRATE:fallthrough
		 	case .MIN_ROWS:fallthrough
		 	case .MODE:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MUTEX:fallthrough
		 	case .MYSQL:fallthrough
		 	case .MYSQL_ERRNO:fallthrough
		 	case .NAME:fallthrough
		 	case .NAMES:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NEVER:fallthrough
		 	case .NEXT:fallthrough
		 	case .NO:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOWAIT:fallthrough
		 	case .NODEGROUP:fallthrough
		 	case .NONE:fallthrough
		 	case .ODBC:fallthrough
		 	case .OFFLINE:fallthrough
		 	case .OFFSET:fallthrough
		 	case .OF:fallthrough
		 	case .OJ:fallthrough
		 	case .OLD_PASSWORD:fallthrough
		 	case .ONE:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .OPTIMIZER_COSTS:fallthrough
		 	case .OPTIONS:fallthrough
		 	case .OWNER:fallthrough
		 	case .PACK_KEYS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PARSER:fallthrough
		 	case .PARTIAL:fallthrough
		 	case .PARTITIONING:fallthrough
		 	case .PARTITIONS:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PASSWORD_LOCK_TIME:fallthrough
		 	case .PHASE:fallthrough
		 	case .PLUGIN:fallthrough
		 	case .PLUGIN_DIR:fallthrough
		 	case .PLUGINS:fallthrough
		 	case .PORT:fallthrough
		 	case .PRECEDES:fallthrough
		 	case .PREPARE:fallthrough
		 	case .PRESERVE:fallthrough
		 	case .PREV:fallthrough
		 	case .PROCESSLIST:fallthrough
		 	case .PROFILE:fallthrough
		 	case .PROFILES:fallthrough
		 	case .PROXY:fallthrough
		 	case .QUERY:fallthrough
		 	case .QUICK:fallthrough
		 	case .REBUILD:fallthrough
		 	case .RECOVER:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REDO_BUFFER_SIZE:fallthrough
		 	case .REDUNDANT:fallthrough
		 	case .RELAY:fallthrough
		 	case .RELAY_LOG_FILE:fallthrough
		 	case .RELAY_LOG_POS:fallthrough
		 	case .RELAYLOG:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REORGANIZE:fallthrough
		 	case .REPAIR:fallthrough
		 	case .REPLICATE_DO_DB:fallthrough
		 	case .REPLICATE_DO_TABLE:fallthrough
		 	case .REPLICATE_IGNORE_DB:fallthrough
		 	case .REPLICATE_IGNORE_TABLE:fallthrough
		 	case .REPLICATE_REWRITE_DB:fallthrough
		 	case .REPLICATE_WILD_DO_TABLE:fallthrough
		 	case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 	case .REPLICATION:fallthrough
		 	case .RESET:fallthrough
		 	case .RESUME:fallthrough
		 	case .RETURNED_SQLSTATE:fallthrough
		 	case .RETURNING:fallthrough
		 	case .RETURNS:fallthrough
		 	case .REUSE:fallthrough
		 	case .ROLE:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROTATE:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_FORMAT:fallthrough
		 	case .RTREE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEDULE:fallthrough
		 	case .SECURITY:fallthrough
		 	case .SERVER:fallthrough
		 	case .SESSION:fallthrough
		 	case .SHARE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SIGNED:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SLAVE:fallthrough
		 	case .SLOW:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOCKET:fallthrough
		 	case .SOME:fallthrough
		 	case .SONAME:fallthrough
		 	case .SOUNDS:fallthrough
		 	case .SOURCE:fallthrough
		 	case .SQL_AFTER_GTIDS:fallthrough
		 	case .SQL_AFTER_MTS_GAPS:fallthrough
		 	case .SQL_BEFORE_GTIDS:fallthrough
		 	case .SQL_BUFFER_RESULT:fallthrough
		 	case .SQL_CACHE:fallthrough
		 	case .SQL_NO_CACHE:fallthrough
		 	case .SQL_THREAD:fallthrough
		 	case .START:fallthrough
		 	case .STARTS:fallthrough
		 	case .STATS_AUTO_RECALC:fallthrough
		 	case .STATS_PERSISTENT:fallthrough
		 	case .STATS_SAMPLE_PAGES:fallthrough
		 	case .STATUS:fallthrough
		 	case .STOP:fallthrough
		 	case .STORAGE:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBCLASS_ORIGIN:fallthrough
		 	case .SUBJECT:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBPARTITIONS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .SWAPS:fallthrough
		 	case .SWITCHES:fallthrough
		 	case .TABLE_NAME:fallthrough
		 	case .TABLESPACE:fallthrough
		 	case .TABLE_TYPE:fallthrough
		 	case .TEMPORARY:fallthrough
		 	case .TEMPTABLE:fallthrough
		 	case .THAN:fallthrough
		 	case .TRADITIONAL:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSACTIONAL:fallthrough
		 	case .TRIGGERS:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDEFINED:fallthrough
		 	case .UNDOFILE:fallthrough
		 	case .UNDO_BUFFER_SIZE:fallthrough
		 	case .UNINSTALL:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPGRADE:fallthrough
		 	case .USER:fallthrough
		 	case .USE_FRM:fallthrough
		 	case .USER_RESOURCES:fallthrough
		 	case .VALIDATION:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARIABLES:fallthrough
		 	case .VIEW:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .VISIBLE:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNINGS:fallthrough
		 	case .WITHOUT:fallthrough
		 	case .WORK:fallthrough
		 	case .WRAPPER:fallthrough
		 	case .X509:fallthrough
		 	case .XA:fallthrough
		 	case .XML:fallthrough
		 	case .EUR:fallthrough
		 	case .USA:fallthrough
		 	case .JIS:fallthrough
		 	case .ISO:fallthrough
		 	case .INTERNAL:fallthrough
		 	case .QUARTER:fallthrough
		 	case .MONTH:fallthrough
		 	case .DAY:fallthrough
		 	case .HOUR:fallthrough
		 	case .MINUTE:fallthrough
		 	case .WEEK:fallthrough
		 	case .SECOND:fallthrough
		 	case .MICROSECOND:fallthrough
		 	case .ADMIN:fallthrough
		 	case .AUDIT_ABORT_EXEMPT:fallthrough
		 	case .AUDIT_ADMIN:fallthrough
		 	case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 	case .BACKUP_ADMIN:fallthrough
		 	case .BINLOG_ADMIN:fallthrough
		 	case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 	case .CLONE_ADMIN:fallthrough
		 	case .CONNECTION_ADMIN:fallthrough
		 	case .ENCRYPTION_KEY_ADMIN:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .FILE:fallthrough
		 	case .FIREWALL_ADMIN:fallthrough
		 	case .FIREWALL_EXEMPT:fallthrough
		 	case .FIREWALL_USER:fallthrough
		 	case .GROUP_REPLICATION_ADMIN:fallthrough
		 	case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 	case .INVOKE:fallthrough
		 	case .LAMBDA:fallthrough
		 	case .NDB_STORED_USER:fallthrough
		 	case .PASSWORDLESS_USER_ADMIN:fallthrough
		 	case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .PROCESS:fallthrough
		 	case .RELOAD:fallthrough
		 	case .REPLICATION_APPLIER:fallthrough
		 	case .REPLICATION_SLAVE_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_USER:fallthrough
		 	case .ROLE_ADMIN:fallthrough
		 	case .ROUTINE:fallthrough
		 	case .S3:fallthrough
		 	case .SESSION_VARIABLES_ADMIN:fallthrough
		 	case .SET_USER_ID:fallthrough
		 	case .SHOW_ROUTINE:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SUPER:fallthrough
		 	case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 	case .TABLES:fallthrough
		 	case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 	case .VERSION_TOKEN_ADMIN:fallthrough
		 	case .XA_RECOVER_ADMIN:fallthrough
		 	case .ARMSCII8:fallthrough
		 	case .ASCII:fallthrough
		 	case .BIG5:fallthrough
		 	case .CP1250:fallthrough
		 	case .CP1251:fallthrough
		 	case .CP1256:fallthrough
		 	case .CP1257:fallthrough
		 	case .CP850:fallthrough
		 	case .CP852:fallthrough
		 	case .CP866:fallthrough
		 	case .CP932:fallthrough
		 	case .DEC8:fallthrough
		 	case .EUCJPMS:fallthrough
		 	case .EUCKR:fallthrough
		 	case .GB18030:fallthrough
		 	case .GB2312:fallthrough
		 	case .GBK:fallthrough
		 	case .GEOSTD8:fallthrough
		 	case .GREEK:fallthrough
		 	case .HEBREW:fallthrough
		 	case .HP8:fallthrough
		 	case .KEYBCS2:fallthrough
		 	case .KOI8R:fallthrough
		 	case .KOI8U:fallthrough
		 	case .LATIN1:fallthrough
		 	case .LATIN2:fallthrough
		 	case .LATIN5:fallthrough
		 	case .LATIN7:fallthrough
		 	case .MACCE:fallthrough
		 	case .MACROMAN:fallthrough
		 	case .SJIS:fallthrough
		 	case .SWE7:fallthrough
		 	case .TIS620:fallthrough
		 	case .UCS2:fallthrough
		 	case .UJIS:fallthrough
		 	case .UTF16:fallthrough
		 	case .UTF16LE:fallthrough
		 	case .UTF32:fallthrough
		 	case .UTF8:fallthrough
		 	case .UTF8MB3:fallthrough
		 	case .UTF8MB4:fallthrough
		 	case .ARCHIVE:fallthrough
		 	case .BLACKHOLE:fallthrough
		 	case .CSV:fallthrough
		 	case .FEDERATED:fallthrough
		 	case .INNODB:fallthrough
		 	case .MEMORY:fallthrough
		 	case .MRG_MYISAM:fallthrough
		 	case .MYISAM:fallthrough
		 	case .NDB:fallthrough
		 	case .NDBCLUSTER:fallthrough
		 	case .PERFORMANCE_SCHEMA:fallthrough
		 	case .TOKUDB:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .GEOMETRYCOLLECTION:fallthrough
		 	case .LINESTRING:fallthrough
		 	case .MULTILINESTRING:fallthrough
		 	case .MULTIPOINT:fallthrough
		 	case .MULTIPOLYGON:fallthrough
		 	case .POINT:fallthrough
		 	case .POLYGON:fallthrough
		 	case .ABS:fallthrough
		 	case .ACOS:fallthrough
		 	case .ADDDATE:fallthrough
		 	case .ADDTIME:fallthrough
		 	case .AES_DECRYPT:fallthrough
		 	case .AES_ENCRYPT:fallthrough
		 	case .AREA:fallthrough
		 	case .ASBINARY:fallthrough
		 	case .ASIN:fallthrough
		 	case .ASTEXT:fallthrough
		 	case .ASWKB:fallthrough
		 	case .ASWKT:fallthrough
		 	case .ASYMMETRIC_DECRYPT:fallthrough
		 	case .ASYMMETRIC_DERIVE:fallthrough
		 	case .ASYMMETRIC_ENCRYPT:fallthrough
		 	case .ASYMMETRIC_SIGN:fallthrough
		 	case .ASYMMETRIC_VERIFY:fallthrough
		 	case .ATAN:fallthrough
		 	case .ATAN2:fallthrough
		 	case .BENCHMARK:fallthrough
		 	case .BIN:fallthrough
		 	case .BIT_COUNT:fallthrough
		 	case .BIT_LENGTH:fallthrough
		 	case .BUFFER:fallthrough
		 	case .CATALOG_NAME:fallthrough
		 	case .CEIL:fallthrough
		 	case .CEILING:fallthrough
		 	case .CENTROID:fallthrough
		 	case .CHARACTER_LENGTH:fallthrough
		 	case .CHARSET:fallthrough
		 	case .CHAR_LENGTH:fallthrough
		 	case .COERCIBILITY:fallthrough
		 	case .COLLATION:fallthrough
		 	case .COMPRESS:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_WS:fallthrough
		 	case .CONNECTION_ID:fallthrough
		 	case .CONV:fallthrough
		 	case .CONVERT_TZ:fallthrough
		 	case .COS:fallthrough
		 	case .COT:fallthrough
		 	case .CRC32:fallthrough
		 	case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 	case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 	case .CREATE_DH_PARAMETERS:fallthrough
		 	case .CREATE_DIGEST:fallthrough
		 	case .CROSSES:fallthrough
		 	case .DATEDIFF:fallthrough
		 	case .DATE_FORMAT:fallthrough
		 	case .DAYNAME:fallthrough
		 	case .DAYOFMONTH:fallthrough
		 	case .DAYOFWEEK:fallthrough
		 	case .DAYOFYEAR:fallthrough
		 	case .DECODE:fallthrough
		 	case .DEGREES:fallthrough
		 	case .DES_DECRYPT:fallthrough
		 	case .DES_ENCRYPT:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISJOINT:fallthrough
		 	case .ELT:fallthrough
		 	case .ENCODE:fallthrough
		 	case .ENCRYPT:fallthrough
		 	case .ENDPOINT:fallthrough
		 	case .ENGINE_ATTRIBUTE:fallthrough
		 	case .ENVELOPE:fallthrough
		 	case .EQUALS:fallthrough
		 	case .EXP:fallthrough
		 	case .EXPORT_SET:fallthrough
		 	case .EXTERIORRING:fallthrough
		 	case .EXTRACTVALUE:fallthrough
		 	case .FIELD:fallthrough
		 	case .FIND_IN_SET:fallthrough
		 	case .FLOOR:fallthrough
		 	case .FORMAT:fallthrough
		 	case .FOUND_ROWS:fallthrough
		 	case .FROM_BASE64:fallthrough
		 	case .FROM_DAYS:fallthrough
		 	case .FROM_UNIXTIME:fallthrough
		 	case .GEOMCOLLFROMTEXT:fallthrough
		 	case .GEOMCOLLFROMWKB:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .GEOMETRYFROMTEXT:fallthrough
		 	case .GEOMETRYFROMWKB:fallthrough
		 	case .GEOMETRYN:fallthrough
		 	case .GEOMETRYTYPE:fallthrough
		 	case .GEOMFROMTEXT:fallthrough
		 	case .GEOMFROMWKB:fallthrough
		 	case .GET_FORMAT:fallthrough
		 	case .GET_LOCK:fallthrough
		 	case .GLENGTH:fallthrough
		 	case .GREATEST:fallthrough
		 	case .GTID_SUBSET:fallthrough
		 	case .GTID_SUBTRACT:fallthrough
		 	case .HEX:fallthrough
		 	case .IFNULL:fallthrough
		 	case .INET6_ATON:fallthrough
		 	case .INET6_NTOA:fallthrough
		 	case .INET_ATON:fallthrough
		 	case .INET_NTOA:fallthrough
		 	case .INSTR:fallthrough
		 	case .INTERIORRINGN:fallthrough
		 	case .INTERSECTS:fallthrough
		 	case .ISCLOSED:fallthrough
		 	case .ISEMPTY:fallthrough
		 	case .ISNULL:fallthrough
		 	case .ISSIMPLE:fallthrough
		 	case .IS_FREE_LOCK:fallthrough
		 	case .IS_IPV4:fallthrough
		 	case .IS_IPV4_COMPAT:fallthrough
		 	case .IS_IPV4_MAPPED:fallthrough
		 	case .IS_IPV6:fallthrough
		 	case .IS_USED_LOCK:fallthrough
		 	case .LAST_INSERT_ID:fallthrough
		 	case .LCASE:fallthrough
		 	case .LEAST:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LINEFROMTEXT:fallthrough
		 	case .LINEFROMWKB:fallthrough
		 	case .LINESTRINGFROMTEXT:fallthrough
		 	case .LINESTRINGFROMWKB:fallthrough
		 	case .LN:fallthrough
		 	case .LOAD_FILE:fallthrough
		 	case .LOCATE:fallthrough
		 	case .LOG:fallthrough
		 	case .LOG10:fallthrough
		 	case .LOG2:fallthrough
		 	case .LOWER:fallthrough
		 	case .LPAD:fallthrough
		 	case .LTRIM:fallthrough
		 	case .MAKEDATE:fallthrough
		 	case .MAKETIME:fallthrough
		 	case .MAKE_SET:fallthrough
		 	case .MASTER_POS_WAIT:fallthrough
		 	case .MBRCONTAINS:fallthrough
		 	case .MBRDISJOINT:fallthrough
		 	case .MBREQUAL:fallthrough
		 	case .MBRINTERSECTS:fallthrough
		 	case .MBROVERLAPS:fallthrough
		 	case .MBRTOUCHES:fallthrough
		 	case .MBRWITHIN:fallthrough
		 	case .MD5:fallthrough
		 	case .MLINEFROMTEXT:fallthrough
		 	case .MLINEFROMWKB:fallthrough
		 	case .MONTHNAME:fallthrough
		 	case .MPOINTFROMTEXT:fallthrough
		 	case .MPOINTFROMWKB:fallthrough
		 	case .MPOLYFROMTEXT:fallthrough
		 	case .MPOLYFROMWKB:fallthrough
		 	case .MULTILINESTRINGFROMTEXT:fallthrough
		 	case .MULTILINESTRINGFROMWKB:fallthrough
		 	case .MULTIPOINTFROMTEXT:fallthrough
		 	case .MULTIPOINTFROMWKB:fallthrough
		 	case .MULTIPOLYGONFROMTEXT:fallthrough
		 	case .MULTIPOLYGONFROMWKB:fallthrough
		 	case .NAME_CONST:fallthrough
		 	case .NULLIF:fallthrough
		 	case .NUMGEOMETRIES:fallthrough
		 	case .NUMINTERIORRINGS:fallthrough
		 	case .NUMPOINTS:fallthrough
		 	case .OCT:fallthrough
		 	case .OCTET_LENGTH:fallthrough
		 	case .ORD:fallthrough
		 	case .OVERLAPS:fallthrough
		 	case .PERIOD_ADD:fallthrough
		 	case .PERIOD_DIFF:fallthrough
		 	case .PI:fallthrough
		 	case .POINTFROMTEXT:fallthrough
		 	case .POINTFROMWKB:fallthrough
		 	case .POINTN:fallthrough
		 	case .POLYFROMTEXT:fallthrough
		 	case .POLYFROMWKB:fallthrough
		 	case .POLYGONFROMTEXT:fallthrough
		 	case .POLYGONFROMWKB:fallthrough
		 	case .POW:fallthrough
		 	case .POWER:fallthrough
		 	case .QUOTE:fallthrough
		 	case .RADIANS:fallthrough
		 	case .RAND:fallthrough
		 	case .RANDOM:fallthrough
		 	case .RANDOM_BYTES:fallthrough
		 	case .RELEASE_LOCK:fallthrough
		 	case .REVERSE:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_COUNT:fallthrough
		 	case .RPAD:fallthrough
		 	case .RTRIM:fallthrough
		 	case .SEC_TO_TIME:fallthrough
		 	case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 	case .SESSION_USER:fallthrough
		 	case .SHA:fallthrough
		 	case .SHA1:fallthrough
		 	case .SHA2:fallthrough
		 	case .SCHEMA_NAME:fallthrough
		 	case .SIGN:fallthrough
		 	case .SIN:fallthrough
		 	case .SLEEP:fallthrough
		 	case .SOUNDEX:fallthrough
		 	case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 	case .SQRT:fallthrough
		 	case .SRID:fallthrough
		 	case .STARTPOINT:fallthrough
		 	case .STRCMP:fallthrough
		 	case .STR_TO_DATE:fallthrough
		 	case .ST_AREA:fallthrough
		 	case .ST_ASBINARY:fallthrough
		 	case .ST_ASTEXT:fallthrough
		 	case .ST_ASWKB:fallthrough
		 	case .ST_ASWKT:fallthrough
		 	case .ST_BUFFER:fallthrough
		 	case .ST_CENTROID:fallthrough
		 	case .ST_CONTAINS:fallthrough
		 	case .ST_CROSSES:fallthrough
		 	case .ST_DIFFERENCE:fallthrough
		 	case .ST_DIMENSION:fallthrough
		 	case .ST_DISJOINT:fallthrough
		 	case .ST_DISTANCE:fallthrough
		 	case .ST_ENDPOINT:fallthrough
		 	case .ST_ENVELOPE:fallthrough
		 	case .ST_EQUALS:fallthrough
		 	case .ST_EXTERIORRING:fallthrough
		 	case .ST_GEOMCOLLFROMTEXT:fallthrough
		 	case .ST_GEOMCOLLFROMTXT:fallthrough
		 	case .ST_GEOMCOLLFROMWKB:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .ST_GEOMETRYFROMTEXT:fallthrough
		 	case .ST_GEOMETRYFROMWKB:fallthrough
		 	case .ST_GEOMETRYN:fallthrough
		 	case .ST_GEOMETRYTYPE:fallthrough
		 	case .ST_GEOMFROMTEXT:fallthrough
		 	case .ST_GEOMFROMWKB:fallthrough
		 	case .ST_INTERIORRINGN:fallthrough
		 	case .ST_INTERSECTION:fallthrough
		 	case .ST_INTERSECTS:fallthrough
		 	case .ST_ISCLOSED:fallthrough
		 	case .ST_ISEMPTY:fallthrough
		 	case .ST_ISSIMPLE:fallthrough
		 	case .ST_LINEFROMTEXT:fallthrough
		 	case .ST_LINEFROMWKB:fallthrough
		 	case .ST_LINESTRINGFROMTEXT:fallthrough
		 	case .ST_LINESTRINGFROMWKB:fallthrough
		 	case .ST_NUMGEOMETRIES:fallthrough
		 	case .ST_NUMINTERIORRING:fallthrough
		 	case .ST_NUMINTERIORRINGS:fallthrough
		 	case .ST_NUMPOINTS:fallthrough
		 	case .ST_OVERLAPS:fallthrough
		 	case .ST_POINTFROMTEXT:fallthrough
		 	case .ST_POINTFROMWKB:fallthrough
		 	case .ST_POINTN:fallthrough
		 	case .ST_POLYFROMTEXT:fallthrough
		 	case .ST_POLYFROMWKB:fallthrough
		 	case .ST_POLYGONFROMTEXT:fallthrough
		 	case .ST_POLYGONFROMWKB:fallthrough
		 	case .ST_SRID:fallthrough
		 	case .ST_STARTPOINT:fallthrough
		 	case .ST_SYMDIFFERENCE:fallthrough
		 	case .ST_TOUCHES:fallthrough
		 	case .ST_UNION:fallthrough
		 	case .ST_WITHIN:fallthrough
		 	case .ST_X:fallthrough
		 	case .ST_Y:fallthrough
		 	case .SUBDATE:fallthrough
		 	case .SUBSTRING_INDEX:fallthrough
		 	case .SUBTIME:fallthrough
		 	case .SYSTEM_USER:fallthrough
		 	case .TAN:fallthrough
		 	case .TIMEDIFF:fallthrough
		 	case .TIMESTAMPADD:fallthrough
		 	case .TIMESTAMPDIFF:fallthrough
		 	case .TIME_FORMAT:fallthrough
		 	case .TIME_TO_SEC:fallthrough
		 	case .TOUCHES:fallthrough
		 	case .TO_BASE64:fallthrough
		 	case .TO_DAYS:fallthrough
		 	case .TO_SECONDS:fallthrough
		 	case .TP_CONNECTION_ADMIN:fallthrough
		 	case .UCASE:fallthrough
		 	case .UNCOMPRESS:fallthrough
		 	case .UNCOMPRESSED_LENGTH:fallthrough
		 	case .UNHEX:fallthrough
		 	case .UNIX_TIMESTAMP:fallthrough
		 	case .UPDATEXML:fallthrough
		 	case .UPPER:fallthrough
		 	case .UUID:fallthrough
		 	case .UUID_SHORT:fallthrough
		 	case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 	case .VERSION:fallthrough
		 	case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 	case .WEEKDAY:fallthrough
		 	case .WEEKOFYEAR:fallthrough
		 	case .WEIGHT_STRING:fallthrough
		 	case .WITHIN:fallthrough
		 	case .YEARWEEK:fallthrough
		 	case .Y_FUNCTION:fallthrough
		 	case .X_FUNCTION:fallthrough
		 	case .MOD:fallthrough
		 	case .ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6379)
		 		try simpleId()

		 		break

		 	case .CHARSET_REVERSE_QOUTE_STRING:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6380)
		 		try match(MySqlParser.Tokens.CHARSET_REVERSE_QOUTE_STRING.rawValue)

		 		break

		 	case .STRING_LITERAL:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6381)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SimpleIdContext: ParserRuleContext {
			open
			func ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ID.rawValue, 0)
			}
			open
			func charsetNameBase() -> CharsetNameBaseContext? {
				return getRuleContext(CharsetNameBaseContext.self, 0)
			}
			open
			func transactionLevelBase() -> TransactionLevelBaseContext? {
				return getRuleContext(TransactionLevelBaseContext.self, 0)
			}
			open
			func engineNameBase() -> EngineNameBaseContext? {
				return getRuleContext(EngineNameBaseContext.self, 0)
			}
			open
			func privilegesBase() -> PrivilegesBaseContext? {
				return getRuleContext(PrivilegesBaseContext.self, 0)
			}
			open
			func intervalTypeBase() -> IntervalTypeBaseContext? {
				return getRuleContext(IntervalTypeBaseContext.self, 0)
			}
			open
			func dataTypeBase() -> DataTypeBaseContext? {
				return getRuleContext(DataTypeBaseContext.self, 0)
			}
			open
			func keywordsCanBeId() -> KeywordsCanBeIdContext? {
				return getRuleContext(KeywordsCanBeIdContext.self, 0)
			}
			open
			func scalarFunctionName() -> ScalarFunctionNameContext? {
				return getRuleContext(ScalarFunctionNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_simpleId
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSimpleId(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSimpleId(self)
			}
		}
	}
	@discardableResult
	 open func simpleId() throws -> SimpleIdContext {
		var _localctx: SimpleIdContext
		_localctx = SimpleIdContext(_ctx, getState())
		try enterRule(_localctx, 586, MySqlParser.RULE_simpleId)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6393)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,938, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6384)
		 		try match(MySqlParser.Tokens.ID.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6385)
		 		try charsetNameBase()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6386)
		 		try transactionLevelBase()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6387)
		 		try engineNameBase()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6388)
		 		try privilegesBase()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6389)
		 		try intervalTypeBase()

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(6390)
		 		try dataTypeBase()

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(6391)
		 		try keywordsCanBeId()

		 		break
		 	case 9:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(6392)
		 		try scalarFunctionName()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DottedIdContext: ParserRuleContext {
			open
			func DOT_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DOT_ID.rawValue, 0)
			}
			open
			func DOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DOT.rawValue, 0)
			}
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dottedId
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDottedId(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDottedId(self)
			}
		}
	}
	@discardableResult
	 open func dottedId() throws -> DottedIdContext {
		var _localctx: DottedIdContext
		_localctx = DottedIdContext(_ctx, getState())
		try enterRule(_localctx, 588, MySqlParser.RULE_dottedId)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6398)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DOT_ID:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6395)
		 		try match(MySqlParser.Tokens.DOT_ID.rawValue)

		 		break

		 	case .DOT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6396)
		 		try match(MySqlParser.Tokens.DOT.rawValue)
		 		setState(6397)
		 		try uid()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DecimalLiteralContext: ParserRuleContext {
			open
			func DECIMAL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DECIMAL_LITERAL.rawValue, 0)
			}
			open
			func ZERO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZERO_DECIMAL.rawValue, 0)
			}
			open
			func ONE_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE_DECIMAL.rawValue, 0)
			}
			open
			func TWO_DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TWO_DECIMAL.rawValue, 0)
			}
			open
			func REAL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REAL_LITERAL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_decimalLiteral
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDecimalLiteral(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDecimalLiteral(self)
			}
		}
	}
	@discardableResult
	 open func decimalLiteral() throws -> DecimalLiteralContext {
		var _localctx: DecimalLiteralContext
		_localctx = DecimalLiteralContext(_ctx, getState())
		try enterRule(_localctx, 590, MySqlParser.RULE_decimalLiteral)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6400)
		 	_la = try _input.LA(1)
		 	if (!(((Int64((_la - 1138)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1138)) & 10247) != 0))) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FileSizeLiteralContext: ParserRuleContext {
			open
			func FILESIZE_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FILESIZE_LITERAL.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_fileSizeLiteral
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFileSizeLiteral(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFileSizeLiteral(self)
			}
		}
	}
	@discardableResult
	 open func fileSizeLiteral() throws -> FileSizeLiteralContext {
		var _localctx: FileSizeLiteralContext
		_localctx = FileSizeLiteralContext(_ctx, getState())
		try enterRule(_localctx, 592, MySqlParser.RULE_fileSizeLiteral)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6404)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FILESIZE_LITERAL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6402)
		 		try match(MySqlParser.Tokens.FILESIZE_LITERAL.rawValue)

		 		break
		 	case .ZERO_DECIMAL:fallthrough
		 	case .ONE_DECIMAL:fallthrough
		 	case .TWO_DECIMAL:fallthrough
		 	case .DECIMAL_LITERAL:fallthrough
		 	case .REAL_LITERAL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6403)
		 		try decimalLiteral()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class StringLiteralContext: ParserRuleContext {
			open
			func STRING_LITERAL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.STRING_LITERAL.rawValue)
			}
			open
			func STRING_LITERAL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, i)
			}
			open
			func START_NATIONAL_STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.START_NATIONAL_STRING_LITERAL.rawValue, 0)
			}
			open
			func STRING_CHARSET_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_CHARSET_NAME.rawValue, 0)
			}
			open
			func COLLATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATE.rawValue, 0)
			}
			open
			func collationName() -> CollationNameContext? {
				return getRuleContext(CollationNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_stringLiteral
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterStringLiteral(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitStringLiteral(self)
			}
		}
	}
	@discardableResult
	 open func stringLiteral() throws -> StringLiteralContext {
		var _localctx: StringLiteralContext
		_localctx = StringLiteralContext(_ctx, getState())
		try enterRule(_localctx, 594, MySqlParser.RULE_stringLiteral)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(6429)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,947, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6411)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .STRING_LITERAL:fallthrough
		 		case .STRING_CHARSET_NAME:
		 			setState(6407)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.STRING_CHARSET_NAME.rawValue) {
		 				setState(6406)
		 				try match(MySqlParser.Tokens.STRING_CHARSET_NAME.rawValue)

		 			}

		 			setState(6409)
		 			try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 			break

		 		case .START_NATIONAL_STRING_LITERAL:
		 			setState(6410)
		 			try match(MySqlParser.Tokens.START_NATIONAL_STRING_LITERAL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(6414); 
		 		try _errHandler.sync(self)
		 		_alt = 1;
		 		repeat {
		 			switch (_alt) {
		 			case 1:
		 				setState(6413)
		 				try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)


		 				break
		 			default:
		 				throw ANTLRException.recognition(e: NoViableAltException(self))
		 			}
		 			setState(6416); 
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,943,_ctx)
		 		} while (_alt != 2 && _alt !=  ATN.INVALID_ALT_NUMBER)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6423)
		 		try _errHandler.sync(self)
		 		switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 		case .STRING_LITERAL:fallthrough
		 		case .STRING_CHARSET_NAME:
		 			setState(6419)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (_la == MySqlParser.Tokens.STRING_CHARSET_NAME.rawValue) {
		 				setState(6418)
		 				try match(MySqlParser.Tokens.STRING_CHARSET_NAME.rawValue)

		 			}

		 			setState(6421)
		 			try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

		 			break

		 		case .START_NATIONAL_STRING_LITERAL:
		 			setState(6422)
		 			try match(MySqlParser.Tokens.START_NATIONAL_STRING_LITERAL.rawValue)

		 			break
		 		default:
		 			throw ANTLRException.recognition(e: NoViableAltException(self))
		 		}
		 		setState(6427)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,946,_ctx)) {
		 		case 1:
		 			setState(6425)
		 			try match(MySqlParser.Tokens.COLLATE.rawValue)
		 			setState(6426)
		 			try collationName()

		 			break
		 		default: break
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BooleanLiteralContext: ParserRuleContext {
			open
			func TRUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRUE.rawValue, 0)
			}
			open
			func FALSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FALSE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_booleanLiteral
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterBooleanLiteral(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitBooleanLiteral(self)
			}
		}
	}
	@discardableResult
	 open func booleanLiteral() throws -> BooleanLiteralContext {
		var _localctx: BooleanLiteralContext
		_localctx = BooleanLiteralContext(_ctx, getState())
		try enterRule(_localctx, 596, MySqlParser.RULE_booleanLiteral)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6431)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.FALSE.rawValue || _la == MySqlParser.Tokens.TRUE.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class HexadecimalLiteralContext: ParserRuleContext {
			open
			func HEXADECIMAL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HEXADECIMAL_LITERAL.rawValue, 0)
			}
			open
			func STRING_CHARSET_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_CHARSET_NAME.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_hexadecimalLiteral
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterHexadecimalLiteral(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitHexadecimalLiteral(self)
			}
		}
	}
	@discardableResult
	 open func hexadecimalLiteral() throws -> HexadecimalLiteralContext {
		var _localctx: HexadecimalLiteralContext
		_localctx = HexadecimalLiteralContext(_ctx, getState())
		try enterRule(_localctx, 598, MySqlParser.RULE_hexadecimalLiteral)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6434)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.STRING_CHARSET_NAME.rawValue) {
		 		setState(6433)
		 		try match(MySqlParser.Tokens.STRING_CHARSET_NAME.rawValue)

		 	}

		 	setState(6436)
		 	try match(MySqlParser.Tokens.HEXADECIMAL_LITERAL.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NullNotnullContext: ParserRuleContext {
			open
			func NULL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NULL_LITERAL.rawValue, 0)
			}
			open
			func NULL_SPEC_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NULL_SPEC_LITERAL.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_nullNotnull
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterNullNotnull(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitNullNotnull(self)
			}
		}
	}
	@discardableResult
	 open func nullNotnull() throws -> NullNotnullContext {
		var _localctx: NullNotnullContext
		_localctx = NullNotnullContext(_ctx, getState())
		try enterRule(_localctx, 600, MySqlParser.RULE_nullNotnull)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6439)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.NOT.rawValue) {
		 		setState(6438)
		 		try match(MySqlParser.Tokens.NOT.rawValue)

		 	}

		 	setState(6441)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.NULL_LITERAL.rawValue || _la == MySqlParser.Tokens.NULL_SPEC_LITERAL.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConstantContext: ParserRuleContext {
		open var nullLiteral: Token!
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func MINUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUS.rawValue, 0)
			}
			open
			func hexadecimalLiteral() -> HexadecimalLiteralContext? {
				return getRuleContext(HexadecimalLiteralContext.self, 0)
			}
			open
			func booleanLiteral() -> BooleanLiteralContext? {
				return getRuleContext(BooleanLiteralContext.self, 0)
			}
			open
			func REAL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REAL_LITERAL.rawValue, 0)
			}
			open
			func BIT_STRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_STRING.rawValue, 0)
			}
			open
			func NULL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NULL_LITERAL.rawValue, 0)
			}
			open
			func NULL_SPEC_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NULL_SPEC_LITERAL.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_constant
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterConstant(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitConstant(self)
			}
		}
	}
	@discardableResult
	 open func constant() throws -> ConstantContext {
		var _localctx: ConstantContext
		_localctx = ConstantContext(_ctx, getState())
		try enterRule(_localctx, 602, MySqlParser.RULE_constant)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6455)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,951, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6443)
		 		try stringLiteral()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6444)
		 		try decimalLiteral()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6445)
		 		try match(MySqlParser.Tokens.MINUS.rawValue)
		 		setState(6446)
		 		try decimalLiteral()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6447)
		 		try hexadecimalLiteral()

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6448)
		 		try booleanLiteral()

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6449)
		 		try match(MySqlParser.Tokens.REAL_LITERAL.rawValue)

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(6450)
		 		try match(MySqlParser.Tokens.BIT_STRING.rawValue)

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(6452)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.NOT.rawValue) {
		 			setState(6451)
		 			try match(MySqlParser.Tokens.NOT.rawValue)

		 		}

		 		setState(6454)
		 		_localctx.castdown(ConstantContext.self).nullLiteral = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.NULL_LITERAL.rawValue || _la == MySqlParser.Tokens.NULL_SPEC_LITERAL.rawValue)) {
		 			_localctx.castdown(ConstantContext.self).nullLiteral = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataTypeContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dataType
		}
	}
	public class SpatialDataTypeContext: DataTypeContext {
		public var typeName: Token!
			open
			func GEOMETRYCOLLECTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMETRYCOLLECTION.rawValue, 0)
			}
			open
			func GEOMCOLLECTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMCOLLECTION.rawValue, 0)
			}
			open
			func LINESTRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINESTRING.rawValue, 0)
			}
			open
			func MULTILINESTRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTILINESTRING.rawValue, 0)
			}
			open
			func MULTIPOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTIPOINT.rawValue, 0)
			}
			open
			func MULTIPOLYGON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTIPOLYGON.rawValue, 0)
			}
			open
			func POINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POINT.rawValue, 0)
			}
			open
			func POLYGON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POLYGON.rawValue, 0)
			}
			open
			func JSON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON.rawValue, 0)
			}
			open
			func GEOMETRY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMETRY.rawValue, 0)
			}
			open
			func SRID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SRID.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}

		public
		init(_ ctx: DataTypeContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSpatialDataType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSpatialDataType(self)
			}
		}
	}
	public class LongVarbinaryDataTypeContext: DataTypeContext {
			open
			func LONG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LONG.rawValue, 0)
			}
			open
			func VARBINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VARBINARY.rawValue, 0)
			}

		public
		init(_ ctx: DataTypeContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLongVarbinaryDataType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLongVarbinaryDataType(self)
			}
		}
	}
	public class CollectionDataTypeContext: DataTypeContext {
		public var typeName: Token!
			open
			func collectionOptions() -> CollectionOptionsContext? {
				return getRuleContext(CollectionOptionsContext.self, 0)
			}
			open
			func ENUM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENUM.rawValue, 0)
			}
			open
			func SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET.rawValue, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}
			open
			func charSet() -> CharSetContext? {
				return getRuleContext(CharSetContext.self, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}

		public
		init(_ ctx: DataTypeContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCollectionDataType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCollectionDataType(self)
			}
		}
	}
	public class NationalVaryingStringDataTypeContext: DataTypeContext {
		public var typeName: Token!
			open
			func NATIONAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NATIONAL.rawValue, 0)
			}
			open
			func VARYING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VARYING.rawValue, 0)
			}
			open
			func CHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHAR.rawValue, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func lengthOneDimension() -> LengthOneDimensionContext? {
				return getRuleContext(LengthOneDimensionContext.self, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}

		public
		init(_ ctx: DataTypeContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterNationalVaryingStringDataType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitNationalVaryingStringDataType(self)
			}
		}
	}
	public class DimensionDataTypeContext: DataTypeContext {
		public var typeName: Token!
			open
			func TINYINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TINYINT.rawValue, 0)
			}
			open
			func SMALLINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SMALLINT.rawValue, 0)
			}
			open
			func MEDIUMINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEDIUMINT.rawValue, 0)
			}
			open
			func INT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INT.rawValue, 0)
			}
			open
			func INTEGER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTEGER.rawValue, 0)
			}
			open
			func BIGINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIGINT.rawValue, 0)
			}
			open
			func MIDDLEINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MIDDLEINT.rawValue, 0)
			}
			open
			func INT1() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INT1.rawValue, 0)
			}
			open
			func INT2() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INT2.rawValue, 0)
			}
			open
			func INT3() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INT3.rawValue, 0)
			}
			open
			func INT4() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INT4.rawValue, 0)
			}
			open
			func INT8() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INT8.rawValue, 0)
			}
			open
			func lengthOneDimension() -> LengthOneDimensionContext? {
				return getRuleContext(LengthOneDimensionContext.self, 0)
			}
			open
			func SIGNED() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.SIGNED.rawValue)
			}
			open
			func SIGNED(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SIGNED.rawValue, i)
			}
			open
			func UNSIGNED() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.UNSIGNED.rawValue)
			}
			open
			func UNSIGNED(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNSIGNED.rawValue, i)
			}
			open
			func ZEROFILL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.ZEROFILL.rawValue)
			}
			open
			func ZEROFILL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ZEROFILL.rawValue, i)
			}
			open
			func REAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REAL.rawValue, 0)
			}
			open
			func lengthTwoDimension() -> LengthTwoDimensionContext? {
				return getRuleContext(LengthTwoDimensionContext.self, 0)
			}
			open
			func DOUBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DOUBLE.rawValue, 0)
			}
			open
			func PRECISION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRECISION.rawValue, 0)
			}
			open
			func DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DECIMAL.rawValue, 0)
			}
			open
			func DEC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEC.rawValue, 0)
			}
			open
			func FIXED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIXED.rawValue, 0)
			}
			open
			func NUMERIC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NUMERIC.rawValue, 0)
			}
			open
			func FLOAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FLOAT.rawValue, 0)
			}
			open
			func FLOAT4() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FLOAT4.rawValue, 0)
			}
			open
			func FLOAT8() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FLOAT8.rawValue, 0)
			}
			open
			func lengthTwoOptionalDimension() -> LengthTwoOptionalDimensionContext? {
				return getRuleContext(LengthTwoOptionalDimensionContext.self, 0)
			}
			open
			func BIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT.rawValue, 0)
			}
			open
			func TIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIME.rawValue, 0)
			}
			open
			func TIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIMESTAMP.rawValue, 0)
			}
			open
			func DATETIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATETIME.rawValue, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}
			open
			func VARBINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VARBINARY.rawValue, 0)
			}
			open
			func BLOB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BLOB.rawValue, 0)
			}
			open
			func YEAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.YEAR.rawValue, 0)
			}

		public
		init(_ ctx: DataTypeContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDimensionDataType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDimensionDataType(self)
			}
		}
	}
	public class StringDataTypeContext: DataTypeContext {
		public var typeName: Token!
			open
			func CHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHAR.rawValue, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func VARCHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VARCHAR.rawValue, 0)
			}
			open
			func TINYTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TINYTEXT.rawValue, 0)
			}
			open
			func TEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TEXT.rawValue, 0)
			}
			open
			func MEDIUMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEDIUMTEXT.rawValue, 0)
			}
			open
			func LONGTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LONGTEXT.rawValue, 0)
			}
			open
			func NCHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NCHAR.rawValue, 0)
			}
			open
			func NVARCHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NVARCHAR.rawValue, 0)
			}
			open
			func LONG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LONG.rawValue, 0)
			}
			open
			func VARYING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VARYING.rawValue, 0)
			}
			open
			func lengthOneDimension() -> LengthOneDimensionContext? {
				return getRuleContext(LengthOneDimensionContext.self, 0)
			}
			open
			func BINARY() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.BINARY.rawValue)
			}
			open
			func BINARY(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, i)
			}
			open
			func charSet() -> CharSetContext? {
				return getRuleContext(CharSetContext.self, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func COLLATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATE.rawValue, 0)
			}
			open
			func collationName() -> CollationNameContext? {
				return getRuleContext(CollationNameContext.self, 0)
			}

		public
		init(_ ctx: DataTypeContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterStringDataType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitStringDataType(self)
			}
		}
	}
	public class LongVarcharDataTypeContext: DataTypeContext {
		public var typeName: Token!
			open
			func LONG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LONG.rawValue, 0)
			}
			open
			func VARCHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VARCHAR.rawValue, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}
			open
			func charSet() -> CharSetContext? {
				return getRuleContext(CharSetContext.self, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func COLLATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATE.rawValue, 0)
			}
			open
			func collationName() -> CollationNameContext? {
				return getRuleContext(CollationNameContext.self, 0)
			}

		public
		init(_ ctx: DataTypeContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLongVarcharDataType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLongVarcharDataType(self)
			}
		}
	}
	public class NationalStringDataTypeContext: DataTypeContext {
		public var typeName: Token!
			open
			func NATIONAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NATIONAL.rawValue, 0)
			}
			open
			func VARCHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VARCHAR.rawValue, 0)
			}
			open
			func CHARACTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARACTER.rawValue, 0)
			}
			open
			func CHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHAR.rawValue, 0)
			}
			open
			func lengthOneDimension() -> LengthOneDimensionContext? {
				return getRuleContext(LengthOneDimensionContext.self, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}
			open
			func NCHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NCHAR.rawValue, 0)
			}

		public
		init(_ ctx: DataTypeContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterNationalStringDataType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitNationalStringDataType(self)
			}
		}
	}
	public class SimpleDataTypeContext: DataTypeContext {
		public var typeName: Token!
			open
			func DATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATE.rawValue, 0)
			}
			open
			func TINYBLOB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TINYBLOB.rawValue, 0)
			}
			open
			func MEDIUMBLOB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEDIUMBLOB.rawValue, 0)
			}
			open
			func LONGBLOB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LONGBLOB.rawValue, 0)
			}
			open
			func BOOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BOOL.rawValue, 0)
			}
			open
			func BOOLEAN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BOOLEAN.rawValue, 0)
			}
			open
			func SERIAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SERIAL.rawValue, 0)
			}

		public
		init(_ ctx: DataTypeContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSimpleDataType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSimpleDataType(self)
			}
		}
	}
	@discardableResult
	 open func dataType() throws -> DataTypeContext {
		var _localctx: DataTypeContext
		_localctx = DataTypeContext(_ctx, getState())
		try enterRule(_localctx, 604, MySqlParser.RULE_dataType)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	setState(6583)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,980, _ctx)) {
		 	case 1:
		 		_localctx =  StringDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6457)
		 		_localctx.castdown(StringDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.CHARACTER.rawValue || ((Int64((_la - 222)) & ~0x3f) == 0 && ((Int64(1) << (_la - 222)) & 31239) != 0) || _la == MySqlParser.Tokens.NCHAR.rawValue)) {
		 			_localctx.castdown(StringDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6459)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.VARYING.rawValue) {
		 			setState(6458)
		 			try match(MySqlParser.Tokens.VARYING.rawValue)

		 		}

		 		setState(6462)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,953,_ctx)) {
		 		case 1:
		 			setState(6461)
		 			try lengthOneDimension()

		 			break
		 		default: break
		 		}
		 		setState(6465)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,954,_ctx)) {
		 		case 1:
		 			setState(6464)
		 			try match(MySqlParser.Tokens.BINARY.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(6470)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,955,_ctx)) {
		 		case 1:
		 			setState(6467)
		 			try charSet()
		 			setState(6468)
		 			try charsetName()

		 			break
		 		default: break
		 		}
		 		setState(6475)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,956,_ctx)) {
		 		case 1:
		 			setState(6472)
		 			try match(MySqlParser.Tokens.COLLATE.rawValue)
		 			setState(6473)
		 			try collationName()

		 			break
		 		case 2:
		 			setState(6474)
		 			try match(MySqlParser.Tokens.BINARY.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		_localctx =  NationalVaryingStringDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6477)
		 		try match(MySqlParser.Tokens.NATIONAL.rawValue)
		 		setState(6478)
		 		_localctx.castdown(NationalVaryingStringDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.CHARACTER.rawValue || _la == MySqlParser.Tokens.CHAR.rawValue)) {
		 			_localctx.castdown(NationalVaryingStringDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6479)
		 		try match(MySqlParser.Tokens.VARYING.rawValue)
		 		setState(6481)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,957,_ctx)) {
		 		case 1:
		 			setState(6480)
		 			try lengthOneDimension()

		 			break
		 		default: break
		 		}
		 		setState(6484)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,958,_ctx)) {
		 		case 1:
		 			setState(6483)
		 			try match(MySqlParser.Tokens.BINARY.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 3:
		 		_localctx =  NationalStringDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6486)
		 		try match(MySqlParser.Tokens.NATIONAL.rawValue)
		 		setState(6487)
		 		_localctx.castdown(NationalStringDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.CHARACTER.rawValue || _la == MySqlParser.Tokens.CHAR.rawValue || _la == MySqlParser.Tokens.VARCHAR.rawValue)) {
		 			_localctx.castdown(NationalStringDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6489)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,959,_ctx)) {
		 		case 1:
		 			setState(6488)
		 			try lengthOneDimension()

		 			break
		 		default: break
		 		}
		 		setState(6492)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,960,_ctx)) {
		 		case 1:
		 			setState(6491)
		 			try match(MySqlParser.Tokens.BINARY.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 4:
		 		_localctx =  NationalStringDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6494)
		 		try match(MySqlParser.Tokens.NCHAR.rawValue)
		 		setState(6495)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.VARCHAR.rawValue)
		 				_localctx.castdown(NationalStringDataTypeContext.self).typeName = assignmentValue
		 		     }()

		 		setState(6497)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,961,_ctx)) {
		 		case 1:
		 			setState(6496)
		 			try lengthOneDimension()

		 			break
		 		default: break
		 		}
		 		setState(6500)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,962,_ctx)) {
		 		case 1:
		 			setState(6499)
		 			try match(MySqlParser.Tokens.BINARY.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 5:
		 		_localctx =  DimensionDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6502)
		 		_localctx.castdown(DimensionDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 196)) & ~0x3f) == 0 && ((Int64(1) << (_la - 196)) & 4095) != 0))) {
		 			_localctx.castdown(DimensionDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6504)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,963,_ctx)) {
		 		case 1:
		 			setState(6503)
		 			try lengthOneDimension()

		 			break
		 		default: break
		 		}
		 		setState(6509)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,964,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(6506)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.UNSIGNED.rawValue || _la == MySqlParser.Tokens.ZEROFILL.rawValue || _la == MySqlParser.Tokens.SIGNED.rawValue)) {
		 				try _errHandler.recoverInline(self)
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 		 
		 			}
		 			setState(6511)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,964,_ctx)
		 		}

		 		break
		 	case 6:
		 		_localctx =  DimensionDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6512)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.REAL.rawValue)
		 				_localctx.castdown(DimensionDataTypeContext.self).typeName = assignmentValue
		 		     }()

		 		setState(6514)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,965,_ctx)) {
		 		case 1:
		 			setState(6513)
		 			try lengthTwoDimension()

		 			break
		 		default: break
		 		}
		 		setState(6519)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,966,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(6516)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.UNSIGNED.rawValue || _la == MySqlParser.Tokens.ZEROFILL.rawValue || _la == MySqlParser.Tokens.SIGNED.rawValue)) {
		 				try _errHandler.recoverInline(self)
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 		 
		 			}
		 			setState(6521)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,966,_ctx)
		 		}

		 		break
		 	case 7:
		 		_localctx =  DimensionDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 7)
		 		setState(6522)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.DOUBLE.rawValue)
		 				_localctx.castdown(DimensionDataTypeContext.self).typeName = assignmentValue
		 		     }()

		 		setState(6524)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.PRECISION.rawValue) {
		 			setState(6523)
		 			try match(MySqlParser.Tokens.PRECISION.rawValue)

		 		}

		 		setState(6527)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,968,_ctx)) {
		 		case 1:
		 			setState(6526)
		 			try lengthTwoDimension()

		 			break
		 		default: break
		 		}
		 		setState(6532)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,969,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(6529)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.UNSIGNED.rawValue || _la == MySqlParser.Tokens.ZEROFILL.rawValue || _la == MySqlParser.Tokens.SIGNED.rawValue)) {
		 				try _errHandler.recoverInline(self)
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 		 
		 			}
		 			setState(6534)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,969,_ctx)
		 		}

		 		break
		 	case 8:
		 		_localctx =  DimensionDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 8)
		 		setState(6535)
		 		_localctx.castdown(DimensionDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 211)) & ~0x3f) == 0 && ((Int64(1) << (_la - 211)) & 63) != 0) || _la == MySqlParser.Tokens.FIXED.rawValue)) {
		 			_localctx.castdown(DimensionDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6537)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,970,_ctx)) {
		 		case 1:
		 			setState(6536)
		 			try lengthTwoOptionalDimension()

		 			break
		 		default: break
		 		}
		 		setState(6542)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,971,_ctx)
		 		while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 			if ( _alt==1 ) {
		 				setState(6539)
		 				_la = try _input.LA(1)
		 				if (!(_la == MySqlParser.Tokens.UNSIGNED.rawValue || _la == MySqlParser.Tokens.ZEROFILL.rawValue || _la == MySqlParser.Tokens.SIGNED.rawValue)) {
		 				try _errHandler.recoverInline(self)
		 				}
		 				else {
		 					_errHandler.reportMatch(self)
		 					try consume()
		 				}

		 		 
		 			}
		 			setState(6544)
		 			try _errHandler.sync(self)
		 			_alt = try getInterpreter().adaptivePredict(_input,971,_ctx)
		 		}

		 		break
		 	case 9:
		 		_localctx =  SimpleDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 9)
		 		setState(6545)
		 		_localctx.castdown(SimpleDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & 4237313) != 0) || _la == MySqlParser.Tokens.BOOL.rawValue || _la == MySqlParser.Tokens.BOOLEAN.rawValue)) {
		 			_localctx.castdown(SimpleDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 10:
		 		_localctx =  DimensionDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 10)
		 		setState(6546)
		 		_localctx.castdown(DimensionDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 218)) & ~0x3f) == 0 && ((Int64(1) << (_la - 218)) & 2831) != 0) || _la == MySqlParser.Tokens.BIT.rawValue)) {
		 			_localctx.castdown(DimensionDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6548)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,972,_ctx)) {
		 		case 1:
		 			setState(6547)
		 			try lengthOneDimension()

		 			break
		 		default: break
		 		}

		 		break
		 	case 11:
		 		_localctx =  CollectionDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 11)
		 		setState(6550)
		 		_localctx.castdown(CollectionDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.SET.rawValue || _la == MySqlParser.Tokens.ENUM.rawValue)) {
		 			_localctx.castdown(CollectionDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6551)
		 		try collectionOptions()
		 		setState(6553)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,973,_ctx)) {
		 		case 1:
		 			setState(6552)
		 			try match(MySqlParser.Tokens.BINARY.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(6558)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,974,_ctx)) {
		 		case 1:
		 			setState(6555)
		 			try charSet()
		 			setState(6556)
		 			try charsetName()

		 			break
		 		default: break
		 		}

		 		break
		 	case 12:
		 		_localctx =  SpatialDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 12)
		 		setState(6560)
		 		_localctx.castdown(SpatialDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.JSON.rawValue || ((Int64((_la - 803)) & ~0x3f) == 0 && ((Int64(1) << (_la - 803)) & 511) != 0))) {
		 			_localctx.castdown(SpatialDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6563)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,975,_ctx)) {
		 		case 1:
		 			setState(6561)
		 			try match(MySqlParser.Tokens.SRID.rawValue)
		 			setState(6562)
		 			try decimalLiteral()

		 			break
		 		default: break
		 		}

		 		break
		 	case 13:
		 		_localctx =  LongVarcharDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 13)
		 		setState(6565)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.LONG.rawValue)
		 				_localctx.castdown(LongVarcharDataTypeContext.self).typeName = assignmentValue
		 		     }()

		 		setState(6567)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.VARCHAR.rawValue) {
		 			setState(6566)
		 			try match(MySqlParser.Tokens.VARCHAR.rawValue)

		 		}

		 		setState(6570)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,977,_ctx)) {
		 		case 1:
		 			setState(6569)
		 			try match(MySqlParser.Tokens.BINARY.rawValue)

		 			break
		 		default: break
		 		}
		 		setState(6575)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,978,_ctx)) {
		 		case 1:
		 			setState(6572)
		 			try charSet()
		 			setState(6573)
		 			try charsetName()

		 			break
		 		default: break
		 		}
		 		setState(6579)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,979,_ctx)) {
		 		case 1:
		 			setState(6577)
		 			try match(MySqlParser.Tokens.COLLATE.rawValue)
		 			setState(6578)
		 			try collationName()

		 			break
		 		default: break
		 		}

		 		break
		 	case 14:
		 		_localctx =  LongVarbinaryDataTypeContext(_localctx);
		 		try enterOuterAlt(_localctx, 14)
		 		setState(6581)
		 		try match(MySqlParser.Tokens.LONG.rawValue)
		 		setState(6582)
		 		try match(MySqlParser.Tokens.VARBINARY.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CollectionOptionsContext: ParserRuleContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.STRING_LITERAL.rawValue)
			}
			open
			func STRING_LITERAL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_collectionOptions
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCollectionOptions(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCollectionOptions(self)
			}
		}
	}
	@discardableResult
	 open func collectionOptions() throws -> CollectionOptionsContext {
		var _localctx: CollectionOptionsContext
		_localctx = CollectionOptionsContext(_ctx, getState())
		try enterRule(_localctx, 606, MySqlParser.RULE_collectionOptions)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6585)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(6586)
		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 	setState(6591)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6587)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6588)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)


		 		setState(6593)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6594)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConvertedDataTypeContext: ParserRuleContext {
		open var typeName: Token!
			open
			func CHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHAR.rawValue, 0)
			}
			open
			func SIGNED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SIGNED.rawValue, 0)
			}
			open
			func UNSIGNED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNSIGNED.rawValue, 0)
			}
			open
			func ARRAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ARRAY.rawValue, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}
			open
			func NCHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NCHAR.rawValue, 0)
			}
			open
			func FLOAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FLOAT.rawValue, 0)
			}
			open
			func DATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATE.rawValue, 0)
			}
			open
			func DATETIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATETIME.rawValue, 0)
			}
			open
			func TIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIME.rawValue, 0)
			}
			open
			func YEAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.YEAR.rawValue, 0)
			}
			open
			func JSON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON.rawValue, 0)
			}
			open
			func INT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INT.rawValue, 0)
			}
			open
			func INTEGER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTEGER.rawValue, 0)
			}
			open
			func DOUBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DOUBLE.rawValue, 0)
			}
			open
			func DECIMAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DECIMAL.rawValue, 0)
			}
			open
			func DEC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEC.rawValue, 0)
			}
			open
			func lengthOneDimension() -> LengthOneDimensionContext? {
				return getRuleContext(LengthOneDimensionContext.self, 0)
			}
			open
			func charSet() -> CharSetContext? {
				return getRuleContext(CharSetContext.self, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func lengthTwoOptionalDimension() -> LengthTwoOptionalDimensionContext? {
				return getRuleContext(LengthTwoOptionalDimensionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_convertedDataType
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterConvertedDataType(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitConvertedDataType(self)
			}
		}
	}
	@discardableResult
	 open func convertedDataType() throws -> ConvertedDataTypeContext {
		var _localctx: ConvertedDataTypeContext
		_localctx = ConvertedDataTypeContext(_ctx, getState())
		try enterRule(_localctx, 608, MySqlParser.RULE_convertedDataType)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6618)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .FLOAT:fallthrough
		 	case .BINARY:fallthrough
		 	case .NCHAR:
		 		setState(6596)
		 		_localctx.castdown(ConvertedDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FLOAT.rawValue || _la == MySqlParser.Tokens.BINARY.rawValue || _la == MySqlParser.Tokens.NCHAR.rawValue)) {
		 			_localctx.castdown(ConvertedDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6598)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 			setState(6597)
		 			try lengthOneDimension()

		 		}


		 		break

		 	case .CHAR:
		 		setState(6600)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.CHAR.rawValue)
		 				_localctx.castdown(ConvertedDataTypeContext.self).typeName = assignmentValue
		 		     }()

		 		setState(6602)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 			setState(6601)
		 			try lengthOneDimension()

		 		}

		 		setState(6607)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.CHARACTER.rawValue || _la == MySqlParser.Tokens.CHAR.rawValue || _la == MySqlParser.Tokens.CHARSET.rawValue) {
		 			setState(6604)
		 			try charSet()
		 			setState(6605)
		 			try charsetName()

		 		}


		 		break
		 	case .INT:fallthrough
		 	case .INTEGER:fallthrough
		 	case .DOUBLE:fallthrough
		 	case .DATE:fallthrough
		 	case .TIME:fallthrough
		 	case .DATETIME:fallthrough
		 	case .YEAR:fallthrough
		 	case .JSON:
		 		setState(6609)
		 		_localctx.castdown(ConvertedDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 200)) & ~0x3f) == 0 && ((Int64(1) << (_la - 200)) & 3539521) != 0) || _la == MySqlParser.Tokens.JSON.rawValue)) {
		 			_localctx.castdown(ConvertedDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case .DECIMAL:fallthrough
		 	case .DEC:
		 		setState(6610)
		 		_localctx.castdown(ConvertedDataTypeContext.self).typeName = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.DECIMAL.rawValue || _la == MySqlParser.Tokens.DEC.rawValue)) {
		 			_localctx.castdown(ConvertedDataTypeContext.self).typeName = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6612)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LR_BRACKET.rawValue) {
		 			setState(6611)
		 			try lengthTwoOptionalDimension()

		 		}


		 		break
		 	case .UNSIGNED:fallthrough
		 	case .SIGNED:
		 		setState(6614)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.UNSIGNED.rawValue || _la == MySqlParser.Tokens.SIGNED.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6616)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.INT.rawValue || _la == MySqlParser.Tokens.INTEGER.rawValue) {
		 			setState(6615)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.INT.rawValue || _la == MySqlParser.Tokens.INTEGER.rawValue)) {
		 			try _errHandler.recoverInline(self)
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 		}


		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		 	setState(6621)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ARRAY.rawValue) {
		 		setState(6620)
		 		try match(MySqlParser.Tokens.ARRAY.rawValue)

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LengthOneDimensionContext: ParserRuleContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_lengthOneDimension
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLengthOneDimension(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLengthOneDimension(self)
			}
		}
	}
	@discardableResult
	 open func lengthOneDimension() throws -> LengthOneDimensionContext {
		var _localctx: LengthOneDimensionContext
		_localctx = LengthOneDimensionContext(_ctx, getState())
		try enterRule(_localctx, 610, MySqlParser.RULE_lengthOneDimension)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6623)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(6624)
		 	try decimalLiteral()
		 	setState(6625)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LengthTwoDimensionContext: ParserRuleContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func decimalLiteral() -> [DecimalLiteralContext] {
				return getRuleContexts(DecimalLiteralContext.self)
			}
			open
			func decimalLiteral(_ i: Int) -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, i)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_lengthTwoDimension
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLengthTwoDimension(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLengthTwoDimension(self)
			}
		}
	}
	@discardableResult
	 open func lengthTwoDimension() throws -> LengthTwoDimensionContext {
		var _localctx: LengthTwoDimensionContext
		_localctx = LengthTwoDimensionContext(_ctx, getState())
		try enterRule(_localctx, 612, MySqlParser.RULE_lengthTwoDimension)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6627)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(6628)
		 	try decimalLiteral()
		 	setState(6629)
		 	try match(MySqlParser.Tokens.COMMA.rawValue)
		 	setState(6630)
		 	try decimalLiteral()
		 	setState(6631)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LengthTwoOptionalDimensionContext: ParserRuleContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func decimalLiteral() -> [DecimalLiteralContext] {
				return getRuleContexts(DecimalLiteralContext.self)
			}
			open
			func decimalLiteral(_ i: Int) -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_lengthTwoOptionalDimension
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLengthTwoOptionalDimension(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLengthTwoOptionalDimension(self)
			}
		}
	}
	@discardableResult
	 open func lengthTwoOptionalDimension() throws -> LengthTwoOptionalDimensionContext {
		var _localctx: LengthTwoOptionalDimensionContext
		_localctx = LengthTwoOptionalDimensionContext(_ctx, getState())
		try enterRule(_localctx, 614, MySqlParser.RULE_lengthTwoOptionalDimension)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6633)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(6634)
		 	try decimalLiteral()
		 	setState(6637)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6635)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6636)
		 		try decimalLiteral()

		 	}

		 	setState(6639)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UidListContext: ParserRuleContext {
			open
			func uid() -> [UidContext] {
				return getRuleContexts(UidContext.self)
			}
			open
			func uid(_ i: Int) -> UidContext? {
				return getRuleContext(UidContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_uidList
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUidList(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUidList(self)
			}
		}
	}
	@discardableResult
	 open func uidList() throws -> UidListContext {
		var _localctx: UidListContext
		_localctx = UidListContext(_ctx, getState())
		try enterRule(_localctx, 616, MySqlParser.RULE_uidList)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6641)
		 	try uid()
		 	setState(6646)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,990,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(6642)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(6643)
		 			try uid()

		 	 
		 		}
		 		setState(6648)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,990,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FullColumnNameListContext: ParserRuleContext {
			open
			func fullColumnName() -> [FullColumnNameContext] {
				return getRuleContexts(FullColumnNameContext.self)
			}
			open
			func fullColumnName(_ i: Int) -> FullColumnNameContext? {
				return getRuleContext(FullColumnNameContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_fullColumnNameList
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFullColumnNameList(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFullColumnNameList(self)
			}
		}
	}
	@discardableResult
	 open func fullColumnNameList() throws -> FullColumnNameListContext {
		var _localctx: FullColumnNameListContext
		_localctx = FullColumnNameListContext(_ctx, getState())
		try enterRule(_localctx, 618, MySqlParser.RULE_fullColumnNameList)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6649)
		 	try fullColumnName()
		 	setState(6654)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6650)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6651)
		 		try fullColumnName()


		 		setState(6656)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TablesContext: ParserRuleContext {
			open
			func tableName() -> [TableNameContext] {
				return getRuleContexts(TableNameContext.self)
			}
			open
			func tableName(_ i: Int) -> TableNameContext? {
				return getRuleContext(TableNameContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_tables
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTables(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTables(self)
			}
		}
	}
	@discardableResult
	 open func tables() throws -> TablesContext {
		var _localctx: TablesContext
		_localctx = TablesContext(_ctx, getState())
		try enterRule(_localctx, 620, MySqlParser.RULE_tables)
		defer {
	    		try! exitRule()
	    }
		do {
			var _alt:Int
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6657)
		 	try tableName()
		 	setState(6662)
		 	try _errHandler.sync(self)
		 	_alt = try getInterpreter().adaptivePredict(_input,992,_ctx)
		 	while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
		 		if ( _alt==1 ) {
		 			setState(6658)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(6659)
		 			try tableName()

		 	 
		 		}
		 		setState(6664)
		 		try _errHandler.sync(self)
		 		_alt = try getInterpreter().adaptivePredict(_input,992,_ctx)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IndexColumnNamesContext: ParserRuleContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func indexColumnName() -> [IndexColumnNameContext] {
				return getRuleContexts(IndexColumnNameContext.self)
			}
			open
			func indexColumnName(_ i: Int) -> IndexColumnNameContext? {
				return getRuleContext(IndexColumnNameContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_indexColumnNames
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIndexColumnNames(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIndexColumnNames(self)
			}
		}
	}
	@discardableResult
	 open func indexColumnNames() throws -> IndexColumnNamesContext {
		var _localctx: IndexColumnNamesContext
		_localctx = IndexColumnNamesContext(_ctx, getState())
		try enterRule(_localctx, 622, MySqlParser.RULE_indexColumnNames)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6665)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(6666)
		 	try indexColumnName()
		 	setState(6671)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6667)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6668)
		 		try indexColumnName()


		 		setState(6673)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}
		 	setState(6674)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExpressionsContext: ParserRuleContext {
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_expressions
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterExpressions(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitExpressions(self)
			}
		}
	}
	@discardableResult
	 open func expressions() throws -> ExpressionsContext {
		var _localctx: ExpressionsContext
		_localctx = ExpressionsContext(_ctx, getState())
		try enterRule(_localctx, 624, MySqlParser.RULE_expressions)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6676)
		 	try expression(0)
		 	setState(6681)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6677)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6678)
		 		try expression(0)


		 		setState(6683)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExpressionsWithDefaultsContext: ParserRuleContext {
			open
			func expressionOrDefault() -> [ExpressionOrDefaultContext] {
				return getRuleContexts(ExpressionOrDefaultContext.self)
			}
			open
			func expressionOrDefault(_ i: Int) -> ExpressionOrDefaultContext? {
				return getRuleContext(ExpressionOrDefaultContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_expressionsWithDefaults
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterExpressionsWithDefaults(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitExpressionsWithDefaults(self)
			}
		}
	}
	@discardableResult
	 open func expressionsWithDefaults() throws -> ExpressionsWithDefaultsContext {
		var _localctx: ExpressionsWithDefaultsContext
		_localctx = ExpressionsWithDefaultsContext(_ctx, getState())
		try enterRule(_localctx, 626, MySqlParser.RULE_expressionsWithDefaults)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6684)
		 	try expressionOrDefault()
		 	setState(6689)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6685)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6686)
		 		try expressionOrDefault()


		 		setState(6691)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ConstantsContext: ParserRuleContext {
			open
			func constant() -> [ConstantContext] {
				return getRuleContexts(ConstantContext.self)
			}
			open
			func constant(_ i: Int) -> ConstantContext? {
				return getRuleContext(ConstantContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_constants
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterConstants(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitConstants(self)
			}
		}
	}
	@discardableResult
	 open func constants() throws -> ConstantsContext {
		var _localctx: ConstantsContext
		_localctx = ConstantsContext(_ctx, getState())
		try enterRule(_localctx, 628, MySqlParser.RULE_constants)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6692)
		 	try constant()
		 	setState(6697)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6693)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6694)
		 		try constant()


		 		setState(6699)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SimpleStringsContext: ParserRuleContext {
			open
			func STRING_LITERAL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.STRING_LITERAL.rawValue)
			}
			open
			func STRING_LITERAL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_simpleStrings
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSimpleStrings(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSimpleStrings(self)
			}
		}
	}
	@discardableResult
	 open func simpleStrings() throws -> SimpleStringsContext {
		var _localctx: SimpleStringsContext
		_localctx = SimpleStringsContext(_ctx, getState())
		try enterRule(_localctx, 630, MySqlParser.RULE_simpleStrings)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6700)
		 	try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 	setState(6705)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6701)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6702)
		 		try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)


		 		setState(6707)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class UserVariablesContext: ParserRuleContext {
			open
			func LOCAL_ID() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LOCAL_ID.rawValue)
			}
			open
			func LOCAL_ID(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL_ID.rawValue, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_userVariables
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUserVariables(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUserVariables(self)
			}
		}
	}
	@discardableResult
	 open func userVariables() throws -> UserVariablesContext {
		var _localctx: UserVariablesContext
		_localctx = UserVariablesContext(_ctx, getState())
		try enterRule(_localctx, 632, MySqlParser.RULE_userVariables)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6708)
		 	try match(MySqlParser.Tokens.LOCAL_ID.rawValue)
		 	setState(6713)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(6709)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6710)
		 		try match(MySqlParser.Tokens.LOCAL_ID.rawValue)


		 		setState(6715)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DefaultValueContext: ParserRuleContext {
			open
			func NULL_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NULL_LITERAL.rawValue, 0)
			}
			open
			func CAST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CAST.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
			open
			func convertedDataType() -> ConvertedDataTypeContext? {
				return getRuleContext(ConvertedDataTypeContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func constant() -> ConstantContext? {
				return getRuleContext(ConstantContext.self, 0)
			}
			open
			func unaryOperator() -> UnaryOperatorContext? {
				return getRuleContext(UnaryOperatorContext.self, 0)
			}
			open
			func currentTimestamp() -> [CurrentTimestampContext] {
				return getRuleContexts(CurrentTimestampContext.self)
			}
			open
			func currentTimestamp(_ i: Int) -> CurrentTimestampContext? {
				return getRuleContext(CurrentTimestampContext.self, i)
			}
			open
			func ON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ON.rawValue, 0)
			}
			open
			func UPDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPDATE.rawValue, 0)
			}
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_defaultValue
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDefaultValue(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDefaultValue(self)
			}
		}
	}
	@discardableResult
	 open func defaultValue() throws -> DefaultValueContext {
		var _localctx: DefaultValueContext
		_localctx = DefaultValueContext(_ctx, getState())
		try enterRule(_localctx, 634, MySqlParser.RULE_defaultValue)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6742)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,1001, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6716)
		 		try match(MySqlParser.Tokens.NULL_LITERAL.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6717)
		 		try match(MySqlParser.Tokens.CAST.rawValue)
		 		setState(6718)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6719)
		 		try expression(0)
		 		setState(6720)
		 		try match(MySqlParser.Tokens.AS.rawValue)
		 		setState(6721)
		 		try convertedDataType()
		 		setState(6722)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6725)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,999,_ctx)) {
		 		case 1:
		 			setState(6724)
		 			try unaryOperator()

		 			break
		 		default: break
		 		}
		 		setState(6727)
		 		try constant()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6728)
		 		try currentTimestamp()
		 		setState(6732)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1000,_ctx)) {
		 		case 1:
		 			setState(6729)
		 			try match(MySqlParser.Tokens.ON.rawValue)
		 			setState(6730)
		 			try match(MySqlParser.Tokens.UPDATE.rawValue)
		 			setState(6731)
		 			try currentTimestamp()

		 			break
		 		default: break
		 		}

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6734)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6735)
		 		try expression(0)
		 		setState(6736)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6738)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6739)
		 		try fullId()
		 		setState(6740)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CurrentTimestampContext: ParserRuleContext {
			open
			func NOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOW.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func CURRENT_TIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT_TIMESTAMP.rawValue, 0)
			}
			open
			func LOCALTIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCALTIME.rawValue, 0)
			}
			open
			func LOCALTIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCALTIMESTAMP.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_currentTimestamp
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCurrentTimestamp(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCurrentTimestamp(self)
			}
		}
	}
	@discardableResult
	 open func currentTimestamp() throws -> CurrentTimestampContext {
		var _localctx: CurrentTimestampContext
		_localctx = CurrentTimestampContext(_ctx, getState())
		try enterRule(_localctx, 636, MySqlParser.RULE_currentTimestamp)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6758)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .CURRENT_TIMESTAMP:fallthrough
		 	case .LOCALTIME:fallthrough
		 	case .LOCALTIMESTAMP:
		 		setState(6744)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 315)) & ~0x3f) == 0 && ((Int64(1) << (_la - 315)) & 131) != 0))) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6750)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1003,_ctx)) {
		 		case 1:
		 			setState(6745)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(6747)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			if (((Int64((_la - 1138)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1138)) & 10247) != 0)) {
		 				setState(6746)
		 				try decimalLiteral()

		 			}

		 			setState(6749)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}

		 		break

		 	case .NOW:
		 		setState(6752)
		 		try match(MySqlParser.Tokens.NOW.rawValue)
		 		setState(6753)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6755)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (((Int64((_la - 1138)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1138)) & 10247) != 0)) {
		 			setState(6754)
		 			try decimalLiteral()

		 		}

		 		setState(6757)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ExpressionOrDefaultContext: ParserRuleContext {
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_expressionOrDefault
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterExpressionOrDefault(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitExpressionOrDefault(self)
			}
		}
	}
	@discardableResult
	 open func expressionOrDefault() throws -> ExpressionOrDefaultContext {
		var _localctx: ExpressionOrDefaultContext
		_localctx = ExpressionOrDefaultContext(_ctx, getState())
		try enterRule(_localctx, 638, MySqlParser.RULE_expressionOrDefault)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6762)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,1006, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6760)
		 		try expression(0)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6761)
		 		try match(MySqlParser.Tokens.DEFAULT.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IfExistsContext: ParserRuleContext {
			open
			func IF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IF.rawValue, 0)
			}
			open
			func EXISTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXISTS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_ifExists
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIfExists(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIfExists(self)
			}
		}
	}
	@discardableResult
	 open func ifExists() throws -> IfExistsContext {
		var _localctx: IfExistsContext
		_localctx = IfExistsContext(_ctx, getState())
		try enterRule(_localctx, 640, MySqlParser.RULE_ifExists)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6764)
		 	try match(MySqlParser.Tokens.IF.rawValue)
		 	setState(6765)
		 	try match(MySqlParser.Tokens.EXISTS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IfNotExistsContext: ParserRuleContext {
			open
			func IF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IF.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
			open
			func EXISTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXISTS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_ifNotExists
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIfNotExists(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIfNotExists(self)
			}
		}
	}
	@discardableResult
	 open func ifNotExists() throws -> IfNotExistsContext {
		var _localctx: IfNotExistsContext
		_localctx = IfNotExistsContext(_ctx, getState())
		try enterRule(_localctx, 642, MySqlParser.RULE_ifNotExists)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6767)
		 	try match(MySqlParser.Tokens.IF.rawValue)
		 	setState(6768)
		 	try match(MySqlParser.Tokens.NOT.rawValue)
		 	setState(6769)
		 	try match(MySqlParser.Tokens.EXISTS.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OrReplaceContext: ParserRuleContext {
			open
			func OR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OR.rawValue, 0)
			}
			open
			func REPLACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLACE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_orReplace
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterOrReplace(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitOrReplace(self)
			}
		}
	}
	@discardableResult
	 open func orReplace() throws -> OrReplaceContext {
		var _localctx: OrReplaceContext
		_localctx = OrReplaceContext(_ctx, getState())
		try enterRule(_localctx, 644, MySqlParser.RULE_orReplace)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6771)
		 	try match(MySqlParser.Tokens.OR.rawValue)
		 	setState(6772)
		 	try match(MySqlParser.Tokens.REPLACE.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WaitNowaitClauseContext: ParserRuleContext {
			open
			func WAIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WAIT.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func NOWAIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOWAIT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_waitNowaitClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterWaitNowaitClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitWaitNowaitClause(self)
			}
		}
	}
	@discardableResult
	 open func waitNowaitClause() throws -> WaitNowaitClauseContext {
		var _localctx: WaitNowaitClauseContext
		_localctx = WaitNowaitClauseContext(_ctx, getState())
		try enterRule(_localctx, 646, MySqlParser.RULE_waitNowaitClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6777)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .WAIT:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6774)
		 		try match(MySqlParser.Tokens.WAIT.rawValue)
		 		setState(6775)
		 		try decimalLiteral()

		 		break

		 	case .NOWAIT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6776)
		 		try match(MySqlParser.Tokens.NOWAIT.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FunctionCallContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_functionCall
		}
	}
	public class SpecificFunctionCallContext: FunctionCallContext {
			open
			func specificFunction() -> SpecificFunctionContext? {
				return getRuleContext(SpecificFunctionContext.self, 0)
			}

		public
		init(_ ctx: FunctionCallContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSpecificFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSpecificFunctionCall(self)
			}
		}
	}
	public class PasswordFunctionCallContext: FunctionCallContext {
			open
			func passwordFunctionClause() -> PasswordFunctionClauseContext? {
				return getRuleContext(PasswordFunctionClauseContext.self, 0)
			}

		public
		init(_ ctx: FunctionCallContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPasswordFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPasswordFunctionCall(self)
			}
		}
	}
	public class UdfFunctionCallContext: FunctionCallContext {
			open
			func fullId() -> FullIdContext? {
				return getRuleContext(FullIdContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func functionArgs() -> FunctionArgsContext? {
				return getRuleContext(FunctionArgsContext.self, 0)
			}

		public
		init(_ ctx: FunctionCallContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUdfFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUdfFunctionCall(self)
			}
		}
	}
	public class NonAggregateFunctionCallContext: FunctionCallContext {
			open
			func nonAggregateWindowedFunction() -> NonAggregateWindowedFunctionContext? {
				return getRuleContext(NonAggregateWindowedFunctionContext.self, 0)
			}

		public
		init(_ ctx: FunctionCallContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterNonAggregateFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitNonAggregateFunctionCall(self)
			}
		}
	}
	public class AggregateFunctionCallContext: FunctionCallContext {
			open
			func aggregateWindowedFunction() -> AggregateWindowedFunctionContext? {
				return getRuleContext(AggregateWindowedFunctionContext.self, 0)
			}

		public
		init(_ ctx: FunctionCallContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAggregateFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAggregateFunctionCall(self)
			}
		}
	}
	public class ScalarFunctionCallContext: FunctionCallContext {
			open
			func scalarFunctionName() -> ScalarFunctionNameContext? {
				return getRuleContext(ScalarFunctionNameContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func functionArgs() -> FunctionArgsContext? {
				return getRuleContext(FunctionArgsContext.self, 0)
			}

		public
		init(_ ctx: FunctionCallContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterScalarFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitScalarFunctionCall(self)
			}
		}
	}
	@discardableResult
	 open func functionCall() throws -> FunctionCallContext {
		var _localctx: FunctionCallContext
		_localctx = FunctionCallContext(_ctx, getState())
		try enterRule(_localctx, 648, MySqlParser.RULE_functionCall)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6797)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,1010, _ctx)) {
		 	case 1:
		 		_localctx =  SpecificFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6779)
		 		try specificFunction()

		 		break
		 	case 2:
		 		_localctx =  AggregateFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6780)
		 		try aggregateWindowedFunction()

		 		break
		 	case 3:
		 		_localctx =  NonAggregateFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6781)
		 		try nonAggregateWindowedFunction()

		 		break
		 	case 4:
		 		_localctx =  ScalarFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6782)
		 		try scalarFunctionName()
		 		setState(6783)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6785)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1008,_ctx)) {
		 		case 1:
		 			setState(6784)
		 			try functionArgs()

		 			break
		 		default: break
		 		}
		 		setState(6787)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 5:
		 		_localctx =  UdfFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6789)
		 		try fullId()
		 		setState(6790)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6792)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1009,_ctx)) {
		 		case 1:
		 			setState(6791)
		 			try functionArgs()

		 			break
		 		default: break
		 		}
		 		setState(6794)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 6:
		 		_localctx =  PasswordFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6796)
		 		try passwordFunctionClause()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class SpecificFunctionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_specificFunction
		}
	}
	public class PositionFunctionCallContext: SpecificFunctionContext {
		public var positionString: StringLiteralContext!
		public var positionExpression: ExpressionContext!
		public var inString: StringLiteralContext!
		public var inExpression: ExpressionContext!
			open
			func POSITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POSITION.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func stringLiteral() -> [StringLiteralContext] {
				return getRuleContexts(StringLiteralContext.self)
			}
			open
			func stringLiteral(_ i: Int) -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, i)
			}
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPositionFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPositionFunctionCall(self)
			}
		}
	}
	public class TrimFunctionCallContext: SpecificFunctionContext {
		public var positioinForm: Token!
		public var sourceString: StringLiteralContext!
		public var sourceExpression: ExpressionContext!
		public var fromString: StringLiteralContext!
		public var fromExpression: ExpressionContext!
			open
			func TRIM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRIM.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func BOTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BOTH.rawValue, 0)
			}
			open
			func LEADING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEADING.rawValue, 0)
			}
			open
			func TRAILING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRAILING.rawValue, 0)
			}
			open
			func stringLiteral() -> [StringLiteralContext] {
				return getRuleContexts(StringLiteralContext.self)
			}
			open
			func stringLiteral(_ i: Int) -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, i)
			}
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTrimFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTrimFunctionCall(self)
			}
		}
	}
	public class JsonValueFunctionCallContext: SpecificFunctionContext {
			open
			func JSON_VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_VALUE.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func RETURNING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RETURNING.rawValue, 0)
			}
			open
			func convertedDataType() -> ConvertedDataTypeContext? {
				return getRuleContext(ConvertedDataTypeContext.self, 0)
			}
			open
			func jsonOnEmpty() -> JsonOnEmptyContext? {
				return getRuleContext(JsonOnEmptyContext.self, 0)
			}
			open
			func jsonOnError() -> JsonOnErrorContext? {
				return getRuleContext(JsonOnErrorContext.self, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterJsonValueFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitJsonValueFunctionCall(self)
			}
		}
	}
	public class CaseFunctionCallContext: SpecificFunctionContext {
		public var elseArg: FunctionArgContext!
			open
			func CASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CASE.rawValue, 0)
			}
			open
			func END() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.END.rawValue, 0)
			}
			open
			func caseFuncAlternative() -> [CaseFuncAlternativeContext] {
				return getRuleContexts(CaseFuncAlternativeContext.self)
			}
			open
			func caseFuncAlternative(_ i: Int) -> CaseFuncAlternativeContext? {
				return getRuleContext(CaseFuncAlternativeContext.self, i)
			}
			open
			func ELSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ELSE.rawValue, 0)
			}
			open
			func functionArg() -> FunctionArgContext? {
				return getRuleContext(FunctionArgContext.self, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCaseFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCaseFunctionCall(self)
			}
		}
	}
	public class ExtractFunctionCallContext: SpecificFunctionContext {
		public var sourceString: StringLiteralContext!
		public var sourceExpression: ExpressionContext!
			open
			func EXTRACT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXTRACT.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func intervalType() -> IntervalTypeContext? {
				return getRuleContext(IntervalTypeContext.self, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterExtractFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitExtractFunctionCall(self)
			}
		}
	}
	public class DataTypeFunctionCallContext: SpecificFunctionContext {
		public var separator: Token!
			open
			func CONVERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONVERT.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func convertedDataType() -> ConvertedDataTypeContext? {
				return getRuleContext(ConvertedDataTypeContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}
			open
			func USING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USING.rawValue, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}
			open
			func CAST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CAST.rawValue, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDataTypeFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDataTypeFunctionCall(self)
			}
		}
	}
	public class ValuesFunctionCallContext: SpecificFunctionContext {
			open
			func VALUES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUES.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func fullColumnName() -> FullColumnNameContext? {
				return getRuleContext(FullColumnNameContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterValuesFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitValuesFunctionCall(self)
			}
		}
	}
	public class CaseExpressionFunctionCallContext: SpecificFunctionContext {
		public var elseArg: FunctionArgContext!
			open
			func CASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CASE.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func END() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.END.rawValue, 0)
			}
			open
			func caseFuncAlternative() -> [CaseFuncAlternativeContext] {
				return getRuleContexts(CaseFuncAlternativeContext.self)
			}
			open
			func caseFuncAlternative(_ i: Int) -> CaseFuncAlternativeContext? {
				return getRuleContext(CaseFuncAlternativeContext.self, i)
			}
			open
			func ELSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ELSE.rawValue, 0)
			}
			open
			func functionArg() -> FunctionArgContext? {
				return getRuleContext(FunctionArgContext.self, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCaseExpressionFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCaseExpressionFunctionCall(self)
			}
		}
	}
	public class CurrentUserContext: SpecificFunctionContext {
			open
			func currentUserExpression() -> CurrentUserExpressionContext? {
				return getRuleContext(CurrentUserExpressionContext.self, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCurrentUser(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCurrentUser(self)
			}
		}
	}
	public class SimpleFunctionCallContext: SpecificFunctionContext {
			open
			func CURRENT_DATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT_DATE.rawValue, 0)
			}
			open
			func CURRENT_TIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT_TIME.rawValue, 0)
			}
			open
			func CURRENT_TIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT_TIMESTAMP.rawValue, 0)
			}
			open
			func LOCALTIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCALTIME.rawValue, 0)
			}
			open
			func UTC_TIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UTC_TIMESTAMP.rawValue, 0)
			}
			open
			func SCHEMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEMA.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSimpleFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSimpleFunctionCall(self)
			}
		}
	}
	public class CharFunctionCallContext: SpecificFunctionContext {
			open
			func CHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHAR.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func functionArgs() -> FunctionArgsContext? {
				return getRuleContext(FunctionArgsContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func USING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USING.rawValue, 0)
			}
			open
			func charsetName() -> CharsetNameContext? {
				return getRuleContext(CharsetNameContext.self, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCharFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCharFunctionCall(self)
			}
		}
	}
	public class WeightFunctionCallContext: SpecificFunctionContext {
		public var stringFormat: Token!
			open
			func WEIGHT_STRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WEIGHT_STRING.rawValue, 0)
			}
			open
			func LR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LR_BRACKET.rawValue)
			}
			open
			func LR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, i)
			}
			open
			func RR_BRACKET() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.RR_BRACKET.rawValue)
			}
			open
			func RR_BRACKET(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, i)
			}
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func AS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AS.rawValue, 0)
			}
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func levelsInWeightString() -> LevelsInWeightStringContext? {
				return getRuleContext(LevelsInWeightStringContext.self, 0)
			}
			open
			func CHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHAR.rawValue, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterWeightFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitWeightFunctionCall(self)
			}
		}
	}
	public class GetFormatFunctionCallContext: SpecificFunctionContext {
		public var datetimeFormat: Token!
			open
			func GET_FORMAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GET_FORMAT.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, 0)
			}
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func DATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATE.rawValue, 0)
			}
			open
			func TIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIME.rawValue, 0)
			}
			open
			func DATETIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATETIME.rawValue, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterGetFormatFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitGetFormatFunctionCall(self)
			}
		}
	}
	public class SubstrFunctionCallContext: SpecificFunctionContext {
		public var sourceString: StringLiteralContext!
		public var sourceExpression: ExpressionContext!
		public var fromDecimal: DecimalLiteralContext!
		public var fromExpression: ExpressionContext!
		public var forDecimal: DecimalLiteralContext!
		public var forExpression: ExpressionContext!
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func FROM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func SUBSTR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBSTR.rawValue, 0)
			}
			open
			func SUBSTRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBSTRING.rawValue, 0)
			}
			open
			func stringLiteral() -> StringLiteralContext? {
				return getRuleContext(StringLiteralContext.self, 0)
			}
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}
			open
			func decimalLiteral() -> [DecimalLiteralContext] {
				return getRuleContexts(DecimalLiteralContext.self)
			}
			open
			func decimalLiteral(_ i: Int) -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, i)
			}
			open
			func FOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOR.rawValue, 0)
			}

		public
		init(_ ctx: SpecificFunctionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSubstrFunctionCall(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSubstrFunctionCall(self)
			}
		}
	}
	@discardableResult
	 open func specificFunction() throws -> SpecificFunctionContext {
		var _localctx: SpecificFunctionContext
		_localctx = SpecificFunctionContext(_ctx, getState())
		try enterRule(_localctx, 650, MySqlParser.RULE_specificFunction)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6978)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,1034, _ctx)) {
		 	case 1:
		 		_localctx =  SimpleFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6799)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.SCHEMA.rawValue || ((Int64((_la - 313)) & ~0x3f) == 0 && ((Int64(1) << (_la - 313)) & 262159) != 0))) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6802)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1011,_ctx)) {
		 		case 1:
		 			setState(6800)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(6801)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 			break
		 		default: break
		 		}

		 		break
		 	case 2:
		 		_localctx =  CurrentUserContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6804)
		 		try currentUserExpression()

		 		break
		 	case 3:
		 		_localctx =  DataTypeFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 3)
		 		setState(6805)
		 		try match(MySqlParser.Tokens.CONVERT.rawValue)
		 		setState(6806)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6807)
		 		try expression(0)
		 		setState(6808)
		 		try {
		 				let assignmentValue = try match(MySqlParser.Tokens.COMMA.rawValue)
		 				_localctx.castdown(DataTypeFunctionCallContext.self).separator = assignmentValue
		 		     }()

		 		setState(6809)
		 		try convertedDataType()
		 		setState(6810)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 4:
		 		_localctx =  DataTypeFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 4)
		 		setState(6812)
		 		try match(MySqlParser.Tokens.CONVERT.rawValue)
		 		setState(6813)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6814)
		 		try expression(0)
		 		setState(6815)
		 		try match(MySqlParser.Tokens.USING.rawValue)
		 		setState(6816)
		 		try charsetName()
		 		setState(6817)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 5:
		 		_localctx =  DataTypeFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 5)
		 		setState(6819)
		 		try match(MySqlParser.Tokens.CAST.rawValue)
		 		setState(6820)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6821)
		 		try expression(0)
		 		setState(6822)
		 		try match(MySqlParser.Tokens.AS.rawValue)
		 		setState(6823)
		 		try convertedDataType()
		 		setState(6824)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 6:
		 		_localctx =  ValuesFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 6)
		 		setState(6826)
		 		try match(MySqlParser.Tokens.VALUES.rawValue)
		 		setState(6827)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6828)
		 		try fullColumnName()
		 		setState(6829)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 7:
		 		_localctx =  CaseExpressionFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 7)
		 		setState(6831)
		 		try match(MySqlParser.Tokens.CASE.rawValue)
		 		setState(6832)
		 		try expression(0)
		 		setState(6834) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(6833)
		 			try caseFuncAlternative()


		 			setState(6836); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (_la == MySqlParser.Tokens.WHEN.rawValue)
		 		setState(6840)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.ELSE.rawValue) {
		 			setState(6838)
		 			try match(MySqlParser.Tokens.ELSE.rawValue)
		 			setState(6839)
		 			try {
		 					let assignmentValue = try functionArg()
		 					_localctx.castdown(CaseExpressionFunctionCallContext.self).elseArg = assignmentValue
		 			     }()


		 		}

		 		setState(6842)
		 		try match(MySqlParser.Tokens.END.rawValue)

		 		break
		 	case 8:
		 		_localctx =  CaseFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 8)
		 		setState(6844)
		 		try match(MySqlParser.Tokens.CASE.rawValue)
		 		setState(6846) 
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		repeat {
		 			setState(6845)
		 			try caseFuncAlternative()


		 			setState(6848); 
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		} while (_la == MySqlParser.Tokens.WHEN.rawValue)
		 		setState(6852)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.ELSE.rawValue) {
		 			setState(6850)
		 			try match(MySqlParser.Tokens.ELSE.rawValue)
		 			setState(6851)
		 			try {
		 					let assignmentValue = try functionArg()
		 					_localctx.castdown(CaseFunctionCallContext.self).elseArg = assignmentValue
		 			     }()


		 		}

		 		setState(6854)
		 		try match(MySqlParser.Tokens.END.rawValue)

		 		break
		 	case 9:
		 		_localctx =  CharFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 9)
		 		setState(6856)
		 		try match(MySqlParser.Tokens.CHAR.rawValue)
		 		setState(6857)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6858)
		 		try functionArgs()
		 		setState(6861)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.USING.rawValue) {
		 			setState(6859)
		 			try match(MySqlParser.Tokens.USING.rawValue)
		 			setState(6860)
		 			try charsetName()

		 		}

		 		setState(6863)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 10:
		 		_localctx =  PositionFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 10)
		 		setState(6865)
		 		try match(MySqlParser.Tokens.POSITION.rawValue)
		 		setState(6866)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6869)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,1017, _ctx)) {
		 		case 1:
		 			setState(6867)
		 			try {
		 					let assignmentValue = try stringLiteral()
		 					_localctx.castdown(PositionFunctionCallContext.self).positionString = assignmentValue
		 			     }()


		 			break
		 		case 2:
		 			setState(6868)
		 			try {
		 					let assignmentValue = try expression(0)
		 					_localctx.castdown(PositionFunctionCallContext.self).positionExpression = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(6871)
		 		try match(MySqlParser.Tokens.IN.rawValue)
		 		setState(6874)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,1018, _ctx)) {
		 		case 1:
		 			setState(6872)
		 			try {
		 					let assignmentValue = try stringLiteral()
		 					_localctx.castdown(PositionFunctionCallContext.self).inString = assignmentValue
		 			     }()


		 			break
		 		case 2:
		 			setState(6873)
		 			try {
		 					let assignmentValue = try expression(0)
		 					_localctx.castdown(PositionFunctionCallContext.self).inExpression = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(6876)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 11:
		 		_localctx =  SubstrFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 11)
		 		setState(6878)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.SUBSTR.rawValue || _la == MySqlParser.Tokens.SUBSTRING.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6879)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6882)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,1019, _ctx)) {
		 		case 1:
		 			setState(6880)
		 			try {
		 					let assignmentValue = try stringLiteral()
		 					_localctx.castdown(SubstrFunctionCallContext.self).sourceString = assignmentValue
		 			     }()


		 			break
		 		case 2:
		 			setState(6881)
		 			try {
		 					let assignmentValue = try expression(0)
		 					_localctx.castdown(SubstrFunctionCallContext.self).sourceExpression = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(6884)
		 		try match(MySqlParser.Tokens.FROM.rawValue)
		 		setState(6887)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,1020, _ctx)) {
		 		case 1:
		 			setState(6885)
		 			try {
		 					let assignmentValue = try decimalLiteral()
		 					_localctx.castdown(SubstrFunctionCallContext.self).fromDecimal = assignmentValue
		 			     }()


		 			break
		 		case 2:
		 			setState(6886)
		 			try {
		 					let assignmentValue = try expression(0)
		 					_localctx.castdown(SubstrFunctionCallContext.self).fromExpression = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(6894)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.FOR.rawValue) {
		 			setState(6889)
		 			try match(MySqlParser.Tokens.FOR.rawValue)
		 			setState(6892)
		 			try _errHandler.sync(self)
		 			switch(try getInterpreter().adaptivePredict(_input,1021, _ctx)) {
		 			case 1:
		 				setState(6890)
		 				try {
		 						let assignmentValue = try decimalLiteral()
		 						_localctx.castdown(SubstrFunctionCallContext.self).forDecimal = assignmentValue
		 				     }()


		 				break
		 			case 2:
		 				setState(6891)
		 				try {
		 						let assignmentValue = try expression(0)
		 						_localctx.castdown(SubstrFunctionCallContext.self).forExpression = assignmentValue
		 				     }()


		 				break
		 			default: break
		 			}

		 		}

		 		setState(6896)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 12:
		 		_localctx =  TrimFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 12)
		 		setState(6898)
		 		try match(MySqlParser.Tokens.TRIM.rawValue)
		 		setState(6899)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6900)
		 		_localctx.castdown(TrimFunctionCallContext.self).positioinForm = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.BOTH.rawValue || _la == MySqlParser.Tokens.LEADING.rawValue || _la == MySqlParser.Tokens.TRAILING.rawValue)) {
		 			_localctx.castdown(TrimFunctionCallContext.self).positioinForm = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6903)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1023,_ctx)) {
		 		case 1:
		 			setState(6901)
		 			try {
		 					let assignmentValue = try stringLiteral()
		 					_localctx.castdown(TrimFunctionCallContext.self).sourceString = assignmentValue
		 			     }()


		 			break
		 		case 2:
		 			setState(6902)
		 			try {
		 					let assignmentValue = try expression(0)
		 					_localctx.castdown(TrimFunctionCallContext.self).sourceExpression = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(6905)
		 		try match(MySqlParser.Tokens.FROM.rawValue)
		 		setState(6908)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,1024, _ctx)) {
		 		case 1:
		 			setState(6906)
		 			try {
		 					let assignmentValue = try stringLiteral()
		 					_localctx.castdown(TrimFunctionCallContext.self).fromString = assignmentValue
		 			     }()


		 			break
		 		case 2:
		 			setState(6907)
		 			try {
		 					let assignmentValue = try expression(0)
		 					_localctx.castdown(TrimFunctionCallContext.self).fromExpression = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(6910)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 13:
		 		_localctx =  TrimFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 13)
		 		setState(6912)
		 		try match(MySqlParser.Tokens.TRIM.rawValue)
		 		setState(6913)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6916)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,1025, _ctx)) {
		 		case 1:
		 			setState(6914)
		 			try {
		 					let assignmentValue = try stringLiteral()
		 					_localctx.castdown(TrimFunctionCallContext.self).sourceString = assignmentValue
		 			     }()


		 			break
		 		case 2:
		 			setState(6915)
		 			try {
		 					let assignmentValue = try expression(0)
		 					_localctx.castdown(TrimFunctionCallContext.self).sourceExpression = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(6918)
		 		try match(MySqlParser.Tokens.FROM.rawValue)
		 		setState(6921)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,1026, _ctx)) {
		 		case 1:
		 			setState(6919)
		 			try {
		 					let assignmentValue = try stringLiteral()
		 					_localctx.castdown(TrimFunctionCallContext.self).fromString = assignmentValue
		 			     }()


		 			break
		 		case 2:
		 			setState(6920)
		 			try {
		 					let assignmentValue = try expression(0)
		 					_localctx.castdown(TrimFunctionCallContext.self).fromExpression = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(6923)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 14:
		 		_localctx =  WeightFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 14)
		 		setState(6925)
		 		try match(MySqlParser.Tokens.WEIGHT_STRING.rawValue)
		 		setState(6926)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6929)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,1027, _ctx)) {
		 		case 1:
		 			setState(6927)
		 			try stringLiteral()

		 			break
		 		case 2:
		 			setState(6928)
		 			try expression(0)

		 			break
		 		default: break
		 		}
		 		setState(6937)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.AS.rawValue) {
		 			setState(6931)
		 			try match(MySqlParser.Tokens.AS.rawValue)
		 			setState(6932)
		 			_localctx.castdown(WeightFunctionCallContext.self).stringFormat = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.CHAR.rawValue || _la == MySqlParser.Tokens.BINARY.rawValue)) {
		 				_localctx.castdown(WeightFunctionCallContext.self).stringFormat = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}
		 			setState(6933)
		 			try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 			setState(6934)
		 			try decimalLiteral()
		 			setState(6935)
		 			try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		}

		 		setState(6940)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.LEVEL.rawValue) {
		 			setState(6939)
		 			try levelsInWeightString()

		 		}

		 		setState(6942)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 15:
		 		_localctx =  ExtractFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 15)
		 		setState(6944)
		 		try match(MySqlParser.Tokens.EXTRACT.rawValue)
		 		setState(6945)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6946)
		 		try intervalType()
		 		setState(6947)
		 		try match(MySqlParser.Tokens.FROM.rawValue)
		 		setState(6950)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,1030, _ctx)) {
		 		case 1:
		 			setState(6948)
		 			try {
		 					let assignmentValue = try stringLiteral()
		 					_localctx.castdown(ExtractFunctionCallContext.self).sourceString = assignmentValue
		 			     }()


		 			break
		 		case 2:
		 			setState(6949)
		 			try {
		 					let assignmentValue = try expression(0)
		 					_localctx.castdown(ExtractFunctionCallContext.self).sourceExpression = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(6952)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 16:
		 		_localctx =  GetFormatFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 16)
		 		setState(6954)
		 		try match(MySqlParser.Tokens.GET_FORMAT.rawValue)
		 		setState(6955)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6956)
		 		_localctx.castdown(GetFormatFunctionCallContext.self).datetimeFormat = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & 11) != 0))) {
		 			_localctx.castdown(GetFormatFunctionCallContext.self).datetimeFormat = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(6957)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6958)
		 		try stringLiteral()
		 		setState(6959)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case 17:
		 		_localctx =  JsonValueFunctionCallContext(_localctx);
		 		try enterOuterAlt(_localctx, 17)
		 		setState(6961)
		 		try match(MySqlParser.Tokens.JSON_VALUE.rawValue)
		 		setState(6962)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(6963)
		 		try expression(0)
		 		setState(6964)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(6965)
		 		try expression(0)
		 		setState(6968)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.RETURNING.rawValue) {
		 			setState(6966)
		 			try match(MySqlParser.Tokens.RETURNING.rawValue)
		 			setState(6967)
		 			try convertedDataType()

		 		}

		 		setState(6971)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1032,_ctx)) {
		 		case 1:
		 			setState(6970)
		 			try jsonOnEmpty()

		 			break
		 		default: break
		 		}
		 		setState(6974)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.DEFAULT.rawValue || _la == MySqlParser.Tokens.NULL_LITERAL.rawValue || _la == MySqlParser.Tokens.ERROR.rawValue) {
		 			setState(6973)
		 			try jsonOnError()

		 		}

		 		setState(6976)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CaseFuncAlternativeContext: ParserRuleContext {
		open var condition: FunctionArgContext!
		open var consequent: FunctionArgContext!
			open
			func WHEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WHEN.rawValue, 0)
			}
			open
			func THEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.THEN.rawValue, 0)
			}
			open
			func functionArg() -> [FunctionArgContext] {
				return getRuleContexts(FunctionArgContext.self)
			}
			open
			func functionArg(_ i: Int) -> FunctionArgContext? {
				return getRuleContext(FunctionArgContext.self, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_caseFuncAlternative
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCaseFuncAlternative(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCaseFuncAlternative(self)
			}
		}
	}
	@discardableResult
	 open func caseFuncAlternative() throws -> CaseFuncAlternativeContext {
		var _localctx: CaseFuncAlternativeContext
		_localctx = CaseFuncAlternativeContext(_ctx, getState())
		try enterRule(_localctx, 652, MySqlParser.RULE_caseFuncAlternative)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(6980)
		 	try match(MySqlParser.Tokens.WHEN.rawValue)
		 	setState(6981)
		 	try {
		 			let assignmentValue = try functionArg()
		 			_localctx.castdown(CaseFuncAlternativeContext.self).condition = assignmentValue
		 	     }()

		 	setState(6982)
		 	try match(MySqlParser.Tokens.THEN.rawValue)
		 	setState(6983)
		 	try {
		 			let assignmentValue = try functionArg()
		 			_localctx.castdown(CaseFuncAlternativeContext.self).consequent = assignmentValue
		 	     }()


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LevelsInWeightStringContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_levelsInWeightString
		}
	}
	public class LevelWeightRangeContext: LevelsInWeightStringContext {
		public var firstLevel: DecimalLiteralContext!
		public var lastLevel: DecimalLiteralContext!
			open
			func LEVEL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEVEL.rawValue, 0)
			}
			open
			func MINUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUS.rawValue, 0)
			}
			open
			func decimalLiteral() -> [DecimalLiteralContext] {
				return getRuleContexts(DecimalLiteralContext.self)
			}
			open
			func decimalLiteral(_ i: Int) -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, i)
			}

		public
		init(_ ctx: LevelsInWeightStringContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLevelWeightRange(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLevelWeightRange(self)
			}
		}
	}
	public class LevelWeightListContext: LevelsInWeightStringContext {
			open
			func LEVEL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEVEL.rawValue, 0)
			}
			open
			func levelInWeightListElement() -> [LevelInWeightListElementContext] {
				return getRuleContexts(LevelInWeightListElementContext.self)
			}
			open
			func levelInWeightListElement(_ i: Int) -> LevelInWeightListElementContext? {
				return getRuleContext(LevelInWeightListElementContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: LevelsInWeightStringContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLevelWeightList(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLevelWeightList(self)
			}
		}
	}
	@discardableResult
	 open func levelsInWeightString() throws -> LevelsInWeightStringContext {
		var _localctx: LevelsInWeightStringContext
		_localctx = LevelsInWeightStringContext(_ctx, getState())
		try enterRule(_localctx, 654, MySqlParser.RULE_levelsInWeightString)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(6999)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,1036, _ctx)) {
		 	case 1:
		 		_localctx =  LevelWeightListContext(_localctx);
		 		try enterOuterAlt(_localctx, 1)
		 		setState(6985)
		 		try match(MySqlParser.Tokens.LEVEL.rawValue)
		 		setState(6986)
		 		try levelInWeightListElement()
		 		setState(6991)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(6987)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(6988)
		 			try levelInWeightListElement()


		 			setState(6993)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 		}

		 		break
		 	case 2:
		 		_localctx =  LevelWeightRangeContext(_localctx);
		 		try enterOuterAlt(_localctx, 2)
		 		setState(6994)
		 		try match(MySqlParser.Tokens.LEVEL.rawValue)
		 		setState(6995)
		 		try {
		 				let assignmentValue = try decimalLiteral()
		 				_localctx.castdown(LevelWeightRangeContext.self).firstLevel = assignmentValue
		 		     }()

		 		setState(6996)
		 		try match(MySqlParser.Tokens.MINUS.rawValue)
		 		setState(6997)
		 		try {
		 				let assignmentValue = try decimalLiteral()
		 				_localctx.castdown(LevelWeightRangeContext.self).lastLevel = assignmentValue
		 		     }()


		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LevelInWeightListElementContext: ParserRuleContext {
		open var orderType: Token!
			open
			func decimalLiteral() -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, 0)
			}
			open
			func ASC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASC.rawValue, 0)
			}
			open
			func DESC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DESC.rawValue, 0)
			}
			open
			func REVERSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REVERSE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_levelInWeightListElement
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLevelInWeightListElement(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLevelInWeightListElement(self)
			}
		}
	}
	@discardableResult
	 open func levelInWeightListElement() throws -> LevelInWeightListElementContext {
		var _localctx: LevelInWeightListElementContext
		_localctx = LevelInWeightListElementContext(_ctx, getState())
		try enterRule(_localctx, 656, MySqlParser.RULE_levelInWeightListElement)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7001)
		 	try decimalLiteral()
		 	setState(7003)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ASC.rawValue || _la == MySqlParser.Tokens.DESC.rawValue || _la == MySqlParser.Tokens.REVERSE.rawValue) {
		 		setState(7002)
		 		_localctx.castdown(LevelInWeightListElementContext.self).orderType = try _input.LT(1)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.ASC.rawValue || _la == MySqlParser.Tokens.DESC.rawValue || _la == MySqlParser.Tokens.REVERSE.rawValue)) {
		 			_localctx.castdown(LevelInWeightListElementContext.self).orderType = try _errHandler.recoverInline(self) as Token
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AggregateWindowedFunctionContext: ParserRuleContext {
		open var aggregator: Token!
		open var starArg: Token!
		open var separator: Token!
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func functionArg() -> FunctionArgContext? {
				return getRuleContext(FunctionArgContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func AVG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AVG.rawValue, 0)
			}
			open
			func MAX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX.rawValue, 0)
			}
			open
			func MIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MIN.rawValue, 0)
			}
			open
			func SUM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUM.rawValue, 0)
			}
			open
			func overClause() -> OverClauseContext? {
				return getRuleContext(OverClauseContext.self, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func DISTINCT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISTINCT.rawValue, 0)
			}
			open
			func COUNT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COUNT.rawValue, 0)
			}
			open
			func functionArgs() -> FunctionArgsContext? {
				return getRuleContext(FunctionArgsContext.self, 0)
			}
			open
			func STAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STAR.rawValue, 0)
			}
			open
			func BIT_AND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_AND.rawValue, 0)
			}
			open
			func BIT_OR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_OR.rawValue, 0)
			}
			open
			func BIT_XOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_XOR.rawValue, 0)
			}
			open
			func STD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STD.rawValue, 0)
			}
			open
			func STDDEV() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STDDEV.rawValue, 0)
			}
			open
			func STDDEV_POP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STDDEV_POP.rawValue, 0)
			}
			open
			func STDDEV_SAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STDDEV_SAMP.rawValue, 0)
			}
			open
			func VAR_POP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VAR_POP.rawValue, 0)
			}
			open
			func VAR_SAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VAR_SAMP.rawValue, 0)
			}
			open
			func VARIANCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VARIANCE.rawValue, 0)
			}
			open
			func GROUP_CONCAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP_CONCAT.rawValue, 0)
			}
			open
			func ORDER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ORDER.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func orderByExpression() -> [OrderByExpressionContext] {
				return getRuleContexts(OrderByExpressionContext.self)
			}
			open
			func orderByExpression(_ i: Int) -> OrderByExpressionContext? {
				return getRuleContext(OrderByExpressionContext.self, i)
			}
			open
			func SEPARATOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SEPARATOR.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_aggregateWindowedFunction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAggregateWindowedFunction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAggregateWindowedFunction(self)
			}
		}
	}
	@discardableResult
	 open func aggregateWindowedFunction() throws -> AggregateWindowedFunctionContext {
		var _localctx: AggregateWindowedFunctionContext
		_localctx = AggregateWindowedFunctionContext(_ctx, getState())
		try enterRule(_localctx, 658, MySqlParser.RULE_aggregateWindowedFunction)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(7064)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .AVG:fallthrough
		 	case .MAX:fallthrough
		 	case .MIN:fallthrough
		 	case .SUM:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(7005)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 286)) & ~0x3f) == 0 && ((Int64(1) << (_la - 286)) & 8400897) != 0))) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(7006)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(7008)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1038,_ctx)) {
		 		case 1:
		 			setState(7007)
		 			_localctx.castdown(AggregateWindowedFunctionContext.self).aggregator = try _input.LT(1)
		 			_la = try _input.LA(1)
		 			if (!(_la == MySqlParser.Tokens.ALL.rawValue || _la == MySqlParser.Tokens.DISTINCT.rawValue)) {
		 				_localctx.castdown(AggregateWindowedFunctionContext.self).aggregator = try _errHandler.recoverInline(self) as Token
		 			}
		 			else {
		 				_errHandler.reportMatch(self)
		 				try consume()
		 			}

		 			break
		 		default: break
		 		}
		 		setState(7010)
		 		try functionArg()
		 		setState(7011)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(7013)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1039,_ctx)) {
		 		case 1:
		 			setState(7012)
		 			try overClause()

		 			break
		 		default: break
		 		}

		 		break

		 	case .COUNT:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(7015)
		 		try match(MySqlParser.Tokens.COUNT.rawValue)
		 		setState(7016)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(7024)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,1041, _ctx)) {
		 		case 1:
		 			setState(7017)
		 			try {
		 					let assignmentValue = try match(MySqlParser.Tokens.STAR.rawValue)
		 					_localctx.castdown(AggregateWindowedFunctionContext.self).starArg = assignmentValue
		 			     }()


		 			break
		 		case 2:
		 			setState(7019)
		 			try _errHandler.sync(self)
		 			switch (try getInterpreter().adaptivePredict(_input,1040,_ctx)) {
		 			case 1:
		 				setState(7018)
		 				try {
		 						let assignmentValue = try match(MySqlParser.Tokens.ALL.rawValue)
		 						_localctx.castdown(AggregateWindowedFunctionContext.self).aggregator = assignmentValue
		 				     }()


		 				break
		 			default: break
		 			}
		 			setState(7021)
		 			try functionArg()

		 			break
		 		case 3:
		 			setState(7022)
		 			try {
		 					let assignmentValue = try match(MySqlParser.Tokens.DISTINCT.rawValue)
		 					_localctx.castdown(AggregateWindowedFunctionContext.self).aggregator = assignmentValue
		 			     }()

		 			setState(7023)
		 			try functionArgs()

		 			break
		 		default: break
		 		}
		 		setState(7026)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(7028)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1042,_ctx)) {
		 		case 1:
		 			setState(7027)
		 			try overClause()

		 			break
		 		default: break
		 		}

		 		break
		 	case .BIT_AND:fallthrough
		 	case .BIT_OR:fallthrough
		 	case .BIT_XOR:fallthrough
		 	case .STD:fallthrough
		 	case .STDDEV:fallthrough
		 	case .STDDEV_POP:fallthrough
		 	case .STDDEV_SAMP:fallthrough
		 	case .VAR_POP:fallthrough
		 	case .VAR_SAMP:fallthrough
		 	case .VARIANCE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(7030)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 287)) & ~0x3f) == 0 && ((Int64(1) << (_la - 287)) & 62652423) != 0))) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(7031)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(7033)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1043,_ctx)) {
		 		case 1:
		 			setState(7032)
		 			try {
		 					let assignmentValue = try match(MySqlParser.Tokens.ALL.rawValue)
		 					_localctx.castdown(AggregateWindowedFunctionContext.self).aggregator = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(7035)
		 		try functionArg()
		 		setState(7036)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(7038)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1044,_ctx)) {
		 		case 1:
		 			setState(7037)
		 			try overClause()

		 			break
		 		default: break
		 		}

		 		break

		 	case .GROUP_CONCAT:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(7040)
		 		try match(MySqlParser.Tokens.GROUP_CONCAT.rawValue)
		 		setState(7041)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(7043)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1045,_ctx)) {
		 		case 1:
		 			setState(7042)
		 			try {
		 					let assignmentValue = try match(MySqlParser.Tokens.DISTINCT.rawValue)
		 					_localctx.castdown(AggregateWindowedFunctionContext.self).aggregator = assignmentValue
		 			     }()


		 			break
		 		default: break
		 		}
		 		setState(7045)
		 		try functionArgs()
		 		setState(7056)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.ORDER.rawValue) {
		 			setState(7046)
		 			try match(MySqlParser.Tokens.ORDER.rawValue)
		 			setState(7047)
		 			try match(MySqlParser.Tokens.BY.rawValue)
		 			setState(7048)
		 			try orderByExpression()
		 			setState(7053)
		 			try _errHandler.sync(self)
		 			_la = try _input.LA(1)
		 			while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 				setState(7049)
		 				try match(MySqlParser.Tokens.COMMA.rawValue)
		 				setState(7050)
		 				try orderByExpression()


		 				setState(7055)
		 				try _errHandler.sync(self)
		 				_la = try _input.LA(1)
		 			}

		 		}

		 		setState(7060)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.SEPARATOR.rawValue) {
		 			setState(7058)
		 			try match(MySqlParser.Tokens.SEPARATOR.rawValue)
		 			setState(7059)
		 			try {
		 					let assignmentValue = try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)
		 					_localctx.castdown(AggregateWindowedFunctionContext.self).separator = assignmentValue
		 			     }()


		 		}

		 		setState(7062)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class NonAggregateWindowedFunctionContext: ParserRuleContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func overClause() -> OverClauseContext? {
				return getRuleContext(OverClauseContext.self, 0)
			}
			open
			func LAG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LAG.rawValue, 0)
			}
			open
			func LEAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEAD.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
			open
			func decimalLiteral() -> [DecimalLiteralContext] {
				return getRuleContexts(DecimalLiteralContext.self)
			}
			open
			func decimalLiteral(_ i: Int) -> DecimalLiteralContext? {
				return getRuleContext(DecimalLiteralContext.self, i)
			}
			open
			func FIRST_VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIRST_VALUE.rawValue, 0)
			}
			open
			func LAST_VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LAST_VALUE.rawValue, 0)
			}
			open
			func CUME_DIST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CUME_DIST.rawValue, 0)
			}
			open
			func DENSE_RANK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DENSE_RANK.rawValue, 0)
			}
			open
			func PERCENT_RANK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PERCENT_RANK.rawValue, 0)
			}
			open
			func RANK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RANK.rawValue, 0)
			}
			open
			func ROW_NUMBER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROW_NUMBER.rawValue, 0)
			}
			open
			func NTH_VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NTH_VALUE.rawValue, 0)
			}
			open
			func NTILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NTILE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_nonAggregateWindowedFunction
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterNonAggregateWindowedFunction(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitNonAggregateWindowedFunction(self)
			}
		}
	}
	@discardableResult
	 open func nonAggregateWindowedFunction() throws -> NonAggregateWindowedFunctionContext {
		var _localctx: NonAggregateWindowedFunctionContext
		_localctx = NonAggregateWindowedFunctionContext(_ctx, getState())
		try enterRule(_localctx, 660, MySqlParser.RULE_nonAggregateWindowedFunction)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(7104)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LAG:fallthrough
		 	case .LEAD:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(7066)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.LAG.rawValue || _la == MySqlParser.Tokens.LEAD.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(7067)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(7068)
		 		try expression(0)
		 		setState(7071)
		 		try _errHandler.sync(self)
		 		switch (try getInterpreter().adaptivePredict(_input,1050,_ctx)) {
		 		case 1:
		 			setState(7069)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(7070)
		 			try decimalLiteral()

		 			break
		 		default: break
		 		}
		 		setState(7075)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 		if (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 			setState(7073)
		 			try match(MySqlParser.Tokens.COMMA.rawValue)
		 			setState(7074)
		 			try decimalLiteral()

		 		}

		 		setState(7077)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(7078)
		 		try overClause()

		 		break
		 	case .FIRST_VALUE:fallthrough
		 	case .LAST_VALUE:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(7080)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FIRST_VALUE.rawValue || _la == MySqlParser.Tokens.LAST_VALUE.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(7081)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(7082)
		 		try expression(0)
		 		setState(7083)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(7084)
		 		try overClause()

		 		break
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(7086)
		 		_la = try _input.LA(1)
		 		if (!(((Int64((_la - 291)) & ~0x3f) == 0 && ((Int64(1) << (_la - 291)) & 14339) != 0))) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}
		 		setState(7087)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(7088)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(7089)
		 		try overClause()

		 		break

		 	case .NTH_VALUE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(7090)
		 		try match(MySqlParser.Tokens.NTH_VALUE.rawValue)
		 		setState(7091)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(7092)
		 		try expression(0)
		 		setState(7093)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(7094)
		 		try decimalLiteral()
		 		setState(7095)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(7096)
		 		try overClause()

		 		break

		 	case .NTILE:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(7098)
		 		try match(MySqlParser.Tokens.NTILE.rawValue)
		 		setState(7099)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(7100)
		 		try decimalLiteral()
		 		setState(7101)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)
		 		setState(7102)
		 		try overClause()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class OverClauseContext: ParserRuleContext {
			open
			func OVER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OVER.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func windowSpec() -> WindowSpecContext? {
				return getRuleContext(WindowSpecContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func windowName() -> WindowNameContext? {
				return getRuleContext(WindowNameContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_overClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterOverClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitOverClause(self)
			}
		}
	}
	@discardableResult
	 open func overClause() throws -> OverClauseContext {
		var _localctx: OverClauseContext
		_localctx = OverClauseContext(_ctx, getState())
		try enterRule(_localctx, 662, MySqlParser.RULE_overClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7106)
		 	try match(MySqlParser.Tokens.OVER.rawValue)
		 	setState(7112)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LR_BRACKET:
		 		setState(7107)
		 		try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 		setState(7108)
		 		try windowSpec()
		 		setState(7109)
		 		try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		 		break
		 	case .ARRAY:fallthrough
		 	case .ATTRIBUTE:fallthrough
		 	case .BUCKETS:fallthrough
		 	case .CONDITION:fallthrough
		 	case .CURRENT:fallthrough
		 	case .CURRENT_USER:fallthrough
		 	case .DATABASE:fallthrough
		 	case .DEFAULT:fallthrough
		 	case .DIAGNOSTICS:fallthrough
		 	case .EMPTY:fallthrough
		 	case .ENFORCED:fallthrough
		 	case .EXCEPT:fallthrough
		 	case .GROUP:fallthrough
		 	case .IF:fallthrough
		 	case .IGNORED:fallthrough
		 	case .INSERT:fallthrough
		 	case .LATERAL:fallthrough
		 	case .LEFT:fallthrough
		 	case .NUMBER:fallthrough
		 	case .OPTIONAL:fallthrough
		 	case .ORDER:fallthrough
		 	case .PRIMARY:fallthrough
		 	case .REPEAT:fallthrough
		 	case .REPLACE:fallthrough
		 	case .RIGHT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .SKIP_QUERY_REWRITE:fallthrough
		 	case .STACKED:fallthrough
		 	case .DATE:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .DATETIME:fallthrough
		 	case .YEAR:fallthrough
		 	case .BINARY:fallthrough
		 	case .TEXT:fallthrough
		 	case .ENUM:fallthrough
		 	case .SERIAL:fallthrough
		 	case .JSON_ARRAY:fallthrough
		 	case .JSON_ARRAYAGG:fallthrough
		 	case .JSON_ARRAY_APPEND:fallthrough
		 	case .JSON_ARRAY_INSERT:fallthrough
		 	case .JSON_CONTAINS:fallthrough
		 	case .JSON_CONTAINS_PATH:fallthrough
		 	case .JSON_DEPTH:fallthrough
		 	case .JSON_EXTRACT:fallthrough
		 	case .JSON_INSERT:fallthrough
		 	case .JSON_KEYS:fallthrough
		 	case .JSON_LENGTH:fallthrough
		 	case .JSON_MERGE:fallthrough
		 	case .JSON_MERGE_PATCH:fallthrough
		 	case .JSON_MERGE_PRESERVE:fallthrough
		 	case .JSON_OBJECT:fallthrough
		 	case .JSON_OBJECTAGG:fallthrough
		 	case .JSON_OVERLAPS:fallthrough
		 	case .JSON_PRETTY:fallthrough
		 	case .JSON_QUOTE:fallthrough
		 	case .JSON_REMOVE:fallthrough
		 	case .JSON_REPLACE:fallthrough
		 	case .JSON_SCHEMA_VALID:fallthrough
		 	case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 	case .JSON_SEARCH:fallthrough
		 	case .JSON_SET:fallthrough
		 	case .JSON_STORAGE_FREE:fallthrough
		 	case .JSON_STORAGE_SIZE:fallthrough
		 	case .JSON_TABLE:fallthrough
		 	case .JSON_TYPE:fallthrough
		 	case .JSON_UNQUOTE:fallthrough
		 	case .JSON_VALID:fallthrough
		 	case .JSON_VALUE:fallthrough
		 	case .NESTED:fallthrough
		 	case .ORDINALITY:fallthrough
		 	case .PATH:fallthrough
		 	case .AVG:fallthrough
		 	case .BIT_AND:fallthrough
		 	case .BIT_OR:fallthrough
		 	case .BIT_XOR:fallthrough
		 	case .COUNT:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .GROUP_CONCAT:fallthrough
		 	case .LAG:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEAD:fallthrough
		 	case .MAX:fallthrough
		 	case .MIN:fallthrough
		 	case .NTILE:fallthrough
		 	case .NTH_VALUE:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .STD:fallthrough
		 	case .STDDEV:fallthrough
		 	case .STDDEV_POP:fallthrough
		 	case .STDDEV_SAMP:fallthrough
		 	case .SUM:fallthrough
		 	case .VAR_POP:fallthrough
		 	case .VAR_SAMP:fallthrough
		 	case .VARIANCE:fallthrough
		 	case .CURRENT_DATE:fallthrough
		 	case .CURRENT_TIME:fallthrough
		 	case .CURRENT_TIMESTAMP:fallthrough
		 	case .LOCALTIME:fallthrough
		 	case .CURDATE:fallthrough
		 	case .CURTIME:fallthrough
		 	case .DATE_ADD:fallthrough
		 	case .DATE_SUB:fallthrough
		 	case .LOCALTIMESTAMP:fallthrough
		 	case .NOW:fallthrough
		 	case .POSITION:fallthrough
		 	case .SUBSTR:fallthrough
		 	case .SUBSTRING:fallthrough
		 	case .SYSDATE:fallthrough
		 	case .TRIM:fallthrough
		 	case .UTC_DATE:fallthrough
		 	case .UTC_TIME:fallthrough
		 	case .UTC_TIMESTAMP:fallthrough
		 	case .ACCOUNT:fallthrough
		 	case .ACTION:fallthrough
		 	case .AFTER:fallthrough
		 	case .AGGREGATE:fallthrough
		 	case .ALGORITHM:fallthrough
		 	case .ANY:fallthrough
		 	case .AT:fallthrough
		 	case .AUTHORS:fallthrough
		 	case .AUTOCOMMIT:fallthrough
		 	case .AUTOEXTEND_SIZE:fallthrough
		 	case .AUTO_INCREMENT:fallthrough
		 	case .AVG_ROW_LENGTH:fallthrough
		 	case .BEGIN:fallthrough
		 	case .BINLOG:fallthrough
		 	case .BIT:fallthrough
		 	case .BLOCK:fallthrough
		 	case .BOOL:fallthrough
		 	case .BOOLEAN:fallthrough
		 	case .BTREE:fallthrough
		 	case .CACHE:fallthrough
		 	case .CASCADED:fallthrough
		 	case .CHAIN:fallthrough
		 	case .CHANGED:fallthrough
		 	case .CHANNEL:fallthrough
		 	case .CHECKSUM:fallthrough
		 	case .PAGE_CHECKSUM:fallthrough
		 	case .CIPHER:fallthrough
		 	case .CLASS_ORIGIN:fallthrough
		 	case .CLIENT:fallthrough
		 	case .CLOSE:fallthrough
		 	case .CLUSTERING:fallthrough
		 	case .COALESCE:fallthrough
		 	case .CODE:fallthrough
		 	case .COLUMNS:fallthrough
		 	case .COLUMN_FORMAT:fallthrough
		 	case .COLUMN_NAME:fallthrough
		 	case .COMMENT:fallthrough
		 	case .COMMIT:fallthrough
		 	case .COMPACT:fallthrough
		 	case .COMPLETION:fallthrough
		 	case .COMPRESSED:fallthrough
		 	case .COMPRESSION:fallthrough
		 	case .CONCURRENT:fallthrough
		 	case .CONNECT:fallthrough
		 	case .CONNECTION:fallthrough
		 	case .CONSISTENT:fallthrough
		 	case .CONSTRAINT_CATALOG:fallthrough
		 	case .CONSTRAINT_SCHEMA:fallthrough
		 	case .CONSTRAINT_NAME:fallthrough
		 	case .CONTAINS:fallthrough
		 	case .CONTEXT:fallthrough
		 	case .CONTRIBUTORS:fallthrough
		 	case .COPY:fallthrough
		 	case .CPU:fallthrough
		 	case .CURSOR_NAME:fallthrough
		 	case .DATA:fallthrough
		 	case .DATAFILE:fallthrough
		 	case .DEALLOCATE:fallthrough
		 	case .DEFAULT_AUTH:fallthrough
		 	case .DEFINER:fallthrough
		 	case .DELAY_KEY_WRITE:fallthrough
		 	case .DES_KEY_FILE:fallthrough
		 	case .DIRECTORY:fallthrough
		 	case .DISABLE:fallthrough
		 	case .DISCARD:fallthrough
		 	case .DISK:fallthrough
		 	case .DO:fallthrough
		 	case .DUMPFILE:fallthrough
		 	case .DUPLICATE:fallthrough
		 	case .DYNAMIC:fallthrough
		 	case .ENABLE:fallthrough
		 	case .ENCRYPTION:fallthrough
		 	case .END:fallthrough
		 	case .ENDS:fallthrough
		 	case .ENGINE:fallthrough
		 	case .ENGINES:fallthrough
		 	case .ERROR:fallthrough
		 	case .ERRORS:fallthrough
		 	case .ESCAPE:fallthrough
		 	case .EVEN:fallthrough
		 	case .EVENT:fallthrough
		 	case .EVENTS:fallthrough
		 	case .EVERY:fallthrough
		 	case .EXCHANGE:fallthrough
		 	case .EXCLUSIVE:fallthrough
		 	case .EXPIRE:fallthrough
		 	case .EXPORT:fallthrough
		 	case .EXTENDED:fallthrough
		 	case .EXTENT_SIZE:fallthrough
		 	case .FAILED_LOGIN_ATTEMPTS:fallthrough
		 	case .FAST:fallthrough
		 	case .FAULTS:fallthrough
		 	case .FIELDS:fallthrough
		 	case .FILE_BLOCK_SIZE:fallthrough
		 	case .FILTER:fallthrough
		 	case .FIRST:fallthrough
		 	case .FIXED:fallthrough
		 	case .FLUSH:fallthrough
		 	case .FOLLOWS:fallthrough
		 	case .FOUND:fallthrough
		 	case .FULL:fallthrough
		 	case .FUNCTION:fallthrough
		 	case .GENERAL:fallthrough
		 	case .GLOBAL:fallthrough
		 	case .GRANTS:fallthrough
		 	case .GROUP_REPLICATION:fallthrough
		 	case .HANDLER:fallthrough
		 	case .HASH:fallthrough
		 	case .HELP:fallthrough
		 	case .HISTORY:fallthrough
		 	case .HOST:fallthrough
		 	case .HOSTS:fallthrough
		 	case .IDENTIFIED:fallthrough
		 	case .IGNORE_SERVER_IDS:fallthrough
		 	case .IMPORT:fallthrough
		 	case .INDEXES:fallthrough
		 	case .INITIAL_SIZE:fallthrough
		 	case .INPLACE:fallthrough
		 	case .INSERT_METHOD:fallthrough
		 	case .INSTALL:fallthrough
		 	case .INSTANCE:fallthrough
		 	case .INSTANT:fallthrough
		 	case .INVISIBLE:fallthrough
		 	case .INVOKER:fallthrough
		 	case .IO:fallthrough
		 	case .IO_THREAD:fallthrough
		 	case .IPC:fallthrough
		 	case .ISOLATION:fallthrough
		 	case .ISSUER:fallthrough
		 	case .JSON:fallthrough
		 	case .KEY_BLOCK_SIZE:fallthrough
		 	case .LANGUAGE:fallthrough
		 	case .LAST:fallthrough
		 	case .LEAVES:fallthrough
		 	case .LESS:fallthrough
		 	case .LEVEL:fallthrough
		 	case .LIST:fallthrough
		 	case .LOCAL:fallthrough
		 	case .LOGFILE:fallthrough
		 	case .LOGS:fallthrough
		 	case .MASTER:fallthrough
		 	case .MASTER_AUTO_POSITION:fallthrough
		 	case .MASTER_CONNECT_RETRY:fallthrough
		 	case .MASTER_DELAY:fallthrough
		 	case .MASTER_HEARTBEAT_PERIOD:fallthrough
		 	case .MASTER_HOST:fallthrough
		 	case .MASTER_LOG_FILE:fallthrough
		 	case .MASTER_LOG_POS:fallthrough
		 	case .MASTER_PASSWORD:fallthrough
		 	case .MASTER_PORT:fallthrough
		 	case .MASTER_RETRY_COUNT:fallthrough
		 	case .MASTER_SSL:fallthrough
		 	case .MASTER_SSL_CA:fallthrough
		 	case .MASTER_SSL_CAPATH:fallthrough
		 	case .MASTER_SSL_CERT:fallthrough
		 	case .MASTER_SSL_CIPHER:fallthrough
		 	case .MASTER_SSL_CRL:fallthrough
		 	case .MASTER_SSL_CRLPATH:fallthrough
		 	case .MASTER_SSL_KEY:fallthrough
		 	case .MASTER_TLS_VERSION:fallthrough
		 	case .MASTER_USER:fallthrough
		 	case .MAX_CONNECTIONS_PER_HOUR:fallthrough
		 	case .MAX_QUERIES_PER_HOUR:fallthrough
		 	case .MAX_ROWS:fallthrough
		 	case .MAX_SIZE:fallthrough
		 	case .MAX_UPDATES_PER_HOUR:fallthrough
		 	case .MAX_USER_CONNECTIONS:fallthrough
		 	case .MEDIUM:fallthrough
		 	case .MEMBER:fallthrough
		 	case .MERGE:fallthrough
		 	case .MESSAGE_TEXT:fallthrough
		 	case .MID:fallthrough
		 	case .MIGRATE:fallthrough
		 	case .MIN_ROWS:fallthrough
		 	case .MODE:fallthrough
		 	case .MODIFY:fallthrough
		 	case .MUTEX:fallthrough
		 	case .MYSQL:fallthrough
		 	case .MYSQL_ERRNO:fallthrough
		 	case .NAME:fallthrough
		 	case .NAMES:fallthrough
		 	case .NCHAR:fallthrough
		 	case .NEVER:fallthrough
		 	case .NEXT:fallthrough
		 	case .NO:fallthrough
		 	case .NOCOPY:fallthrough
		 	case .NOWAIT:fallthrough
		 	case .NODEGROUP:fallthrough
		 	case .NONE:fallthrough
		 	case .ODBC:fallthrough
		 	case .OFFLINE:fallthrough
		 	case .OFFSET:fallthrough
		 	case .OF:fallthrough
		 	case .OJ:fallthrough
		 	case .OLD_PASSWORD:fallthrough
		 	case .ONE:fallthrough
		 	case .ONLINE:fallthrough
		 	case .ONLY:fallthrough
		 	case .OPEN:fallthrough
		 	case .OPTIMIZER_COSTS:fallthrough
		 	case .OPTIONS:fallthrough
		 	case .OWNER:fallthrough
		 	case .PACK_KEYS:fallthrough
		 	case .PAGE:fallthrough
		 	case .PARSER:fallthrough
		 	case .PARTIAL:fallthrough
		 	case .PARTITIONING:fallthrough
		 	case .PARTITIONS:fallthrough
		 	case .PASSWORD:fallthrough
		 	case .PASSWORD_LOCK_TIME:fallthrough
		 	case .PHASE:fallthrough
		 	case .PLUGIN:fallthrough
		 	case .PLUGIN_DIR:fallthrough
		 	case .PLUGINS:fallthrough
		 	case .PORT:fallthrough
		 	case .PRECEDES:fallthrough
		 	case .PREPARE:fallthrough
		 	case .PRESERVE:fallthrough
		 	case .PREV:fallthrough
		 	case .PROCESSLIST:fallthrough
		 	case .PROFILE:fallthrough
		 	case .PROFILES:fallthrough
		 	case .PROXY:fallthrough
		 	case .QUERY:fallthrough
		 	case .QUICK:fallthrough
		 	case .REBUILD:fallthrough
		 	case .RECOVER:fallthrough
		 	case .RECURSIVE:fallthrough
		 	case .REDO_BUFFER_SIZE:fallthrough
		 	case .REDUNDANT:fallthrough
		 	case .RELAY:fallthrough
		 	case .RELAY_LOG_FILE:fallthrough
		 	case .RELAY_LOG_POS:fallthrough
		 	case .RELAYLOG:fallthrough
		 	case .REMOVE:fallthrough
		 	case .REORGANIZE:fallthrough
		 	case .REPAIR:fallthrough
		 	case .REPLICATE_DO_DB:fallthrough
		 	case .REPLICATE_DO_TABLE:fallthrough
		 	case .REPLICATE_IGNORE_DB:fallthrough
		 	case .REPLICATE_IGNORE_TABLE:fallthrough
		 	case .REPLICATE_REWRITE_DB:fallthrough
		 	case .REPLICATE_WILD_DO_TABLE:fallthrough
		 	case .REPLICATE_WILD_IGNORE_TABLE:fallthrough
		 	case .REPLICATION:fallthrough
		 	case .RESET:fallthrough
		 	case .RESUME:fallthrough
		 	case .RETURNED_SQLSTATE:fallthrough
		 	case .RETURNING:fallthrough
		 	case .RETURNS:fallthrough
		 	case .REUSE:fallthrough
		 	case .ROLE:fallthrough
		 	case .ROLLBACK:fallthrough
		 	case .ROLLUP:fallthrough
		 	case .ROTATE:fallthrough
		 	case .ROW:fallthrough
		 	case .ROWS:fallthrough
		 	case .ROW_FORMAT:fallthrough
		 	case .RTREE:fallthrough
		 	case .SAVEPOINT:fallthrough
		 	case .SCHEDULE:fallthrough
		 	case .SECURITY:fallthrough
		 	case .SERVER:fallthrough
		 	case .SESSION:fallthrough
		 	case .SHARE:fallthrough
		 	case .SHARED:fallthrough
		 	case .SIGNED:fallthrough
		 	case .SIMPLE:fallthrough
		 	case .SLAVE:fallthrough
		 	case .SLOW:fallthrough
		 	case .SNAPSHOT:fallthrough
		 	case .SOCKET:fallthrough
		 	case .SOME:fallthrough
		 	case .SONAME:fallthrough
		 	case .SOUNDS:fallthrough
		 	case .SOURCE:fallthrough
		 	case .SQL_AFTER_GTIDS:fallthrough
		 	case .SQL_AFTER_MTS_GAPS:fallthrough
		 	case .SQL_BEFORE_GTIDS:fallthrough
		 	case .SQL_BUFFER_RESULT:fallthrough
		 	case .SQL_CACHE:fallthrough
		 	case .SQL_NO_CACHE:fallthrough
		 	case .SQL_THREAD:fallthrough
		 	case .START:fallthrough
		 	case .STARTS:fallthrough
		 	case .STATS_AUTO_RECALC:fallthrough
		 	case .STATS_PERSISTENT:fallthrough
		 	case .STATS_SAMPLE_PAGES:fallthrough
		 	case .STATUS:fallthrough
		 	case .STOP:fallthrough
		 	case .STORAGE:fallthrough
		 	case .STRING:fallthrough
		 	case .SUBCLASS_ORIGIN:fallthrough
		 	case .SUBJECT:fallthrough
		 	case .SUBPARTITION:fallthrough
		 	case .SUBPARTITIONS:fallthrough
		 	case .SUSPEND:fallthrough
		 	case .SWAPS:fallthrough
		 	case .SWITCHES:fallthrough
		 	case .TABLE_NAME:fallthrough
		 	case .TABLESPACE:fallthrough
		 	case .TABLE_TYPE:fallthrough
		 	case .TEMPORARY:fallthrough
		 	case .TEMPTABLE:fallthrough
		 	case .THAN:fallthrough
		 	case .TRADITIONAL:fallthrough
		 	case .TRANSACTION:fallthrough
		 	case .TRANSACTIONAL:fallthrough
		 	case .TRIGGERS:fallthrough
		 	case .TRUNCATE:fallthrough
		 	case .UNBOUNDED:fallthrough
		 	case .UNDEFINED:fallthrough
		 	case .UNDOFILE:fallthrough
		 	case .UNDO_BUFFER_SIZE:fallthrough
		 	case .UNINSTALL:fallthrough
		 	case .UNKNOWN:fallthrough
		 	case .UNTIL:fallthrough
		 	case .UPGRADE:fallthrough
		 	case .USER:fallthrough
		 	case .USE_FRM:fallthrough
		 	case .USER_RESOURCES:fallthrough
		 	case .VALIDATION:fallthrough
		 	case .VALUE:fallthrough
		 	case .VARIABLES:fallthrough
		 	case .VIEW:fallthrough
		 	case .VIRTUAL:fallthrough
		 	case .VISIBLE:fallthrough
		 	case .WAIT:fallthrough
		 	case .WARNINGS:fallthrough
		 	case .WITHOUT:fallthrough
		 	case .WORK:fallthrough
		 	case .WRAPPER:fallthrough
		 	case .X509:fallthrough
		 	case .XA:fallthrough
		 	case .XML:fallthrough
		 	case .EUR:fallthrough
		 	case .USA:fallthrough
		 	case .JIS:fallthrough
		 	case .ISO:fallthrough
		 	case .INTERNAL:fallthrough
		 	case .QUARTER:fallthrough
		 	case .MONTH:fallthrough
		 	case .DAY:fallthrough
		 	case .HOUR:fallthrough
		 	case .MINUTE:fallthrough
		 	case .WEEK:fallthrough
		 	case .SECOND:fallthrough
		 	case .MICROSECOND:fallthrough
		 	case .ADMIN:fallthrough
		 	case .AUDIT_ABORT_EXEMPT:fallthrough
		 	case .AUDIT_ADMIN:fallthrough
		 	case .AUTHENTICATION_POLICY_ADMIN:fallthrough
		 	case .BACKUP_ADMIN:fallthrough
		 	case .BINLOG_ADMIN:fallthrough
		 	case .BINLOG_ENCRYPTION_ADMIN:fallthrough
		 	case .CLONE_ADMIN:fallthrough
		 	case .CONNECTION_ADMIN:fallthrough
		 	case .ENCRYPTION_KEY_ADMIN:fallthrough
		 	case .EXECUTE:fallthrough
		 	case .FILE:fallthrough
		 	case .FIREWALL_ADMIN:fallthrough
		 	case .FIREWALL_EXEMPT:fallthrough
		 	case .FIREWALL_USER:fallthrough
		 	case .GROUP_REPLICATION_ADMIN:fallthrough
		 	case .INNODB_REDO_LOG_ARCHIVE:fallthrough
		 	case .INVOKE:fallthrough
		 	case .LAMBDA:fallthrough
		 	case .NDB_STORED_USER:fallthrough
		 	case .PASSWORDLESS_USER_ADMIN:fallthrough
		 	case .PERSIST_RO_VARIABLES_ADMIN:fallthrough
		 	case .PRIVILEGES:fallthrough
		 	case .PROCESS:fallthrough
		 	case .RELOAD:fallthrough
		 	case .REPLICATION_APPLIER:fallthrough
		 	case .REPLICATION_SLAVE_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_ADMIN:fallthrough
		 	case .RESOURCE_GROUP_USER:fallthrough
		 	case .ROLE_ADMIN:fallthrough
		 	case .ROUTINE:fallthrough
		 	case .S3:fallthrough
		 	case .SESSION_VARIABLES_ADMIN:fallthrough
		 	case .SET_USER_ID:fallthrough
		 	case .SHOW_ROUTINE:fallthrough
		 	case .SHUTDOWN:fallthrough
		 	case .SUPER:fallthrough
		 	case .SYSTEM_VARIABLES_ADMIN:fallthrough
		 	case .TABLES:fallthrough
		 	case .TABLE_ENCRYPTION_ADMIN:fallthrough
		 	case .VERSION_TOKEN_ADMIN:fallthrough
		 	case .XA_RECOVER_ADMIN:fallthrough
		 	case .ARMSCII8:fallthrough
		 	case .ASCII:fallthrough
		 	case .BIG5:fallthrough
		 	case .CP1250:fallthrough
		 	case .CP1251:fallthrough
		 	case .CP1256:fallthrough
		 	case .CP1257:fallthrough
		 	case .CP850:fallthrough
		 	case .CP852:fallthrough
		 	case .CP866:fallthrough
		 	case .CP932:fallthrough
		 	case .DEC8:fallthrough
		 	case .EUCJPMS:fallthrough
		 	case .EUCKR:fallthrough
		 	case .GB18030:fallthrough
		 	case .GB2312:fallthrough
		 	case .GBK:fallthrough
		 	case .GEOSTD8:fallthrough
		 	case .GREEK:fallthrough
		 	case .HEBREW:fallthrough
		 	case .HP8:fallthrough
		 	case .KEYBCS2:fallthrough
		 	case .KOI8R:fallthrough
		 	case .KOI8U:fallthrough
		 	case .LATIN1:fallthrough
		 	case .LATIN2:fallthrough
		 	case .LATIN5:fallthrough
		 	case .LATIN7:fallthrough
		 	case .MACCE:fallthrough
		 	case .MACROMAN:fallthrough
		 	case .SJIS:fallthrough
		 	case .SWE7:fallthrough
		 	case .TIS620:fallthrough
		 	case .UCS2:fallthrough
		 	case .UJIS:fallthrough
		 	case .UTF16:fallthrough
		 	case .UTF16LE:fallthrough
		 	case .UTF32:fallthrough
		 	case .UTF8:fallthrough
		 	case .UTF8MB3:fallthrough
		 	case .UTF8MB4:fallthrough
		 	case .ARCHIVE:fallthrough
		 	case .BLACKHOLE:fallthrough
		 	case .CSV:fallthrough
		 	case .FEDERATED:fallthrough
		 	case .INNODB:fallthrough
		 	case .MEMORY:fallthrough
		 	case .MRG_MYISAM:fallthrough
		 	case .MYISAM:fallthrough
		 	case .NDB:fallthrough
		 	case .NDBCLUSTER:fallthrough
		 	case .PERFORMANCE_SCHEMA:fallthrough
		 	case .TOKUDB:fallthrough
		 	case .REPEATABLE:fallthrough
		 	case .COMMITTED:fallthrough
		 	case .UNCOMMITTED:fallthrough
		 	case .SERIALIZABLE:fallthrough
		 	case .GEOMETRYCOLLECTION:fallthrough
		 	case .LINESTRING:fallthrough
		 	case .MULTILINESTRING:fallthrough
		 	case .MULTIPOINT:fallthrough
		 	case .MULTIPOLYGON:fallthrough
		 	case .POINT:fallthrough
		 	case .POLYGON:fallthrough
		 	case .ABS:fallthrough
		 	case .ACOS:fallthrough
		 	case .ADDDATE:fallthrough
		 	case .ADDTIME:fallthrough
		 	case .AES_DECRYPT:fallthrough
		 	case .AES_ENCRYPT:fallthrough
		 	case .AREA:fallthrough
		 	case .ASBINARY:fallthrough
		 	case .ASIN:fallthrough
		 	case .ASTEXT:fallthrough
		 	case .ASWKB:fallthrough
		 	case .ASWKT:fallthrough
		 	case .ASYMMETRIC_DECRYPT:fallthrough
		 	case .ASYMMETRIC_DERIVE:fallthrough
		 	case .ASYMMETRIC_ENCRYPT:fallthrough
		 	case .ASYMMETRIC_SIGN:fallthrough
		 	case .ASYMMETRIC_VERIFY:fallthrough
		 	case .ATAN:fallthrough
		 	case .ATAN2:fallthrough
		 	case .BENCHMARK:fallthrough
		 	case .BIN:fallthrough
		 	case .BIT_COUNT:fallthrough
		 	case .BIT_LENGTH:fallthrough
		 	case .BUFFER:fallthrough
		 	case .CATALOG_NAME:fallthrough
		 	case .CEIL:fallthrough
		 	case .CEILING:fallthrough
		 	case .CENTROID:fallthrough
		 	case .CHARACTER_LENGTH:fallthrough
		 	case .CHARSET:fallthrough
		 	case .CHAR_LENGTH:fallthrough
		 	case .COERCIBILITY:fallthrough
		 	case .COLLATION:fallthrough
		 	case .COMPRESS:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_WS:fallthrough
		 	case .CONNECTION_ID:fallthrough
		 	case .CONV:fallthrough
		 	case .CONVERT_TZ:fallthrough
		 	case .COS:fallthrough
		 	case .COT:fallthrough
		 	case .CRC32:fallthrough
		 	case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 	case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 	case .CREATE_DH_PARAMETERS:fallthrough
		 	case .CREATE_DIGEST:fallthrough
		 	case .CROSSES:fallthrough
		 	case .DATEDIFF:fallthrough
		 	case .DATE_FORMAT:fallthrough
		 	case .DAYNAME:fallthrough
		 	case .DAYOFMONTH:fallthrough
		 	case .DAYOFWEEK:fallthrough
		 	case .DAYOFYEAR:fallthrough
		 	case .DECODE:fallthrough
		 	case .DEGREES:fallthrough
		 	case .DES_DECRYPT:fallthrough
		 	case .DES_ENCRYPT:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISJOINT:fallthrough
		 	case .ELT:fallthrough
		 	case .ENCODE:fallthrough
		 	case .ENCRYPT:fallthrough
		 	case .ENDPOINT:fallthrough
		 	case .ENGINE_ATTRIBUTE:fallthrough
		 	case .ENVELOPE:fallthrough
		 	case .EQUALS:fallthrough
		 	case .EXP:fallthrough
		 	case .EXPORT_SET:fallthrough
		 	case .EXTERIORRING:fallthrough
		 	case .EXTRACTVALUE:fallthrough
		 	case .FIELD:fallthrough
		 	case .FIND_IN_SET:fallthrough
		 	case .FLOOR:fallthrough
		 	case .FORMAT:fallthrough
		 	case .FOUND_ROWS:fallthrough
		 	case .FROM_BASE64:fallthrough
		 	case .FROM_DAYS:fallthrough
		 	case .FROM_UNIXTIME:fallthrough
		 	case .GEOMCOLLFROMTEXT:fallthrough
		 	case .GEOMCOLLFROMWKB:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .GEOMETRYFROMTEXT:fallthrough
		 	case .GEOMETRYFROMWKB:fallthrough
		 	case .GEOMETRYN:fallthrough
		 	case .GEOMETRYTYPE:fallthrough
		 	case .GEOMFROMTEXT:fallthrough
		 	case .GEOMFROMWKB:fallthrough
		 	case .GET_FORMAT:fallthrough
		 	case .GET_LOCK:fallthrough
		 	case .GLENGTH:fallthrough
		 	case .GREATEST:fallthrough
		 	case .GTID_SUBSET:fallthrough
		 	case .GTID_SUBTRACT:fallthrough
		 	case .HEX:fallthrough
		 	case .IFNULL:fallthrough
		 	case .INET6_ATON:fallthrough
		 	case .INET6_NTOA:fallthrough
		 	case .INET_ATON:fallthrough
		 	case .INET_NTOA:fallthrough
		 	case .INSTR:fallthrough
		 	case .INTERIORRINGN:fallthrough
		 	case .INTERSECTS:fallthrough
		 	case .ISCLOSED:fallthrough
		 	case .ISEMPTY:fallthrough
		 	case .ISNULL:fallthrough
		 	case .ISSIMPLE:fallthrough
		 	case .IS_FREE_LOCK:fallthrough
		 	case .IS_IPV4:fallthrough
		 	case .IS_IPV4_COMPAT:fallthrough
		 	case .IS_IPV4_MAPPED:fallthrough
		 	case .IS_IPV6:fallthrough
		 	case .IS_USED_LOCK:fallthrough
		 	case .LAST_INSERT_ID:fallthrough
		 	case .LCASE:fallthrough
		 	case .LEAST:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LINEFROMTEXT:fallthrough
		 	case .LINEFROMWKB:fallthrough
		 	case .LINESTRINGFROMTEXT:fallthrough
		 	case .LINESTRINGFROMWKB:fallthrough
		 	case .LN:fallthrough
		 	case .LOAD_FILE:fallthrough
		 	case .LOCATE:fallthrough
		 	case .LOG:fallthrough
		 	case .LOG10:fallthrough
		 	case .LOG2:fallthrough
		 	case .LOWER:fallthrough
		 	case .LPAD:fallthrough
		 	case .LTRIM:fallthrough
		 	case .MAKEDATE:fallthrough
		 	case .MAKETIME:fallthrough
		 	case .MAKE_SET:fallthrough
		 	case .MASTER_POS_WAIT:fallthrough
		 	case .MBRCONTAINS:fallthrough
		 	case .MBRDISJOINT:fallthrough
		 	case .MBREQUAL:fallthrough
		 	case .MBRINTERSECTS:fallthrough
		 	case .MBROVERLAPS:fallthrough
		 	case .MBRTOUCHES:fallthrough
		 	case .MBRWITHIN:fallthrough
		 	case .MD5:fallthrough
		 	case .MLINEFROMTEXT:fallthrough
		 	case .MLINEFROMWKB:fallthrough
		 	case .MONTHNAME:fallthrough
		 	case .MPOINTFROMTEXT:fallthrough
		 	case .MPOINTFROMWKB:fallthrough
		 	case .MPOLYFROMTEXT:fallthrough
		 	case .MPOLYFROMWKB:fallthrough
		 	case .MULTILINESTRINGFROMTEXT:fallthrough
		 	case .MULTILINESTRINGFROMWKB:fallthrough
		 	case .MULTIPOINTFROMTEXT:fallthrough
		 	case .MULTIPOINTFROMWKB:fallthrough
		 	case .MULTIPOLYGONFROMTEXT:fallthrough
		 	case .MULTIPOLYGONFROMWKB:fallthrough
		 	case .NAME_CONST:fallthrough
		 	case .NULLIF:fallthrough
		 	case .NUMGEOMETRIES:fallthrough
		 	case .NUMINTERIORRINGS:fallthrough
		 	case .NUMPOINTS:fallthrough
		 	case .OCT:fallthrough
		 	case .OCTET_LENGTH:fallthrough
		 	case .ORD:fallthrough
		 	case .OVERLAPS:fallthrough
		 	case .PERIOD_ADD:fallthrough
		 	case .PERIOD_DIFF:fallthrough
		 	case .PI:fallthrough
		 	case .POINTFROMTEXT:fallthrough
		 	case .POINTFROMWKB:fallthrough
		 	case .POINTN:fallthrough
		 	case .POLYFROMTEXT:fallthrough
		 	case .POLYFROMWKB:fallthrough
		 	case .POLYGONFROMTEXT:fallthrough
		 	case .POLYGONFROMWKB:fallthrough
		 	case .POW:fallthrough
		 	case .POWER:fallthrough
		 	case .QUOTE:fallthrough
		 	case .RADIANS:fallthrough
		 	case .RAND:fallthrough
		 	case .RANDOM:fallthrough
		 	case .RANDOM_BYTES:fallthrough
		 	case .RELEASE_LOCK:fallthrough
		 	case .REVERSE:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_COUNT:fallthrough
		 	case .RPAD:fallthrough
		 	case .RTRIM:fallthrough
		 	case .SEC_TO_TIME:fallthrough
		 	case .SECONDARY_ENGINE_ATTRIBUTE:fallthrough
		 	case .SESSION_USER:fallthrough
		 	case .SHA:fallthrough
		 	case .SHA1:fallthrough
		 	case .SHA2:fallthrough
		 	case .SCHEMA_NAME:fallthrough
		 	case .SIGN:fallthrough
		 	case .SIN:fallthrough
		 	case .SLEEP:fallthrough
		 	case .SOUNDEX:fallthrough
		 	case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 	case .SQRT:fallthrough
		 	case .SRID:fallthrough
		 	case .STARTPOINT:fallthrough
		 	case .STRCMP:fallthrough
		 	case .STR_TO_DATE:fallthrough
		 	case .ST_AREA:fallthrough
		 	case .ST_ASBINARY:fallthrough
		 	case .ST_ASTEXT:fallthrough
		 	case .ST_ASWKB:fallthrough
		 	case .ST_ASWKT:fallthrough
		 	case .ST_BUFFER:fallthrough
		 	case .ST_CENTROID:fallthrough
		 	case .ST_CONTAINS:fallthrough
		 	case .ST_CROSSES:fallthrough
		 	case .ST_DIFFERENCE:fallthrough
		 	case .ST_DIMENSION:fallthrough
		 	case .ST_DISJOINT:fallthrough
		 	case .ST_DISTANCE:fallthrough
		 	case .ST_ENDPOINT:fallthrough
		 	case .ST_ENVELOPE:fallthrough
		 	case .ST_EQUALS:fallthrough
		 	case .ST_EXTERIORRING:fallthrough
		 	case .ST_GEOMCOLLFROMTEXT:fallthrough
		 	case .ST_GEOMCOLLFROMTXT:fallthrough
		 	case .ST_GEOMCOLLFROMWKB:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .ST_GEOMETRYFROMTEXT:fallthrough
		 	case .ST_GEOMETRYFROMWKB:fallthrough
		 	case .ST_GEOMETRYN:fallthrough
		 	case .ST_GEOMETRYTYPE:fallthrough
		 	case .ST_GEOMFROMTEXT:fallthrough
		 	case .ST_GEOMFROMWKB:fallthrough
		 	case .ST_INTERIORRINGN:fallthrough
		 	case .ST_INTERSECTION:fallthrough
		 	case .ST_INTERSECTS:fallthrough
		 	case .ST_ISCLOSED:fallthrough
		 	case .ST_ISEMPTY:fallthrough
		 	case .ST_ISSIMPLE:fallthrough
		 	case .ST_LINEFROMTEXT:fallthrough
		 	case .ST_LINEFROMWKB:fallthrough
		 	case .ST_LINESTRINGFROMTEXT:fallthrough
		 	case .ST_LINESTRINGFROMWKB:fallthrough
		 	case .ST_NUMGEOMETRIES:fallthrough
		 	case .ST_NUMINTERIORRING:fallthrough
		 	case .ST_NUMINTERIORRINGS:fallthrough
		 	case .ST_NUMPOINTS:fallthrough
		 	case .ST_OVERLAPS:fallthrough
		 	case .ST_POINTFROMTEXT:fallthrough
		 	case .ST_POINTFROMWKB:fallthrough
		 	case .ST_POINTN:fallthrough
		 	case .ST_POLYFROMTEXT:fallthrough
		 	case .ST_POLYFROMWKB:fallthrough
		 	case .ST_POLYGONFROMTEXT:fallthrough
		 	case .ST_POLYGONFROMWKB:fallthrough
		 	case .ST_SRID:fallthrough
		 	case .ST_STARTPOINT:fallthrough
		 	case .ST_SYMDIFFERENCE:fallthrough
		 	case .ST_TOUCHES:fallthrough
		 	case .ST_UNION:fallthrough
		 	case .ST_WITHIN:fallthrough
		 	case .ST_X:fallthrough
		 	case .ST_Y:fallthrough
		 	case .SUBDATE:fallthrough
		 	case .SUBSTRING_INDEX:fallthrough
		 	case .SUBTIME:fallthrough
		 	case .SYSTEM_USER:fallthrough
		 	case .TAN:fallthrough
		 	case .TIMEDIFF:fallthrough
		 	case .TIMESTAMPADD:fallthrough
		 	case .TIMESTAMPDIFF:fallthrough
		 	case .TIME_FORMAT:fallthrough
		 	case .TIME_TO_SEC:fallthrough
		 	case .TOUCHES:fallthrough
		 	case .TO_BASE64:fallthrough
		 	case .TO_DAYS:fallthrough
		 	case .TO_SECONDS:fallthrough
		 	case .TP_CONNECTION_ADMIN:fallthrough
		 	case .UCASE:fallthrough
		 	case .UNCOMPRESS:fallthrough
		 	case .UNCOMPRESSED_LENGTH:fallthrough
		 	case .UNHEX:fallthrough
		 	case .UNIX_TIMESTAMP:fallthrough
		 	case .UPDATEXML:fallthrough
		 	case .UPPER:fallthrough
		 	case .UUID:fallthrough
		 	case .UUID_SHORT:fallthrough
		 	case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 	case .VERSION:fallthrough
		 	case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 	case .WEEKDAY:fallthrough
		 	case .WEEKOFYEAR:fallthrough
		 	case .WEIGHT_STRING:fallthrough
		 	case .WITHIN:fallthrough
		 	case .YEARWEEK:fallthrough
		 	case .Y_FUNCTION:fallthrough
		 	case .X_FUNCTION:fallthrough
		 	case .MOD:fallthrough
		 	case .CHARSET_REVERSE_QOUTE_STRING:fallthrough
		 	case .STRING_LITERAL:fallthrough
		 	case .ID:
		 		setState(7111)
		 		try windowName()

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WindowSpecContext: ParserRuleContext {
			open
			func windowName() -> WindowNameContext? {
				return getRuleContext(WindowNameContext.self, 0)
			}
			open
			func partitionClause() -> PartitionClauseContext? {
				return getRuleContext(PartitionClauseContext.self, 0)
			}
			open
			func orderByClause() -> OrderByClauseContext? {
				return getRuleContext(OrderByClauseContext.self, 0)
			}
			open
			func frameClause() -> FrameClauseContext? {
				return getRuleContext(FrameClauseContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_windowSpec
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterWindowSpec(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitWindowSpec(self)
			}
		}
	}
	@discardableResult
	 open func windowSpec() throws -> WindowSpecContext {
		var _localctx: WindowSpecContext
		_localctx = WindowSpecContext(_ctx, getState())
		try enterRule(_localctx, 664, MySqlParser.RULE_windowSpec)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7115)
		 	try _errHandler.sync(self)
		 	switch (try getInterpreter().adaptivePredict(_input,1054,_ctx)) {
		 	case 1:
		 		setState(7114)
		 		try windowName()

		 		break
		 	default: break
		 	}
		 	setState(7118)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.PARTITION.rawValue) {
		 		setState(7117)
		 		try partitionClause()

		 	}

		 	setState(7121)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.ORDER.rawValue) {
		 		setState(7120)
		 		try orderByClause()

		 	}

		 	setState(7124)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	if (_la == MySqlParser.Tokens.RANGE.rawValue || _la == MySqlParser.Tokens.ROWS.rawValue) {
		 		setState(7123)
		 		try frameClause()

		 	}


		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class WindowNameContext: ParserRuleContext {
			open
			func uid() -> UidContext? {
				return getRuleContext(UidContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_windowName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterWindowName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitWindowName(self)
			}
		}
	}
	@discardableResult
	 open func windowName() throws -> WindowNameContext {
		var _localctx: WindowNameContext
		_localctx = WindowNameContext(_ctx, getState())
		try enterRule(_localctx, 666, MySqlParser.RULE_windowName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7126)
		 	try uid()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FrameClauseContext: ParserRuleContext {
			open
			func frameUnits() -> FrameUnitsContext? {
				return getRuleContext(FrameUnitsContext.self, 0)
			}
			open
			func frameExtent() -> FrameExtentContext? {
				return getRuleContext(FrameExtentContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_frameClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFrameClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFrameClause(self)
			}
		}
	}
	@discardableResult
	 open func frameClause() throws -> FrameClauseContext {
		var _localctx: FrameClauseContext
		_localctx = FrameClauseContext(_ctx, getState())
		try enterRule(_localctx, 668, MySqlParser.RULE_frameClause)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7128)
		 	try frameUnits()
		 	setState(7129)
		 	try frameExtent()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FrameUnitsContext: ParserRuleContext {
			open
			func ROWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROWS.rawValue, 0)
			}
			open
			func RANGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RANGE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_frameUnits
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFrameUnits(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFrameUnits(self)
			}
		}
	}
	@discardableResult
	 open func frameUnits() throws -> FrameUnitsContext {
		var _localctx: FrameUnitsContext
		_localctx = FrameUnitsContext(_ctx, getState())
		try enterRule(_localctx, 670, MySqlParser.RULE_frameUnits)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7131)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.RANGE.rawValue || _la == MySqlParser.Tokens.ROWS.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FrameExtentContext: ParserRuleContext {
			open
			func frameRange() -> FrameRangeContext? {
				return getRuleContext(FrameRangeContext.self, 0)
			}
			open
			func frameBetween() -> FrameBetweenContext? {
				return getRuleContext(FrameBetweenContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_frameExtent
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFrameExtent(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFrameExtent(self)
			}
		}
	}
	@discardableResult
	 open func frameExtent() throws -> FrameExtentContext {
		var _localctx: FrameExtentContext
		_localctx = FrameExtentContext(_ctx, getState())
		try enterRule(_localctx, 672, MySqlParser.RULE_frameExtent)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(7135)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,1058, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(7133)
		 		try frameRange()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(7134)
		 		try frameBetween()

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FrameBetweenContext: ParserRuleContext {
			open
			func BETWEEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BETWEEN.rawValue, 0)
			}
			open
			func frameRange() -> [FrameRangeContext] {
				return getRuleContexts(FrameRangeContext.self)
			}
			open
			func frameRange(_ i: Int) -> FrameRangeContext? {
				return getRuleContext(FrameRangeContext.self, i)
			}
			open
			func AND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AND.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_frameBetween
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFrameBetween(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFrameBetween(self)
			}
		}
	}
	@discardableResult
	 open func frameBetween() throws -> FrameBetweenContext {
		var _localctx: FrameBetweenContext
		_localctx = FrameBetweenContext(_ctx, getState())
		try enterRule(_localctx, 674, MySqlParser.RULE_frameBetween)
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7137)
		 	try match(MySqlParser.Tokens.BETWEEN.rawValue)
		 	setState(7138)
		 	try frameRange()
		 	setState(7139)
		 	try match(MySqlParser.Tokens.AND.rawValue)
		 	setState(7140)
		 	try frameRange()

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FrameRangeContext: ParserRuleContext {
			open
			func CURRENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT.rawValue, 0)
			}
			open
			func ROW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROW.rawValue, 0)
			}
			open
			func UNBOUNDED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNBOUNDED.rawValue, 0)
			}
			open
			func PRECEDING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRECEDING.rawValue, 0)
			}
			open
			func FOLLOWING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOLLOWING.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_frameRange
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFrameRange(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFrameRange(self)
			}
		}
	}
	@discardableResult
	 open func frameRange() throws -> FrameRangeContext {
		var _localctx: FrameRangeContext
		_localctx = FrameRangeContext(_ctx, getState())
		try enterRule(_localctx, 676, MySqlParser.RULE_frameRange)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(7149)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,1059, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(7142)
		 		try match(MySqlParser.Tokens.CURRENT.rawValue)
		 		setState(7143)
		 		try match(MySqlParser.Tokens.ROW.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(7144)
		 		try match(MySqlParser.Tokens.UNBOUNDED.rawValue)
		 		setState(7145)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FOLLOWING.rawValue || _la == MySqlParser.Tokens.PRECEDING.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(7146)
		 		try expression(0)
		 		setState(7147)
		 		_la = try _input.LA(1)
		 		if (!(_la == MySqlParser.Tokens.FOLLOWING.rawValue || _la == MySqlParser.Tokens.PRECEDING.rawValue)) {
		 		try _errHandler.recoverInline(self)
		 		}
		 		else {
		 			_errHandler.reportMatch(self)
		 			try consume()
		 		}

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PartitionClauseContext: ParserRuleContext {
			open
			func PARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITION.rawValue, 0)
			}
			open
			func BY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BY.rawValue, 0)
			}
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_partitionClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPartitionClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPartitionClause(self)
			}
		}
	}
	@discardableResult
	 open func partitionClause() throws -> PartitionClauseContext {
		var _localctx: PartitionClauseContext
		_localctx = PartitionClauseContext(_ctx, getState())
		try enterRule(_localctx, 678, MySqlParser.RULE_partitionClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7151)
		 	try match(MySqlParser.Tokens.PARTITION.rawValue)
		 	setState(7152)
		 	try match(MySqlParser.Tokens.BY.rawValue)
		 	setState(7153)
		 	try expression(0)
		 	setState(7158)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(7154)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(7155)
		 		try expression(0)


		 		setState(7160)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ScalarFunctionNameContext: ParserRuleContext {
			open
			func functionNameBase() -> FunctionNameBaseContext? {
				return getRuleContext(FunctionNameBaseContext.self, 0)
			}
			open
			func ASCII() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASCII.rawValue, 0)
			}
			open
			func CURDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURDATE.rawValue, 0)
			}
			open
			func CURRENT_DATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT_DATE.rawValue, 0)
			}
			open
			func CURRENT_TIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT_TIME.rawValue, 0)
			}
			open
			func CURRENT_TIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT_TIMESTAMP.rawValue, 0)
			}
			open
			func CURTIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURTIME.rawValue, 0)
			}
			open
			func DATE_ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATE_ADD.rawValue, 0)
			}
			open
			func DATE_SUB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATE_SUB.rawValue, 0)
			}
			open
			func IF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IF.rawValue, 0)
			}
			open
			func INSERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSERT.rawValue, 0)
			}
			open
			func LOCALTIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCALTIME.rawValue, 0)
			}
			open
			func LOCALTIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCALTIMESTAMP.rawValue, 0)
			}
			open
			func MID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MID.rawValue, 0)
			}
			open
			func NOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOW.rawValue, 0)
			}
			open
			func REPEAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPEAT.rawValue, 0)
			}
			open
			func REPLACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLACE.rawValue, 0)
			}
			open
			func SUBSTR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBSTR.rawValue, 0)
			}
			open
			func SUBSTRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBSTRING.rawValue, 0)
			}
			open
			func SYSDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SYSDATE.rawValue, 0)
			}
			open
			func TRIM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRIM.rawValue, 0)
			}
			open
			func UTC_DATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UTC_DATE.rawValue, 0)
			}
			open
			func UTC_TIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UTC_TIME.rawValue, 0)
			}
			open
			func UTC_TIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UTC_TIMESTAMP.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_scalarFunctionName
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterScalarFunctionName(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitScalarFunctionName(self)
			}
		}
	}
	@discardableResult
	 open func scalarFunctionName() throws -> ScalarFunctionNameContext {
		var _localctx: ScalarFunctionNameContext
		_localctx = ScalarFunctionNameContext(_ctx, getState())
		try enterRule(_localctx, 680, MySqlParser.RULE_scalarFunctionName)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(7185)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .DATABASE:fallthrough
		 	case .LEFT:fallthrough
		 	case .RIGHT:fallthrough
		 	case .SCHEMA:fallthrough
		 	case .DATE:fallthrough
		 	case .TIME:fallthrough
		 	case .TIMESTAMP:fallthrough
		 	case .YEAR:fallthrough
		 	case .JSON_ARRAY:fallthrough
		 	case .JSON_ARRAYAGG:fallthrough
		 	case .JSON_ARRAY_APPEND:fallthrough
		 	case .JSON_ARRAY_INSERT:fallthrough
		 	case .JSON_CONTAINS:fallthrough
		 	case .JSON_CONTAINS_PATH:fallthrough
		 	case .JSON_DEPTH:fallthrough
		 	case .JSON_EXTRACT:fallthrough
		 	case .JSON_INSERT:fallthrough
		 	case .JSON_KEYS:fallthrough
		 	case .JSON_LENGTH:fallthrough
		 	case .JSON_MERGE:fallthrough
		 	case .JSON_MERGE_PATCH:fallthrough
		 	case .JSON_MERGE_PRESERVE:fallthrough
		 	case .JSON_OBJECT:fallthrough
		 	case .JSON_OBJECTAGG:fallthrough
		 	case .JSON_OVERLAPS:fallthrough
		 	case .JSON_PRETTY:fallthrough
		 	case .JSON_QUOTE:fallthrough
		 	case .JSON_REMOVE:fallthrough
		 	case .JSON_REPLACE:fallthrough
		 	case .JSON_SCHEMA_VALID:fallthrough
		 	case .JSON_SCHEMA_VALIDATION_REPORT:fallthrough
		 	case .JSON_SEARCH:fallthrough
		 	case .JSON_SET:fallthrough
		 	case .JSON_STORAGE_FREE:fallthrough
		 	case .JSON_STORAGE_SIZE:fallthrough
		 	case .JSON_TABLE:fallthrough
		 	case .JSON_TYPE:fallthrough
		 	case .JSON_UNQUOTE:fallthrough
		 	case .JSON_VALID:fallthrough
		 	case .JSON_VALUE:fallthrough
		 	case .COUNT:fallthrough
		 	case .CUME_DIST:fallthrough
		 	case .DENSE_RANK:fallthrough
		 	case .FIRST_VALUE:fallthrough
		 	case .LAG:fallthrough
		 	case .LAST_VALUE:fallthrough
		 	case .LEAD:fallthrough
		 	case .NTILE:fallthrough
		 	case .NTH_VALUE:fallthrough
		 	case .PERCENT_RANK:fallthrough
		 	case .RANK:fallthrough
		 	case .ROW_NUMBER:fallthrough
		 	case .POSITION:fallthrough
		 	case .INVISIBLE:fallthrough
		 	case .VISIBLE:fallthrough
		 	case .QUARTER:fallthrough
		 	case .MONTH:fallthrough
		 	case .DAY:fallthrough
		 	case .HOUR:fallthrough
		 	case .MINUTE:fallthrough
		 	case .WEEK:fallthrough
		 	case .SECOND:fallthrough
		 	case .MICROSECOND:fallthrough
		 	case .SESSION_VARIABLES_ADMIN:fallthrough
		 	case .GEOMETRYCOLLECTION:fallthrough
		 	case .LINESTRING:fallthrough
		 	case .MULTILINESTRING:fallthrough
		 	case .MULTIPOINT:fallthrough
		 	case .MULTIPOLYGON:fallthrough
		 	case .POINT:fallthrough
		 	case .POLYGON:fallthrough
		 	case .ABS:fallthrough
		 	case .ACOS:fallthrough
		 	case .ADDDATE:fallthrough
		 	case .ADDTIME:fallthrough
		 	case .AES_DECRYPT:fallthrough
		 	case .AES_ENCRYPT:fallthrough
		 	case .AREA:fallthrough
		 	case .ASBINARY:fallthrough
		 	case .ASIN:fallthrough
		 	case .ASTEXT:fallthrough
		 	case .ASWKB:fallthrough
		 	case .ASWKT:fallthrough
		 	case .ASYMMETRIC_DECRYPT:fallthrough
		 	case .ASYMMETRIC_DERIVE:fallthrough
		 	case .ASYMMETRIC_ENCRYPT:fallthrough
		 	case .ASYMMETRIC_SIGN:fallthrough
		 	case .ASYMMETRIC_VERIFY:fallthrough
		 	case .ATAN:fallthrough
		 	case .ATAN2:fallthrough
		 	case .BENCHMARK:fallthrough
		 	case .BIN:fallthrough
		 	case .BIT_COUNT:fallthrough
		 	case .BIT_LENGTH:fallthrough
		 	case .BUFFER:fallthrough
		 	case .CEIL:fallthrough
		 	case .CEILING:fallthrough
		 	case .CENTROID:fallthrough
		 	case .CHARACTER_LENGTH:fallthrough
		 	case .CHARSET:fallthrough
		 	case .CHAR_LENGTH:fallthrough
		 	case .COERCIBILITY:fallthrough
		 	case .COLLATION:fallthrough
		 	case .COMPRESS:fallthrough
		 	case .CONCAT:fallthrough
		 	case .CONCAT_WS:fallthrough
		 	case .CONNECTION_ID:fallthrough
		 	case .CONV:fallthrough
		 	case .CONVERT_TZ:fallthrough
		 	case .COS:fallthrough
		 	case .COT:fallthrough
		 	case .CRC32:fallthrough
		 	case .CREATE_ASYMMETRIC_PRIV_KEY:fallthrough
		 	case .CREATE_ASYMMETRIC_PUB_KEY:fallthrough
		 	case .CREATE_DH_PARAMETERS:fallthrough
		 	case .CREATE_DIGEST:fallthrough
		 	case .CROSSES:fallthrough
		 	case .DATEDIFF:fallthrough
		 	case .DATE_FORMAT:fallthrough
		 	case .DAYNAME:fallthrough
		 	case .DAYOFMONTH:fallthrough
		 	case .DAYOFWEEK:fallthrough
		 	case .DAYOFYEAR:fallthrough
		 	case .DECODE:fallthrough
		 	case .DEGREES:fallthrough
		 	case .DES_DECRYPT:fallthrough
		 	case .DES_ENCRYPT:fallthrough
		 	case .DIMENSION:fallthrough
		 	case .DISJOINT:fallthrough
		 	case .ELT:fallthrough
		 	case .ENCODE:fallthrough
		 	case .ENCRYPT:fallthrough
		 	case .ENDPOINT:fallthrough
		 	case .ENVELOPE:fallthrough
		 	case .EQUALS:fallthrough
		 	case .EXP:fallthrough
		 	case .EXPORT_SET:fallthrough
		 	case .EXTERIORRING:fallthrough
		 	case .EXTRACTVALUE:fallthrough
		 	case .FIELD:fallthrough
		 	case .FIND_IN_SET:fallthrough
		 	case .FLOOR:fallthrough
		 	case .FORMAT:fallthrough
		 	case .FOUND_ROWS:fallthrough
		 	case .FROM_BASE64:fallthrough
		 	case .FROM_DAYS:fallthrough
		 	case .FROM_UNIXTIME:fallthrough
		 	case .GEOMCOLLFROMTEXT:fallthrough
		 	case .GEOMCOLLFROMWKB:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .GEOMETRYFROMTEXT:fallthrough
		 	case .GEOMETRYFROMWKB:fallthrough
		 	case .GEOMETRYN:fallthrough
		 	case .GEOMETRYTYPE:fallthrough
		 	case .GEOMFROMTEXT:fallthrough
		 	case .GEOMFROMWKB:fallthrough
		 	case .GET_FORMAT:fallthrough
		 	case .GET_LOCK:fallthrough
		 	case .GLENGTH:fallthrough
		 	case .GREATEST:fallthrough
		 	case .GTID_SUBSET:fallthrough
		 	case .GTID_SUBTRACT:fallthrough
		 	case .HEX:fallthrough
		 	case .IFNULL:fallthrough
		 	case .INET6_ATON:fallthrough
		 	case .INET6_NTOA:fallthrough
		 	case .INET_ATON:fallthrough
		 	case .INET_NTOA:fallthrough
		 	case .INSTR:fallthrough
		 	case .INTERIORRINGN:fallthrough
		 	case .INTERSECTS:fallthrough
		 	case .ISCLOSED:fallthrough
		 	case .ISEMPTY:fallthrough
		 	case .ISNULL:fallthrough
		 	case .ISSIMPLE:fallthrough
		 	case .IS_FREE_LOCK:fallthrough
		 	case .IS_IPV4:fallthrough
		 	case .IS_IPV4_COMPAT:fallthrough
		 	case .IS_IPV4_MAPPED:fallthrough
		 	case .IS_IPV6:fallthrough
		 	case .IS_USED_LOCK:fallthrough
		 	case .LAST_INSERT_ID:fallthrough
		 	case .LCASE:fallthrough
		 	case .LEAST:fallthrough
		 	case .LENGTH:fallthrough
		 	case .LINEFROMTEXT:fallthrough
		 	case .LINEFROMWKB:fallthrough
		 	case .LINESTRINGFROMTEXT:fallthrough
		 	case .LINESTRINGFROMWKB:fallthrough
		 	case .LN:fallthrough
		 	case .LOAD_FILE:fallthrough
		 	case .LOCATE:fallthrough
		 	case .LOG:fallthrough
		 	case .LOG10:fallthrough
		 	case .LOG2:fallthrough
		 	case .LOWER:fallthrough
		 	case .LPAD:fallthrough
		 	case .LTRIM:fallthrough
		 	case .MAKEDATE:fallthrough
		 	case .MAKETIME:fallthrough
		 	case .MAKE_SET:fallthrough
		 	case .MASTER_POS_WAIT:fallthrough
		 	case .MBRCONTAINS:fallthrough
		 	case .MBRDISJOINT:fallthrough
		 	case .MBREQUAL:fallthrough
		 	case .MBRINTERSECTS:fallthrough
		 	case .MBROVERLAPS:fallthrough
		 	case .MBRTOUCHES:fallthrough
		 	case .MBRWITHIN:fallthrough
		 	case .MD5:fallthrough
		 	case .MLINEFROMTEXT:fallthrough
		 	case .MLINEFROMWKB:fallthrough
		 	case .MONTHNAME:fallthrough
		 	case .MPOINTFROMTEXT:fallthrough
		 	case .MPOINTFROMWKB:fallthrough
		 	case .MPOLYFROMTEXT:fallthrough
		 	case .MPOLYFROMWKB:fallthrough
		 	case .MULTILINESTRINGFROMTEXT:fallthrough
		 	case .MULTILINESTRINGFROMWKB:fallthrough
		 	case .MULTIPOINTFROMTEXT:fallthrough
		 	case .MULTIPOINTFROMWKB:fallthrough
		 	case .MULTIPOLYGONFROMTEXT:fallthrough
		 	case .MULTIPOLYGONFROMWKB:fallthrough
		 	case .NAME_CONST:fallthrough
		 	case .NULLIF:fallthrough
		 	case .NUMGEOMETRIES:fallthrough
		 	case .NUMINTERIORRINGS:fallthrough
		 	case .NUMPOINTS:fallthrough
		 	case .OCT:fallthrough
		 	case .OCTET_LENGTH:fallthrough
		 	case .ORD:fallthrough
		 	case .OVERLAPS:fallthrough
		 	case .PERIOD_ADD:fallthrough
		 	case .PERIOD_DIFF:fallthrough
		 	case .PI:fallthrough
		 	case .POINTFROMTEXT:fallthrough
		 	case .POINTFROMWKB:fallthrough
		 	case .POINTN:fallthrough
		 	case .POLYFROMTEXT:fallthrough
		 	case .POLYFROMWKB:fallthrough
		 	case .POLYGONFROMTEXT:fallthrough
		 	case .POLYGONFROMWKB:fallthrough
		 	case .POW:fallthrough
		 	case .POWER:fallthrough
		 	case .QUOTE:fallthrough
		 	case .RADIANS:fallthrough
		 	case .RAND:fallthrough
		 	case .RANDOM:fallthrough
		 	case .RANDOM_BYTES:fallthrough
		 	case .RELEASE_LOCK:fallthrough
		 	case .REVERSE:fallthrough
		 	case .ROUND:fallthrough
		 	case .ROW_COUNT:fallthrough
		 	case .RPAD:fallthrough
		 	case .RTRIM:fallthrough
		 	case .SEC_TO_TIME:fallthrough
		 	case .SESSION_USER:fallthrough
		 	case .SHA:fallthrough
		 	case .SHA1:fallthrough
		 	case .SHA2:fallthrough
		 	case .SIGN:fallthrough
		 	case .SIN:fallthrough
		 	case .SLEEP:fallthrough
		 	case .SOUNDEX:fallthrough
		 	case .SQL_THREAD_WAIT_AFTER_GTIDS:fallthrough
		 	case .SQRT:fallthrough
		 	case .SRID:fallthrough
		 	case .STARTPOINT:fallthrough
		 	case .STRCMP:fallthrough
		 	case .STR_TO_DATE:fallthrough
		 	case .ST_AREA:fallthrough
		 	case .ST_ASBINARY:fallthrough
		 	case .ST_ASTEXT:fallthrough
		 	case .ST_ASWKB:fallthrough
		 	case .ST_ASWKT:fallthrough
		 	case .ST_BUFFER:fallthrough
		 	case .ST_CENTROID:fallthrough
		 	case .ST_CONTAINS:fallthrough
		 	case .ST_CROSSES:fallthrough
		 	case .ST_DIFFERENCE:fallthrough
		 	case .ST_DIMENSION:fallthrough
		 	case .ST_DISJOINT:fallthrough
		 	case .ST_DISTANCE:fallthrough
		 	case .ST_ENDPOINT:fallthrough
		 	case .ST_ENVELOPE:fallthrough
		 	case .ST_EQUALS:fallthrough
		 	case .ST_EXTERIORRING:fallthrough
		 	case .ST_GEOMCOLLFROMTEXT:fallthrough
		 	case .ST_GEOMCOLLFROMTXT:fallthrough
		 	case .ST_GEOMCOLLFROMWKB:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMTEXT:fallthrough
		 	case .ST_GEOMETRYCOLLECTIONFROMWKB:fallthrough
		 	case .ST_GEOMETRYFROMTEXT:fallthrough
		 	case .ST_GEOMETRYFROMWKB:fallthrough
		 	case .ST_GEOMETRYN:fallthrough
		 	case .ST_GEOMETRYTYPE:fallthrough
		 	case .ST_GEOMFROMTEXT:fallthrough
		 	case .ST_GEOMFROMWKB:fallthrough
		 	case .ST_INTERIORRINGN:fallthrough
		 	case .ST_INTERSECTION:fallthrough
		 	case .ST_INTERSECTS:fallthrough
		 	case .ST_ISCLOSED:fallthrough
		 	case .ST_ISEMPTY:fallthrough
		 	case .ST_ISSIMPLE:fallthrough
		 	case .ST_LINEFROMTEXT:fallthrough
		 	case .ST_LINEFROMWKB:fallthrough
		 	case .ST_LINESTRINGFROMTEXT:fallthrough
		 	case .ST_LINESTRINGFROMWKB:fallthrough
		 	case .ST_NUMGEOMETRIES:fallthrough
		 	case .ST_NUMINTERIORRING:fallthrough
		 	case .ST_NUMINTERIORRINGS:fallthrough
		 	case .ST_NUMPOINTS:fallthrough
		 	case .ST_OVERLAPS:fallthrough
		 	case .ST_POINTFROMTEXT:fallthrough
		 	case .ST_POINTFROMWKB:fallthrough
		 	case .ST_POINTN:fallthrough
		 	case .ST_POLYFROMTEXT:fallthrough
		 	case .ST_POLYFROMWKB:fallthrough
		 	case .ST_POLYGONFROMTEXT:fallthrough
		 	case .ST_POLYGONFROMWKB:fallthrough
		 	case .ST_SRID:fallthrough
		 	case .ST_STARTPOINT:fallthrough
		 	case .ST_SYMDIFFERENCE:fallthrough
		 	case .ST_TOUCHES:fallthrough
		 	case .ST_UNION:fallthrough
		 	case .ST_WITHIN:fallthrough
		 	case .ST_X:fallthrough
		 	case .ST_Y:fallthrough
		 	case .SUBDATE:fallthrough
		 	case .SUBSTRING_INDEX:fallthrough
		 	case .SUBTIME:fallthrough
		 	case .SYSTEM_USER:fallthrough
		 	case .TAN:fallthrough
		 	case .TIMEDIFF:fallthrough
		 	case .TIMESTAMPADD:fallthrough
		 	case .TIMESTAMPDIFF:fallthrough
		 	case .TIME_FORMAT:fallthrough
		 	case .TIME_TO_SEC:fallthrough
		 	case .TOUCHES:fallthrough
		 	case .TO_BASE64:fallthrough
		 	case .TO_DAYS:fallthrough
		 	case .TO_SECONDS:fallthrough
		 	case .UCASE:fallthrough
		 	case .UNCOMPRESS:fallthrough
		 	case .UNCOMPRESSED_LENGTH:fallthrough
		 	case .UNHEX:fallthrough
		 	case .UNIX_TIMESTAMP:fallthrough
		 	case .UPDATEXML:fallthrough
		 	case .UPPER:fallthrough
		 	case .UUID:fallthrough
		 	case .UUID_SHORT:fallthrough
		 	case .VALIDATE_PASSWORD_STRENGTH:fallthrough
		 	case .VERSION:fallthrough
		 	case .WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS:fallthrough
		 	case .WEEKDAY:fallthrough
		 	case .WEEKOFYEAR:fallthrough
		 	case .WEIGHT_STRING:fallthrough
		 	case .WITHIN:fallthrough
		 	case .YEARWEEK:fallthrough
		 	case .Y_FUNCTION:fallthrough
		 	case .X_FUNCTION:fallthrough
		 	case .MOD:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(7161)
		 		try functionNameBase()

		 		break

		 	case .ASCII:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(7162)
		 		try match(MySqlParser.Tokens.ASCII.rawValue)

		 		break

		 	case .CURDATE:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(7163)
		 		try match(MySqlParser.Tokens.CURDATE.rawValue)

		 		break

		 	case .CURRENT_DATE:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(7164)
		 		try match(MySqlParser.Tokens.CURRENT_DATE.rawValue)

		 		break

		 	case .CURRENT_TIME:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(7165)
		 		try match(MySqlParser.Tokens.CURRENT_TIME.rawValue)

		 		break

		 	case .CURRENT_TIMESTAMP:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(7166)
		 		try match(MySqlParser.Tokens.CURRENT_TIMESTAMP.rawValue)

		 		break

		 	case .CURTIME:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(7167)
		 		try match(MySqlParser.Tokens.CURTIME.rawValue)

		 		break

		 	case .DATE_ADD:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(7168)
		 		try match(MySqlParser.Tokens.DATE_ADD.rawValue)

		 		break

		 	case .DATE_SUB:
		 		try enterOuterAlt(_localctx, 9)
		 		setState(7169)
		 		try match(MySqlParser.Tokens.DATE_SUB.rawValue)

		 		break

		 	case .IF:
		 		try enterOuterAlt(_localctx, 10)
		 		setState(7170)
		 		try match(MySqlParser.Tokens.IF.rawValue)

		 		break

		 	case .INSERT:
		 		try enterOuterAlt(_localctx, 11)
		 		setState(7171)
		 		try match(MySqlParser.Tokens.INSERT.rawValue)

		 		break

		 	case .LOCALTIME:
		 		try enterOuterAlt(_localctx, 12)
		 		setState(7172)
		 		try match(MySqlParser.Tokens.LOCALTIME.rawValue)

		 		break

		 	case .LOCALTIMESTAMP:
		 		try enterOuterAlt(_localctx, 13)
		 		setState(7173)
		 		try match(MySqlParser.Tokens.LOCALTIMESTAMP.rawValue)

		 		break

		 	case .MID:
		 		try enterOuterAlt(_localctx, 14)
		 		setState(7174)
		 		try match(MySqlParser.Tokens.MID.rawValue)

		 		break

		 	case .NOW:
		 		try enterOuterAlt(_localctx, 15)
		 		setState(7175)
		 		try match(MySqlParser.Tokens.NOW.rawValue)

		 		break

		 	case .REPEAT:
		 		try enterOuterAlt(_localctx, 16)
		 		setState(7176)
		 		try match(MySqlParser.Tokens.REPEAT.rawValue)

		 		break

		 	case .REPLACE:
		 		try enterOuterAlt(_localctx, 17)
		 		setState(7177)
		 		try match(MySqlParser.Tokens.REPLACE.rawValue)

		 		break

		 	case .SUBSTR:
		 		try enterOuterAlt(_localctx, 18)
		 		setState(7178)
		 		try match(MySqlParser.Tokens.SUBSTR.rawValue)

		 		break

		 	case .SUBSTRING:
		 		try enterOuterAlt(_localctx, 19)
		 		setState(7179)
		 		try match(MySqlParser.Tokens.SUBSTRING.rawValue)

		 		break

		 	case .SYSDATE:
		 		try enterOuterAlt(_localctx, 20)
		 		setState(7180)
		 		try match(MySqlParser.Tokens.SYSDATE.rawValue)

		 		break

		 	case .TRIM:
		 		try enterOuterAlt(_localctx, 21)
		 		setState(7181)
		 		try match(MySqlParser.Tokens.TRIM.rawValue)

		 		break

		 	case .UTC_DATE:
		 		try enterOuterAlt(_localctx, 22)
		 		setState(7182)
		 		try match(MySqlParser.Tokens.UTC_DATE.rawValue)

		 		break

		 	case .UTC_TIME:
		 		try enterOuterAlt(_localctx, 23)
		 		setState(7183)
		 		try match(MySqlParser.Tokens.UTC_TIME.rawValue)

		 		break

		 	case .UTC_TIMESTAMP:
		 		try enterOuterAlt(_localctx, 24)
		 		setState(7184)
		 		try match(MySqlParser.Tokens.UTC_TIMESTAMP.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PasswordFunctionClauseContext: ParserRuleContext {
		open var functionName: Token!
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func functionArg() -> FunctionArgContext? {
				return getRuleContext(FunctionArgContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD.rawValue, 0)
			}
			open
			func OLD_PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OLD_PASSWORD.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_passwordFunctionClause
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPasswordFunctionClause(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPasswordFunctionClause(self)
			}
		}
	}
	@discardableResult
	 open func passwordFunctionClause() throws -> PasswordFunctionClauseContext {
		var _localctx: PasswordFunctionClauseContext
		_localctx = PasswordFunctionClauseContext(_ctx, getState())
		try enterRule(_localctx, 682, MySqlParser.RULE_passwordFunctionClause)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7187)
		 	_localctx.castdown(PasswordFunctionClauseContext.self).functionName = try _input.LT(1)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.OLD_PASSWORD.rawValue || _la == MySqlParser.Tokens.PASSWORD.rawValue)) {
		 		_localctx.castdown(PasswordFunctionClauseContext.self).functionName = try _errHandler.recoverInline(self) as Token
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}
		 	setState(7188)
		 	try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
		 	setState(7189)
		 	try functionArg()
		 	setState(7190)
		 	try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FunctionArgsContext: ParserRuleContext {
			open
			func constant() -> [ConstantContext] {
				return getRuleContexts(ConstantContext.self)
			}
			open
			func constant(_ i: Int) -> ConstantContext? {
				return getRuleContext(ConstantContext.self, i)
			}
			open
			func fullColumnName() -> [FullColumnNameContext] {
				return getRuleContexts(FullColumnNameContext.self)
			}
			open
			func fullColumnName(_ i: Int) -> FullColumnNameContext? {
				return getRuleContext(FullColumnNameContext.self, i)
			}
			open
			func functionCall() -> [FunctionCallContext] {
				return getRuleContexts(FunctionCallContext.self)
			}
			open
			func functionCall(_ i: Int) -> FunctionCallContext? {
				return getRuleContext(FunctionCallContext.self, i)
			}
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_functionArgs
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFunctionArgs(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFunctionArgs(self)
			}
		}
	}
	@discardableResult
	 open func functionArgs() throws -> FunctionArgsContext {
		var _localctx: FunctionArgsContext
		_localctx = FunctionArgsContext(_ctx, getState())
		try enterRule(_localctx, 684, MySqlParser.RULE_functionArgs)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7196)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,1062, _ctx)) {
		 	case 1:
		 		setState(7192)
		 		try constant()

		 		break
		 	case 2:
		 		setState(7193)
		 		try fullColumnName()

		 		break
		 	case 3:
		 		setState(7194)
		 		try functionCall()

		 		break
		 	case 4:
		 		setState(7195)
		 		try expression(0)

		 		break
		 	default: break
		 	}
		 	setState(7207)
		 	try _errHandler.sync(self)
		 	_la = try _input.LA(1)
		 	while (_la == MySqlParser.Tokens.COMMA.rawValue) {
		 		setState(7198)
		 		try match(MySqlParser.Tokens.COMMA.rawValue)
		 		setState(7203)
		 		try _errHandler.sync(self)
		 		switch(try getInterpreter().adaptivePredict(_input,1063, _ctx)) {
		 		case 1:
		 			setState(7199)
		 			try constant()

		 			break
		 		case 2:
		 			setState(7200)
		 			try fullColumnName()

		 			break
		 		case 3:
		 			setState(7201)
		 			try functionCall()

		 			break
		 		case 4:
		 			setState(7202)
		 			try expression(0)

		 			break
		 		default: break
		 		}


		 		setState(7209)
		 		try _errHandler.sync(self)
		 		_la = try _input.LA(1)
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FunctionArgContext: ParserRuleContext {
			open
			func constant() -> ConstantContext? {
				return getRuleContext(ConstantContext.self, 0)
			}
			open
			func fullColumnName() -> FullColumnNameContext? {
				return getRuleContext(FullColumnNameContext.self, 0)
			}
			open
			func functionCall() -> FunctionCallContext? {
				return getRuleContext(FunctionCallContext.self, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_functionArg
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFunctionArg(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFunctionArg(self)
			}
		}
	}
	@discardableResult
	 open func functionArg() throws -> FunctionArgContext {
		var _localctx: FunctionArgContext
		_localctx = FunctionArgContext(_ctx, getState())
		try enterRule(_localctx, 686, MySqlParser.RULE_functionArg)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(7214)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,1065, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(7210)
		 		try constant()

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(7211)
		 		try fullColumnName()

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(7212)
		 		try functionCall()

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(7213)
		 		try expression(0)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}


	public class ExpressionContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_expression
		}
	}
	public class IsExpressionContext: ExpressionContext {
		public var testValue: Token!
			open
			func predicate() -> PredicateContext? {
				return getRuleContext(PredicateContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IS.rawValue, 0)
			}
			open
			func TRUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRUE.rawValue, 0)
			}
			open
			func FALSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FALSE.rawValue, 0)
			}
			open
			func UNKNOWN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNKNOWN.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}

		public
		init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIsExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIsExpression(self)
			}
		}
	}
	public class NotExpressionContext: ExpressionContext {
		public var notOperator: Token!
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
			open
			func EXCLAMATION_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXCLAMATION_SYMBOL.rawValue, 0)
			}

		public
		init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterNotExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitNotExpression(self)
			}
		}
	}
	public class LogicalExpressionContext: ExpressionContext {
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}
			open
			func logicalOperator() -> LogicalOperatorContext? {
				return getRuleContext(LogicalOperatorContext.self, 0)
			}

		public
		init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLogicalExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLogicalExpression(self)
			}
		}
	}
	public class PredicateExpressionContext: ExpressionContext {
			open
			func predicate() -> PredicateContext? {
				return getRuleContext(PredicateContext.self, 0)
			}

		public
		init(_ ctx: ExpressionContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPredicateExpression(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPredicateExpression(self)
			}
		}
	}

	 public final  func expression( ) throws -> ExpressionContext   {
		return try expression(0)
	}
	@discardableResult
	private func expression(_ _p: Int) throws -> ExpressionContext   {
		let _parentctx: ParserRuleContext? = _ctx
		let _parentState: Int = getState()
		var _localctx: ExpressionContext
		_localctx = ExpressionContext(_ctx, _parentState)
		var _prevctx: ExpressionContext = _localctx
		let _startState: Int = 688
		try enterRecursionRule(_localctx, 688, MySqlParser.RULE_expression, _p)
		var _la: Int = 0
		defer {
	    		try! unrollRecursionContexts(_parentctx)
	    }
		do {
			var _alt: Int
			try enterOuterAlt(_localctx, 1)
			setState(7227)
			try _errHandler.sync(self)
			switch(try getInterpreter().adaptivePredict(_input,1067, _ctx)) {
			case 1:
				_localctx = NotExpressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx

				setState(7217)
				_localctx.castdown(NotExpressionContext.self).notOperator = try _input.LT(1)
				_la = try _input.LA(1)
				if (!(_la == MySqlParser.Tokens.NOT.rawValue || _la == MySqlParser.Tokens.EXCLAMATION_SYMBOL.rawValue)) {
					_localctx.castdown(NotExpressionContext.self).notOperator = try _errHandler.recoverInline(self) as Token
				}
				else {
					_errHandler.reportMatch(self)
					try consume()
				}
				setState(7218)
				try expression(4)

				break
			case 2:
				_localctx = IsExpressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7219)
				try predicate(0)
				setState(7220)
				try match(MySqlParser.Tokens.IS.rawValue)
				setState(7222)
				try _errHandler.sync(self)
				_la = try _input.LA(1)
				if (_la == MySqlParser.Tokens.NOT.rawValue) {
					setState(7221)
					try match(MySqlParser.Tokens.NOT.rawValue)

				}

				setState(7224)
				_localctx.castdown(IsExpressionContext.self).testValue = try _input.LT(1)
				_la = try _input.LA(1)
				if (!(_la == MySqlParser.Tokens.FALSE.rawValue || _la == MySqlParser.Tokens.TRUE.rawValue || _la == MySqlParser.Tokens.UNKNOWN.rawValue)) {
					_localctx.castdown(IsExpressionContext.self).testValue = try _errHandler.recoverInline(self) as Token
				}
				else {
					_errHandler.reportMatch(self)
					try consume()
				}

				break
			case 3:
				_localctx = PredicateExpressionContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7226)
				try predicate(0)

				break
			default: break
			}
			_ctx!.stop = try _input.LT(-1)
			setState(7235)
			try _errHandler.sync(self)
			_alt = try getInterpreter().adaptivePredict(_input,1068,_ctx)
			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
				if ( _alt==1 ) {
					if _parseListeners != nil {
					   try triggerExitRuleEvent()
					}
					_prevctx = _localctx
					_localctx = LogicalExpressionContext(  ExpressionContext(_parentctx, _parentState))
					try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_expression)
					setState(7229)
					if (!(precpred(_ctx, 3))) {
					    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 3)"))
					}
					setState(7230)
					try logicalOperator()
					setState(7231)
					try expression(4)

			 
				}
				setState(7237)
				try _errHandler.sync(self)
				_alt = try getInterpreter().adaptivePredict(_input,1068,_ctx)
			}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx;
	}


	public class PredicateContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_predicate
		}
	}
	public class SoundsLikePredicateContext: PredicateContext {
			open
			func predicate() -> [PredicateContext] {
				return getRuleContexts(PredicateContext.self)
			}
			open
			func predicate(_ i: Int) -> PredicateContext? {
				return getRuleContext(PredicateContext.self, i)
			}
			open
			func SOUNDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SOUNDS.rawValue, 0)
			}
			open
			func LIKE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIKE.rawValue, 0)
			}

		public
		init(_ ctx: PredicateContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSoundsLikePredicate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSoundsLikePredicate(self)
			}
		}
	}
	public class ExpressionAtomPredicateContext: PredicateContext {
			open
			func expressionAtom() -> ExpressionAtomContext? {
				return getRuleContext(ExpressionAtomContext.self, 0)
			}

		public
		init(_ ctx: PredicateContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterExpressionAtomPredicate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitExpressionAtomPredicate(self)
			}
		}
	}
	public class SubqueryComparisonPredicateContext: PredicateContext {
		public var quantifier: Token!
			open
			func predicate() -> PredicateContext? {
				return getRuleContext(PredicateContext.self, 0)
			}
			open
			func comparisonOperator() -> ComparisonOperatorContext? {
				return getRuleContext(ComparisonOperatorContext.self, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func ALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALL.rawValue, 0)
			}
			open
			func ANY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ANY.rawValue, 0)
			}
			open
			func SOME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SOME.rawValue, 0)
			}

		public
		init(_ ctx: PredicateContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSubqueryComparisonPredicate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSubqueryComparisonPredicate(self)
			}
		}
	}
	public class JsonMemberOfPredicateContext: PredicateContext {
			open
			func predicate() -> [PredicateContext] {
				return getRuleContexts(PredicateContext.self)
			}
			open
			func predicate(_ i: Int) -> PredicateContext? {
				return getRuleContext(PredicateContext.self, i)
			}
			open
			func MEMBER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEMBER.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OF.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: PredicateContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterJsonMemberOfPredicate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitJsonMemberOfPredicate(self)
			}
		}
	}
	public class BinaryComparisonPredicateContext: PredicateContext {
		public var `left`: PredicateContext!
		public var `right`: PredicateContext!
			open
			func comparisonOperator() -> ComparisonOperatorContext? {
				return getRuleContext(ComparisonOperatorContext.self, 0)
			}
			open
			func predicate() -> [PredicateContext] {
				return getRuleContexts(PredicateContext.self)
			}
			open
			func predicate(_ i: Int) -> PredicateContext? {
				return getRuleContext(PredicateContext.self, i)
			}

		public
		init(_ ctx: PredicateContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterBinaryComparisonPredicate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitBinaryComparisonPredicate(self)
			}
		}
	}
	public class InPredicateContext: PredicateContext {
			open
			func predicate() -> PredicateContext? {
				return getRuleContext(PredicateContext.self, 0)
			}
			open
			func IN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IN.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
			open
			func expressions() -> ExpressionsContext? {
				return getRuleContext(ExpressionsContext.self, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}

		public
		init(_ ctx: PredicateContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterInPredicate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitInPredicate(self)
			}
		}
	}
	public class BetweenPredicateContext: PredicateContext {
			open
			func predicate() -> [PredicateContext] {
				return getRuleContexts(PredicateContext.self)
			}
			open
			func predicate(_ i: Int) -> PredicateContext? {
				return getRuleContext(PredicateContext.self, i)
			}
			open
			func BETWEEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BETWEEN.rawValue, 0)
			}
			open
			func AND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AND.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}

		public
		init(_ ctx: PredicateContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterBetweenPredicate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitBetweenPredicate(self)
			}
		}
	}
	public class IsNullPredicateContext: PredicateContext {
			open
			func predicate() -> PredicateContext? {
				return getRuleContext(PredicateContext.self, 0)
			}
			open
			func IS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IS.rawValue, 0)
			}
			open
			func nullNotnull() -> NullNotnullContext? {
				return getRuleContext(NullNotnullContext.self, 0)
			}

		public
		init(_ ctx: PredicateContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIsNullPredicate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIsNullPredicate(self)
			}
		}
	}
	public class LikePredicateContext: PredicateContext {
			open
			func predicate() -> [PredicateContext] {
				return getRuleContexts(PredicateContext.self)
			}
			open
			func predicate(_ i: Int) -> PredicateContext? {
				return getRuleContext(PredicateContext.self, i)
			}
			open
			func LIKE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIKE.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
			open
			func ESCAPE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ESCAPE.rawValue, 0)
			}
			open
			func STRING_LITERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING_LITERAL.rawValue, 0)
			}

		public
		init(_ ctx: PredicateContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLikePredicate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLikePredicate(self)
			}
		}
	}
	public class RegexpPredicateContext: PredicateContext {
		public var regex: Token!
			open
			func predicate() -> [PredicateContext] {
				return getRuleContexts(PredicateContext.self)
			}
			open
			func predicate(_ i: Int) -> PredicateContext? {
				return getRuleContext(PredicateContext.self, i)
			}
			open
			func REGEXP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REGEXP.rawValue, 0)
			}
			open
			func RLIKE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RLIKE.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}

		public
		init(_ ctx: PredicateContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterRegexpPredicate(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitRegexpPredicate(self)
			}
		}
	}

	 public final  func predicate( ) throws -> PredicateContext   {
		return try predicate(0)
	}
	@discardableResult
	private func predicate(_ _p: Int) throws -> PredicateContext   {
		let _parentctx: ParserRuleContext? = _ctx
		let _parentState: Int = getState()
		var _localctx: PredicateContext
		_localctx = PredicateContext(_ctx, _parentState)
		var _prevctx: PredicateContext = _localctx
		let _startState: Int = 690
		try enterRecursionRule(_localctx, 690, MySqlParser.RULE_predicate, _p)
		var _la: Int = 0
		defer {
	    		try! unrollRecursionContexts(_parentctx)
	    }
		do {
			var _alt: Int
			try enterOuterAlt(_localctx, 1)
			_localctx = ExpressionAtomPredicateContext(_localctx)
			_ctx = _localctx
			_prevctx = _localctx

			setState(7239)
			try expressionAtom(0)

			_ctx!.stop = try _input.LT(-1)
			setState(7305)
			try _errHandler.sync(self)
			_alt = try getInterpreter().adaptivePredict(_input,1076,_ctx)
			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
				if ( _alt==1 ) {
					if _parseListeners != nil {
					   try triggerExitRuleEvent()
					}
					_prevctx = _localctx
					setState(7303)
					try _errHandler.sync(self)
					switch(try getInterpreter().adaptivePredict(_input,1075, _ctx)) {
					case 1:
						_localctx = BinaryComparisonPredicateContext(  PredicateContext(_parentctx, _parentState))
						(_localctx as! BinaryComparisonPredicateContext).left = _prevctx
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_predicate)
						setState(7241)
						if (!(precpred(_ctx, 8))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 8)"))
						}
						setState(7242)
						try comparisonOperator()
						setState(7243)
						try {
								let assignmentValue = try predicate(9)
								_localctx.castdown(BinaryComparisonPredicateContext.self).`right` = assignmentValue
						     }()


						break
					case 2:
						_localctx = BetweenPredicateContext(  PredicateContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_predicate)
						setState(7245)
						if (!(precpred(_ctx, 6))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 6)"))
						}
						setState(7247)
						try _errHandler.sync(self)
						_la = try _input.LA(1)
						if (_la == MySqlParser.Tokens.NOT.rawValue) {
							setState(7246)
							try match(MySqlParser.Tokens.NOT.rawValue)

						}

						setState(7249)
						try match(MySqlParser.Tokens.BETWEEN.rawValue)
						setState(7250)
						try predicate(0)
						setState(7251)
						try match(MySqlParser.Tokens.AND.rawValue)
						setState(7252)
						try predicate(7)

						break
					case 3:
						_localctx = SoundsLikePredicateContext(  PredicateContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_predicate)
						setState(7254)
						if (!(precpred(_ctx, 5))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 5)"))
						}
						setState(7255)
						try match(MySqlParser.Tokens.SOUNDS.rawValue)
						setState(7256)
						try match(MySqlParser.Tokens.LIKE.rawValue)
						setState(7257)
						try predicate(6)

						break
					case 4:
						_localctx = RegexpPredicateContext(  PredicateContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_predicate)
						setState(7258)
						if (!(precpred(_ctx, 3))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 3)"))
						}
						setState(7260)
						try _errHandler.sync(self)
						_la = try _input.LA(1)
						if (_la == MySqlParser.Tokens.NOT.rawValue) {
							setState(7259)
							try match(MySqlParser.Tokens.NOT.rawValue)

						}

						setState(7262)
						_localctx.castdown(RegexpPredicateContext.self).regex = try _input.LT(1)
						_la = try _input.LA(1)
						if (!(_la == MySqlParser.Tokens.REGEXP.rawValue || _la == MySqlParser.Tokens.RLIKE.rawValue)) {
							_localctx.castdown(RegexpPredicateContext.self).regex = try _errHandler.recoverInline(self) as Token
						}
						else {
							_errHandler.reportMatch(self)
							try consume()
						}
						setState(7263)
						try predicate(4)

						break
					case 5:
						_localctx = InPredicateContext(  PredicateContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_predicate)
						setState(7264)
						if (!(precpred(_ctx, 10))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 10)"))
						}
						setState(7266)
						try _errHandler.sync(self)
						_la = try _input.LA(1)
						if (_la == MySqlParser.Tokens.NOT.rawValue) {
							setState(7265)
							try match(MySqlParser.Tokens.NOT.rawValue)

						}

						setState(7268)
						try match(MySqlParser.Tokens.IN.rawValue)
						setState(7269)
						try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
						setState(7272)
						try _errHandler.sync(self)
						switch(try getInterpreter().adaptivePredict(_input,1072, _ctx)) {
						case 1:
							setState(7270)
							try selectStatement()

							break
						case 2:
							setState(7271)
							try expressions()

							break
						default: break
						}
						setState(7274)
						try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

						break
					case 6:
						_localctx = IsNullPredicateContext(  PredicateContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_predicate)
						setState(7276)
						if (!(precpred(_ctx, 9))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 9)"))
						}
						setState(7277)
						try match(MySqlParser.Tokens.IS.rawValue)
						setState(7278)
						try nullNotnull()

						break
					case 7:
						_localctx = SubqueryComparisonPredicateContext(  PredicateContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_predicate)
						setState(7279)
						if (!(precpred(_ctx, 7))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 7)"))
						}
						setState(7280)
						try comparisonOperator()
						setState(7281)
						_localctx.castdown(SubqueryComparisonPredicateContext.self).quantifier = try _input.LT(1)
						_la = try _input.LA(1)
						if (!(_la == MySqlParser.Tokens.ALL.rawValue || _la == MySqlParser.Tokens.ANY.rawValue || _la == MySqlParser.Tokens.SOME.rawValue)) {
							_localctx.castdown(SubqueryComparisonPredicateContext.self).quantifier = try _errHandler.recoverInline(self) as Token
						}
						else {
							_errHandler.reportMatch(self)
							try consume()
						}
						setState(7282)
						try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
						setState(7283)
						try selectStatement()
						setState(7284)
						try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

						break
					case 8:
						_localctx = LikePredicateContext(  PredicateContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_predicate)
						setState(7286)
						if (!(precpred(_ctx, 4))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 4)"))
						}
						setState(7288)
						try _errHandler.sync(self)
						_la = try _input.LA(1)
						if (_la == MySqlParser.Tokens.NOT.rawValue) {
							setState(7287)
							try match(MySqlParser.Tokens.NOT.rawValue)

						}

						setState(7290)
						try match(MySqlParser.Tokens.LIKE.rawValue)
						setState(7291)
						try predicate(0)
						setState(7294)
						try _errHandler.sync(self)
						switch (try getInterpreter().adaptivePredict(_input,1074,_ctx)) {
						case 1:
							setState(7292)
							try match(MySqlParser.Tokens.ESCAPE.rawValue)
							setState(7293)
							try match(MySqlParser.Tokens.STRING_LITERAL.rawValue)

							break
						default: break
						}

						break
					case 9:
						_localctx = JsonMemberOfPredicateContext(  PredicateContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_predicate)
						setState(7296)
						if (!(precpred(_ctx, 2))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 2)"))
						}
						setState(7297)
						try match(MySqlParser.Tokens.MEMBER.rawValue)
						setState(7298)
						try match(MySqlParser.Tokens.OF.rawValue)
						setState(7299)
						try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
						setState(7300)
						try predicate(0)
						setState(7301)
						try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

						break
					default: break
					}
			 
				}
				setState(7307)
				try _errHandler.sync(self)
				_alt = try getInterpreter().adaptivePredict(_input,1076,_ctx)
			}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx;
	}


	public class ExpressionAtomContext: ParserRuleContext {
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_expressionAtom
		}
	}
	public class UnaryExpressionAtomContext: ExpressionAtomContext {
			open
			func unaryOperator() -> UnaryOperatorContext? {
				return getRuleContext(UnaryOperatorContext.self, 0)
			}
			open
			func expressionAtom() -> ExpressionAtomContext? {
				return getRuleContext(ExpressionAtomContext.self, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUnaryExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUnaryExpressionAtom(self)
			}
		}
	}
	public class CollateExpressionAtomContext: ExpressionAtomContext {
			open
			func expressionAtom() -> ExpressionAtomContext? {
				return getRuleContext(ExpressionAtomContext.self, 0)
			}
			open
			func COLLATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATE.rawValue, 0)
			}
			open
			func collationName() -> CollationNameContext? {
				return getRuleContext(CollationNameContext.self, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCollateExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCollateExpressionAtom(self)
			}
		}
	}
	public class VariableAssignExpressionAtomContext: ExpressionAtomContext {
			open
			func LOCAL_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL_ID.rawValue, 0)
			}
			open
			func VAR_ASSIGN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VAR_ASSIGN.rawValue, 0)
			}
			open
			func expressionAtom() -> ExpressionAtomContext? {
				return getRuleContext(ExpressionAtomContext.self, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterVariableAssignExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitVariableAssignExpressionAtom(self)
			}
		}
	}
	public class MysqlVariableExpressionAtomContext: ExpressionAtomContext {
			open
			func mysqlVariable() -> MysqlVariableContext? {
				return getRuleContext(MysqlVariableContext.self, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMysqlVariableExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMysqlVariableExpressionAtom(self)
			}
		}
	}
	public class NestedExpressionAtomContext: ExpressionAtomContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterNestedExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitNestedExpressionAtom(self)
			}
		}
	}
	public class NestedRowExpressionAtomContext: ExpressionAtomContext {
			open
			func ROW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROW.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func expression() -> [ExpressionContext] {
				return getRuleContexts(ExpressionContext.self)
			}
			open
			func expression(_ i: Int) -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, i)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}
			open
			func COMMA() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.COMMA.rawValue)
			}
			open
			func COMMA(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMA.rawValue, i)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterNestedRowExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitNestedRowExpressionAtom(self)
			}
		}
	}
	public class MathExpressionAtomContext: ExpressionAtomContext {
		public var `left`: ExpressionAtomContext!
		public var `right`: ExpressionAtomContext!
			open
			func multOperator() -> MultOperatorContext? {
				return getRuleContext(MultOperatorContext.self, 0)
			}
			open
			func expressionAtom() -> [ExpressionAtomContext] {
				return getRuleContexts(ExpressionAtomContext.self)
			}
			open
			func expressionAtom(_ i: Int) -> ExpressionAtomContext? {
				return getRuleContext(ExpressionAtomContext.self, i)
			}
			open
			func addOperator() -> AddOperatorContext? {
				return getRuleContext(AddOperatorContext.self, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMathExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMathExpressionAtom(self)
			}
		}
	}
	public class ExistsExpressionAtomContext: ExpressionAtomContext {
			open
			func EXISTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXISTS.rawValue, 0)
			}
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterExistsExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitExistsExpressionAtom(self)
			}
		}
	}
	public class IntervalExpressionAtomContext: ExpressionAtomContext {
			open
			func INTERVAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTERVAL.rawValue, 0)
			}
			open
			func expression() -> ExpressionContext? {
				return getRuleContext(ExpressionContext.self, 0)
			}
			open
			func intervalType() -> IntervalTypeContext? {
				return getRuleContext(IntervalTypeContext.self, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIntervalExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIntervalExpressionAtom(self)
			}
		}
	}
	public class JsonExpressionAtomContext: ExpressionAtomContext {
		public var `left`: ExpressionAtomContext!
		public var `right`: ExpressionAtomContext!
			open
			func jsonOperator() -> JsonOperatorContext? {
				return getRuleContext(JsonOperatorContext.self, 0)
			}
			open
			func expressionAtom() -> [ExpressionAtomContext] {
				return getRuleContexts(ExpressionAtomContext.self)
			}
			open
			func expressionAtom(_ i: Int) -> ExpressionAtomContext? {
				return getRuleContext(ExpressionAtomContext.self, i)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterJsonExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitJsonExpressionAtom(self)
			}
		}
	}
	public class SubqueryExpressionAtomContext: ExpressionAtomContext {
			open
			func LR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LR_BRACKET.rawValue, 0)
			}
			open
			func selectStatement() -> SelectStatementContext? {
				return getRuleContext(SelectStatementContext.self, 0)
			}
			open
			func RR_BRACKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RR_BRACKET.rawValue, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterSubqueryExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitSubqueryExpressionAtom(self)
			}
		}
	}
	public class ConstantExpressionAtomContext: ExpressionAtomContext {
			open
			func constant() -> ConstantContext? {
				return getRuleContext(ConstantContext.self, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterConstantExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitConstantExpressionAtom(self)
			}
		}
	}
	public class FunctionCallExpressionAtomContext: ExpressionAtomContext {
			open
			func functionCall() -> FunctionCallContext? {
				return getRuleContext(FunctionCallContext.self, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFunctionCallExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFunctionCallExpressionAtom(self)
			}
		}
	}
	public class BinaryExpressionAtomContext: ExpressionAtomContext {
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}
			open
			func expressionAtom() -> ExpressionAtomContext? {
				return getRuleContext(ExpressionAtomContext.self, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterBinaryExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitBinaryExpressionAtom(self)
			}
		}
	}
	public class FullColumnNameExpressionAtomContext: ExpressionAtomContext {
			open
			func fullColumnName() -> FullColumnNameContext? {
				return getRuleContext(FullColumnNameContext.self, 0)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFullColumnNameExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFullColumnNameExpressionAtom(self)
			}
		}
	}
	public class BitExpressionAtomContext: ExpressionAtomContext {
		public var `left`: ExpressionAtomContext!
		public var `right`: ExpressionAtomContext!
			open
			func bitOperator() -> BitOperatorContext? {
				return getRuleContext(BitOperatorContext.self, 0)
			}
			open
			func expressionAtom() -> [ExpressionAtomContext] {
				return getRuleContexts(ExpressionAtomContext.self)
			}
			open
			func expressionAtom(_ i: Int) -> ExpressionAtomContext? {
				return getRuleContext(ExpressionAtomContext.self, i)
			}

		public
		init(_ ctx: ExpressionAtomContext) {
			super.init()
			copyFrom(ctx)
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterBitExpressionAtom(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitBitExpressionAtom(self)
			}
		}
	}

	 public final  func expressionAtom( ) throws -> ExpressionAtomContext   {
		return try expressionAtom(0)
	}
	@discardableResult
	private func expressionAtom(_ _p: Int) throws -> ExpressionAtomContext   {
		let _parentctx: ParserRuleContext? = _ctx
		let _parentState: Int = getState()
		var _localctx: ExpressionAtomContext
		_localctx = ExpressionAtomContext(_ctx, _parentState)
		var _prevctx: ExpressionAtomContext = _localctx
		let _startState: Int = 692
		try enterRecursionRule(_localctx, 692, MySqlParser.RULE_expressionAtom, _p)
		var _la: Int = 0
		defer {
	    		try! unrollRecursionContexts(_parentctx)
	    }
		do {
			var _alt: Int
			try enterOuterAlt(_localctx, 1)
			setState(7356)
			try _errHandler.sync(self)
			switch(try getInterpreter().adaptivePredict(_input,1079, _ctx)) {
			case 1:
				_localctx = ConstantExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx

				setState(7309)
				try constant()

				break
			case 2:
				_localctx = FullColumnNameExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7310)
				try fullColumnName()

				break
			case 3:
				_localctx = FunctionCallExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7311)
				try functionCall()

				break
			case 4:
				_localctx = MysqlVariableExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7312)
				try mysqlVariable()

				break
			case 5:
				_localctx = UnaryExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7313)
				try unaryOperator()
				setState(7314)
				try expressionAtom(12)

				break
			case 6:
				_localctx = BinaryExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7316)
				try match(MySqlParser.Tokens.BINARY.rawValue)
				setState(7317)
				try expressionAtom(11)

				break
			case 7:
				_localctx = VariableAssignExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7318)
				try match(MySqlParser.Tokens.LOCAL_ID.rawValue)
				setState(7319)
				try match(MySqlParser.Tokens.VAR_ASSIGN.rawValue)
				setState(7320)
				try expressionAtom(10)

				break
			case 8:
				_localctx = NestedExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7321)
				try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
				setState(7322)
				try expression(0)
				setState(7327)
				try _errHandler.sync(self)
				_la = try _input.LA(1)
				while (_la == MySqlParser.Tokens.COMMA.rawValue) {
					setState(7323)
					try match(MySqlParser.Tokens.COMMA.rawValue)
					setState(7324)
					try expression(0)


					setState(7329)
					try _errHandler.sync(self)
					_la = try _input.LA(1)
				}
				setState(7330)
				try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

				break
			case 9:
				_localctx = NestedRowExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7332)
				try match(MySqlParser.Tokens.ROW.rawValue)
				setState(7333)
				try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
				setState(7334)
				try expression(0)
				setState(7337) 
				try _errHandler.sync(self)
				_la = try _input.LA(1)
				repeat {
					setState(7335)
					try match(MySqlParser.Tokens.COMMA.rawValue)
					setState(7336)
					try expression(0)


					setState(7339); 
					try _errHandler.sync(self)
					_la = try _input.LA(1)
				} while (_la == MySqlParser.Tokens.COMMA.rawValue)
				setState(7341)
				try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

				break
			case 10:
				_localctx = ExistsExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7343)
				try match(MySqlParser.Tokens.EXISTS.rawValue)
				setState(7344)
				try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
				setState(7345)
				try selectStatement()
				setState(7346)
				try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

				break
			case 11:
				_localctx = SubqueryExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7348)
				try match(MySqlParser.Tokens.LR_BRACKET.rawValue)
				setState(7349)
				try selectStatement()
				setState(7350)
				try match(MySqlParser.Tokens.RR_BRACKET.rawValue)

				break
			case 12:
				_localctx = IntervalExpressionAtomContext(_localctx)
				_ctx = _localctx
				_prevctx = _localctx
				setState(7352)
				try match(MySqlParser.Tokens.INTERVAL.rawValue)
				setState(7353)
				try expression(0)
				setState(7354)
				try intervalType()

				break
			default: break
			}
			_ctx!.stop = try _input.LT(-1)
			setState(7379)
			try _errHandler.sync(self)
			_alt = try getInterpreter().adaptivePredict(_input,1081,_ctx)
			while (_alt != 2 && _alt != ATN.INVALID_ALT_NUMBER) {
				if ( _alt==1 ) {
					if _parseListeners != nil {
					   try triggerExitRuleEvent()
					}
					_prevctx = _localctx
					setState(7377)
					try _errHandler.sync(self)
					switch(try getInterpreter().adaptivePredict(_input,1080, _ctx)) {
					case 1:
						_localctx = BitExpressionAtomContext(  ExpressionAtomContext(_parentctx, _parentState))
						(_localctx as! BitExpressionAtomContext).left = _prevctx
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_expressionAtom)
						setState(7358)
						if (!(precpred(_ctx, 4))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 4)"))
						}
						setState(7359)
						try bitOperator()
						setState(7360)
						try {
								let assignmentValue = try expressionAtom(5)
								_localctx.castdown(BitExpressionAtomContext.self).`right` = assignmentValue
						     }()


						break
					case 2:
						_localctx = MathExpressionAtomContext(  ExpressionAtomContext(_parentctx, _parentState))
						(_localctx as! MathExpressionAtomContext).left = _prevctx
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_expressionAtom)
						setState(7362)
						if (!(precpred(_ctx, 3))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 3)"))
						}
						setState(7363)
						try multOperator()
						setState(7364)
						try {
								let assignmentValue = try expressionAtom(4)
								_localctx.castdown(MathExpressionAtomContext.self).`right` = assignmentValue
						     }()


						break
					case 3:
						_localctx = MathExpressionAtomContext(  ExpressionAtomContext(_parentctx, _parentState))
						(_localctx as! MathExpressionAtomContext).left = _prevctx
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_expressionAtom)
						setState(7366)
						if (!(precpred(_ctx, 2))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 2)"))
						}
						setState(7367)
						try addOperator()
						setState(7368)
						try {
								let assignmentValue = try expressionAtom(3)
								_localctx.castdown(MathExpressionAtomContext.self).`right` = assignmentValue
						     }()


						break
					case 4:
						_localctx = JsonExpressionAtomContext(  ExpressionAtomContext(_parentctx, _parentState))
						(_localctx as! JsonExpressionAtomContext).left = _prevctx
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_expressionAtom)
						setState(7370)
						if (!(precpred(_ctx, 1))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 1)"))
						}
						setState(7371)
						try jsonOperator()
						setState(7372)
						try {
								let assignmentValue = try expressionAtom(2)
								_localctx.castdown(JsonExpressionAtomContext.self).`right` = assignmentValue
						     }()


						break
					case 5:
						_localctx = CollateExpressionAtomContext(  ExpressionAtomContext(_parentctx, _parentState))
						try pushNewRecursionContext(_localctx, _startState, MySqlParser.RULE_expressionAtom)
						setState(7374)
						if (!(precpred(_ctx, 14))) {
						    throw ANTLRException.recognition(e:FailedPredicateException(self, "precpred(_ctx, 14)"))
						}
						setState(7375)
						try match(MySqlParser.Tokens.COLLATE.rawValue)
						setState(7376)
						try collationName()

						break
					default: break
					}
			 
				}
				setState(7381)
				try _errHandler.sync(self)
				_alt = try getInterpreter().adaptivePredict(_input,1081,_ctx)
			}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx;
	}

	public class UnaryOperatorContext: ParserRuleContext {
			open
			func EXCLAMATION_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXCLAMATION_SYMBOL.rawValue, 0)
			}
			open
			func BIT_NOT_OP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_NOT_OP.rawValue, 0)
			}
			open
			func PLUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PLUS.rawValue, 0)
			}
			open
			func MINUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUS.rawValue, 0)
			}
			open
			func NOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_unaryOperator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterUnaryOperator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitUnaryOperator(self)
			}
		}
	}
	@discardableResult
	 open func unaryOperator() throws -> UnaryOperatorContext {
		var _localctx: UnaryOperatorContext
		_localctx = UnaryOperatorContext(_ctx, getState())
		try enterRule(_localctx, 694, MySqlParser.RULE_unaryOperator)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7382)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.NOT.rawValue || ((Int64((_la - 1120)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1120)) & 387) != 0))) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class ComparisonOperatorContext: ParserRuleContext {
			open
			func EQUAL_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue, 0)
			}
			open
			func GREATER_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GREATER_SYMBOL.rawValue, 0)
			}
			open
			func LESS_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LESS_SYMBOL.rawValue, 0)
			}
			open
			func EXCLAMATION_SYMBOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXCLAMATION_SYMBOL.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_comparisonOperator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterComparisonOperator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitComparisonOperator(self)
			}
		}
	}
	@discardableResult
	 open func comparisonOperator() throws -> ComparisonOperatorContext {
		var _localctx: ComparisonOperatorContext
		_localctx = ComparisonOperatorContext(_ctx, getState())
		try enterRule(_localctx, 696, MySqlParser.RULE_comparisonOperator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(7398)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,1082, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(7384)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(7385)
		 		try match(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)

		 		break
		 	case 3:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(7386)
		 		try match(MySqlParser.Tokens.LESS_SYMBOL.rawValue)

		 		break
		 	case 4:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(7387)
		 		try match(MySqlParser.Tokens.LESS_SYMBOL.rawValue)
		 		setState(7388)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		break
		 	case 5:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(7389)
		 		try match(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)
		 		setState(7390)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		break
		 	case 6:
		 		try enterOuterAlt(_localctx, 6)
		 		setState(7391)
		 		try match(MySqlParser.Tokens.LESS_SYMBOL.rawValue)
		 		setState(7392)
		 		try match(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)

		 		break
		 	case 7:
		 		try enterOuterAlt(_localctx, 7)
		 		setState(7393)
		 		try match(MySqlParser.Tokens.EXCLAMATION_SYMBOL.rawValue)
		 		setState(7394)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)

		 		break
		 	case 8:
		 		try enterOuterAlt(_localctx, 8)
		 		setState(7395)
		 		try match(MySqlParser.Tokens.LESS_SYMBOL.rawValue)
		 		setState(7396)
		 		try match(MySqlParser.Tokens.EQUAL_SYMBOL.rawValue)
		 		setState(7397)
		 		try match(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class LogicalOperatorContext: ParserRuleContext {
			open
			func AND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AND.rawValue, 0)
			}
			open
			func BIT_AND_OP() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.BIT_AND_OP.rawValue)
			}
			open
			func BIT_AND_OP(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_AND_OP.rawValue, i)
			}
			open
			func XOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XOR.rawValue, 0)
			}
			open
			func OR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OR.rawValue, 0)
			}
			open
			func BIT_OR_OP() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.BIT_OR_OP.rawValue)
			}
			open
			func BIT_OR_OP(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_OR_OP.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_logicalOperator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterLogicalOperator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitLogicalOperator(self)
			}
		}
	}
	@discardableResult
	 open func logicalOperator() throws -> LogicalOperatorContext {
		var _localctx: LogicalOperatorContext
		_localctx = LogicalOperatorContext(_ctx, getState())
		try enterRule(_localctx, 698, MySqlParser.RULE_logicalOperator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(7407)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .AND:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(7400)
		 		try match(MySqlParser.Tokens.AND.rawValue)

		 		break

		 	case .BIT_AND_OP:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(7401)
		 		try match(MySqlParser.Tokens.BIT_AND_OP.rawValue)
		 		setState(7402)
		 		try match(MySqlParser.Tokens.BIT_AND_OP.rawValue)

		 		break

		 	case .XOR:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(7403)
		 		try match(MySqlParser.Tokens.XOR.rawValue)

		 		break

		 	case .OR:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(7404)
		 		try match(MySqlParser.Tokens.OR.rawValue)

		 		break

		 	case .BIT_OR_OP:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(7405)
		 		try match(MySqlParser.Tokens.BIT_OR_OP.rawValue)
		 		setState(7406)
		 		try match(MySqlParser.Tokens.BIT_OR_OP.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class BitOperatorContext: ParserRuleContext {
			open
			func LESS_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.LESS_SYMBOL.rawValue)
			}
			open
			func LESS_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LESS_SYMBOL.rawValue, i)
			}
			open
			func GREATER_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)
			}
			open
			func GREATER_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GREATER_SYMBOL.rawValue, i)
			}
			open
			func BIT_AND_OP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_AND_OP.rawValue, 0)
			}
			open
			func BIT_XOR_OP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_XOR_OP.rawValue, 0)
			}
			open
			func BIT_OR_OP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_OR_OP.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_bitOperator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterBitOperator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitBitOperator(self)
			}
		}
	}
	@discardableResult
	 open func bitOperator() throws -> BitOperatorContext {
		var _localctx: BitOperatorContext
		_localctx = BitOperatorContext(_ctx, getState())
		try enterRule(_localctx, 700, MySqlParser.RULE_bitOperator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(7416)
		 	try _errHandler.sync(self)
		 	switch (MySqlParser.Tokens(rawValue: try _input.LA(1))!) {
		 	case .LESS_SYMBOL:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(7409)
		 		try match(MySqlParser.Tokens.LESS_SYMBOL.rawValue)
		 		setState(7410)
		 		try match(MySqlParser.Tokens.LESS_SYMBOL.rawValue)

		 		break

		 	case .GREATER_SYMBOL:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(7411)
		 		try match(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)
		 		setState(7412)
		 		try match(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)

		 		break

		 	case .BIT_AND_OP:
		 		try enterOuterAlt(_localctx, 3)
		 		setState(7413)
		 		try match(MySqlParser.Tokens.BIT_AND_OP.rawValue)

		 		break

		 	case .BIT_XOR_OP:
		 		try enterOuterAlt(_localctx, 4)
		 		setState(7414)
		 		try match(MySqlParser.Tokens.BIT_XOR_OP.rawValue)

		 		break

		 	case .BIT_OR_OP:
		 		try enterOuterAlt(_localctx, 5)
		 		setState(7415)
		 		try match(MySqlParser.Tokens.BIT_OR_OP.rawValue)

		 		break
		 	default:
		 		throw ANTLRException.recognition(e: NoViableAltException(self))
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class MultOperatorContext: ParserRuleContext {
			open
			func STAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STAR.rawValue, 0)
			}
			open
			func DIVIDE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DIVIDE.rawValue, 0)
			}
			open
			func MODULE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MODULE.rawValue, 0)
			}
			open
			func DIV() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DIV.rawValue, 0)
			}
			open
			func MOD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MOD.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_multOperator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterMultOperator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitMultOperator(self)
			}
		}
	}
	@discardableResult
	 open func multOperator() throws -> MultOperatorContext {
		var _localctx: MultOperatorContext
		_localctx = MultOperatorContext(_ctx, getState())
		try enterRule(_localctx, 702, MySqlParser.RULE_multOperator)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7418)
		 	_la = try _input.LA(1)
		 	if (!(((Int64((_la - 1117)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1117)) & 103) != 0))) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class AddOperatorContext: ParserRuleContext {
			open
			func PLUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PLUS.rawValue, 0)
			}
			open
			func MINUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUS.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_addOperator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterAddOperator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitAddOperator(self)
			}
		}
	}
	@discardableResult
	 open func addOperator() throws -> AddOperatorContext {
		var _localctx: AddOperatorContext
		_localctx = AddOperatorContext(_ctx, getState())
		try enterRule(_localctx, 704, MySqlParser.RULE_addOperator)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7420)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.PLUS.rawValue || _la == MySqlParser.Tokens.MINUS.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class JsonOperatorContext: ParserRuleContext {
			open
			func MINUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUS.rawValue, 0)
			}
			open
			func GREATER_SYMBOL() -> [TerminalNode] {
				return getTokens(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)
			}
			open
			func GREATER_SYMBOL(_ i:Int) -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GREATER_SYMBOL.rawValue, i)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_jsonOperator
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterJsonOperator(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitJsonOperator(self)
			}
		}
	}
	@discardableResult
	 open func jsonOperator() throws -> JsonOperatorContext {
		var _localctx: JsonOperatorContext
		_localctx = JsonOperatorContext(_ctx, getState())
		try enterRule(_localctx, 706, MySqlParser.RULE_jsonOperator)
		defer {
	    		try! exitRule()
	    }
		do {
		 	setState(7427)
		 	try _errHandler.sync(self)
		 	switch(try getInterpreter().adaptivePredict(_input,1085, _ctx)) {
		 	case 1:
		 		try enterOuterAlt(_localctx, 1)
		 		setState(7422)
		 		try match(MySqlParser.Tokens.MINUS.rawValue)
		 		setState(7423)
		 		try match(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)

		 		break
		 	case 2:
		 		try enterOuterAlt(_localctx, 2)
		 		setState(7424)
		 		try match(MySqlParser.Tokens.MINUS.rawValue)
		 		setState(7425)
		 		try match(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)
		 		setState(7426)
		 		try match(MySqlParser.Tokens.GREATER_SYMBOL.rawValue)

		 		break
		 	default: break
		 	}
		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class CharsetNameBaseContext: ParserRuleContext {
			open
			func ARMSCII8() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ARMSCII8.rawValue, 0)
			}
			open
			func ASCII() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASCII.rawValue, 0)
			}
			open
			func BIG5() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIG5.rawValue, 0)
			}
			open
			func BINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINARY.rawValue, 0)
			}
			open
			func CP1250() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CP1250.rawValue, 0)
			}
			open
			func CP1251() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CP1251.rawValue, 0)
			}
			open
			func CP1256() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CP1256.rawValue, 0)
			}
			open
			func CP1257() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CP1257.rawValue, 0)
			}
			open
			func CP850() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CP850.rawValue, 0)
			}
			open
			func CP852() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CP852.rawValue, 0)
			}
			open
			func CP866() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CP866.rawValue, 0)
			}
			open
			func CP932() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CP932.rawValue, 0)
			}
			open
			func DEC8() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEC8.rawValue, 0)
			}
			open
			func EUCJPMS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EUCJPMS.rawValue, 0)
			}
			open
			func EUCKR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EUCKR.rawValue, 0)
			}
			open
			func GB18030() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GB18030.rawValue, 0)
			}
			open
			func GB2312() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GB2312.rawValue, 0)
			}
			open
			func GBK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GBK.rawValue, 0)
			}
			open
			func GEOSTD8() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOSTD8.rawValue, 0)
			}
			open
			func GREEK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GREEK.rawValue, 0)
			}
			open
			func HEBREW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HEBREW.rawValue, 0)
			}
			open
			func HP8() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HP8.rawValue, 0)
			}
			open
			func KEYBCS2() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEYBCS2.rawValue, 0)
			}
			open
			func KOI8R() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KOI8R.rawValue, 0)
			}
			open
			func KOI8U() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KOI8U.rawValue, 0)
			}
			open
			func LATIN1() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LATIN1.rawValue, 0)
			}
			open
			func LATIN2() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LATIN2.rawValue, 0)
			}
			open
			func LATIN5() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LATIN5.rawValue, 0)
			}
			open
			func LATIN7() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LATIN7.rawValue, 0)
			}
			open
			func MACCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MACCE.rawValue, 0)
			}
			open
			func MACROMAN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MACROMAN.rawValue, 0)
			}
			open
			func SJIS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SJIS.rawValue, 0)
			}
			open
			func SWE7() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SWE7.rawValue, 0)
			}
			open
			func TIS620() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIS620.rawValue, 0)
			}
			open
			func UCS2() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UCS2.rawValue, 0)
			}
			open
			func UJIS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UJIS.rawValue, 0)
			}
			open
			func UTF16() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UTF16.rawValue, 0)
			}
			open
			func UTF16LE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UTF16LE.rawValue, 0)
			}
			open
			func UTF32() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UTF32.rawValue, 0)
			}
			open
			func UTF8() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UTF8.rawValue, 0)
			}
			open
			func UTF8MB3() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UTF8MB3.rawValue, 0)
			}
			open
			func UTF8MB4() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UTF8MB4.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_charsetNameBase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterCharsetNameBase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitCharsetNameBase(self)
			}
		}
	}
	@discardableResult
	 open func charsetNameBase() throws -> CharsetNameBaseContext {
		var _localctx: CharsetNameBaseContext
		_localctx = CharsetNameBaseContext(_ctx, getState())
		try enterRule(_localctx, 708, MySqlParser.RULE_charsetNameBase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7429)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.BINARY.rawValue || ((Int64((_la - 746)) & ~0x3f) == 0 && ((Int64(1) << (_la - 746)) & 2199023255551) != 0))) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class TransactionLevelBaseContext: ParserRuleContext {
			open
			func REPEATABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPEATABLE.rawValue, 0)
			}
			open
			func COMMITTED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMITTED.rawValue, 0)
			}
			open
			func UNCOMMITTED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNCOMMITTED.rawValue, 0)
			}
			open
			func SERIALIZABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SERIALIZABLE.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_transactionLevelBase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterTransactionLevelBase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitTransactionLevelBase(self)
			}
		}
	}
	@discardableResult
	 open func transactionLevelBase() throws -> TransactionLevelBaseContext {
		var _localctx: TransactionLevelBaseContext
		_localctx = TransactionLevelBaseContext(_ctx, getState())
		try enterRule(_localctx, 710, MySqlParser.RULE_transactionLevelBase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7431)
		 	_la = try _input.LA(1)
		 	if (!(((Int64((_la - 799)) & ~0x3f) == 0 && ((Int64(1) << (_la - 799)) & 15) != 0))) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class PrivilegesBaseContext: ParserRuleContext {
			open
			func TABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLES.rawValue, 0)
			}
			open
			func ROUTINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROUTINE.rawValue, 0)
			}
			open
			func EXECUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXECUTE.rawValue, 0)
			}
			open
			func FILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FILE.rawValue, 0)
			}
			open
			func PROCESS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCESS.rawValue, 0)
			}
			open
			func RELOAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELOAD.rawValue, 0)
			}
			open
			func SHUTDOWN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHUTDOWN.rawValue, 0)
			}
			open
			func SUPER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUPER.rawValue, 0)
			}
			open
			func PRIVILEGES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRIVILEGES.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_privilegesBase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterPrivilegesBase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitPrivilegesBase(self)
			}
		}
	}
	@discardableResult
	 open func privilegesBase() throws -> PrivilegesBaseContext {
		var _localctx: PrivilegesBaseContext
		_localctx = PrivilegesBaseContext(_ctx, getState())
		try enterRule(_localctx, 712, MySqlParser.RULE_privilegesBase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7433)
		 	_la = try _input.LA(1)
		 	if (!(((Int64((_la - 708)) & ~0x3f) == 0 && ((Int64(1) << (_la - 708)) & 23656792067) != 0))) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class IntervalTypeBaseContext: ParserRuleContext {
			open
			func QUARTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUARTER.rawValue, 0)
			}
			open
			func MONTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MONTH.rawValue, 0)
			}
			open
			func DAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DAY.rawValue, 0)
			}
			open
			func HOUR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HOUR.rawValue, 0)
			}
			open
			func MINUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUTE.rawValue, 0)
			}
			open
			func WEEK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WEEK.rawValue, 0)
			}
			open
			func SECOND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SECOND.rawValue, 0)
			}
			open
			func MICROSECOND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MICROSECOND.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_intervalTypeBase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterIntervalTypeBase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitIntervalTypeBase(self)
			}
		}
	}
	@discardableResult
	 open func intervalTypeBase() throws -> IntervalTypeBaseContext {
		var _localctx: IntervalTypeBaseContext
		_localctx = IntervalTypeBaseContext(_ctx, getState())
		try enterRule(_localctx, 714, MySqlParser.RULE_intervalTypeBase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7435)
		 	_la = try _input.LA(1)
		 	if (!(((Int64((_la - 689)) & ~0x3f) == 0 && ((Int64(1) << (_la - 689)) & 255) != 0))) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class DataTypeBaseContext: ParserRuleContext {
			open
			func DATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATE.rawValue, 0)
			}
			open
			func TIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIME.rawValue, 0)
			}
			open
			func TIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIMESTAMP.rawValue, 0)
			}
			open
			func DATETIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATETIME.rawValue, 0)
			}
			open
			func YEAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.YEAR.rawValue, 0)
			}
			open
			func ENUM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENUM.rawValue, 0)
			}
			open
			func TEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TEXT.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_dataTypeBase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterDataTypeBase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitDataTypeBase(self)
			}
		}
	}
	@discardableResult
	 open func dataTypeBase() throws -> DataTypeBaseContext {
		var _localctx: DataTypeBaseContext
		_localctx = DataTypeBaseContext(_ctx, getState())
		try enterRule(_localctx, 716, MySqlParser.RULE_dataTypeBase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7437)
		 	_la = try _input.LA(1)
		 	if (!(((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & 1179679) != 0))) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class KeywordsCanBeIdContext: ParserRuleContext {
			open
			func ACCOUNT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ACCOUNT.rawValue, 0)
			}
			open
			func ACTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ACTION.rawValue, 0)
			}
			open
			func ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADMIN.rawValue, 0)
			}
			open
			func AFTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AFTER.rawValue, 0)
			}
			open
			func AGGREGATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AGGREGATE.rawValue, 0)
			}
			open
			func ALGORITHM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ALGORITHM.rawValue, 0)
			}
			open
			func ANY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ANY.rawValue, 0)
			}
			open
			func ARRAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ARRAY.rawValue, 0)
			}
			open
			func AT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AT.rawValue, 0)
			}
			open
			func AUDIT_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUDIT_ADMIN.rawValue, 0)
			}
			open
			func AUDIT_ABORT_EXEMPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUDIT_ABORT_EXEMPT.rawValue, 0)
			}
			open
			func AUTHORS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTHORS.rawValue, 0)
			}
			open
			func AUTOCOMMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTOCOMMIT.rawValue, 0)
			}
			open
			func AUTOEXTEND_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTOEXTEND_SIZE.rawValue, 0)
			}
			open
			func AUTO_INCREMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTO_INCREMENT.rawValue, 0)
			}
			open
			func AUTHENTICATION_POLICY_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AUTHENTICATION_POLICY_ADMIN.rawValue, 0)
			}
			open
			func AVG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AVG.rawValue, 0)
			}
			open
			func AVG_ROW_LENGTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AVG_ROW_LENGTH.rawValue, 0)
			}
			open
			func ATTRIBUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ATTRIBUTE.rawValue, 0)
			}
			open
			func BACKUP_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BACKUP_ADMIN.rawValue, 0)
			}
			open
			func BEGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BEGIN.rawValue, 0)
			}
			open
			func BINLOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINLOG.rawValue, 0)
			}
			open
			func BINLOG_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINLOG_ADMIN.rawValue, 0)
			}
			open
			func BINLOG_ENCRYPTION_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BINLOG_ENCRYPTION_ADMIN.rawValue, 0)
			}
			open
			func BIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT.rawValue, 0)
			}
			open
			func BIT_AND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_AND.rawValue, 0)
			}
			open
			func BIT_OR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_OR.rawValue, 0)
			}
			open
			func BIT_XOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_XOR.rawValue, 0)
			}
			open
			func BLOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BLOCK.rawValue, 0)
			}
			open
			func BOOL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BOOL.rawValue, 0)
			}
			open
			func BOOLEAN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BOOLEAN.rawValue, 0)
			}
			open
			func BTREE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BTREE.rawValue, 0)
			}
			open
			func BUCKETS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BUCKETS.rawValue, 0)
			}
			open
			func CACHE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CACHE.rawValue, 0)
			}
			open
			func CASCADED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CASCADED.rawValue, 0)
			}
			open
			func CHAIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHAIN.rawValue, 0)
			}
			open
			func CHANGED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHANGED.rawValue, 0)
			}
			open
			func CHANNEL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHANNEL.rawValue, 0)
			}
			open
			func CHECKSUM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHECKSUM.rawValue, 0)
			}
			open
			func PAGE_CHECKSUM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PAGE_CHECKSUM.rawValue, 0)
			}
			open
			func CATALOG_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CATALOG_NAME.rawValue, 0)
			}
			open
			func CIPHER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CIPHER.rawValue, 0)
			}
			open
			func CLASS_ORIGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CLASS_ORIGIN.rawValue, 0)
			}
			open
			func CLIENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CLIENT.rawValue, 0)
			}
			open
			func CLONE_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CLONE_ADMIN.rawValue, 0)
			}
			open
			func CLOSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CLOSE.rawValue, 0)
			}
			open
			func CLUSTERING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CLUSTERING.rawValue, 0)
			}
			open
			func COALESCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COALESCE.rawValue, 0)
			}
			open
			func CODE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CODE.rawValue, 0)
			}
			open
			func COLUMNS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMNS.rawValue, 0)
			}
			open
			func COLUMN_FORMAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN_FORMAT.rawValue, 0)
			}
			open
			func COLUMN_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLUMN_NAME.rawValue, 0)
			}
			open
			func COMMENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMENT.rawValue, 0)
			}
			open
			func COMMIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMMIT.rawValue, 0)
			}
			open
			func COMPACT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMPACT.rawValue, 0)
			}
			open
			func COMPLETION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMPLETION.rawValue, 0)
			}
			open
			func COMPRESSED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMPRESSED.rawValue, 0)
			}
			open
			func COMPRESSION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMPRESSION.rawValue, 0)
			}
			open
			func CONCURRENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONCURRENT.rawValue, 0)
			}
			open
			func CONDITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONDITION.rawValue, 0)
			}
			open
			func CONNECT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONNECT.rawValue, 0)
			}
			open
			func CONNECTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONNECTION.rawValue, 0)
			}
			open
			func CONNECTION_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONNECTION_ADMIN.rawValue, 0)
			}
			open
			func CONSISTENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSISTENT.rawValue, 0)
			}
			open
			func CONSTRAINT_CATALOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT_CATALOG.rawValue, 0)
			}
			open
			func CONSTRAINT_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT_NAME.rawValue, 0)
			}
			open
			func CONSTRAINT_SCHEMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONSTRAINT_SCHEMA.rawValue, 0)
			}
			open
			func CONTAINS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONTAINS.rawValue, 0)
			}
			open
			func CONTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONTEXT.rawValue, 0)
			}
			open
			func CONTRIBUTORS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONTRIBUTORS.rawValue, 0)
			}
			open
			func COPY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COPY.rawValue, 0)
			}
			open
			func COUNT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COUNT.rawValue, 0)
			}
			open
			func CPU() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CPU.rawValue, 0)
			}
			open
			func CURRENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT.rawValue, 0)
			}
			open
			func CURRENT_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURRENT_USER.rawValue, 0)
			}
			open
			func CURSOR_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CURSOR_NAME.rawValue, 0)
			}
			open
			func DATA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATA.rawValue, 0)
			}
			open
			func DATAFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATAFILE.rawValue, 0)
			}
			open
			func DEALLOCATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEALLOCATE.rawValue, 0)
			}
			open
			func DEFAULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT.rawValue, 0)
			}
			open
			func DEFAULT_AUTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFAULT_AUTH.rawValue, 0)
			}
			open
			func DEFINER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEFINER.rawValue, 0)
			}
			open
			func DELAY_KEY_WRITE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DELAY_KEY_WRITE.rawValue, 0)
			}
			open
			func DES_KEY_FILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DES_KEY_FILE.rawValue, 0)
			}
			open
			func DIAGNOSTICS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DIAGNOSTICS.rawValue, 0)
			}
			open
			func DIRECTORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DIRECTORY.rawValue, 0)
			}
			open
			func DISABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISABLE.rawValue, 0)
			}
			open
			func DISCARD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISCARD.rawValue, 0)
			}
			open
			func DISK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISK.rawValue, 0)
			}
			open
			func DO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DO.rawValue, 0)
			}
			open
			func DUMPFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DUMPFILE.rawValue, 0)
			}
			open
			func DUPLICATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DUPLICATE.rawValue, 0)
			}
			open
			func DYNAMIC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DYNAMIC.rawValue, 0)
			}
			open
			func EMPTY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EMPTY.rawValue, 0)
			}
			open
			func ENABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENABLE.rawValue, 0)
			}
			open
			func ENCRYPTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENCRYPTION.rawValue, 0)
			}
			open
			func ENCRYPTION_KEY_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENCRYPTION_KEY_ADMIN.rawValue, 0)
			}
			open
			func END() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.END.rawValue, 0)
			}
			open
			func ENDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENDS.rawValue, 0)
			}
			open
			func ENGINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE.rawValue, 0)
			}
			open
			func ENGINE_ATTRIBUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue, 0)
			}
			open
			func ENGINES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENGINES.rawValue, 0)
			}
			open
			func ENFORCED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENFORCED.rawValue, 0)
			}
			open
			func ERROR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ERROR.rawValue, 0)
			}
			open
			func ERRORS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ERRORS.rawValue, 0)
			}
			open
			func ESCAPE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ESCAPE.rawValue, 0)
			}
			open
			func EUR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EUR.rawValue, 0)
			}
			open
			func EVEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVEN.rawValue, 0)
			}
			open
			func EVENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVENT.rawValue, 0)
			}
			open
			func EVENTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVENTS.rawValue, 0)
			}
			open
			func EVERY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EVERY.rawValue, 0)
			}
			open
			func EXCEPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXCEPT.rawValue, 0)
			}
			open
			func EXCHANGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXCHANGE.rawValue, 0)
			}
			open
			func EXCLUSIVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXCLUSIVE.rawValue, 0)
			}
			open
			func EXPIRE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXPIRE.rawValue, 0)
			}
			open
			func EXPORT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXPORT.rawValue, 0)
			}
			open
			func EXTENDED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXTENDED.rawValue, 0)
			}
			open
			func EXTENT_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXTENT_SIZE.rawValue, 0)
			}
			open
			func FAILED_LOGIN_ATTEMPTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FAILED_LOGIN_ATTEMPTS.rawValue, 0)
			}
			open
			func FAST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FAST.rawValue, 0)
			}
			open
			func FAULTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FAULTS.rawValue, 0)
			}
			open
			func FIELDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIELDS.rawValue, 0)
			}
			open
			func FILE_BLOCK_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FILE_BLOCK_SIZE.rawValue, 0)
			}
			open
			func FILTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FILTER.rawValue, 0)
			}
			open
			func FIREWALL_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIREWALL_ADMIN.rawValue, 0)
			}
			open
			func FIREWALL_EXEMPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIREWALL_EXEMPT.rawValue, 0)
			}
			open
			func FIREWALL_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIREWALL_USER.rawValue, 0)
			}
			open
			func FIRST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIRST.rawValue, 0)
			}
			open
			func FIXED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIXED.rawValue, 0)
			}
			open
			func FLUSH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FLUSH.rawValue, 0)
			}
			open
			func FOLLOWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOLLOWS.rawValue, 0)
			}
			open
			func FOUND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOUND.rawValue, 0)
			}
			open
			func FULL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FULL.rawValue, 0)
			}
			open
			func FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FUNCTION.rawValue, 0)
			}
			open
			func GENERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GENERAL.rawValue, 0)
			}
			open
			func GLOBAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GLOBAL.rawValue, 0)
			}
			open
			func GRANTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GRANTS.rawValue, 0)
			}
			open
			func GROUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP.rawValue, 0)
			}
			open
			func GROUP_CONCAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP_CONCAT.rawValue, 0)
			}
			open
			func GROUP_REPLICATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP_REPLICATION.rawValue, 0)
			}
			open
			func GROUP_REPLICATION_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GROUP_REPLICATION_ADMIN.rawValue, 0)
			}
			open
			func HANDLER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HANDLER.rawValue, 0)
			}
			open
			func HASH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HASH.rawValue, 0)
			}
			open
			func HELP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HELP.rawValue, 0)
			}
			open
			func HISTORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HISTORY.rawValue, 0)
			}
			open
			func HOST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HOST.rawValue, 0)
			}
			open
			func HOSTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HOSTS.rawValue, 0)
			}
			open
			func IDENTIFIED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IDENTIFIED.rawValue, 0)
			}
			open
			func IGNORED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORED.rawValue, 0)
			}
			open
			func IGNORE_SERVER_IDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IGNORE_SERVER_IDS.rawValue, 0)
			}
			open
			func IMPORT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IMPORT.rawValue, 0)
			}
			open
			func INDEXES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INDEXES.rawValue, 0)
			}
			open
			func INITIAL_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INITIAL_SIZE.rawValue, 0)
			}
			open
			func INNODB_REDO_LOG_ARCHIVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INNODB_REDO_LOG_ARCHIVE.rawValue, 0)
			}
			open
			func INPLACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INPLACE.rawValue, 0)
			}
			open
			func INSERT_METHOD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSERT_METHOD.rawValue, 0)
			}
			open
			func INSTALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSTALL.rawValue, 0)
			}
			open
			func INSTANCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSTANCE.rawValue, 0)
			}
			open
			func INSTANT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSTANT.rawValue, 0)
			}
			open
			func INTERNAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTERNAL.rawValue, 0)
			}
			open
			func INVOKE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INVOKE.rawValue, 0)
			}
			open
			func INVOKER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INVOKER.rawValue, 0)
			}
			open
			func IO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IO.rawValue, 0)
			}
			open
			func IO_THREAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IO_THREAD.rawValue, 0)
			}
			open
			func IPC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IPC.rawValue, 0)
			}
			open
			func ISO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ISO.rawValue, 0)
			}
			open
			func ISOLATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ISOLATION.rawValue, 0)
			}
			open
			func ISSUER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ISSUER.rawValue, 0)
			}
			open
			func JIS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JIS.rawValue, 0)
			}
			open
			func JSON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON.rawValue, 0)
			}
			open
			func KEY_BLOCK_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.KEY_BLOCK_SIZE.rawValue, 0)
			}
			open
			func LAMBDA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LAMBDA.rawValue, 0)
			}
			open
			func LANGUAGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LANGUAGE.rawValue, 0)
			}
			open
			func LAST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LAST.rawValue, 0)
			}
			open
			func LATERAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LATERAL.rawValue, 0)
			}
			open
			func LEAVES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEAVES.rawValue, 0)
			}
			open
			func LESS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LESS.rawValue, 0)
			}
			open
			func LEVEL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEVEL.rawValue, 0)
			}
			open
			func LIST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LIST.rawValue, 0)
			}
			open
			func LOCAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCAL.rawValue, 0)
			}
			open
			func LOGFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOGFILE.rawValue, 0)
			}
			open
			func LOGS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOGS.rawValue, 0)
			}
			open
			func MASTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER.rawValue, 0)
			}
			open
			func MASTER_AUTO_POSITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_AUTO_POSITION.rawValue, 0)
			}
			open
			func MASTER_CONNECT_RETRY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_CONNECT_RETRY.rawValue, 0)
			}
			open
			func MASTER_DELAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_DELAY.rawValue, 0)
			}
			open
			func MASTER_HEARTBEAT_PERIOD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_HEARTBEAT_PERIOD.rawValue, 0)
			}
			open
			func MASTER_HOST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_HOST.rawValue, 0)
			}
			open
			func MASTER_LOG_FILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_LOG_FILE.rawValue, 0)
			}
			open
			func MASTER_LOG_POS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_LOG_POS.rawValue, 0)
			}
			open
			func MASTER_PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_PASSWORD.rawValue, 0)
			}
			open
			func MASTER_PORT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_PORT.rawValue, 0)
			}
			open
			func MASTER_RETRY_COUNT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_RETRY_COUNT.rawValue, 0)
			}
			open
			func MASTER_SSL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL.rawValue, 0)
			}
			open
			func MASTER_SSL_CA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CA.rawValue, 0)
			}
			open
			func MASTER_SSL_CAPATH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CAPATH.rawValue, 0)
			}
			open
			func MASTER_SSL_CERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CERT.rawValue, 0)
			}
			open
			func MASTER_SSL_CIPHER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CIPHER.rawValue, 0)
			}
			open
			func MASTER_SSL_CRL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CRL.rawValue, 0)
			}
			open
			func MASTER_SSL_CRLPATH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_CRLPATH.rawValue, 0)
			}
			open
			func MASTER_SSL_KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_SSL_KEY.rawValue, 0)
			}
			open
			func MASTER_TLS_VERSION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_TLS_VERSION.rawValue, 0)
			}
			open
			func MASTER_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_USER.rawValue, 0)
			}
			open
			func MAX_CONNECTIONS_PER_HOUR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_CONNECTIONS_PER_HOUR.rawValue, 0)
			}
			open
			func MAX_QUERIES_PER_HOUR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_QUERIES_PER_HOUR.rawValue, 0)
			}
			open
			func MAX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX.rawValue, 0)
			}
			open
			func MAX_ROWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_ROWS.rawValue, 0)
			}
			open
			func MAX_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_SIZE.rawValue, 0)
			}
			open
			func MAX_UPDATES_PER_HOUR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_UPDATES_PER_HOUR.rawValue, 0)
			}
			open
			func MAX_USER_CONNECTIONS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAX_USER_CONNECTIONS.rawValue, 0)
			}
			open
			func MEDIUM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEDIUM.rawValue, 0)
			}
			open
			func MEMBER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEMBER.rawValue, 0)
			}
			open
			func MEMORY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MEMORY.rawValue, 0)
			}
			open
			func MERGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MERGE.rawValue, 0)
			}
			open
			func MESSAGE_TEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MESSAGE_TEXT.rawValue, 0)
			}
			open
			func MID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MID.rawValue, 0)
			}
			open
			func MIGRATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MIGRATE.rawValue, 0)
			}
			open
			func MIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MIN.rawValue, 0)
			}
			open
			func MIN_ROWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MIN_ROWS.rawValue, 0)
			}
			open
			func MODE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MODE.rawValue, 0)
			}
			open
			func MODIFY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MODIFY.rawValue, 0)
			}
			open
			func MUTEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MUTEX.rawValue, 0)
			}
			open
			func MYSQL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MYSQL.rawValue, 0)
			}
			open
			func MYSQL_ERRNO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MYSQL_ERRNO.rawValue, 0)
			}
			open
			func NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NAME.rawValue, 0)
			}
			open
			func NAMES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NAMES.rawValue, 0)
			}
			open
			func NCHAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NCHAR.rawValue, 0)
			}
			open
			func NDB_STORED_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NDB_STORED_USER.rawValue, 0)
			}
			open
			func NESTED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NESTED.rawValue, 0)
			}
			open
			func NEVER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NEVER.rawValue, 0)
			}
			open
			func NEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NEXT.rawValue, 0)
			}
			open
			func NO() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NO.rawValue, 0)
			}
			open
			func NOCOPY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOCOPY.rawValue, 0)
			}
			open
			func NODEGROUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NODEGROUP.rawValue, 0)
			}
			open
			func NONE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NONE.rawValue, 0)
			}
			open
			func NOWAIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NOWAIT.rawValue, 0)
			}
			open
			func NUMBER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NUMBER.rawValue, 0)
			}
			open
			func ODBC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ODBC.rawValue, 0)
			}
			open
			func OFFLINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OFFLINE.rawValue, 0)
			}
			open
			func OFFSET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OFFSET.rawValue, 0)
			}
			open
			func OF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OF.rawValue, 0)
			}
			open
			func OJ() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OJ.rawValue, 0)
			}
			open
			func OLD_PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OLD_PASSWORD.rawValue, 0)
			}
			open
			func ONE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONE.rawValue, 0)
			}
			open
			func ONLINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONLINE.rawValue, 0)
			}
			open
			func ONLY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ONLY.rawValue, 0)
			}
			open
			func OPEN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPEN.rawValue, 0)
			}
			open
			func OPTIMIZER_COSTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTIMIZER_COSTS.rawValue, 0)
			}
			open
			func OPTIONAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTIONAL.rawValue, 0)
			}
			open
			func OPTIONS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OPTIONS.rawValue, 0)
			}
			open
			func ORDER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ORDER.rawValue, 0)
			}
			open
			func ORDINALITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ORDINALITY.rawValue, 0)
			}
			open
			func OWNER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OWNER.rawValue, 0)
			}
			open
			func PACK_KEYS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PACK_KEYS.rawValue, 0)
			}
			open
			func PAGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PAGE.rawValue, 0)
			}
			open
			func PARSER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARSER.rawValue, 0)
			}
			open
			func PARTIAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTIAL.rawValue, 0)
			}
			open
			func PARTITIONING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITIONING.rawValue, 0)
			}
			open
			func PARTITIONS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PARTITIONS.rawValue, 0)
			}
			open
			func PASSWORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD.rawValue, 0)
			}
			open
			func PASSWORDLESS_USER_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORDLESS_USER_ADMIN.rawValue, 0)
			}
			open
			func PASSWORD_LOCK_TIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PASSWORD_LOCK_TIME.rawValue, 0)
			}
			open
			func PATH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PATH.rawValue, 0)
			}
			open
			func PERSIST_RO_VARIABLES_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PERSIST_RO_VARIABLES_ADMIN.rawValue, 0)
			}
			open
			func PHASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PHASE.rawValue, 0)
			}
			open
			func PLUGINS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PLUGINS.rawValue, 0)
			}
			open
			func PLUGIN_DIR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PLUGIN_DIR.rawValue, 0)
			}
			open
			func PLUGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PLUGIN.rawValue, 0)
			}
			open
			func PORT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PORT.rawValue, 0)
			}
			open
			func PRECEDES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRECEDES.rawValue, 0)
			}
			open
			func PREPARE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PREPARE.rawValue, 0)
			}
			open
			func PRESERVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRESERVE.rawValue, 0)
			}
			open
			func PREV() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PREV.rawValue, 0)
			}
			open
			func PRIMARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PRIMARY.rawValue, 0)
			}
			open
			func PROCESSLIST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROCESSLIST.rawValue, 0)
			}
			open
			func PROFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROFILE.rawValue, 0)
			}
			open
			func PROFILES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROFILES.rawValue, 0)
			}
			open
			func PROXY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PROXY.rawValue, 0)
			}
			open
			func QUERY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUERY.rawValue, 0)
			}
			open
			func QUICK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUICK.rawValue, 0)
			}
			open
			func REBUILD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REBUILD.rawValue, 0)
			}
			open
			func RECOVER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RECOVER.rawValue, 0)
			}
			open
			func RECURSIVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RECURSIVE.rawValue, 0)
			}
			open
			func REDO_BUFFER_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REDO_BUFFER_SIZE.rawValue, 0)
			}
			open
			func REDUNDANT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REDUNDANT.rawValue, 0)
			}
			open
			func RELAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELAY.rawValue, 0)
			}
			open
			func RELAYLOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELAYLOG.rawValue, 0)
			}
			open
			func RELAY_LOG_FILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELAY_LOG_FILE.rawValue, 0)
			}
			open
			func RELAY_LOG_POS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELAY_LOG_POS.rawValue, 0)
			}
			open
			func REMOVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REMOVE.rawValue, 0)
			}
			open
			func REORGANIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REORGANIZE.rawValue, 0)
			}
			open
			func REPAIR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPAIR.rawValue, 0)
			}
			open
			func REPLICATE_DO_DB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_DO_DB.rawValue, 0)
			}
			open
			func REPLICATE_DO_TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_DO_TABLE.rawValue, 0)
			}
			open
			func REPLICATE_IGNORE_DB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_IGNORE_DB.rawValue, 0)
			}
			open
			func REPLICATE_IGNORE_TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_IGNORE_TABLE.rawValue, 0)
			}
			open
			func REPLICATE_REWRITE_DB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_REWRITE_DB.rawValue, 0)
			}
			open
			func REPLICATE_WILD_DO_TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_WILD_DO_TABLE.rawValue, 0)
			}
			open
			func REPLICATE_WILD_IGNORE_TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATE_WILD_IGNORE_TABLE.rawValue, 0)
			}
			open
			func REPLICATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATION.rawValue, 0)
			}
			open
			func REPLICATION_APPLIER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATION_APPLIER.rawValue, 0)
			}
			open
			func REPLICATION_SLAVE_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REPLICATION_SLAVE_ADMIN.rawValue, 0)
			}
			open
			func RESET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESET.rawValue, 0)
			}
			open
			func RESOURCE_GROUP_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESOURCE_GROUP_ADMIN.rawValue, 0)
			}
			open
			func RESOURCE_GROUP_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESOURCE_GROUP_USER.rawValue, 0)
			}
			open
			func RESUME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RESUME.rawValue, 0)
			}
			open
			func RETURNED_SQLSTATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RETURNED_SQLSTATE.rawValue, 0)
			}
			open
			func RETURNING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RETURNING.rawValue, 0)
			}
			open
			func RETURNS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RETURNS.rawValue, 0)
			}
			open
			func REUSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REUSE.rawValue, 0)
			}
			open
			func ROLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLE.rawValue, 0)
			}
			open
			func ROLE_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLE_ADMIN.rawValue, 0)
			}
			open
			func ROLLBACK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLLBACK.rawValue, 0)
			}
			open
			func ROLLUP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROLLUP.rawValue, 0)
			}
			open
			func ROTATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROTATE.rawValue, 0)
			}
			open
			func ROW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROW.rawValue, 0)
			}
			open
			func ROWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROWS.rawValue, 0)
			}
			open
			func ROW_FORMAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROW_FORMAT.rawValue, 0)
			}
			open
			func RTREE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RTREE.rawValue, 0)
			}
			open
			func S3() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.S3.rawValue, 0)
			}
			open
			func SAVEPOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SAVEPOINT.rawValue, 0)
			}
			open
			func SCHEDULE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEDULE.rawValue, 0)
			}
			open
			func SCHEMA_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEMA_NAME.rawValue, 0)
			}
			open
			func SECURITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SECURITY.rawValue, 0)
			}
			open
			func SECONDARY_ENGINE_ATTRIBUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue, 0)
			}
			open
			func SERIAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SERIAL.rawValue, 0)
			}
			open
			func SERVER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SERVER.rawValue, 0)
			}
			open
			func SESSION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SESSION.rawValue, 0)
			}
			open
			func SESSION_VARIABLES_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SESSION_VARIABLES_ADMIN.rawValue, 0)
			}
			open
			func SET_USER_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SET_USER_ID.rawValue, 0)
			}
			open
			func SHARE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHARE.rawValue, 0)
			}
			open
			func SHARED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHARED.rawValue, 0)
			}
			open
			func SHOW_ROUTINE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHOW_ROUTINE.rawValue, 0)
			}
			open
			func SIGNED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SIGNED.rawValue, 0)
			}
			open
			func SIMPLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SIMPLE.rawValue, 0)
			}
			open
			func SLAVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SLAVE.rawValue, 0)
			}
			open
			func SLOW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SLOW.rawValue, 0)
			}
			open
			func SKIP_QUERY_REWRITE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SKIP_QUERY_REWRITE.rawValue, 0)
			}
			open
			func SNAPSHOT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SNAPSHOT.rawValue, 0)
			}
			open
			func SOCKET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SOCKET.rawValue, 0)
			}
			open
			func SOME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SOME.rawValue, 0)
			}
			open
			func SONAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SONAME.rawValue, 0)
			}
			open
			func SOUNDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SOUNDS.rawValue, 0)
			}
			open
			func SOURCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SOURCE.rawValue, 0)
			}
			open
			func SQL_AFTER_GTIDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_AFTER_GTIDS.rawValue, 0)
			}
			open
			func SQL_AFTER_MTS_GAPS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_AFTER_MTS_GAPS.rawValue, 0)
			}
			open
			func SQL_BEFORE_GTIDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_BEFORE_GTIDS.rawValue, 0)
			}
			open
			func SQL_BUFFER_RESULT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_BUFFER_RESULT.rawValue, 0)
			}
			open
			func SQL_CACHE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_CACHE.rawValue, 0)
			}
			open
			func SQL_NO_CACHE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_NO_CACHE.rawValue, 0)
			}
			open
			func SQL_THREAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_THREAD.rawValue, 0)
			}
			open
			func STACKED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STACKED.rawValue, 0)
			}
			open
			func START() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.START.rawValue, 0)
			}
			open
			func STARTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STARTS.rawValue, 0)
			}
			open
			func STATS_AUTO_RECALC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATS_AUTO_RECALC.rawValue, 0)
			}
			open
			func STATS_PERSISTENT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATS_PERSISTENT.rawValue, 0)
			}
			open
			func STATS_SAMPLE_PAGES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATS_SAMPLE_PAGES.rawValue, 0)
			}
			open
			func STATUS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STATUS.rawValue, 0)
			}
			open
			func STD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STD.rawValue, 0)
			}
			open
			func STDDEV() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STDDEV.rawValue, 0)
			}
			open
			func STDDEV_POP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STDDEV_POP.rawValue, 0)
			}
			open
			func STDDEV_SAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STDDEV_SAMP.rawValue, 0)
			}
			open
			func STOP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STOP.rawValue, 0)
			}
			open
			func STORAGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STORAGE.rawValue, 0)
			}
			open
			func STRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRING.rawValue, 0)
			}
			open
			func SUBCLASS_ORIGIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBCLASS_ORIGIN.rawValue, 0)
			}
			open
			func SUBJECT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBJECT.rawValue, 0)
			}
			open
			func SUBPARTITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBPARTITION.rawValue, 0)
			}
			open
			func SUBPARTITIONS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBPARTITIONS.rawValue, 0)
			}
			open
			func SUM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUM.rawValue, 0)
			}
			open
			func SUSPEND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUSPEND.rawValue, 0)
			}
			open
			func SWAPS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SWAPS.rawValue, 0)
			}
			open
			func SWITCHES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SWITCHES.rawValue, 0)
			}
			open
			func SYSTEM_VARIABLES_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SYSTEM_VARIABLES_ADMIN.rawValue, 0)
			}
			open
			func TABLE_NAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE_NAME.rawValue, 0)
			}
			open
			func TABLESPACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLESPACE.rawValue, 0)
			}
			open
			func TABLE_ENCRYPTION_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE_ENCRYPTION_ADMIN.rawValue, 0)
			}
			open
			func TABLE_TYPE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TABLE_TYPE.rawValue, 0)
			}
			open
			func TEMPORARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TEMPORARY.rawValue, 0)
			}
			open
			func TEMPTABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TEMPTABLE.rawValue, 0)
			}
			open
			func THAN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.THAN.rawValue, 0)
			}
			open
			func TP_CONNECTION_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TP_CONNECTION_ADMIN.rawValue, 0)
			}
			open
			func TRADITIONAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRADITIONAL.rawValue, 0)
			}
			open
			func TRANSACTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRANSACTION.rawValue, 0)
			}
			open
			func TRANSACTIONAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRANSACTIONAL.rawValue, 0)
			}
			open
			func TRIGGERS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRIGGERS.rawValue, 0)
			}
			open
			func TRUNCATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TRUNCATE.rawValue, 0)
			}
			open
			func UNBOUNDED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNBOUNDED.rawValue, 0)
			}
			open
			func UNDEFINED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNDEFINED.rawValue, 0)
			}
			open
			func UNDOFILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNDOFILE.rawValue, 0)
			}
			open
			func UNDO_BUFFER_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNDO_BUFFER_SIZE.rawValue, 0)
			}
			open
			func UNINSTALL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNINSTALL.rawValue, 0)
			}
			open
			func UNKNOWN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNKNOWN.rawValue, 0)
			}
			open
			func UNTIL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNTIL.rawValue, 0)
			}
			open
			func UPGRADE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPGRADE.rawValue, 0)
			}
			open
			func USA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USA.rawValue, 0)
			}
			open
			func USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER.rawValue, 0)
			}
			open
			func USE_FRM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USE_FRM.rawValue, 0)
			}
			open
			func USER_RESOURCES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.USER_RESOURCES.rawValue, 0)
			}
			open
			func VALIDATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALIDATION.rawValue, 0)
			}
			open
			func VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALUE.rawValue, 0)
			}
			open
			func VAR_POP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VAR_POP.rawValue, 0)
			}
			open
			func VAR_SAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VAR_SAMP.rawValue, 0)
			}
			open
			func VARIABLES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VARIABLES.rawValue, 0)
			}
			open
			func VARIANCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VARIANCE.rawValue, 0)
			}
			open
			func VERSION_TOKEN_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VERSION_TOKEN_ADMIN.rawValue, 0)
			}
			open
			func VIEW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VIEW.rawValue, 0)
			}
			open
			func VIRTUAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VIRTUAL.rawValue, 0)
			}
			open
			func WAIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WAIT.rawValue, 0)
			}
			open
			func WARNINGS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WARNINGS.rawValue, 0)
			}
			open
			func WITHOUT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITHOUT.rawValue, 0)
			}
			open
			func WORK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WORK.rawValue, 0)
			}
			open
			func WRAPPER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WRAPPER.rawValue, 0)
			}
			open
			func X509() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.X509.rawValue, 0)
			}
			open
			func XA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XA.rawValue, 0)
			}
			open
			func XA_RECOVER_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XA_RECOVER_ADMIN.rawValue, 0)
			}
			open
			func XML() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.XML.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_keywordsCanBeId
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterKeywordsCanBeId(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitKeywordsCanBeId(self)
			}
		}
	}
	@discardableResult
	 open func keywordsCanBeId() throws -> KeywordsCanBeIdContext {
		var _localctx: KeywordsCanBeIdContext
		_localctx = KeywordsCanBeIdContext(_ctx, getState())
		try enterRule(_localctx, 718, MySqlParser.RULE_keywordsCanBeId)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7439)
		 	_la = try _input.LA(1)
		 	if (!(((Int64(_la) & ~0x3f) == 0 && ((Int64(1) << _la) & 756890782757308416) != 0) || ((Int64((_la - 73)) & ~0x3f) == 0 && ((Int64(1) << (_la - 73)) & 146666055054393409) != 0) || _la == MySqlParser.Tokens.SKIP_QUERY_REWRITE.rawValue || _la == MySqlParser.Tokens.STACKED.rawValue || ((Int64((_la - 239)) & ~0x3f) == 0 && ((Int64(1) << (_la - 239)) & 1769897061370560513) != 0) || ((Int64((_la - 305)) & ~0x3f) == 0 && ((Int64(1) << (_la - 305)) & -134217473) != 0) || ((Int64((_la - 369)) & ~0x3f) == 0 && ((Int64(1) << (_la - 369)) & -171798822913) != 0) || ((Int64((_la - 434)) & ~0x3f) == 0 && ((Int64(1) << (_la - 434)) & -33685505) != 0) || ((Int64((_la - 498)) & ~0x3f) == 0 && ((Int64(1) << (_la - 498)) & -2306265222165299201) != 0) || ((Int64((_la - 562)) & ~0x3f) == 0 && ((Int64(1) << (_la - 562)) & -35184640524289) != 0) || ((Int64((_la - 626)) & ~0x3f) == 0 && ((Int64(1) << (_la - 626)) & 9077990211383719935) != 0) || ((Int64((_la - 697)) & ~0x3f) == 0 && ((Int64(1) << (_la - 697)) & 514225960183805) != 0) || _la == MySqlParser.Tokens.MEMORY.rawValue || _la == MySqlParser.Tokens.CATALOG_NAME.rawValue || _la == MySqlParser.Tokens.ENGINE_ATTRIBUTE.rawValue || _la == MySqlParser.Tokens.SECONDARY_ENGINE_ATTRIBUTE.rawValue || _la == MySqlParser.Tokens.SCHEMA_NAME.rawValue || _la == MySqlParser.Tokens.TP_CONNECTION_ADMIN.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	public class FunctionNameBaseContext: ParserRuleContext {
			open
			func ABS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ABS.rawValue, 0)
			}
			open
			func ACOS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ACOS.rawValue, 0)
			}
			open
			func ADDDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADDDATE.rawValue, 0)
			}
			open
			func ADDTIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ADDTIME.rawValue, 0)
			}
			open
			func AES_DECRYPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AES_DECRYPT.rawValue, 0)
			}
			open
			func AES_ENCRYPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AES_ENCRYPT.rawValue, 0)
			}
			open
			func AREA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.AREA.rawValue, 0)
			}
			open
			func ASBINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASBINARY.rawValue, 0)
			}
			open
			func ASIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASIN.rawValue, 0)
			}
			open
			func ASTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASTEXT.rawValue, 0)
			}
			open
			func ASWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASWKB.rawValue, 0)
			}
			open
			func ASWKT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASWKT.rawValue, 0)
			}
			open
			func ASYMMETRIC_DECRYPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASYMMETRIC_DECRYPT.rawValue, 0)
			}
			open
			func ASYMMETRIC_DERIVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASYMMETRIC_DERIVE.rawValue, 0)
			}
			open
			func ASYMMETRIC_ENCRYPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASYMMETRIC_ENCRYPT.rawValue, 0)
			}
			open
			func ASYMMETRIC_SIGN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASYMMETRIC_SIGN.rawValue, 0)
			}
			open
			func ASYMMETRIC_VERIFY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ASYMMETRIC_VERIFY.rawValue, 0)
			}
			open
			func ATAN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ATAN.rawValue, 0)
			}
			open
			func ATAN2() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ATAN2.rawValue, 0)
			}
			open
			func BENCHMARK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BENCHMARK.rawValue, 0)
			}
			open
			func BIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIN.rawValue, 0)
			}
			open
			func BIT_COUNT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_COUNT.rawValue, 0)
			}
			open
			func BIT_LENGTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BIT_LENGTH.rawValue, 0)
			}
			open
			func BUFFER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.BUFFER.rawValue, 0)
			}
			open
			func CEIL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CEIL.rawValue, 0)
			}
			open
			func CEILING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CEILING.rawValue, 0)
			}
			open
			func CENTROID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CENTROID.rawValue, 0)
			}
			open
			func CHARACTER_LENGTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARACTER_LENGTH.rawValue, 0)
			}
			open
			func CHARSET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHARSET.rawValue, 0)
			}
			open
			func CHAR_LENGTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CHAR_LENGTH.rawValue, 0)
			}
			open
			func COERCIBILITY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COERCIBILITY.rawValue, 0)
			}
			open
			func COLLATION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COLLATION.rawValue, 0)
			}
			open
			func COMPRESS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COMPRESS.rawValue, 0)
			}
			open
			func CONCAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONCAT.rawValue, 0)
			}
			open
			func CONCAT_WS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONCAT_WS.rawValue, 0)
			}
			open
			func CONNECTION_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONNECTION_ID.rawValue, 0)
			}
			open
			func CONV() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONV.rawValue, 0)
			}
			open
			func CONVERT_TZ() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CONVERT_TZ.rawValue, 0)
			}
			open
			func COS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COS.rawValue, 0)
			}
			open
			func COT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COT.rawValue, 0)
			}
			open
			func COUNT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.COUNT.rawValue, 0)
			}
			open
			func CRC32() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CRC32.rawValue, 0)
			}
			open
			func CREATE_ASYMMETRIC_PRIV_KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE_ASYMMETRIC_PRIV_KEY.rawValue, 0)
			}
			open
			func CREATE_ASYMMETRIC_PUB_KEY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE_ASYMMETRIC_PUB_KEY.rawValue, 0)
			}
			open
			func CREATE_DH_PARAMETERS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE_DH_PARAMETERS.rawValue, 0)
			}
			open
			func CREATE_DIGEST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CREATE_DIGEST.rawValue, 0)
			}
			open
			func CROSSES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CROSSES.rawValue, 0)
			}
			open
			func CUME_DIST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.CUME_DIST.rawValue, 0)
			}
			open
			func DATABASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATABASE.rawValue, 0)
			}
			open
			func DATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATE.rawValue, 0)
			}
			open
			func DATEDIFF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATEDIFF.rawValue, 0)
			}
			open
			func DATE_FORMAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DATE_FORMAT.rawValue, 0)
			}
			open
			func DAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DAY.rawValue, 0)
			}
			open
			func DAYNAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DAYNAME.rawValue, 0)
			}
			open
			func DAYOFMONTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DAYOFMONTH.rawValue, 0)
			}
			open
			func DAYOFWEEK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DAYOFWEEK.rawValue, 0)
			}
			open
			func DAYOFYEAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DAYOFYEAR.rawValue, 0)
			}
			open
			func DECODE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DECODE.rawValue, 0)
			}
			open
			func DEGREES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DEGREES.rawValue, 0)
			}
			open
			func DENSE_RANK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DENSE_RANK.rawValue, 0)
			}
			open
			func DES_DECRYPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DES_DECRYPT.rawValue, 0)
			}
			open
			func DES_ENCRYPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DES_ENCRYPT.rawValue, 0)
			}
			open
			func DIMENSION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DIMENSION.rawValue, 0)
			}
			open
			func DISJOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.DISJOINT.rawValue, 0)
			}
			open
			func ELT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ELT.rawValue, 0)
			}
			open
			func ENCODE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENCODE.rawValue, 0)
			}
			open
			func ENCRYPT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENCRYPT.rawValue, 0)
			}
			open
			func ENDPOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENDPOINT.rawValue, 0)
			}
			open
			func ENVELOPE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ENVELOPE.rawValue, 0)
			}
			open
			func EQUALS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EQUALS.rawValue, 0)
			}
			open
			func EXP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXP.rawValue, 0)
			}
			open
			func EXPORT_SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXPORT_SET.rawValue, 0)
			}
			open
			func EXTERIORRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXTERIORRING.rawValue, 0)
			}
			open
			func EXTRACTVALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.EXTRACTVALUE.rawValue, 0)
			}
			open
			func FIELD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIELD.rawValue, 0)
			}
			open
			func FIND_IN_SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIND_IN_SET.rawValue, 0)
			}
			open
			func FIRST_VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FIRST_VALUE.rawValue, 0)
			}
			open
			func FLOOR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FLOOR.rawValue, 0)
			}
			open
			func FORMAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FORMAT.rawValue, 0)
			}
			open
			func FOUND_ROWS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FOUND_ROWS.rawValue, 0)
			}
			open
			func FROM_BASE64() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM_BASE64.rawValue, 0)
			}
			open
			func FROM_DAYS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM_DAYS.rawValue, 0)
			}
			open
			func FROM_UNIXTIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.FROM_UNIXTIME.rawValue, 0)
			}
			open
			func GEOMCOLLFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMCOLLFROMTEXT.rawValue, 0)
			}
			open
			func GEOMCOLLFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMCOLLFROMWKB.rawValue, 0)
			}
			open
			func GEOMETRYCOLLECTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMETRYCOLLECTION.rawValue, 0)
			}
			open
			func GEOMETRYCOLLECTIONFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMETRYCOLLECTIONFROMTEXT.rawValue, 0)
			}
			open
			func GEOMETRYCOLLECTIONFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMETRYCOLLECTIONFROMWKB.rawValue, 0)
			}
			open
			func GEOMETRYFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMETRYFROMTEXT.rawValue, 0)
			}
			open
			func GEOMETRYFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMETRYFROMWKB.rawValue, 0)
			}
			open
			func GEOMETRYN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMETRYN.rawValue, 0)
			}
			open
			func GEOMETRYTYPE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMETRYTYPE.rawValue, 0)
			}
			open
			func GEOMFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMFROMTEXT.rawValue, 0)
			}
			open
			func GEOMFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GEOMFROMWKB.rawValue, 0)
			}
			open
			func GET_FORMAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GET_FORMAT.rawValue, 0)
			}
			open
			func GET_LOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GET_LOCK.rawValue, 0)
			}
			open
			func GLENGTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GLENGTH.rawValue, 0)
			}
			open
			func GREATEST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GREATEST.rawValue, 0)
			}
			open
			func GTID_SUBSET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GTID_SUBSET.rawValue, 0)
			}
			open
			func GTID_SUBTRACT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.GTID_SUBTRACT.rawValue, 0)
			}
			open
			func HEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HEX.rawValue, 0)
			}
			open
			func HOUR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.HOUR.rawValue, 0)
			}
			open
			func IFNULL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IFNULL.rawValue, 0)
			}
			open
			func INET6_ATON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INET6_ATON.rawValue, 0)
			}
			open
			func INET6_NTOA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INET6_NTOA.rawValue, 0)
			}
			open
			func INET_ATON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INET_ATON.rawValue, 0)
			}
			open
			func INET_NTOA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INET_NTOA.rawValue, 0)
			}
			open
			func INSTR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INSTR.rawValue, 0)
			}
			open
			func INTERIORRINGN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTERIORRINGN.rawValue, 0)
			}
			open
			func INTERSECTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INTERSECTS.rawValue, 0)
			}
			open
			func INVISIBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.INVISIBLE.rawValue, 0)
			}
			open
			func ISCLOSED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ISCLOSED.rawValue, 0)
			}
			open
			func ISEMPTY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ISEMPTY.rawValue, 0)
			}
			open
			func ISNULL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ISNULL.rawValue, 0)
			}
			open
			func ISSIMPLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ISSIMPLE.rawValue, 0)
			}
			open
			func IS_FREE_LOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IS_FREE_LOCK.rawValue, 0)
			}
			open
			func IS_IPV4() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IS_IPV4.rawValue, 0)
			}
			open
			func IS_IPV4_COMPAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IS_IPV4_COMPAT.rawValue, 0)
			}
			open
			func IS_IPV4_MAPPED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IS_IPV4_MAPPED.rawValue, 0)
			}
			open
			func IS_IPV6() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IS_IPV6.rawValue, 0)
			}
			open
			func IS_USED_LOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.IS_USED_LOCK.rawValue, 0)
			}
			open
			func LAG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LAG.rawValue, 0)
			}
			open
			func LAST_INSERT_ID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LAST_INSERT_ID.rawValue, 0)
			}
			open
			func LAST_VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LAST_VALUE.rawValue, 0)
			}
			open
			func LCASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LCASE.rawValue, 0)
			}
			open
			func LEAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEAD.rawValue, 0)
			}
			open
			func LEAST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEAST.rawValue, 0)
			}
			open
			func LEFT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LEFT.rawValue, 0)
			}
			open
			func LENGTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LENGTH.rawValue, 0)
			}
			open
			func LINEFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINEFROMTEXT.rawValue, 0)
			}
			open
			func LINEFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINEFROMWKB.rawValue, 0)
			}
			open
			func LINESTRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINESTRING.rawValue, 0)
			}
			open
			func LINESTRINGFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINESTRINGFROMTEXT.rawValue, 0)
			}
			open
			func LINESTRINGFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LINESTRINGFROMWKB.rawValue, 0)
			}
			open
			func LN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LN.rawValue, 0)
			}
			open
			func LOAD_FILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOAD_FILE.rawValue, 0)
			}
			open
			func LOCATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOCATE.rawValue, 0)
			}
			open
			func LOG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOG.rawValue, 0)
			}
			open
			func LOG10() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOG10.rawValue, 0)
			}
			open
			func LOG2() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOG2.rawValue, 0)
			}
			open
			func LOWER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LOWER.rawValue, 0)
			}
			open
			func LPAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LPAD.rawValue, 0)
			}
			open
			func LTRIM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.LTRIM.rawValue, 0)
			}
			open
			func MAKEDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAKEDATE.rawValue, 0)
			}
			open
			func MAKETIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAKETIME.rawValue, 0)
			}
			open
			func MAKE_SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MAKE_SET.rawValue, 0)
			}
			open
			func MASTER_POS_WAIT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MASTER_POS_WAIT.rawValue, 0)
			}
			open
			func MBRCONTAINS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MBRCONTAINS.rawValue, 0)
			}
			open
			func MBRDISJOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MBRDISJOINT.rawValue, 0)
			}
			open
			func MBREQUAL() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MBREQUAL.rawValue, 0)
			}
			open
			func MBRINTERSECTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MBRINTERSECTS.rawValue, 0)
			}
			open
			func MBROVERLAPS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MBROVERLAPS.rawValue, 0)
			}
			open
			func MBRTOUCHES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MBRTOUCHES.rawValue, 0)
			}
			open
			func MBRWITHIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MBRWITHIN.rawValue, 0)
			}
			open
			func MD5() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MD5.rawValue, 0)
			}
			open
			func MICROSECOND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MICROSECOND.rawValue, 0)
			}
			open
			func MINUTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MINUTE.rawValue, 0)
			}
			open
			func MLINEFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MLINEFROMTEXT.rawValue, 0)
			}
			open
			func MLINEFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MLINEFROMWKB.rawValue, 0)
			}
			open
			func MOD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MOD.rawValue, 0)
			}
			open
			func MONTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MONTH.rawValue, 0)
			}
			open
			func MONTHNAME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MONTHNAME.rawValue, 0)
			}
			open
			func MPOINTFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MPOINTFROMTEXT.rawValue, 0)
			}
			open
			func MPOINTFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MPOINTFROMWKB.rawValue, 0)
			}
			open
			func MPOLYFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MPOLYFROMTEXT.rawValue, 0)
			}
			open
			func MPOLYFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MPOLYFROMWKB.rawValue, 0)
			}
			open
			func MULTILINESTRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTILINESTRING.rawValue, 0)
			}
			open
			func MULTILINESTRINGFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTILINESTRINGFROMTEXT.rawValue, 0)
			}
			open
			func MULTILINESTRINGFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTILINESTRINGFROMWKB.rawValue, 0)
			}
			open
			func MULTIPOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTIPOINT.rawValue, 0)
			}
			open
			func MULTIPOINTFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTIPOINTFROMTEXT.rawValue, 0)
			}
			open
			func MULTIPOINTFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTIPOINTFROMWKB.rawValue, 0)
			}
			open
			func MULTIPOLYGON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTIPOLYGON.rawValue, 0)
			}
			open
			func MULTIPOLYGONFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTIPOLYGONFROMTEXT.rawValue, 0)
			}
			open
			func MULTIPOLYGONFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.MULTIPOLYGONFROMWKB.rawValue, 0)
			}
			open
			func NAME_CONST() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NAME_CONST.rawValue, 0)
			}
			open
			func NTH_VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NTH_VALUE.rawValue, 0)
			}
			open
			func NTILE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NTILE.rawValue, 0)
			}
			open
			func NULLIF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NULLIF.rawValue, 0)
			}
			open
			func NUMGEOMETRIES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NUMGEOMETRIES.rawValue, 0)
			}
			open
			func NUMINTERIORRINGS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NUMINTERIORRINGS.rawValue, 0)
			}
			open
			func NUMPOINTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.NUMPOINTS.rawValue, 0)
			}
			open
			func OCT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OCT.rawValue, 0)
			}
			open
			func OCTET_LENGTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OCTET_LENGTH.rawValue, 0)
			}
			open
			func ORD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ORD.rawValue, 0)
			}
			open
			func OVERLAPS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.OVERLAPS.rawValue, 0)
			}
			open
			func PERCENT_RANK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PERCENT_RANK.rawValue, 0)
			}
			open
			func PERIOD_ADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PERIOD_ADD.rawValue, 0)
			}
			open
			func PERIOD_DIFF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PERIOD_DIFF.rawValue, 0)
			}
			open
			func PI() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.PI.rawValue, 0)
			}
			open
			func POINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POINT.rawValue, 0)
			}
			open
			func POINTFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POINTFROMTEXT.rawValue, 0)
			}
			open
			func POINTFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POINTFROMWKB.rawValue, 0)
			}
			open
			func POINTN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POINTN.rawValue, 0)
			}
			open
			func POLYFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POLYFROMTEXT.rawValue, 0)
			}
			open
			func POLYFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POLYFROMWKB.rawValue, 0)
			}
			open
			func POLYGON() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POLYGON.rawValue, 0)
			}
			open
			func POLYGONFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POLYGONFROMTEXT.rawValue, 0)
			}
			open
			func POLYGONFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POLYGONFROMWKB.rawValue, 0)
			}
			open
			func POSITION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POSITION.rawValue, 0)
			}
			open
			func POW() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POW.rawValue, 0)
			}
			open
			func POWER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.POWER.rawValue, 0)
			}
			open
			func QUARTER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUARTER.rawValue, 0)
			}
			open
			func QUOTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.QUOTE.rawValue, 0)
			}
			open
			func RADIANS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RADIANS.rawValue, 0)
			}
			open
			func RAND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RAND.rawValue, 0)
			}
			open
			func RANDOM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RANDOM.rawValue, 0)
			}
			open
			func RANK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RANK.rawValue, 0)
			}
			open
			func RANDOM_BYTES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RANDOM_BYTES.rawValue, 0)
			}
			open
			func RELEASE_LOCK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RELEASE_LOCK.rawValue, 0)
			}
			open
			func REVERSE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.REVERSE.rawValue, 0)
			}
			open
			func RIGHT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RIGHT.rawValue, 0)
			}
			open
			func ROUND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROUND.rawValue, 0)
			}
			open
			func ROW_COUNT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROW_COUNT.rawValue, 0)
			}
			open
			func ROW_NUMBER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ROW_NUMBER.rawValue, 0)
			}
			open
			func RPAD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RPAD.rawValue, 0)
			}
			open
			func RTRIM() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.RTRIM.rawValue, 0)
			}
			open
			func SCHEMA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SCHEMA.rawValue, 0)
			}
			open
			func SECOND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SECOND.rawValue, 0)
			}
			open
			func SEC_TO_TIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SEC_TO_TIME.rawValue, 0)
			}
			open
			func SESSION_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SESSION_USER.rawValue, 0)
			}
			open
			func SESSION_VARIABLES_ADMIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SESSION_VARIABLES_ADMIN.rawValue, 0)
			}
			open
			func SHA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHA.rawValue, 0)
			}
			open
			func SHA1() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHA1.rawValue, 0)
			}
			open
			func SHA2() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SHA2.rawValue, 0)
			}
			open
			func SIGN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SIGN.rawValue, 0)
			}
			open
			func SIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SIN.rawValue, 0)
			}
			open
			func SLEEP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SLEEP.rawValue, 0)
			}
			open
			func SOUNDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SOUNDEX.rawValue, 0)
			}
			open
			func SQL_THREAD_WAIT_AFTER_GTIDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQL_THREAD_WAIT_AFTER_GTIDS.rawValue, 0)
			}
			open
			func SQRT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SQRT.rawValue, 0)
			}
			open
			func SRID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SRID.rawValue, 0)
			}
			open
			func STARTPOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STARTPOINT.rawValue, 0)
			}
			open
			func STRCMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STRCMP.rawValue, 0)
			}
			open
			func STR_TO_DATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.STR_TO_DATE.rawValue, 0)
			}
			open
			func ST_AREA() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_AREA.rawValue, 0)
			}
			open
			func ST_ASBINARY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_ASBINARY.rawValue, 0)
			}
			open
			func ST_ASTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_ASTEXT.rawValue, 0)
			}
			open
			func ST_ASWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_ASWKB.rawValue, 0)
			}
			open
			func ST_ASWKT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_ASWKT.rawValue, 0)
			}
			open
			func ST_BUFFER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_BUFFER.rawValue, 0)
			}
			open
			func ST_CENTROID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_CENTROID.rawValue, 0)
			}
			open
			func ST_CONTAINS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_CONTAINS.rawValue, 0)
			}
			open
			func ST_CROSSES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_CROSSES.rawValue, 0)
			}
			open
			func ST_DIFFERENCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_DIFFERENCE.rawValue, 0)
			}
			open
			func ST_DIMENSION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_DIMENSION.rawValue, 0)
			}
			open
			func ST_DISJOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_DISJOINT.rawValue, 0)
			}
			open
			func ST_DISTANCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_DISTANCE.rawValue, 0)
			}
			open
			func ST_ENDPOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_ENDPOINT.rawValue, 0)
			}
			open
			func ST_ENVELOPE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_ENVELOPE.rawValue, 0)
			}
			open
			func ST_EQUALS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_EQUALS.rawValue, 0)
			}
			open
			func ST_EXTERIORRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_EXTERIORRING.rawValue, 0)
			}
			open
			func ST_GEOMCOLLFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_GEOMCOLLFROMTEXT.rawValue, 0)
			}
			open
			func ST_GEOMCOLLFROMTXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_GEOMCOLLFROMTXT.rawValue, 0)
			}
			open
			func ST_GEOMCOLLFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_GEOMCOLLFROMWKB.rawValue, 0)
			}
			open
			func ST_GEOMETRYCOLLECTIONFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_GEOMETRYCOLLECTIONFROMTEXT.rawValue, 0)
			}
			open
			func ST_GEOMETRYCOLLECTIONFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_GEOMETRYCOLLECTIONFROMWKB.rawValue, 0)
			}
			open
			func ST_GEOMETRYFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_GEOMETRYFROMTEXT.rawValue, 0)
			}
			open
			func ST_GEOMETRYFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_GEOMETRYFROMWKB.rawValue, 0)
			}
			open
			func ST_GEOMETRYN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_GEOMETRYN.rawValue, 0)
			}
			open
			func ST_GEOMETRYTYPE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_GEOMETRYTYPE.rawValue, 0)
			}
			open
			func ST_GEOMFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_GEOMFROMTEXT.rawValue, 0)
			}
			open
			func ST_GEOMFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_GEOMFROMWKB.rawValue, 0)
			}
			open
			func ST_INTERIORRINGN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_INTERIORRINGN.rawValue, 0)
			}
			open
			func ST_INTERSECTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_INTERSECTION.rawValue, 0)
			}
			open
			func ST_INTERSECTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_INTERSECTS.rawValue, 0)
			}
			open
			func ST_ISCLOSED() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_ISCLOSED.rawValue, 0)
			}
			open
			func ST_ISEMPTY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_ISEMPTY.rawValue, 0)
			}
			open
			func ST_ISSIMPLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_ISSIMPLE.rawValue, 0)
			}
			open
			func ST_LINEFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_LINEFROMTEXT.rawValue, 0)
			}
			open
			func ST_LINEFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_LINEFROMWKB.rawValue, 0)
			}
			open
			func ST_LINESTRINGFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_LINESTRINGFROMTEXT.rawValue, 0)
			}
			open
			func ST_LINESTRINGFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_LINESTRINGFROMWKB.rawValue, 0)
			}
			open
			func ST_NUMGEOMETRIES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_NUMGEOMETRIES.rawValue, 0)
			}
			open
			func ST_NUMINTERIORRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_NUMINTERIORRING.rawValue, 0)
			}
			open
			func ST_NUMINTERIORRINGS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_NUMINTERIORRINGS.rawValue, 0)
			}
			open
			func ST_NUMPOINTS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_NUMPOINTS.rawValue, 0)
			}
			open
			func ST_OVERLAPS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_OVERLAPS.rawValue, 0)
			}
			open
			func ST_POINTFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_POINTFROMTEXT.rawValue, 0)
			}
			open
			func ST_POINTFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_POINTFROMWKB.rawValue, 0)
			}
			open
			func ST_POINTN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_POINTN.rawValue, 0)
			}
			open
			func ST_POLYFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_POLYFROMTEXT.rawValue, 0)
			}
			open
			func ST_POLYFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_POLYFROMWKB.rawValue, 0)
			}
			open
			func ST_POLYGONFROMTEXT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_POLYGONFROMTEXT.rawValue, 0)
			}
			open
			func ST_POLYGONFROMWKB() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_POLYGONFROMWKB.rawValue, 0)
			}
			open
			func ST_SRID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_SRID.rawValue, 0)
			}
			open
			func ST_STARTPOINT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_STARTPOINT.rawValue, 0)
			}
			open
			func ST_SYMDIFFERENCE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_SYMDIFFERENCE.rawValue, 0)
			}
			open
			func ST_TOUCHES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_TOUCHES.rawValue, 0)
			}
			open
			func ST_UNION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_UNION.rawValue, 0)
			}
			open
			func ST_WITHIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_WITHIN.rawValue, 0)
			}
			open
			func ST_X() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_X.rawValue, 0)
			}
			open
			func ST_Y() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.ST_Y.rawValue, 0)
			}
			open
			func SUBDATE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBDATE.rawValue, 0)
			}
			open
			func SUBSTRING_INDEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBSTRING_INDEX.rawValue, 0)
			}
			open
			func SUBTIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SUBTIME.rawValue, 0)
			}
			open
			func SYSTEM_USER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.SYSTEM_USER.rawValue, 0)
			}
			open
			func TAN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TAN.rawValue, 0)
			}
			open
			func TIME() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIME.rawValue, 0)
			}
			open
			func TIMEDIFF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIMEDIFF.rawValue, 0)
			}
			open
			func TIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIMESTAMP.rawValue, 0)
			}
			open
			func TIMESTAMPADD() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIMESTAMPADD.rawValue, 0)
			}
			open
			func TIMESTAMPDIFF() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIMESTAMPDIFF.rawValue, 0)
			}
			open
			func TIME_FORMAT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIME_FORMAT.rawValue, 0)
			}
			open
			func TIME_TO_SEC() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TIME_TO_SEC.rawValue, 0)
			}
			open
			func TOUCHES() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TOUCHES.rawValue, 0)
			}
			open
			func TO_BASE64() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO_BASE64.rawValue, 0)
			}
			open
			func TO_DAYS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO_DAYS.rawValue, 0)
			}
			open
			func TO_SECONDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.TO_SECONDS.rawValue, 0)
			}
			open
			func UCASE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UCASE.rawValue, 0)
			}
			open
			func UNCOMPRESS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNCOMPRESS.rawValue, 0)
			}
			open
			func UNCOMPRESSED_LENGTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNCOMPRESSED_LENGTH.rawValue, 0)
			}
			open
			func UNHEX() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNHEX.rawValue, 0)
			}
			open
			func UNIX_TIMESTAMP() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UNIX_TIMESTAMP.rawValue, 0)
			}
			open
			func UPDATEXML() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPDATEXML.rawValue, 0)
			}
			open
			func UPPER() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UPPER.rawValue, 0)
			}
			open
			func UUID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UUID.rawValue, 0)
			}
			open
			func UUID_SHORT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.UUID_SHORT.rawValue, 0)
			}
			open
			func VALIDATE_PASSWORD_STRENGTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VALIDATE_PASSWORD_STRENGTH.rawValue, 0)
			}
			open
			func VERSION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VERSION.rawValue, 0)
			}
			open
			func VISIBLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.VISIBLE.rawValue, 0)
			}
			open
			func WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS.rawValue, 0)
			}
			open
			func WEEK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WEEK.rawValue, 0)
			}
			open
			func WEEKDAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WEEKDAY.rawValue, 0)
			}
			open
			func WEEKOFYEAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WEEKOFYEAR.rawValue, 0)
			}
			open
			func WEIGHT_STRING() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WEIGHT_STRING.rawValue, 0)
			}
			open
			func WITHIN() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.WITHIN.rawValue, 0)
			}
			open
			func YEAR() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.YEAR.rawValue, 0)
			}
			open
			func YEARWEEK() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.YEARWEEK.rawValue, 0)
			}
			open
			func Y_FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.Y_FUNCTION.rawValue, 0)
			}
			open
			func X_FUNCTION() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.X_FUNCTION.rawValue, 0)
			}
			open
			func JSON_ARRAY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_ARRAY.rawValue, 0)
			}
			open
			func JSON_OBJECT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_OBJECT.rawValue, 0)
			}
			open
			func JSON_QUOTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_QUOTE.rawValue, 0)
			}
			open
			func JSON_CONTAINS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_CONTAINS.rawValue, 0)
			}
			open
			func JSON_CONTAINS_PATH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_CONTAINS_PATH.rawValue, 0)
			}
			open
			func JSON_EXTRACT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_EXTRACT.rawValue, 0)
			}
			open
			func JSON_KEYS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_KEYS.rawValue, 0)
			}
			open
			func JSON_OVERLAPS() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_OVERLAPS.rawValue, 0)
			}
			open
			func JSON_SEARCH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_SEARCH.rawValue, 0)
			}
			open
			func JSON_VALUE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_VALUE.rawValue, 0)
			}
			open
			func JSON_ARRAY_APPEND() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_ARRAY_APPEND.rawValue, 0)
			}
			open
			func JSON_ARRAY_INSERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_ARRAY_INSERT.rawValue, 0)
			}
			open
			func JSON_INSERT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_INSERT.rawValue, 0)
			}
			open
			func JSON_MERGE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_MERGE.rawValue, 0)
			}
			open
			func JSON_MERGE_PATCH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_MERGE_PATCH.rawValue, 0)
			}
			open
			func JSON_MERGE_PRESERVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_MERGE_PRESERVE.rawValue, 0)
			}
			open
			func JSON_REMOVE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_REMOVE.rawValue, 0)
			}
			open
			func JSON_REPLACE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_REPLACE.rawValue, 0)
			}
			open
			func JSON_SET() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_SET.rawValue, 0)
			}
			open
			func JSON_UNQUOTE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_UNQUOTE.rawValue, 0)
			}
			open
			func JSON_DEPTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_DEPTH.rawValue, 0)
			}
			open
			func JSON_LENGTH() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_LENGTH.rawValue, 0)
			}
			open
			func JSON_TYPE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_TYPE.rawValue, 0)
			}
			open
			func JSON_VALID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_VALID.rawValue, 0)
			}
			open
			func JSON_TABLE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_TABLE.rawValue, 0)
			}
			open
			func JSON_SCHEMA_VALID() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_SCHEMA_VALID.rawValue, 0)
			}
			open
			func JSON_SCHEMA_VALIDATION_REPORT() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_SCHEMA_VALIDATION_REPORT.rawValue, 0)
			}
			open
			func JSON_PRETTY() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_PRETTY.rawValue, 0)
			}
			open
			func JSON_STORAGE_FREE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_STORAGE_FREE.rawValue, 0)
			}
			open
			func JSON_STORAGE_SIZE() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_STORAGE_SIZE.rawValue, 0)
			}
			open
			func JSON_ARRAYAGG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_ARRAYAGG.rawValue, 0)
			}
			open
			func JSON_OBJECTAGG() -> TerminalNode? {
				return getToken(MySqlParser.Tokens.JSON_OBJECTAGG.rawValue, 0)
			}
		override open
		func getRuleIndex() -> Int {
			return MySqlParser.RULE_functionNameBase
		}
		override open
		func enterRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.enterFunctionNameBase(self)
			}
		}
		override open
		func exitRule(_ listener: ParseTreeListener) {
			if let listener = listener as? MySqlParserListener {
				listener.exitFunctionNameBase(self)
			}
		}
	}
	@discardableResult
	 open func functionNameBase() throws -> FunctionNameBaseContext {
		var _localctx: FunctionNameBaseContext
		_localctx = FunctionNameBaseContext(_ctx, getState())
		try enterRule(_localctx, 720, MySqlParser.RULE_functionNameBase)
		var _la: Int = 0
		defer {
	    		try! exitRule()
	    }
		do {
		 	try enterOuterAlt(_localctx, 1)
		 	setState(7441)
		 	_la = try _input.LA(1)
		 	if (!(_la == MySqlParser.Tokens.DATABASE.rawValue || ((Int64((_la - 97)) & ~0x3f) == 0 && ((Int64(1) << (_la - 97)) & 11258999068426241) != 0) || ((Int64((_la - 217)) & ~0x3f) == 0 && ((Int64(1) << (_la - 217)) & -17179869161) != 0) || ((Int64((_la - 281)) & ~0x3f) == 0 && ((Int64(1) << (_la - 281)) & 8796109397507) != 0) || _la == MySqlParser.Tokens.INVISIBLE.rawValue || ((Int64((_la - 673)) & ~0x3f) == 0 && ((Int64(1) << (_la - 673)) & -9223372036838064127) != 0) || ((Int64((_la - 803)) & ~0x3f) == 0 && ((Int64(1) << (_la - 803)) & -8589934599) != 0) || ((Int64((_la - 867)) & ~0x3f) == 0 && ((Int64(1) << (_la - 867)) & -257) != 0) || ((Int64((_la - 931)) & ~0x3f) == 0 && ((Int64(1) << (_la - 931)) & -1) != 0) || ((Int64((_la - 995)) & ~0x3f) == 0 && ((Int64(1) << (_la - 995)) & -1057) != 0) || ((Int64((_la - 1059)) & ~0x3f) == 0 && ((Int64(1) << (_la - 1059)) & 562949416550399) != 0) || _la == MySqlParser.Tokens.MOD.rawValue)) {
		 	try _errHandler.recoverInline(self)
		 	}
		 	else {
		 		_errHandler.reportMatch(self)
		 		try consume()
		 	}

		}
		catch ANTLRException.recognition(let re) {
			_localctx.exception = re
			_errHandler.reportError(self, re)
			try _errHandler.recover(self, re)
		}

		return _localctx
	}

	override open
	func sempred(_ _localctx: RuleContext?, _ ruleIndex: Int,  _ predIndex: Int)throws -> Bool {
		switch (ruleIndex) {
		case  344:
			return try expression_sempred(_localctx?.castdown(ExpressionContext.self), predIndex)
		case  345:
			return try predicate_sempred(_localctx?.castdown(PredicateContext.self), predIndex)
		case  346:
			return try expressionAtom_sempred(_localctx?.castdown(ExpressionAtomContext.self), predIndex)
	    default: return true
		}
	}
	private func expression_sempred(_ _localctx: ExpressionContext!,  _ predIndex: Int) throws -> Bool {
		switch (predIndex) {
		    case 0:return precpred(_ctx, 3)
		    default: return true
		}
	}
	private func predicate_sempred(_ _localctx: PredicateContext!,  _ predIndex: Int) throws -> Bool {
		switch (predIndex) {
		    case 1:return precpred(_ctx, 8)
		    case 2:return precpred(_ctx, 6)
		    case 3:return precpred(_ctx, 5)
		    case 4:return precpred(_ctx, 3)
		    case 5:return precpred(_ctx, 10)
		    case 6:return precpred(_ctx, 9)
		    case 7:return precpred(_ctx, 7)
		    case 8:return precpred(_ctx, 4)
		    case 9:return precpred(_ctx, 2)
		    default: return true
		}
	}
	private func expressionAtom_sempred(_ _localctx: ExpressionAtomContext!,  _ predIndex: Int) throws -> Bool {
		switch (predIndex) {
		    case 10:return precpred(_ctx, 4)
		    case 11:return precpred(_ctx, 3)
		    case 12:return precpred(_ctx, 2)
		    case 13:return precpred(_ctx, 1)
		    case 14:return precpred(_ctx, 14)
		    default: return true
		}
	}

	static let _serializedATN:[Int] = [
		4,1,1161,7444,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,
		2,7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
		14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
		21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
		28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
		35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
		42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
		49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
		56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,2,63,7,
		63,2,64,7,64,2,65,7,65,2,66,7,66,2,67,7,67,2,68,7,68,2,69,7,69,2,70,7,
		70,2,71,7,71,2,72,7,72,2,73,7,73,2,74,7,74,2,75,7,75,2,76,7,76,2,77,7,
		77,2,78,7,78,2,79,7,79,2,80,7,80,2,81,7,81,2,82,7,82,2,83,7,83,2,84,7,
		84,2,85,7,85,2,86,7,86,2,87,7,87,2,88,7,88,2,89,7,89,2,90,7,90,2,91,7,
		91,2,92,7,92,2,93,7,93,2,94,7,94,2,95,7,95,2,96,7,96,2,97,7,97,2,98,7,
		98,2,99,7,99,2,100,7,100,2,101,7,101,2,102,7,102,2,103,7,103,2,104,7,104,
		2,105,7,105,2,106,7,106,2,107,7,107,2,108,7,108,2,109,7,109,2,110,7,110,
		2,111,7,111,2,112,7,112,2,113,7,113,2,114,7,114,2,115,7,115,2,116,7,116,
		2,117,7,117,2,118,7,118,2,119,7,119,2,120,7,120,2,121,7,121,2,122,7,122,
		2,123,7,123,2,124,7,124,2,125,7,125,2,126,7,126,2,127,7,127,2,128,7,128,
		2,129,7,129,2,130,7,130,2,131,7,131,2,132,7,132,2,133,7,133,2,134,7,134,
		2,135,7,135,2,136,7,136,2,137,7,137,2,138,7,138,2,139,7,139,2,140,7,140,
		2,141,7,141,2,142,7,142,2,143,7,143,2,144,7,144,2,145,7,145,2,146,7,146,
		2,147,7,147,2,148,7,148,2,149,7,149,2,150,7,150,2,151,7,151,2,152,7,152,
		2,153,7,153,2,154,7,154,2,155,7,155,2,156,7,156,2,157,7,157,2,158,7,158,
		2,159,7,159,2,160,7,160,2,161,7,161,2,162,7,162,2,163,7,163,2,164,7,164,
		2,165,7,165,2,166,7,166,2,167,7,167,2,168,7,168,2,169,7,169,2,170,7,170,
		2,171,7,171,2,172,7,172,2,173,7,173,2,174,7,174,2,175,7,175,2,176,7,176,
		2,177,7,177,2,178,7,178,2,179,7,179,2,180,7,180,2,181,7,181,2,182,7,182,
		2,183,7,183,2,184,7,184,2,185,7,185,2,186,7,186,2,187,7,187,2,188,7,188,
		2,189,7,189,2,190,7,190,2,191,7,191,2,192,7,192,2,193,7,193,2,194,7,194,
		2,195,7,195,2,196,7,196,2,197,7,197,2,198,7,198,2,199,7,199,2,200,7,200,
		2,201,7,201,2,202,7,202,2,203,7,203,2,204,7,204,2,205,7,205,2,206,7,206,
		2,207,7,207,2,208,7,208,2,209,7,209,2,210,7,210,2,211,7,211,2,212,7,212,
		2,213,7,213,2,214,7,214,2,215,7,215,2,216,7,216,2,217,7,217,2,218,7,218,
		2,219,7,219,2,220,7,220,2,221,7,221,2,222,7,222,2,223,7,223,2,224,7,224,
		2,225,7,225,2,226,7,226,2,227,7,227,2,228,7,228,2,229,7,229,2,230,7,230,
		2,231,7,231,2,232,7,232,2,233,7,233,2,234,7,234,2,235,7,235,2,236,7,236,
		2,237,7,237,2,238,7,238,2,239,7,239,2,240,7,240,2,241,7,241,2,242,7,242,
		2,243,7,243,2,244,7,244,2,245,7,245,2,246,7,246,2,247,7,247,2,248,7,248,
		2,249,7,249,2,250,7,250,2,251,7,251,2,252,7,252,2,253,7,253,2,254,7,254,
		2,255,7,255,2,256,7,256,2,257,7,257,2,258,7,258,2,259,7,259,2,260,7,260,
		2,261,7,261,2,262,7,262,2,263,7,263,2,264,7,264,2,265,7,265,2,266,7,266,
		2,267,7,267,2,268,7,268,2,269,7,269,2,270,7,270,2,271,7,271,2,272,7,272,
		2,273,7,273,2,274,7,274,2,275,7,275,2,276,7,276,2,277,7,277,2,278,7,278,
		2,279,7,279,2,280,7,280,2,281,7,281,2,282,7,282,2,283,7,283,2,284,7,284,
		2,285,7,285,2,286,7,286,2,287,7,287,2,288,7,288,2,289,7,289,2,290,7,290,
		2,291,7,291,2,292,7,292,2,293,7,293,2,294,7,294,2,295,7,295,2,296,7,296,
		2,297,7,297,2,298,7,298,2,299,7,299,2,300,7,300,2,301,7,301,2,302,7,302,
		2,303,7,303,2,304,7,304,2,305,7,305,2,306,7,306,2,307,7,307,2,308,7,308,
		2,309,7,309,2,310,7,310,2,311,7,311,2,312,7,312,2,313,7,313,2,314,7,314,
		2,315,7,315,2,316,7,316,2,317,7,317,2,318,7,318,2,319,7,319,2,320,7,320,
		2,321,7,321,2,322,7,322,2,323,7,323,2,324,7,324,2,325,7,325,2,326,7,326,
		2,327,7,327,2,328,7,328,2,329,7,329,2,330,7,330,2,331,7,331,2,332,7,332,
		2,333,7,333,2,334,7,334,2,335,7,335,2,336,7,336,2,337,7,337,2,338,7,338,
		2,339,7,339,2,340,7,340,2,341,7,341,2,342,7,342,2,343,7,343,2,344,7,344,
		2,345,7,345,2,346,7,346,2,347,7,347,2,348,7,348,2,349,7,349,2,350,7,350,
		2,351,7,351,2,352,7,352,2,353,7,353,2,354,7,354,2,355,7,355,2,356,7,356,
		2,357,7,357,2,358,7,358,2,359,7,359,2,360,7,360,1,0,3,0,724,8,0,1,0,1,
		0,3,0,728,8,0,1,0,1,0,1,1,1,1,1,1,3,1,735,8,1,1,1,3,1,738,8,1,1,1,5,1,
		741,8,1,10,1,12,1,744,9,1,1,1,1,1,1,1,3,1,749,8,1,1,1,3,1,752,8,1,1,1,
		3,1,755,8,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3,2,764,8,2,1,3,1,3,1,4,1,4,1,
		4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,
		1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,4,1,
		4,3,4,806,8,4,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,1,5,3,5,
		821,8,5,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,1,6,3,6,832,8,6,1,7,1,7,1,7,1,
		7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,1,7,3,7,849,8,7,1,8,1,8,1,8,
		3,8,854,8,8,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,1,9,3,9,866,8,9,1,10,1,
		10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,
		10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,1,10,3,10,893,8,10,1,11,1,11,
		1,11,1,11,1,11,1,11,1,11,3,11,902,8,11,1,12,1,12,1,12,3,12,907,8,12,1,
		12,1,12,5,12,911,8,12,10,12,12,12,914,9,12,1,13,1,13,3,13,918,8,13,1,13,
		1,13,3,13,922,8,13,1,13,1,13,1,13,1,13,1,13,1,13,1,13,3,13,931,8,13,1,
		13,3,13,934,8,13,1,13,3,13,937,8,13,1,13,1,13,3,13,941,8,13,1,13,1,13,
		1,13,1,14,1,14,3,14,948,8,14,1,14,3,14,951,8,14,1,14,1,14,1,14,3,14,956,
		8,14,1,14,1,14,1,14,1,14,5,14,962,8,14,10,14,12,14,965,9,14,1,14,1,14,
		3,14,969,8,14,1,14,1,14,1,14,3,14,974,8,14,1,14,5,14,977,8,14,10,14,12,
		14,980,9,14,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,1,15,3,15,991,8,15,
		1,15,3,15,994,8,15,1,15,1,15,3,15,998,8,15,1,15,3,15,1001,8,15,1,15,1,
		15,3,15,1005,8,15,1,15,3,15,1008,8,15,1,15,1,15,3,15,1012,8,15,1,15,3,
		15,1015,8,15,1,15,3,15,1018,8,15,1,15,1,15,3,15,1022,8,15,1,15,3,15,1025,
		8,15,1,15,1,15,3,15,1029,8,15,1,15,1,15,1,16,1,16,3,16,1035,8,16,1,16,
		1,16,1,16,1,16,3,16,1041,8,16,1,16,1,16,5,16,1045,8,16,10,16,12,16,1048,
		9,16,1,16,1,16,5,16,1052,8,16,10,16,12,16,1055,9,16,1,16,1,16,1,17,1,17,
		3,17,1061,8,17,1,17,3,17,1064,8,17,1,17,1,17,3,17,1068,8,17,1,17,1,17,
		1,17,3,17,1073,8,17,1,17,1,17,5,17,1077,8,17,10,17,12,17,1080,9,17,1,17,
		1,17,1,17,1,17,5,17,1086,8,17,10,17,12,17,1089,9,17,1,17,1,17,3,17,1093,
		8,17,1,18,1,18,1,18,3,18,1098,8,18,1,18,1,18,1,18,5,18,1103,8,18,10,18,
		12,18,1106,9,18,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,1,19,
		1,19,5,19,1120,8,19,10,19,12,19,1123,9,19,1,19,1,19,1,20,1,20,3,20,1129,
		8,20,1,20,1,20,3,20,1133,8,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,1,20,
		3,20,1143,8,20,1,20,1,20,3,20,1147,8,20,1,20,1,20,3,20,1151,8,20,1,20,
		1,20,3,20,1155,8,20,1,20,1,20,3,20,1159,8,20,1,20,5,20,1162,8,20,10,20,
		12,20,1165,9,20,3,20,1167,8,20,1,20,3,20,1170,8,20,1,20,3,20,1173,8,20,
		1,20,3,20,1176,8,20,1,20,1,20,1,20,1,20,3,20,1182,8,20,1,20,1,20,3,20,
		1186,8,20,1,20,1,20,1,20,1,20,3,20,1192,8,20,1,20,5,20,1195,8,20,10,20,
		12,20,1198,9,20,3,20,1200,8,20,1,20,3,20,1203,8,20,3,20,1205,8,20,1,21,
		1,21,1,21,1,21,1,21,1,21,1,21,1,21,1,21,3,21,1216,8,21,1,21,1,21,3,21,
		1220,8,21,1,21,3,21,1223,8,21,1,22,1,22,1,22,1,22,1,22,1,22,1,22,1,22,
		1,22,1,22,1,22,1,22,3,22,1237,8,22,1,22,3,22,1240,8,22,1,22,1,22,3,22,
		1244,8,22,1,22,3,22,1247,8,22,1,22,1,22,3,22,1251,8,22,1,22,3,22,1254,
		8,22,1,22,1,22,3,22,1258,8,22,1,22,3,22,1261,8,22,1,22,1,22,3,22,1265,
		8,22,1,22,3,22,1268,8,22,1,22,3,22,1271,8,22,1,22,1,22,3,22,1275,8,22,
		1,22,3,22,1278,8,22,1,22,1,22,3,22,1282,8,22,1,22,1,22,1,23,1,23,3,23,
		1288,8,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,1,23,3,23,
		1301,8,23,1,23,1,23,1,24,1,24,3,24,1307,8,24,1,24,1,24,1,25,1,25,1,25,
		1,25,1,25,5,25,1316,8,25,10,25,12,25,1319,9,25,1,25,1,25,3,25,1323,8,25,
		1,25,1,25,1,25,1,25,1,25,1,25,3,25,1331,8,25,1,26,1,26,1,27,1,27,1,28,
		1,28,3,28,1339,8,28,1,28,1,28,1,28,3,28,1344,8,28,1,28,3,28,1347,8,28,
		1,28,1,28,1,28,3,28,1352,8,28,1,28,1,28,1,28,1,28,1,28,1,28,3,28,1360,
		8,28,1,28,1,28,1,28,3,28,1365,8,28,1,28,1,28,1,28,1,28,3,28,1371,8,28,
		1,28,1,28,1,28,3,28,1376,8,28,1,28,1,28,3,28,1380,8,28,3,28,1382,8,28,
		1,29,3,29,1385,8,29,1,29,1,29,3,29,1389,8,29,1,29,1,29,3,29,1393,8,29,
		1,29,3,29,1396,8,29,1,29,1,29,3,29,1400,8,29,1,29,1,29,3,29,1404,8,29,
		1,29,1,29,3,29,1408,8,29,1,29,1,29,1,29,1,29,3,29,1414,8,29,1,29,3,29,
		1417,8,29,1,30,1,30,1,30,1,30,1,30,3,30,1424,8,30,1,31,1,31,1,31,3,31,
		1429,8,31,1,32,1,32,1,32,1,32,3,32,1435,8,32,1,33,1,33,1,33,5,33,1440,
		8,33,10,33,12,33,1443,9,33,1,33,1,33,1,33,3,33,1448,8,33,1,33,1,33,1,33,
		1,33,5,33,1454,8,33,10,33,12,33,1457,9,33,3,33,1459,8,33,1,33,1,33,1,33,
		5,33,1464,8,33,10,33,12,33,1467,9,33,3,33,1469,8,33,3,33,1471,8,33,1,34,
		1,34,1,34,1,34,3,34,1477,8,34,1,35,1,35,1,35,1,35,3,35,1483,8,35,1,35,
		1,35,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,1,36,
		3,36,1500,8,36,1,37,1,37,1,37,1,37,1,37,3,37,1507,8,37,1,38,1,38,1,38,
		1,39,1,39,3,39,1514,8,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,
		1,39,3,39,1526,8,39,1,39,1,39,1,39,3,39,1531,8,39,1,39,3,39,1534,8,39,
		1,40,3,40,1537,8,40,1,40,1,40,1,40,1,41,1,41,1,41,1,42,1,42,1,42,1,42,
		1,42,3,42,1550,8,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,1,42,
		1,42,3,42,1563,8,42,1,42,1,42,1,42,3,42,1568,8,42,1,43,1,43,1,43,1,43,
		1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,1,43,3,43,1584,8,43,1,44,
		1,44,1,44,1,44,5,44,1590,8,44,10,44,12,44,1593,9,44,1,44,1,44,1,45,1,45,
		1,45,1,45,1,45,3,45,1602,8,45,1,45,3,45,1605,8,45,1,45,3,45,1608,8,45,
		1,46,1,46,5,46,1612,8,46,10,46,12,46,1615,9,46,1,46,3,46,1618,8,46,1,46,
		3,46,1621,8,46,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,3,47,1632,
		8,47,1,47,3,47,1635,8,47,1,47,1,47,1,47,3,47,1640,8,47,1,47,1,47,1,47,
		1,47,1,47,1,47,1,47,1,47,1,47,1,47,1,47,3,47,1653,8,47,1,47,1,47,1,47,
		1,47,1,47,3,47,1660,8,47,1,47,1,47,1,47,1,47,1,47,3,47,1667,8,47,3,47,
		1669,8,47,1,47,1,47,1,47,1,47,1,47,3,47,1676,8,47,1,48,1,48,3,48,1680,
		8,48,3,48,1682,8,48,1,48,1,48,1,48,3,48,1687,8,48,1,48,3,48,1690,8,48,
		1,48,1,48,5,48,1694,8,48,10,48,12,48,1697,9,48,1,48,1,48,3,48,1701,8,48,
		3,48,1703,8,48,1,48,1,48,3,48,1707,8,48,1,48,3,48,1710,8,48,1,48,3,48,
		1713,8,48,1,48,1,48,5,48,1717,8,48,10,48,12,48,1720,9,48,1,48,1,48,3,48,
		1724,8,48,3,48,1726,8,48,1,48,1,48,1,48,3,48,1731,8,48,1,48,1,48,1,48,
		1,48,1,48,3,48,1738,8,48,3,48,1740,8,48,1,48,1,48,1,48,1,48,1,48,3,48,
		1747,8,48,1,49,1,49,1,49,3,49,1752,8,49,1,49,1,49,3,49,1756,8,49,1,49,
		3,49,1759,8,49,1,50,1,50,1,50,1,50,1,50,1,50,3,50,1767,8,50,1,50,1,50,
		1,50,1,50,1,50,1,50,3,50,1775,8,50,3,50,1777,8,50,1,51,1,51,1,51,1,51,
		1,51,1,51,1,51,1,51,3,51,1787,8,51,1,52,1,52,3,52,1791,8,52,1,52,3,52,
		1794,8,52,1,52,1,52,5,52,1798,8,52,10,52,12,52,1801,9,52,1,52,1,52,3,52,
		1805,8,52,1,52,3,52,1808,8,52,1,52,1,52,5,52,1812,8,52,10,52,12,52,1815,
		9,52,3,52,1817,8,52,1,53,1,53,3,53,1821,8,53,1,53,3,53,1824,8,53,1,53,
		1,53,3,53,1828,8,53,1,53,1,53,1,53,3,53,1833,8,53,1,53,1,53,1,53,3,53,
		1838,8,53,1,53,1,53,1,53,3,53,1843,8,53,1,53,1,53,3,53,1847,8,53,1,53,
		1,53,3,53,1851,8,53,1,53,1,53,3,53,1855,8,53,1,53,1,53,3,53,1859,8,53,
		1,53,1,53,3,53,1863,8,53,1,53,1,53,3,53,1867,8,53,1,53,1,53,1,53,3,53,
		1872,8,53,1,53,1,53,1,53,3,53,1877,8,53,1,53,1,53,1,53,3,53,1882,8,53,
		1,53,1,53,1,53,1,53,3,53,1888,8,53,1,53,1,53,1,53,3,53,1893,8,53,1,53,
		1,53,1,53,3,53,1898,8,53,1,53,1,53,1,53,3,53,1903,8,53,1,53,1,53,1,53,
		3,53,1908,8,53,1,53,1,53,1,53,3,53,1913,8,53,1,53,1,53,1,53,1,53,3,53,
		1919,8,53,1,53,1,53,1,53,3,53,1924,8,53,1,53,1,53,1,53,3,53,1929,8,53,
		1,53,1,53,1,53,3,53,1934,8,53,1,53,1,53,1,53,3,53,1939,8,53,1,53,1,53,
		1,53,3,53,1944,8,53,1,53,1,53,1,53,3,53,1949,8,53,1,53,1,53,1,53,3,53,
		1954,8,53,1,53,1,53,1,53,1,53,1,53,3,53,1961,8,53,1,53,1,53,1,53,3,53,
		1966,8,53,1,53,1,53,1,53,3,53,1971,8,53,1,53,1,53,1,53,3,53,1976,8,53,
		1,53,1,53,3,53,1980,8,53,1,53,1,53,1,53,3,53,1985,8,53,1,53,1,53,1,53,
		1,53,1,53,1,53,3,53,1993,8,53,1,53,1,53,1,53,3,53,1998,8,53,1,53,1,53,
		1,53,1,53,3,53,2004,8,53,1,54,1,54,1,55,1,55,1,55,1,56,1,56,1,56,1,56,
		1,56,3,56,2016,8,56,1,56,1,56,1,56,1,56,1,56,3,56,2023,8,56,3,56,2025,
		8,56,1,56,1,56,1,56,1,56,5,56,2031,8,56,10,56,12,56,2034,9,56,1,56,1,56,
		3,56,2038,8,56,1,57,3,57,2041,8,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,
		2049,8,57,1,57,1,57,1,57,1,57,3,57,2055,8,57,1,57,1,57,3,57,2059,8,57,
		1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,2072,8,57,
		1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,1,57,3,57,2084,8,57,3,57,
		2086,8,57,1,58,3,58,2089,8,58,1,58,1,58,1,58,1,58,1,58,1,58,3,58,2097,
		8,58,1,58,1,58,1,58,1,58,3,58,2103,8,58,1,58,1,58,1,58,1,58,3,58,2109,
		8,58,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,5,59,2120,8,59,10,59,
		12,59,2123,9,59,1,59,1,59,5,59,2127,8,59,10,59,12,59,2130,9,59,1,59,1,
		59,1,59,1,59,5,59,2136,8,59,10,59,12,59,2139,9,59,1,59,1,59,3,59,2143,
		8,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,5,59,2152,8,59,10,59,12,59,2155,
		9,59,1,59,1,59,1,59,1,59,5,59,2161,8,59,10,59,12,59,2164,9,59,1,59,1,59,
		3,59,2168,8,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,5,59,2178,8,59,
		10,59,12,59,2181,9,59,1,59,1,59,5,59,2185,8,59,10,59,12,59,2188,9,59,1,
		59,1,59,1,59,1,59,5,59,2194,8,59,10,59,12,59,2197,9,59,1,59,1,59,3,59,
		2201,8,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,1,59,5,59,2211,8,59,10,59,
		12,59,2214,9,59,1,59,1,59,5,59,2218,8,59,10,59,12,59,2221,9,59,1,59,1,
		59,1,59,1,59,5,59,2227,8,59,10,59,12,59,2230,9,59,1,59,1,59,3,59,2234,
		8,59,1,59,1,59,1,59,5,59,2239,8,59,10,59,12,59,2242,9,59,1,59,1,59,1,59,
		1,59,5,59,2248,8,59,10,59,12,59,2251,9,59,1,59,1,59,3,59,2255,8,59,3,59,
		2257,8,59,1,60,1,60,1,60,3,60,2262,8,60,1,61,1,61,1,61,1,61,4,61,2268,
		8,61,11,61,12,61,2269,1,61,1,61,1,62,1,62,1,62,5,62,2277,8,62,10,62,12,
		62,2280,9,62,1,63,3,63,2283,8,63,1,63,3,63,2286,8,63,1,63,1,63,3,63,2290,
		8,63,1,63,1,63,1,63,3,63,2295,8,63,1,63,1,63,1,63,1,63,3,63,2301,8,63,
		1,63,1,63,1,63,1,63,3,63,2307,8,63,1,63,1,63,1,63,3,63,2312,8,63,1,63,
		1,63,1,63,3,63,2317,8,63,1,63,1,63,1,63,3,63,2322,8,63,1,63,1,63,1,63,
		3,63,2327,8,63,1,63,3,63,2330,8,63,1,64,1,64,1,64,3,64,2335,8,64,1,64,
		4,64,2338,8,64,11,64,12,64,2339,1,64,1,64,1,64,1,64,1,64,1,64,1,64,1,64,
		3,64,2350,8,64,1,65,1,65,3,65,2354,8,65,1,65,1,65,1,65,1,65,1,65,3,65,
		2361,8,65,1,65,1,65,1,65,3,65,2366,8,65,1,65,3,65,2369,8,65,1,65,1,65,
		1,65,3,65,2374,8,65,1,65,3,65,2377,8,65,1,65,1,65,3,65,2381,8,65,1,65,
		1,65,3,65,2385,8,65,1,66,1,66,1,66,1,66,5,66,2391,8,66,10,66,12,66,2394,
		9,66,1,67,1,67,1,67,1,67,1,67,1,67,1,67,1,68,1,68,1,68,1,68,1,68,1,68,
		1,68,1,68,1,68,3,68,2412,8,68,1,68,3,68,2415,8,68,1,68,3,68,2418,8,68,
		1,68,1,68,3,68,2422,8,68,1,68,1,68,1,69,1,69,1,69,1,69,5,69,2430,8,69,
		10,69,12,69,2433,9,69,1,70,1,70,1,70,1,70,1,70,1,70,1,70,1,70,5,70,2443,
		8,70,10,70,12,70,2446,9,70,1,70,1,70,1,71,1,71,3,71,2452,8,71,1,71,3,71,
		2455,8,71,1,71,1,71,1,71,3,71,2460,8,71,1,71,1,71,1,71,5,71,2465,8,71,
		10,71,12,71,2468,9,71,3,71,2470,8,71,1,71,3,71,2473,8,71,1,72,1,72,1,72,
		1,72,1,72,1,72,1,72,1,72,1,72,3,72,2484,8,72,1,72,3,72,2487,8,72,1,72,
		1,72,3,72,2491,8,72,1,72,1,72,1,73,1,73,1,73,1,73,3,73,2499,8,73,1,73,
		3,73,2502,8,73,1,73,1,73,1,73,3,73,2507,8,73,1,73,1,73,1,73,1,73,1,73,
		1,73,3,73,2515,8,73,1,73,1,73,1,73,1,73,3,73,2521,8,73,1,73,1,73,3,73,
		2525,8,73,1,74,1,74,3,74,2529,8,74,1,74,5,74,2532,8,74,10,74,12,74,2535,
		9,74,1,74,1,74,3,74,2539,8,74,1,74,1,74,1,74,1,74,1,74,3,74,2546,8,74,
		1,74,1,74,3,74,2550,8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,5,74,2559,
		8,74,10,74,12,74,2562,9,74,1,74,1,74,1,74,1,74,1,74,3,74,2569,8,74,1,74,
		3,74,2572,8,74,1,74,1,74,5,74,2576,8,74,10,74,12,74,2579,9,74,1,74,1,74,
		1,74,3,74,2584,8,74,3,74,2586,8,74,1,74,1,74,1,74,3,74,2591,8,74,1,74,
		3,74,2594,8,74,1,74,1,74,5,74,2598,8,74,10,74,12,74,2601,9,74,1,74,1,74,
		1,74,3,74,2606,8,74,3,74,2608,8,74,1,74,1,74,3,74,2612,8,74,1,74,3,74,
		2615,8,74,1,74,3,74,2618,8,74,1,74,1,74,5,74,2622,8,74,10,74,12,74,2625,
		9,74,1,74,1,74,1,74,3,74,2630,8,74,1,74,3,74,2633,8,74,1,74,1,74,5,74,
		2637,8,74,10,74,12,74,2640,9,74,1,74,1,74,1,74,3,74,2645,8,74,3,74,2647,
		8,74,1,74,1,74,1,74,3,74,2652,8,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,
		2660,8,74,3,74,2662,8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2671,
		8,74,1,74,3,74,2674,8,74,1,74,3,74,2677,8,74,1,74,1,74,1,74,3,74,2682,
		8,74,3,74,2684,8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2693,8,74,
		1,74,3,74,2696,8,74,1,74,3,74,2699,8,74,1,74,1,74,1,74,3,74,2704,8,74,
		3,74,2706,8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2715,8,74,1,74,
		1,74,1,74,3,74,2720,8,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2728,8,74,
		1,74,1,74,3,74,2732,8,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2740,8,74,
		1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2750,8,74,1,74,1,74,1,74,
		3,74,2755,8,74,1,74,1,74,1,74,1,74,1,74,3,74,2762,8,74,1,74,1,74,3,74,
		2766,8,74,1,74,1,74,3,74,2770,8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,
		1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2789,8,74,1,74,
		1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2799,8,74,1,74,1,74,1,74,1,74,
		3,74,2805,8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,
		1,74,1,74,1,74,1,74,3,74,2822,8,74,1,74,1,74,3,74,2826,8,74,1,74,1,74,
		1,74,1,74,1,74,1,74,1,74,1,74,3,74,2836,8,74,1,74,1,74,1,74,3,74,2841,
		8,74,1,74,3,74,2844,8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2853,
		8,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,1,74,3,74,2864,8,74,1,74,
		1,74,1,74,1,74,5,74,2870,8,74,10,74,12,74,2873,9,74,1,74,1,74,1,74,3,74,
		2878,8,74,1,75,1,75,1,75,1,75,1,75,1,75,5,75,2886,8,75,10,75,12,75,2889,
		9,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,3,75,2900,8,75,1,75,
		1,75,1,75,1,75,1,75,3,75,2907,8,75,1,75,1,75,1,75,1,75,1,75,3,75,2914,
		8,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,5,75,2927,
		8,75,10,75,12,75,2930,9,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,1,75,
		1,75,3,75,2942,8,75,1,75,1,75,1,75,1,75,3,75,2948,8,75,1,75,1,75,1,75,
		1,75,3,75,2954,8,75,1,75,1,75,1,75,1,75,3,75,2960,8,75,1,75,1,75,1,75,
		1,75,3,75,2966,8,75,1,75,1,75,1,75,1,75,3,75,2972,8,75,1,75,1,75,1,75,
		1,75,3,75,2978,8,75,1,76,1,76,1,76,3,76,2983,8,76,1,76,1,76,1,77,1,77,
		1,77,3,77,2990,8,77,1,77,1,77,1,78,1,78,1,78,3,78,2997,8,78,1,78,1,78,
		1,78,1,78,1,78,3,78,3004,8,78,1,78,1,78,1,78,3,78,3009,8,78,1,78,5,78,
		3012,8,78,10,78,12,78,3015,9,78,1,79,1,79,1,79,1,79,1,79,1,79,1,79,1,79,
		1,80,1,80,1,80,3,80,3028,8,80,1,80,1,80,1,81,1,81,1,81,3,81,3035,8,81,
		1,81,1,81,1,82,1,82,1,82,3,82,3042,8,82,1,82,1,82,1,83,1,83,3,83,3048,
		8,83,1,83,1,83,3,83,3052,8,83,1,83,1,83,3,83,3056,8,83,1,84,1,84,1,84,
		1,84,1,84,3,84,3063,8,84,1,84,3,84,3066,8,84,1,85,1,85,1,85,3,85,3071,
		8,85,1,85,1,85,1,86,1,86,1,86,3,86,3078,8,86,1,86,1,86,1,86,5,86,3083,
		8,86,10,86,12,86,3086,9,86,1,86,3,86,3089,8,86,1,87,1,87,1,87,3,87,3094,
		8,87,1,87,1,87,1,87,5,87,3099,8,87,10,87,12,87,3102,9,87,1,88,1,88,1,88,
		1,88,1,88,1,88,1,88,1,88,5,88,3112,8,88,10,88,12,88,3115,9,88,3,88,3117,
		8,88,1,88,1,88,1,88,3,88,3122,8,88,1,88,1,88,1,88,3,88,3127,8,88,5,88,
		3129,8,88,10,88,12,88,3132,9,88,1,88,1,88,1,88,3,88,3137,8,88,1,89,1,89,
		1,89,1,89,1,89,5,89,3144,8,89,10,89,12,89,3147,9,89,1,90,1,90,1,90,1,90,
		1,91,1,91,3,91,3155,8,91,1,91,1,91,1,92,1,92,1,92,1,92,1,92,3,92,3164,
		8,92,1,92,3,92,3167,8,92,1,93,1,93,3,93,3171,8,93,1,94,1,94,1,94,1,95,
		1,95,1,95,1,95,3,95,3180,8,95,1,96,1,96,3,96,3184,8,96,1,96,3,96,3187,
		8,96,1,96,3,96,3190,8,96,1,96,1,96,1,96,1,96,3,96,3196,8,96,1,96,3,96,
		3199,8,96,1,96,1,96,3,96,3203,8,96,1,96,3,96,3206,8,96,1,96,1,96,3,96,
		3210,8,96,1,96,3,96,3213,8,96,1,96,1,96,1,96,1,96,5,96,3219,8,96,10,96,
		12,96,3222,9,96,3,96,3224,8,96,1,96,1,96,1,96,1,96,1,96,1,96,1,96,5,96,
		3233,8,96,10,96,12,96,3236,9,96,3,96,3238,8,96,1,97,1,97,1,97,3,97,3243,
		8,97,1,97,3,97,3246,8,97,1,97,1,97,1,97,3,97,3251,8,97,1,97,1,97,1,97,
		1,97,1,97,1,97,1,97,1,97,3,97,3261,8,97,1,97,1,97,1,97,3,97,3266,8,97,
		1,97,1,97,4,97,3270,8,97,11,97,12,97,3271,3,97,3274,8,97,1,97,1,97,4,97,
		3278,8,97,11,97,12,97,3279,3,97,3282,8,97,1,97,1,97,1,97,1,97,3,97,3288,
		8,97,1,97,1,97,1,97,1,97,5,97,3294,8,97,10,97,12,97,3297,9,97,1,97,1,97,
		3,97,3301,8,97,1,97,1,97,1,97,1,97,5,97,3307,8,97,10,97,12,97,3310,9,97,
		3,97,3312,8,97,1,98,1,98,1,98,3,98,3317,8,98,1,98,3,98,3320,8,98,1,98,
		1,98,1,98,3,98,3325,8,98,1,98,1,98,1,98,1,98,1,98,1,98,3,98,3333,8,98,
		1,98,1,98,1,98,1,98,1,98,1,98,3,98,3341,8,98,1,98,1,98,1,98,1,98,3,98,
		3347,8,98,1,98,1,98,1,98,1,98,5,98,3353,8,98,10,98,12,98,3356,9,98,1,98,
		1,98,3,98,3360,8,98,1,98,1,98,1,98,1,98,5,98,3366,8,98,10,98,12,98,3369,
		9,98,3,98,3371,8,98,1,99,1,99,3,99,3375,8,99,1,99,3,99,3378,8,99,1,99,
		1,99,1,99,1,99,1,99,1,99,3,99,3386,8,99,1,99,1,99,1,99,1,99,3,99,3392,
		8,99,1,99,1,99,1,99,1,99,1,99,5,99,3399,8,99,10,99,12,99,3402,9,99,3,99,
		3404,8,99,1,100,1,100,3,100,3408,8,100,1,100,1,100,3,100,3412,8,100,1,
		100,1,100,3,100,3416,8,100,1,100,4,100,3419,8,100,11,100,12,100,3420,1,
		100,1,100,3,100,3425,8,100,1,100,1,100,3,100,3429,8,100,3,100,3431,8,100,
		1,100,3,100,3434,8,100,1,100,3,100,3437,8,100,1,100,3,100,3440,8,100,1,
		100,1,100,4,100,3444,8,100,11,100,12,100,3445,1,100,1,100,3,100,3450,8,
		100,1,100,3,100,3453,8,100,1,100,3,100,3456,8,100,1,100,3,100,3459,8,100,
		1,100,3,100,3462,8,100,1,100,1,100,1,100,4,100,3467,8,100,11,100,12,100,
		3468,3,100,3471,8,100,1,101,1,101,3,101,3475,8,101,1,102,1,102,1,102,3,
		102,3480,8,102,1,102,1,102,1,102,1,102,3,102,3486,8,102,1,102,5,102,3489,
		8,102,10,102,12,102,3492,9,102,1,103,1,103,1,103,1,103,3,103,3498,8,103,
		1,103,1,103,1,103,1,103,3,103,3504,8,103,1,103,5,103,3507,8,103,10,103,
		12,103,3510,9,103,3,103,3512,8,103,1,104,1,104,1,104,1,104,3,104,3518,
		8,104,1,105,1,105,3,105,3522,8,105,1,106,1,106,1,106,1,106,1,106,1,106,
		3,106,3530,8,106,1,107,1,107,3,107,3534,8,107,1,107,3,107,3537,8,107,1,
		107,3,107,3540,8,107,1,107,1,107,1,107,3,107,3545,8,107,1,107,3,107,3548,
		8,107,1,107,1,107,1,107,1,107,1,107,3,107,3555,8,107,1,107,1,107,3,107,
		3559,8,107,1,107,3,107,3562,8,107,1,107,1,107,3,107,3566,8,107,1,108,1,
		108,3,108,3570,8,108,1,108,3,108,3573,8,108,1,108,3,108,3576,8,108,1,108,
		1,108,1,108,3,108,3581,8,108,1,108,1,108,1,108,1,108,3,108,3587,8,108,
		5,108,3589,8,108,10,108,12,108,3592,9,108,1,108,1,108,1,108,1,108,1,108,
		1,108,1,108,3,108,3601,8,108,1,108,1,108,1,108,1,108,3,108,3607,8,108,
		5,108,3609,8,108,10,108,12,108,3612,9,108,1,108,1,108,1,108,3,108,3617,
		8,108,1,108,1,108,3,108,3621,8,108,1,109,1,109,1,109,1,109,3,109,3627,
		8,109,1,109,3,109,3630,8,109,1,110,1,110,1,110,1,110,1,110,1,110,1,110,
		1,110,1,110,1,110,3,110,3642,8,110,1,110,1,110,3,110,3646,8,110,1,110,
		1,110,3,110,3650,8,110,1,111,1,111,1,111,1,111,1,111,1,111,3,111,3658,
		8,111,1,111,1,111,3,111,3662,8,111,1,112,1,112,1,112,1,112,1,113,1,113,
		3,113,3670,8,113,1,113,3,113,3673,8,113,1,113,1,113,3,113,3677,8,113,1,
		113,3,113,3680,8,113,1,113,1,113,1,113,1,113,5,113,3686,8,113,10,113,12,
		113,3689,9,113,1,113,1,113,3,113,3693,8,113,1,113,3,113,3696,8,113,1,113,
		3,113,3699,8,113,1,114,1,114,3,114,3703,8,114,1,114,3,114,3706,8,114,1,
		114,1,114,1,114,1,114,1,114,5,114,3713,8,114,10,114,12,114,3716,9,114,
		1,114,1,114,3,114,3720,8,114,1,115,1,115,1,115,1,115,1,115,5,115,3727,
		8,115,10,115,12,115,3730,9,115,1,116,1,116,3,116,3734,8,116,1,117,1,117,
		1,117,5,117,3739,8,117,10,117,12,117,3742,9,117,1,118,1,118,5,118,3746,
		8,118,10,118,12,118,3749,9,118,1,118,1,118,1,118,5,118,3754,8,118,10,118,
		12,118,3757,9,118,1,118,1,118,1,118,3,118,3762,8,118,1,119,1,119,1,119,
		1,119,1,119,1,119,3,119,3770,8,119,1,119,3,119,3773,8,119,1,119,3,119,
		3776,8,119,1,119,1,119,1,119,5,119,3781,8,119,10,119,12,119,3784,9,119,
		3,119,3786,8,119,1,119,1,119,1,119,1,119,1,119,3,119,3793,8,119,1,119,
		3,119,3796,8,119,1,119,1,119,1,119,1,119,1,119,1,119,3,119,3804,8,119,
		1,120,1,120,1,120,1,120,3,120,3810,8,120,1,120,1,120,1,120,1,120,1,121,
		1,121,1,121,1,121,1,121,3,121,3821,8,121,1,122,3,122,3824,8,122,1,122,
		1,122,3,122,3828,8,122,1,122,1,122,5,122,3832,8,122,10,122,12,122,3835,
		9,122,1,122,1,122,1,122,1,122,5,122,3841,8,122,10,122,12,122,3844,9,122,
		1,122,1,122,3,122,3848,8,122,1,122,1,122,3,122,3852,8,122,1,122,1,122,
		5,122,3856,8,122,10,122,12,122,3859,9,122,1,122,1,122,1,122,3,122,3864,
		8,122,3,122,3866,8,122,1,122,1,122,3,122,3870,8,122,1,123,1,123,1,123,
		1,123,1,123,1,123,1,123,3,123,3879,8,123,1,124,1,124,1,124,1,124,1,124,
		1,124,1,124,1,124,3,124,3889,8,124,1,125,1,125,1,125,1,125,1,125,1,125,
		1,125,1,125,3,125,3899,8,125,1,126,1,126,5,126,3903,8,126,10,126,12,126,
		3906,9,126,1,126,1,126,3,126,3910,8,126,1,126,1,126,3,126,3914,8,126,1,
		126,3,126,3917,8,126,1,126,3,126,3920,8,126,1,126,3,126,3923,8,126,1,126,
		3,126,3926,8,126,1,126,1,126,5,126,3930,8,126,10,126,12,126,3933,9,126,
		1,126,1,126,1,126,3,126,3938,8,126,1,126,3,126,3941,8,126,1,126,3,126,
		3944,8,126,1,126,3,126,3947,8,126,1,126,3,126,3950,8,126,1,126,3,126,3953,
		8,126,3,126,3955,8,126,1,127,1,127,5,127,3959,8,127,10,127,12,127,3962,
		9,127,1,127,1,127,1,127,3,127,3967,8,127,1,127,3,127,3970,8,127,1,127,
		3,127,3973,8,127,1,127,3,127,3976,8,127,1,127,3,127,3979,8,127,1,127,3,
		127,3982,8,127,1,128,1,128,3,128,3986,8,128,1,128,1,128,1,129,1,129,3,
		129,3992,8,129,1,129,1,129,3,129,3996,8,129,1,130,1,130,1,130,1,130,1,
		130,1,130,3,130,4004,8,130,1,130,1,130,3,130,4008,8,130,1,130,3,130,4011,
		8,130,3,130,4013,8,130,1,131,1,131,1,131,1,131,1,131,1,131,1,131,1,131,
		1,131,1,131,1,131,3,131,4026,8,131,1,131,3,131,4029,8,131,1,132,1,132,
		1,132,5,132,4034,8,132,10,132,12,132,4037,9,132,1,133,1,133,1,133,1,133,
		1,133,1,133,1,133,3,133,4046,8,133,1,133,3,133,4049,8,133,1,133,1,133,
		1,133,3,133,4054,8,133,3,133,4056,8,133,1,133,1,133,3,133,4060,8,133,1,
		133,1,133,1,133,1,133,1,133,1,133,3,133,4068,8,133,1,134,1,134,1,134,1,
		134,3,134,4074,8,134,1,134,1,134,1,134,1,135,1,135,1,135,1,135,3,135,4083,
		8,135,1,135,1,135,1,135,1,136,1,136,1,136,1,136,1,136,1,136,1,136,1,136,
		3,136,4096,8,136,1,137,1,137,3,137,4100,8,137,1,137,1,137,5,137,4104,8,
		137,10,137,12,137,4107,9,137,1,138,1,138,1,138,1,138,1,138,1,138,3,138,
		4115,8,138,1,138,3,138,4118,8,138,1,138,1,138,3,138,4122,8,138,1,138,3,
		138,4125,8,138,1,138,1,138,3,138,4129,8,138,1,138,1,138,3,138,4133,8,138,
		1,138,3,138,4136,8,138,3,138,4138,8,138,1,139,1,139,1,139,1,139,5,139,
		4144,8,139,10,139,12,139,4147,9,139,1,139,1,139,1,139,1,139,1,139,1,139,
		1,139,1,139,1,139,3,139,4158,8,139,1,139,1,139,4,139,4162,8,139,11,139,
		12,139,4163,3,139,4166,8,139,1,139,1,139,4,139,4170,8,139,11,139,12,139,
		4171,3,139,4174,8,139,3,139,4176,8,139,1,140,1,140,1,140,1,140,3,140,4182,
		8,140,1,140,1,140,1,140,1,140,1,140,1,140,3,140,4190,8,140,1,141,1,141,
		1,141,1,141,1,141,1,141,3,141,4198,8,141,1,142,1,142,3,142,4202,8,142,
		1,142,1,142,3,142,4206,8,142,1,143,1,143,1,143,1,143,1,143,5,143,4213,
		8,143,10,143,12,143,4216,9,143,1,143,1,143,3,143,4220,8,143,1,144,1,144,
		1,144,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,1,145,
		1,145,1,145,5,145,4238,8,145,10,145,12,145,4241,9,145,1,146,1,146,3,146,
		4245,8,146,1,147,1,147,1,147,1,147,3,147,4251,8,147,1,147,1,147,1,147,
		1,147,1,147,3,147,4258,8,147,1,148,1,148,1,148,3,148,4263,8,148,1,149,
		1,149,1,149,1,149,1,149,5,149,4270,8,149,10,149,12,149,4273,9,149,3,149,
		4275,8,149,1,150,1,150,3,150,4279,8,150,1,151,1,151,3,151,4283,8,151,1,
		151,1,151,3,151,4287,8,151,1,151,3,151,4290,8,151,1,151,3,151,4293,8,151,
		1,151,3,151,4296,8,151,1,152,1,152,3,152,4300,8,152,1,152,1,152,3,152,
		4304,8,152,1,152,3,152,4307,8,152,1,152,3,152,4310,8,152,1,152,3,152,4313,
		8,152,1,153,1,153,1,153,1,154,1,154,3,154,4320,8,154,1,154,1,154,3,154,
		4324,8,154,1,154,1,154,1,155,1,155,1,155,1,155,1,156,1,156,1,156,1,156,
		1,156,5,156,4337,8,156,10,156,12,156,4340,9,156,1,156,3,156,4343,8,156,
		1,157,1,157,1,157,1,158,1,158,1,158,1,158,1,158,1,159,1,159,3,159,4355,
		8,159,1,159,1,159,1,159,1,159,5,159,4361,8,159,10,159,12,159,4364,9,159,
		1,160,1,160,1,160,1,160,1,160,1,160,1,160,3,160,4373,8,160,1,161,1,161,
		3,161,4377,8,161,1,161,3,161,4380,8,161,1,161,1,161,1,162,1,162,3,162,
		4386,8,162,1,162,3,162,4389,8,162,1,162,3,162,4392,8,162,1,163,1,163,1,
		163,1,163,1,163,1,163,1,163,3,163,4401,8,163,1,164,1,164,1,164,1,164,1,
		164,1,164,1,164,3,164,4410,8,164,1,165,1,165,1,165,1,165,1,165,1,165,5,
		165,4418,8,165,10,165,12,165,4421,9,165,1,165,3,165,4424,8,165,1,166,1,
		166,1,166,1,166,1,166,1,166,5,166,4432,8,166,10,166,12,166,4435,9,166,
		1,167,1,167,1,167,1,167,1,167,1,167,1,167,3,167,4444,8,167,1,168,1,168,
		1,168,1,169,1,169,1,169,3,169,4452,8,169,1,169,3,169,4455,8,169,1,170,
		1,170,1,170,1,170,1,170,5,170,4462,8,170,10,170,12,170,4465,9,170,3,170,
		4467,8,170,1,170,1,170,3,170,4471,8,170,1,170,5,170,4474,8,170,10,170,
		12,170,4477,9,170,1,170,3,170,4480,8,170,1,171,1,171,1,171,1,171,1,171,
		5,171,4487,8,171,10,171,12,171,4490,9,171,3,171,4492,8,171,1,172,1,172,
		1,172,1,173,1,173,1,173,1,174,1,174,1,174,1,174,1,174,1,174,1,174,1,174,
		1,174,1,174,1,174,1,174,1,174,1,174,1,174,1,174,1,174,1,174,1,174,1,174,
		1,174,5,174,4521,8,174,10,174,12,174,4524,9,174,3,174,4526,8,174,1,174,
		3,174,4529,8,174,1,175,1,175,1,176,1,176,1,177,1,177,1,178,1,178,1,178,
		1,178,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,
		1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,
		1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,1,179,
		1,179,1,179,1,179,1,179,1,179,1,179,1,179,5,179,4583,8,179,10,179,12,179,
		4586,9,179,1,179,1,179,3,179,4590,8,179,1,180,1,180,1,180,1,180,1,180,
		1,180,1,181,1,181,1,182,1,182,1,182,1,182,1,182,1,182,1,182,1,182,1,182,
		1,182,1,182,1,182,1,182,1,182,1,182,1,182,1,182,1,182,3,182,4618,8,182,
		1,183,1,183,1,183,1,183,1,183,1,183,1,183,1,183,1,183,1,183,1,183,1,183,
		3,183,4632,8,183,1,184,1,184,1,184,5,184,4637,8,184,10,184,12,184,4640,
		9,184,1,184,3,184,4643,8,184,1,185,1,185,1,185,1,185,3,185,4649,8,185,
		1,186,1,186,1,186,1,186,1,186,1,186,3,186,4657,8,186,3,186,4659,8,186,
		1,187,1,187,1,187,1,187,1,188,1,188,1,188,1,188,1,188,3,188,4670,8,188,
		1,189,1,189,1,189,1,189,1,190,1,190,1,190,1,190,3,190,4680,8,190,1,191,
		1,191,1,191,1,191,1,191,3,191,4687,8,191,1,192,1,192,1,192,1,192,3,192,
		4693,8,192,1,193,1,193,1,193,1,193,1,194,1,194,3,194,4701,8,194,1,195,
		1,195,1,195,3,195,4706,8,195,1,195,1,195,1,195,1,195,5,195,4712,8,195,
		10,195,12,195,4715,9,195,1,195,1,195,1,195,5,195,4720,8,195,10,195,12,
		195,4723,9,195,1,195,1,195,1,195,5,195,4728,8,195,10,195,12,195,4731,9,
		195,1,195,1,195,1,195,5,195,4736,8,195,10,195,12,195,4739,9,195,1,195,
		5,195,4742,8,195,10,195,12,195,4745,9,195,1,195,1,195,3,195,4749,8,195,
		1,196,1,196,1,196,3,196,4754,8,196,1,196,4,196,4757,8,196,11,196,12,196,
		4758,1,196,1,196,4,196,4763,8,196,11,196,12,196,4764,3,196,4767,8,196,
		1,196,1,196,1,196,1,197,1,197,1,197,1,197,4,197,4776,8,197,11,197,12,197,
		4777,1,197,5,197,4781,8,197,10,197,12,197,4784,9,197,1,197,1,197,4,197,
		4788,8,197,11,197,12,197,4789,3,197,4792,8,197,1,197,1,197,1,197,1,198,
		1,198,1,198,1,199,1,199,1,199,1,200,1,200,1,200,3,200,4806,8,200,1,200,
		1,200,4,200,4810,8,200,11,200,12,200,4811,1,200,1,200,1,200,3,200,4817,
		8,200,1,201,1,201,1,201,3,201,4822,8,201,1,201,1,201,4,201,4826,8,201,
		11,201,12,201,4827,1,201,1,201,1,201,1,201,1,201,3,201,4835,8,201,1,202,
		1,202,1,202,1,203,1,203,1,203,3,203,4843,8,203,1,203,1,203,1,203,1,203,
		4,203,4849,8,203,11,203,12,203,4850,1,203,1,203,1,203,3,203,4856,8,203,
		1,204,1,204,1,204,1,204,3,204,4862,8,204,1,204,3,204,4865,8,204,1,204,
		1,204,1,204,1,204,1,204,1,204,3,204,4873,8,204,1,205,1,205,1,205,1,205,
		1,205,3,205,4880,8,205,1,206,1,206,1,206,1,206,1,206,1,206,1,206,3,206,
		4889,8,206,1,206,3,206,4892,8,206,1,207,1,207,1,207,1,207,1,207,1,207,
		1,208,1,208,1,208,1,208,1,208,1,208,1,208,5,208,4907,8,208,10,208,12,208,
		4910,9,208,1,208,1,208,1,209,1,209,1,209,3,209,4917,8,209,1,209,1,209,
		1,209,1,209,1,209,1,209,3,209,4925,8,209,1,210,1,210,3,210,4929,8,210,
		1,210,1,210,1,211,1,211,1,211,3,211,4936,8,211,1,211,1,211,4,211,4940,
		8,211,11,211,12,211,4941,1,212,1,212,1,212,1,212,4,212,4948,8,212,11,212,
		12,212,4949,1,213,1,213,1,213,1,213,1,213,5,213,4957,8,213,10,213,12,213,
		4960,9,213,1,213,1,213,1,213,3,213,4965,8,213,1,213,1,213,1,213,5,213,
		4970,8,213,10,213,12,213,4973,9,213,1,213,1,213,1,213,1,213,3,213,4979,
		8,213,1,213,5,213,4982,8,213,10,213,12,213,4985,9,213,3,213,4987,8,213,
		3,213,4989,8,213,1,213,1,213,4,213,4993,8,213,11,213,12,213,4994,3,213,
		4997,8,213,1,213,1,213,5,213,5001,8,213,10,213,12,213,5004,9,213,1,213,
		1,213,1,213,1,213,3,213,5010,8,213,1,213,1,213,1,213,3,213,5015,8,213,
		1,213,1,213,3,213,5019,8,213,1,213,1,213,1,213,1,213,3,213,5025,8,213,
		1,214,1,214,1,214,1,214,1,214,5,214,5032,8,214,10,214,12,214,5035,9,214,
		1,214,1,214,1,214,3,214,5040,8,214,1,214,1,214,1,214,5,214,5045,8,214,
		10,214,12,214,5048,9,214,1,214,1,214,1,214,3,214,5053,8,214,1,214,1,214,
		1,214,1,214,3,214,5059,8,214,1,214,5,214,5062,8,214,10,214,12,214,5065,
		9,214,3,214,5067,8,214,3,214,5069,8,214,1,214,1,214,4,214,5073,8,214,11,
		214,12,214,5074,3,214,5077,8,214,1,214,1,214,5,214,5081,8,214,10,214,12,
		214,5084,9,214,1,214,1,214,1,214,1,214,3,214,5090,8,214,3,214,5092,8,214,
		1,215,1,215,1,215,3,215,5097,8,215,1,215,1,215,1,215,5,215,5102,8,215,
		10,215,12,215,5105,9,215,1,216,1,216,1,216,1,216,5,216,5111,8,216,10,216,
		12,216,5114,9,216,1,216,1,216,3,216,5118,8,216,1,216,1,216,1,216,1,216,
		1,216,5,216,5125,8,216,10,216,12,216,5128,9,216,1,216,1,216,1,216,1,216,
		3,216,5134,8,216,1,216,5,216,5137,8,216,10,216,12,216,5140,9,216,3,216,
		5142,8,216,3,216,5144,8,216,1,216,1,216,1,216,1,216,5,216,5150,8,216,10,
		216,12,216,5153,9,216,3,216,5155,8,216,1,216,1,216,1,216,1,216,1,216,1,
		216,3,216,5163,8,216,1,216,1,216,1,216,3,216,5168,8,216,1,216,1,216,1,
		216,3,216,5173,8,216,5,216,5175,8,216,10,216,12,216,5178,9,216,1,216,1,
		216,1,216,3,216,5183,8,216,1,216,1,216,1,216,3,216,5188,8,216,5,216,5190,
		8,216,10,216,12,216,5193,9,216,1,216,1,216,1,216,3,216,5198,8,216,3,216,
		5200,8,216,1,217,1,217,1,217,1,217,1,217,1,217,1,217,5,217,5209,8,217,
		10,217,12,217,5212,9,217,3,217,5214,8,217,1,217,1,217,1,217,5,217,5219,
		8,217,10,217,12,217,5222,9,217,3,217,5224,8,217,1,218,1,218,1,218,1,218,
		1,218,1,218,1,218,1,218,5,218,5234,8,218,10,218,12,218,5237,9,218,1,218,
		1,218,1,218,3,218,5242,8,218,1,219,1,219,1,219,1,219,1,219,5,219,5249,
		8,219,10,219,12,219,5252,9,219,1,220,1,220,1,220,1,220,5,220,5258,8,220,
		10,220,12,220,5261,9,220,1,220,1,220,3,220,5265,8,220,1,220,1,220,1,220,
		1,220,1,220,5,220,5272,8,220,10,220,12,220,5275,9,220,1,220,1,220,1,220,
		3,220,5280,8,220,1,220,1,220,1,220,1,220,1,220,1,220,1,220,5,220,5289,
		8,220,10,220,12,220,5292,9,220,1,220,1,220,1,220,3,220,5297,8,220,1,220,
		1,220,1,220,3,220,5302,8,220,5,220,5304,8,220,10,220,12,220,5307,9,220,
		1,220,1,220,1,220,3,220,5312,8,220,1,220,1,220,1,220,3,220,5317,8,220,
		5,220,5319,8,220,10,220,12,220,5322,9,220,3,220,5324,8,220,1,221,1,221,
		1,221,1,221,1,221,1,221,1,221,1,221,5,221,5334,8,221,10,221,12,221,5337,
		9,221,1,222,1,222,1,222,1,222,3,222,5343,8,222,1,222,1,222,1,222,3,222,
		5348,8,222,1,223,1,223,1,223,1,224,1,224,1,224,1,224,1,224,1,224,1,224,
		1,224,1,224,1,224,1,224,1,224,1,224,1,224,1,224,1,224,1,224,1,224,1,224,
		1,224,1,224,1,224,1,224,1,224,1,224,3,224,5378,8,224,1,225,1,225,3,225,
		5382,8,225,1,225,1,225,1,225,3,225,5387,8,225,1,226,1,226,1,226,1,226,
		1,226,3,226,5394,8,226,1,226,3,226,5397,8,226,1,226,1,226,1,226,1,226,
		3,226,5403,8,226,1,227,1,227,1,227,1,227,1,227,1,227,1,227,1,227,3,227,
		5413,8,227,1,228,1,228,1,228,1,228,1,228,1,228,1,228,1,228,3,228,5423,
		8,228,1,229,1,229,1,229,1,229,1,229,1,229,1,229,1,229,3,229,5433,8,229,
		1,229,1,229,1,229,1,229,3,229,5439,8,229,1,229,1,229,1,229,1,229,1,229,
		1,229,1,229,3,229,5448,8,229,1,229,1,229,1,229,1,229,3,229,5454,8,229,
		1,229,1,229,1,229,1,229,1,229,3,229,5461,8,229,3,229,5463,8,229,1,230,
		1,230,1,230,1,231,1,231,1,231,1,231,1,231,3,231,5473,8,231,1,232,1,232,
		3,232,5477,8,232,1,232,1,232,3,232,5481,8,232,1,232,1,232,1,232,1,232,
		1,232,1,232,1,232,1,232,3,232,5491,8,232,1,232,1,232,1,232,3,232,5496,
		8,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,
		1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,
		1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,
		1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,
		1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,
		1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,1,232,3,232,
		5568,8,232,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,1,233,
		1,233,1,233,1,233,1,233,1,233,1,233,3,233,5586,8,233,1,234,1,234,1,234,
		1,234,1,235,1,235,3,235,5594,8,235,1,235,1,235,1,235,1,235,1,235,1,235,
		1,235,1,235,5,235,5604,8,235,10,235,12,235,5607,9,235,1,235,1,235,1,235,
		1,235,3,235,5613,8,235,3,235,5615,8,235,1,235,1,235,1,235,1,235,1,235,
		1,235,5,235,5623,8,235,10,235,12,235,5626,9,235,3,235,5628,8,235,1,236,
		1,236,1,236,1,236,5,236,5634,8,236,10,236,12,236,5637,9,236,1,237,1,237,
		1,237,1,237,3,237,5643,8,237,1,238,1,238,3,238,5647,8,238,1,238,1,238,
		1,238,1,239,1,239,3,239,5654,8,239,1,239,1,239,1,239,3,239,5659,8,239,
		1,239,3,239,5662,8,239,1,239,3,239,5665,8,239,1,240,1,240,1,240,1,240,
		1,240,1,240,1,240,3,240,5674,8,240,1,241,1,241,3,241,5678,8,241,1,241,
		1,241,3,241,5682,8,241,1,241,1,241,1,241,1,241,1,241,1,241,1,242,1,242,
		1,242,1,242,1,242,1,242,1,243,1,243,1,243,1,243,1,244,1,244,1,244,1,244,
		1,244,3,244,5705,8,244,1,244,1,244,1,244,1,244,1,244,3,244,5712,8,244,
		5,244,5714,8,244,10,244,12,244,5717,9,244,1,244,1,244,1,244,1,244,3,244,
		5723,8,244,1,244,1,244,1,244,1,244,1,244,3,244,5730,8,244,1,244,3,244,
		5733,8,244,1,244,1,244,1,244,1,244,1,244,1,244,1,244,1,244,1,244,1,244,
		1,244,1,244,5,244,5747,8,244,10,244,12,244,5750,9,244,3,244,5752,8,244,
		1,245,1,245,1,245,1,245,1,245,1,245,1,245,1,245,3,245,5762,8,245,1,245,
		1,245,3,245,5766,8,245,1,245,1,245,1,245,1,245,3,245,5772,8,245,1,245,
		3,245,5775,8,245,1,245,1,245,1,245,3,245,5780,8,245,1,245,1,245,3,245,
		5784,8,245,1,245,1,245,1,245,1,245,1,245,3,245,5791,8,245,1,245,3,245,
		5794,8,245,1,245,1,245,1,245,1,245,3,245,5800,8,245,1,245,1,245,1,245,
		1,245,1,245,1,245,1,245,1,245,1,245,1,245,1,245,1,245,1,245,1,245,1,245,
		1,245,1,245,1,245,1,245,1,245,1,245,1,245,3,245,5824,8,245,1,245,3,245,
		5827,8,245,1,245,1,245,1,245,1,245,1,245,1,245,1,245,1,245,1,245,1,245,
		3,245,5839,8,245,1,245,3,245,5842,8,245,1,245,1,245,1,245,1,245,1,245,
		1,245,1,245,1,245,3,245,5852,8,245,1,245,1,245,1,245,1,245,1,245,1,245,
		3,245,5860,8,245,1,245,1,245,3,245,5864,8,245,1,245,1,245,1,245,1,245,
		1,245,3,245,5871,8,245,1,245,3,245,5874,8,245,1,245,1,245,1,245,1,245,
		1,245,5,245,5881,8,245,10,245,12,245,5884,9,245,1,245,1,245,1,245,3,245,
		5889,8,245,1,245,1,245,1,245,1,245,3,245,5895,8,245,1,245,1,245,1,245,
		1,245,1,245,1,245,1,245,1,245,3,245,5905,8,245,3,245,5907,8,245,1,246,
		1,246,1,246,1,246,3,246,5913,8,246,1,246,3,246,5916,8,246,1,246,3,246,
		5919,8,246,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,1,247,
		3,247,5931,8,247,1,247,3,247,5934,8,247,1,248,1,248,1,248,1,248,3,248,
		5940,8,248,1,249,3,249,5943,8,249,1,249,1,249,1,249,1,249,1,249,1,249,
		3,249,5951,8,249,1,249,1,249,1,249,1,249,1,249,1,249,3,249,5959,8,249,
		1,250,1,250,1,250,1,250,3,250,5965,8,250,1,250,1,250,3,250,5969,8,250,
		1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,1,251,
		3,251,5983,8,251,1,252,1,252,1,252,1,253,1,253,1,253,1,253,1,253,5,253,
		5993,8,253,10,253,12,253,5996,9,253,1,253,1,253,1,253,1,253,3,253,6002,
		8,253,1,253,3,253,6005,8,253,1,253,1,253,1,253,1,254,1,254,3,254,6012,
		8,254,1,254,1,254,1,254,5,254,6017,8,254,10,254,12,254,6020,9,254,1,255,
		1,255,3,255,6024,8,255,1,255,1,255,1,256,1,256,1,256,1,256,1,256,1,256,
		1,256,5,256,6035,8,256,10,256,12,256,6038,9,256,1,257,1,257,1,257,1,257,
		1,258,1,258,1,259,1,259,3,259,6048,8,259,1,259,1,259,1,259,1,259,3,259,
		6054,8,259,1,260,1,260,1,260,3,260,6059,8,260,1,260,1,260,1,260,1,260,
		1,260,1,260,1,260,1,260,1,260,1,260,1,260,3,260,6072,8,260,3,260,6074,
		8,260,1,260,1,260,1,260,3,260,6079,8,260,1,260,1,260,3,260,6083,8,260,
		1,260,3,260,6086,8,260,3,260,6088,8,260,1,261,1,261,1,261,1,261,1,261,
		3,261,6095,8,261,1,262,1,262,1,262,1,262,1,262,3,262,6102,8,262,1,262,
		3,262,6105,8,262,1,262,3,262,6108,8,262,1,262,1,262,1,262,1,262,3,262,
		6114,8,262,1,262,1,262,3,262,6118,8,262,1,263,1,263,1,263,1,263,3,263,
		6124,8,263,1,264,1,264,1,264,1,264,3,264,6130,8,264,1,264,1,264,1,265,
		1,265,1,265,1,266,1,266,1,266,1,267,1,267,1,267,3,267,6143,8,267,1,267,
		1,267,1,267,3,267,6148,8,267,1,267,1,267,1,267,1,267,5,267,6154,8,267,
		10,267,12,267,6157,9,267,3,267,6159,8,267,1,268,1,268,1,268,3,268,6164,
		8,268,1,268,1,268,1,268,3,268,6169,8,268,1,268,1,268,1,268,1,268,5,268,
		6175,8,268,10,268,12,268,6178,9,268,3,268,6180,8,268,1,269,1,269,1,269,
		1,269,1,269,1,269,3,269,6188,8,269,1,270,1,270,3,270,6192,8,270,1,270,
		1,270,1,270,5,270,6197,8,270,10,270,12,270,6200,9,270,1,271,1,271,1,271,
		3,271,6205,8,271,1,271,3,271,6208,8,271,1,272,1,272,3,272,6212,8,272,1,
		272,1,272,1,272,1,272,1,272,1,272,1,272,1,272,1,272,5,272,6223,8,272,10,
		272,12,272,6226,9,272,1,272,1,272,1,272,3,272,6231,8,272,1,272,1,272,1,
		272,1,272,1,272,1,272,1,272,1,272,5,272,6241,8,272,10,272,12,272,6244,
		9,272,3,272,6246,8,272,1,273,1,273,1,274,1,274,1,274,1,274,1,274,3,274,
		6255,8,274,1,274,1,274,1,274,3,274,6260,8,274,1,275,1,275,1,275,1,275,
		3,275,6266,8,275,1,276,1,276,1,277,1,277,3,277,6272,8,277,1,278,1,278,
		1,278,3,278,6277,8,278,3,278,6279,8,278,1,278,3,278,6282,8,278,1,278,1,
		278,3,278,6286,8,278,3,278,6288,8,278,1,279,1,279,3,279,6292,8,279,1,279,
		1,279,1,279,1,279,3,279,6298,8,279,1,279,3,279,6301,8,279,1,279,3,279,
		6304,8,279,1,280,1,280,1,280,1,280,3,280,6310,8,280,1,281,1,281,1,282,
		1,282,1,282,1,282,1,282,3,282,6319,8,282,1,283,1,283,1,284,1,284,1,284,
		1,284,3,284,6327,8,284,1,285,1,285,3,285,6331,8,285,1,286,1,286,1,286,
		3,286,6336,8,286,1,287,1,287,1,288,1,288,1,288,1,288,1,288,1,288,1,288,
		1,288,1,288,1,288,1,288,1,288,1,288,1,288,4,288,6354,8,288,11,288,12,288,
		6355,1,289,1,289,1,289,1,289,1,289,3,289,6363,8,289,3,289,6365,8,289,1,
		290,1,290,1,290,4,290,6370,8,290,11,290,12,290,6371,3,290,6374,8,290,1,
		291,1,291,3,291,6378,8,291,1,292,1,292,1,292,3,292,6383,8,292,1,293,1,
		293,1,293,1,293,1,293,1,293,1,293,1,293,1,293,3,293,6394,8,293,1,294,1,
		294,1,294,3,294,6399,8,294,1,295,1,295,1,296,1,296,3,296,6405,8,296,1,
		297,3,297,6408,8,297,1,297,1,297,3,297,6412,8,297,1,297,4,297,6415,8,297,
		11,297,12,297,6416,1,297,3,297,6420,8,297,1,297,1,297,3,297,6424,8,297,
		1,297,1,297,3,297,6428,8,297,3,297,6430,8,297,1,298,1,298,1,299,3,299,
		6435,8,299,1,299,1,299,1,300,3,300,6440,8,300,1,300,1,300,1,301,1,301,
		1,301,1,301,1,301,1,301,1,301,1,301,1,301,3,301,6453,8,301,1,301,3,301,
		6456,8,301,1,302,1,302,3,302,6460,8,302,1,302,3,302,6463,8,302,1,302,3,
		302,6466,8,302,1,302,1,302,1,302,3,302,6471,8,302,1,302,1,302,1,302,3,
		302,6476,8,302,1,302,1,302,1,302,1,302,3,302,6482,8,302,1,302,3,302,6485,
		8,302,1,302,1,302,1,302,3,302,6490,8,302,1,302,3,302,6493,8,302,1,302,
		1,302,1,302,3,302,6498,8,302,1,302,3,302,6501,8,302,1,302,1,302,3,302,
		6505,8,302,1,302,5,302,6508,8,302,10,302,12,302,6511,9,302,1,302,1,302,
		3,302,6515,8,302,1,302,5,302,6518,8,302,10,302,12,302,6521,9,302,1,302,
		1,302,3,302,6525,8,302,1,302,3,302,6528,8,302,1,302,5,302,6531,8,302,10,
		302,12,302,6534,9,302,1,302,1,302,3,302,6538,8,302,1,302,5,302,6541,8,
		302,10,302,12,302,6544,9,302,1,302,1,302,1,302,3,302,6549,8,302,1,302,
		1,302,1,302,3,302,6554,8,302,1,302,1,302,1,302,3,302,6559,8,302,1,302,
		1,302,1,302,3,302,6564,8,302,1,302,1,302,3,302,6568,8,302,1,302,3,302,
		6571,8,302,1,302,1,302,1,302,3,302,6576,8,302,1,302,1,302,3,302,6580,8,
		302,1,302,1,302,3,302,6584,8,302,1,303,1,303,1,303,1,303,5,303,6590,8,
		303,10,303,12,303,6593,9,303,1,303,1,303,1,304,1,304,3,304,6599,8,304,
		1,304,1,304,3,304,6603,8,304,1,304,1,304,1,304,3,304,6608,8,304,1,304,
		1,304,1,304,3,304,6613,8,304,1,304,1,304,3,304,6617,8,304,3,304,6619,8,
		304,1,304,3,304,6622,8,304,1,305,1,305,1,305,1,305,1,306,1,306,1,306,1,
		306,1,306,1,306,1,307,1,307,1,307,1,307,3,307,6638,8,307,1,307,1,307,1,
		308,1,308,1,308,5,308,6645,8,308,10,308,12,308,6648,9,308,1,309,1,309,
		1,309,5,309,6653,8,309,10,309,12,309,6656,9,309,1,310,1,310,1,310,5,310,
		6661,8,310,10,310,12,310,6664,9,310,1,311,1,311,1,311,1,311,5,311,6670,
		8,311,10,311,12,311,6673,9,311,1,311,1,311,1,312,1,312,1,312,5,312,6680,
		8,312,10,312,12,312,6683,9,312,1,313,1,313,1,313,5,313,6688,8,313,10,313,
		12,313,6691,9,313,1,314,1,314,1,314,5,314,6696,8,314,10,314,12,314,6699,
		9,314,1,315,1,315,1,315,5,315,6704,8,315,10,315,12,315,6707,9,315,1,316,
		1,316,1,316,5,316,6712,8,316,10,316,12,316,6715,9,316,1,317,1,317,1,317,
		1,317,1,317,1,317,1,317,1,317,1,317,3,317,6726,8,317,1,317,1,317,1,317,
		1,317,1,317,3,317,6733,8,317,1,317,1,317,1,317,1,317,1,317,1,317,1,317,
		1,317,3,317,6743,8,317,1,318,1,318,1,318,3,318,6748,8,318,1,318,3,318,
		6751,8,318,1,318,1,318,1,318,3,318,6756,8,318,1,318,3,318,6759,8,318,1,
		319,1,319,3,319,6763,8,319,1,320,1,320,1,320,1,321,1,321,1,321,1,321,1,
		322,1,322,1,322,1,323,1,323,1,323,3,323,6778,8,323,1,324,1,324,1,324,1,
		324,1,324,1,324,3,324,6786,8,324,1,324,1,324,1,324,1,324,1,324,3,324,6793,
		8,324,1,324,1,324,1,324,3,324,6798,8,324,1,325,1,325,1,325,3,325,6803,
		8,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,
		1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,
		1,325,1,325,1,325,1,325,1,325,1,325,1,325,4,325,6835,8,325,11,325,12,325,
		6836,1,325,1,325,3,325,6841,8,325,1,325,1,325,1,325,1,325,4,325,6847,8,
		325,11,325,12,325,6848,1,325,1,325,3,325,6853,8,325,1,325,1,325,1,325,
		1,325,1,325,1,325,1,325,3,325,6862,8,325,1,325,1,325,1,325,1,325,1,325,
		1,325,3,325,6870,8,325,1,325,1,325,1,325,3,325,6875,8,325,1,325,1,325,
		1,325,1,325,1,325,1,325,3,325,6883,8,325,1,325,1,325,1,325,3,325,6888,
		8,325,1,325,1,325,1,325,3,325,6893,8,325,3,325,6895,8,325,1,325,1,325,
		1,325,1,325,1,325,1,325,1,325,3,325,6904,8,325,1,325,1,325,1,325,3,325,
		6909,8,325,1,325,1,325,1,325,1,325,1,325,1,325,3,325,6917,8,325,1,325,
		1,325,1,325,3,325,6922,8,325,1,325,1,325,1,325,1,325,1,325,1,325,3,325,
		6930,8,325,1,325,1,325,1,325,1,325,1,325,1,325,3,325,6938,8,325,1,325,
		3,325,6941,8,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,3,325,
		6951,8,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,1,325,
		1,325,1,325,1,325,1,325,1,325,1,325,3,325,6969,8,325,1,325,3,325,6972,
		8,325,1,325,3,325,6975,8,325,1,325,1,325,3,325,6979,8,325,1,326,1,326,
		1,326,1,326,1,326,1,327,1,327,1,327,1,327,5,327,6990,8,327,10,327,12,327,
		6993,9,327,1,327,1,327,1,327,1,327,1,327,3,327,7000,8,327,1,328,1,328,
		3,328,7004,8,328,1,329,1,329,1,329,3,329,7009,8,329,1,329,1,329,1,329,
		3,329,7014,8,329,1,329,1,329,1,329,1,329,3,329,7020,8,329,1,329,1,329,
		1,329,3,329,7025,8,329,1,329,1,329,3,329,7029,8,329,1,329,1,329,1,329,
		3,329,7034,8,329,1,329,1,329,1,329,3,329,7039,8,329,1,329,1,329,1,329,
		3,329,7044,8,329,1,329,1,329,1,329,1,329,1,329,1,329,5,329,7052,8,329,
		10,329,12,329,7055,9,329,3,329,7057,8,329,1,329,1,329,3,329,7061,8,329,
		1,329,1,329,3,329,7065,8,329,1,330,1,330,1,330,1,330,1,330,3,330,7072,
		8,330,1,330,1,330,3,330,7076,8,330,1,330,1,330,1,330,1,330,1,330,1,330,
		1,330,1,330,1,330,1,330,1,330,1,330,1,330,1,330,1,330,1,330,1,330,1,330,
		1,330,1,330,1,330,1,330,1,330,1,330,1,330,1,330,1,330,3,330,7105,8,330,
		1,331,1,331,1,331,1,331,1,331,1,331,3,331,7113,8,331,1,332,3,332,7116,
		8,332,1,332,3,332,7119,8,332,1,332,3,332,7122,8,332,1,332,3,332,7125,8,
		332,1,333,1,333,1,334,1,334,1,334,1,335,1,335,1,336,1,336,3,336,7136,8,
		336,1,337,1,337,1,337,1,337,1,337,1,338,1,338,1,338,1,338,1,338,1,338,
		1,338,3,338,7150,8,338,1,339,1,339,1,339,1,339,1,339,5,339,7157,8,339,
		10,339,12,339,7160,9,339,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,
		1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,1,340,
		1,340,1,340,1,340,1,340,3,340,7186,8,340,1,341,1,341,1,341,1,341,1,341,
		1,342,1,342,1,342,1,342,3,342,7197,8,342,1,342,1,342,1,342,1,342,1,342,
		3,342,7204,8,342,5,342,7206,8,342,10,342,12,342,7209,9,342,1,343,1,343,
		1,343,1,343,3,343,7215,8,343,1,344,1,344,1,344,1,344,1,344,1,344,3,344,
		7223,8,344,1,344,1,344,1,344,3,344,7228,8,344,1,344,1,344,1,344,1,344,
		5,344,7234,8,344,10,344,12,344,7237,9,344,1,345,1,345,1,345,1,345,1,345,
		1,345,1,345,1,345,1,345,3,345,7248,8,345,1,345,1,345,1,345,1,345,1,345,
		1,345,1,345,1,345,1,345,1,345,1,345,3,345,7261,8,345,1,345,1,345,1,345,
		1,345,3,345,7267,8,345,1,345,1,345,1,345,1,345,3,345,7273,8,345,1,345,
		1,345,1,345,1,345,1,345,1,345,1,345,1,345,1,345,1,345,1,345,1,345,1,345,
		1,345,3,345,7289,8,345,1,345,1,345,1,345,1,345,3,345,7295,8,345,1,345,
		1,345,1,345,1,345,1,345,1,345,1,345,5,345,7304,8,345,10,345,12,345,7307,
		9,345,1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,
		1,346,1,346,1,346,1,346,1,346,1,346,5,346,7326,8,346,10,346,12,346,7329,
		9,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,4,346,7338,8,346,11,346,
		12,346,7339,1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,
		1,346,1,346,1,346,1,346,1,346,3,346,7357,8,346,1,346,1,346,1,346,1,346,
		1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,1,346,
		1,346,1,346,1,346,5,346,7378,8,346,10,346,12,346,7381,9,346,1,347,1,347,
		1,348,1,348,1,348,1,348,1,348,1,348,1,348,1,348,1,348,1,348,1,348,1,348,
		1,348,1,348,3,348,7399,8,348,1,349,1,349,1,349,1,349,1,349,1,349,1,349,
		3,349,7408,8,349,1,350,1,350,1,350,1,350,1,350,1,350,1,350,3,350,7417,
		8,350,1,351,1,351,1,352,1,352,1,353,1,353,1,353,1,353,1,353,3,353,7428,
		8,353,1,354,1,354,1,355,1,355,1,356,1,356,1,357,1,357,1,358,1,358,1,359,
		1,359,1,360,1,360,1,360,0,3,688,690,692,361,0,2,4,6,8,10,12,14,16,18,20,
		22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,
		70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,
		114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,
		150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,
		186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,
		222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,256,
		258,260,262,264,266,268,270,272,274,276,278,280,282,284,286,288,290,292,
		294,296,298,300,302,304,306,308,310,312,314,316,318,320,322,324,326,328,
		330,332,334,336,338,340,342,344,346,348,350,352,354,356,358,360,362,364,
		366,368,370,372,374,376,378,380,382,384,386,388,390,392,394,396,398,400,
		402,404,406,408,410,412,414,416,418,420,422,424,426,428,430,432,434,436,
		438,440,442,444,446,448,450,452,454,456,458,460,462,464,466,468,470,472,
		474,476,478,480,482,484,486,488,490,492,494,496,498,500,502,504,506,508,
		510,512,514,516,518,520,522,524,526,528,530,532,534,536,538,540,542,544,
		546,548,550,552,554,556,558,560,562,564,566,568,570,572,574,576,578,580,
		582,584,586,588,590,592,594,596,598,600,602,604,606,608,610,612,614,616,
		618,620,622,624,626,628,630,632,634,636,638,640,642,644,646,648,650,652,
		654,656,658,660,662,664,666,668,670,672,674,676,678,680,682,684,686,688,
		690,692,694,696,698,700,702,704,706,708,710,712,714,716,718,720,0,144,
		2,0,39,39,150,150,2,0,531,531,537,537,3,0,69,69,159,159,181,181,3,0,42,
		42,384,384,454,454,4,0,42,42,419,419,529,529,611,611,2,0,514,514,1148,
		1148,2,0,78,78,141,141,2,0,15,15,334,334,3,0,44,44,85,85,184,184,2,0,434,
		434,558,558,3,0,506,506,650,650,658,658,2,0,392,392,460,460,2,0,352,352,
		474,474,2,0,42,42,1138,1139,2,0,350,350,443,443,2,0,459,459,673,673,3,
		0,80,80,84,84,125,125,3,0,42,42,402,402,431,431,3,0,42,42,398,398,792,
		792,2,0,637,637,672,672,2,0,81,81,91,91,3,0,436,436,548,548,613,613,2,
		0,69,69,159,159,1,0,356,357,1,0,1138,1139,2,0,1148,1148,1156,1156,2,0,
		81,81,388,388,2,0,545,545,1148,1148,2,0,546,546,1148,1148,3,0,430,430,
		469,469,521,521,7,0,42,42,370,370,372,372,402,402,431,431,573,573,1156,
		1156,2,0,514,514,530,530,1,0,1139,1140,2,0,5,5,51,51,4,0,42,42,384,384,
		454,454,458,458,2,0,26,26,30,30,2,0,12,12,175,175,2,0,192,192,677,677,
		2,0,21,21,144,144,3,0,43,43,75,75,106,106,2,0,106,106,374,374,2,0,365,
		365,427,427,2,0,101,101,601,601,2,0,43,43,106,106,2,0,6,6,49,49,2,0,188,
		188,669,669,4,0,430,430,469,469,520,520,562,562,2,0,430,430,520,520,2,
		0,13,13,45,45,3,0,66,66,78,78,186,186,2,0,34,34,83,83,2,0,97,97,148,148,
		2,0,6,6,49,50,1,0,626,627,2,0,172,172,742,742,2,0,439,439,609,609,2,0,
		226,226,477,477,5,0,107,107,482,483,485,485,489,497,575,575,4,0,479,480,
		484,484,486,487,576,576,3,0,108,108,478,478,488,488,2,0,462,462,628,628,
		2,0,622,622,624,624,2,0,344,344,629,629,2,0,90,90,591,591,2,0,51,51,390,
		390,3,0,31,31,61,61,179,179,3,0,131,131,172,172,437,437,3,0,12,12,19,19,
		187,187,2,0,42,42,121,121,2,0,103,103,182,182,2,0,360,360,614,614,2,0,
		40,40,671,671,2,0,115,115,474,474,2,0,422,422,568,568,4,0,206,206,208,
		208,214,214,638,638,2,0,1108,1108,1124,1124,2,0,345,345,577,577,2,0,68,
		68,80,80,6,0,131,131,172,172,177,177,415,415,437,437,671,671,2,0,513,513,
		634,634,2,0,412,412,675,675,2,0,131,131,437,437,3,0,81,81,92,92,452,452,
		3,0,439,439,474,474,609,609,2,0,634,634,670,670,2,0,376,376,567,567,6,
		0,226,226,409,409,411,411,438,438,574,574,615,615,2,0,45,46,62,62,3,0,
		422,422,550,550,885,885,2,0,466,466,652,652,10,0,359,359,367,367,378,380,
		387,387,507,507,515,515,639,639,646,646,836,836,1005,1005,2,0,35,35,168,
		168,2,0,117,117,996,996,11,0,359,359,367,367,378,380,387,387,507,507,515,
		515,592,592,639,639,646,646,836,836,1005,1005,2,0,1137,1137,1158,1159,
		1,0,1159,1160,2,0,375,375,787,798,3,0,1138,1140,1149,1149,1151,1151,2,
		0,63,63,178,178,2,0,116,116,1152,1152,5,0,25,25,222,224,231,231,233,236,
		518,518,2,0,25,25,222,222,2,0,25,25,222,223,1,0,196,207,3,0,183,183,195,
		195,612,612,2,0,211,216,431,431,6,0,217,217,228,228,230,230,232,232,239,
		239,348,349,4,0,218,221,226,227,229,229,346,346,2,0,153,153,237,237,2,
		0,466,466,803,811,3,0,211,211,226,226,518,518,6,0,200,200,206,206,209,
		209,217,218,220,221,466,466,1,0,214,215,2,0,183,183,612,612,2,0,200,200,
		206,206,2,0,315,316,322,322,3,0,150,150,313,316,331,331,1,0,325,326,3,
		0,17,17,95,95,176,176,2,0,222,222,226,226,2,0,217,218,220,220,3,0,13,13,
		45,45,994,994,3,0,286,286,298,299,309,309,3,0,287,289,305,308,310,312,
		2,0,295,295,297,297,2,0,293,293,296,296,2,0,291,292,302,304,2,0,133,133,
		601,601,2,0,433,433,559,559,2,0,535,535,551,551,2,0,114,114,1127,1127,
		3,0,63,63,178,178,662,662,2,0,137,137,149,149,3,0,6,6,337,337,618,618,
		3,0,114,114,1120,1121,1127,1128,2,0,1117,1119,1122,1123,1,0,1120,1121,
		2,0,226,226,746,786,1,0,799,802,5,0,708,709,725,727,733,733,739,740,742,
		742,1,0,689,696,3,0,217,221,234,234,237,237,58,0,11,11,14,14,18,18,29,
		29,35,35,37,37,42,42,48,48,55,55,57,57,59,59,73,73,79,79,94,94,117,117,
		121,121,124,124,130,130,158,158,168,168,239,239,283,290,294,294,298,299,
		305,312,332,385,387,403,405,405,407,432,434,450,452,458,460,521,523,523,
		527,544,547,558,560,589,591,606,608,636,638,672,674,675,677,682,684,688,
		697,697,699,707,710,712,717,718,720,724,728,732,734,734,736,738,741,741,
		743,745,792,792,836,836,875,875,1000,1000,1005,1005,1088,1088,23,0,39,
		39,97,97,148,148,150,150,217,219,221,221,251,282,290,293,295,297,300,304,
		324,324,459,459,673,673,689,696,736,736,803,803,806,835,837,874,876,999,
		1001,1004,1006,1087,1089,1107,1123,1123,8763,0,723,1,0,0,0,2,742,1,0,0,
		0,4,763,1,0,0,0,6,765,1,0,0,0,8,805,1,0,0,0,10,820,1,0,0,0,12,831,1,0,
		0,0,14,848,1,0,0,0,16,853,1,0,0,0,18,865,1,0,0,0,20,892,1,0,0,0,22,901,
		1,0,0,0,24,903,1,0,0,0,26,915,1,0,0,0,28,945,1,0,0,0,30,981,1,0,0,0,32,
		1032,1,0,0,0,34,1058,1,0,0,0,36,1094,1,0,0,0,38,1107,1,0,0,0,40,1204,1,
		0,0,0,42,1206,1,0,0,0,44,1224,1,0,0,0,46,1285,1,0,0,0,48,1304,1,0,0,0,
		50,1310,1,0,0,0,52,1332,1,0,0,0,54,1334,1,0,0,0,56,1336,1,0,0,0,58,1416,
		1,0,0,0,60,1423,1,0,0,0,62,1425,1,0,0,0,64,1430,1,0,0,0,66,1470,1,0,0,
		0,68,1476,1,0,0,0,70,1478,1,0,0,0,72,1499,1,0,0,0,74,1506,1,0,0,0,76,1508,
		1,0,0,0,78,1533,1,0,0,0,80,1536,1,0,0,0,82,1541,1,0,0,0,84,1567,1,0,0,
		0,86,1583,1,0,0,0,88,1585,1,0,0,0,90,1607,1,0,0,0,92,1609,1,0,0,0,94,1675,
		1,0,0,0,96,1746,1,0,0,0,98,1748,1,0,0,0,100,1776,1,0,0,0,102,1786,1,0,
		0,0,104,1816,1,0,0,0,106,2003,1,0,0,0,108,2005,1,0,0,0,110,2007,1,0,0,
		0,112,2010,1,0,0,0,114,2085,1,0,0,0,116,2108,1,0,0,0,118,2256,1,0,0,0,
		120,2261,1,0,0,0,122,2263,1,0,0,0,124,2273,1,0,0,0,126,2329,1,0,0,0,128,
		2349,1,0,0,0,130,2351,1,0,0,0,132,2386,1,0,0,0,134,2395,1,0,0,0,136,2402,
		1,0,0,0,138,2425,1,0,0,0,140,2434,1,0,0,0,142,2449,1,0,0,0,144,2474,1,
		0,0,0,146,2494,1,0,0,0,148,2877,1,0,0,0,150,2977,1,0,0,0,152,2979,1,0,
		0,0,154,2986,1,0,0,0,156,2993,1,0,0,0,158,3016,1,0,0,0,160,3024,1,0,0,
		0,162,3031,1,0,0,0,164,3038,1,0,0,0,166,3045,1,0,0,0,168,3057,1,0,0,0,
		170,3067,1,0,0,0,172,3074,1,0,0,0,174,3090,1,0,0,0,176,3136,1,0,0,0,178,
		3138,1,0,0,0,180,3148,1,0,0,0,182,3152,1,0,0,0,184,3158,1,0,0,0,186,3170,
		1,0,0,0,188,3172,1,0,0,0,190,3179,1,0,0,0,192,3181,1,0,0,0,194,3239,1,
		0,0,0,196,3313,1,0,0,0,198,3372,1,0,0,0,200,3470,1,0,0,0,202,3474,1,0,
		0,0,204,3476,1,0,0,0,206,3511,1,0,0,0,208,3513,1,0,0,0,210,3521,1,0,0,
		0,212,3529,1,0,0,0,214,3531,1,0,0,0,216,3567,1,0,0,0,218,3622,1,0,0,0,
		220,3631,1,0,0,0,222,3651,1,0,0,0,224,3663,1,0,0,0,226,3667,1,0,0,0,228,
		3700,1,0,0,0,230,3721,1,0,0,0,232,3731,1,0,0,0,234,3735,1,0,0,0,236,3761,
		1,0,0,0,238,3803,1,0,0,0,240,3805,1,0,0,0,242,3820,1,0,0,0,244,3869,1,
		0,0,0,246,3878,1,0,0,0,248,3888,1,0,0,0,250,3898,1,0,0,0,252,3954,1,0,
		0,0,254,3956,1,0,0,0,256,3983,1,0,0,0,258,3989,1,0,0,0,260,3997,1,0,0,
		0,262,4014,1,0,0,0,264,4030,1,0,0,0,266,4067,1,0,0,0,268,4073,1,0,0,0,
		270,4082,1,0,0,0,272,4095,1,0,0,0,274,4099,1,0,0,0,276,4137,1,0,0,0,278,
		4175,1,0,0,0,280,4189,1,0,0,0,282,4197,1,0,0,0,284,4201,1,0,0,0,286,4207,
		1,0,0,0,288,4221,1,0,0,0,290,4224,1,0,0,0,292,4242,1,0,0,0,294,4246,1,
		0,0,0,296,4262,1,0,0,0,298,4264,1,0,0,0,300,4276,1,0,0,0,302,4280,1,0,
		0,0,304,4297,1,0,0,0,306,4314,1,0,0,0,308,4317,1,0,0,0,310,4327,1,0,0,
		0,312,4331,1,0,0,0,314,4344,1,0,0,0,316,4347,1,0,0,0,318,4352,1,0,0,0,
		320,4372,1,0,0,0,322,4374,1,0,0,0,324,4391,1,0,0,0,326,4400,1,0,0,0,328,
		4409,1,0,0,0,330,4411,1,0,0,0,332,4425,1,0,0,0,334,4436,1,0,0,0,336,4445,
		1,0,0,0,338,4448,1,0,0,0,340,4456,1,0,0,0,342,4481,1,0,0,0,344,4493,1,
		0,0,0,346,4496,1,0,0,0,348,4528,1,0,0,0,350,4530,1,0,0,0,352,4532,1,0,
		0,0,354,4534,1,0,0,0,356,4536,1,0,0,0,358,4589,1,0,0,0,360,4591,1,0,0,
		0,362,4597,1,0,0,0,364,4617,1,0,0,0,366,4631,1,0,0,0,368,4642,1,0,0,0,
		370,4644,1,0,0,0,372,4650,1,0,0,0,374,4660,1,0,0,0,376,4664,1,0,0,0,378,
		4671,1,0,0,0,380,4675,1,0,0,0,382,4681,1,0,0,0,384,4688,1,0,0,0,386,4694,
		1,0,0,0,388,4700,1,0,0,0,390,4705,1,0,0,0,392,4750,1,0,0,0,394,4771,1,
		0,0,0,396,4796,1,0,0,0,398,4799,1,0,0,0,400,4805,1,0,0,0,402,4821,1,0,
		0,0,404,4836,1,0,0,0,406,4842,1,0,0,0,408,4872,1,0,0,0,410,4874,1,0,0,
		0,412,4881,1,0,0,0,414,4893,1,0,0,0,416,4899,1,0,0,0,418,4924,1,0,0,0,
		420,4928,1,0,0,0,422,4932,1,0,0,0,424,4943,1,0,0,0,426,5024,1,0,0,0,428,
		5091,1,0,0,0,430,5093,1,0,0,0,432,5199,1,0,0,0,434,5223,1,0,0,0,436,5225,
		1,0,0,0,438,5243,1,0,0,0,440,5323,1,0,0,0,442,5325,1,0,0,0,444,5338,1,
		0,0,0,446,5349,1,0,0,0,448,5377,1,0,0,0,450,5381,1,0,0,0,452,5402,1,0,
		0,0,454,5412,1,0,0,0,456,5422,1,0,0,0,458,5462,1,0,0,0,460,5464,1,0,0,
		0,462,5467,1,0,0,0,464,5567,1,0,0,0,466,5585,1,0,0,0,468,5587,1,0,0,0,
		470,5591,1,0,0,0,472,5629,1,0,0,0,474,5638,1,0,0,0,476,5644,1,0,0,0,478,
		5651,1,0,0,0,480,5673,1,0,0,0,482,5675,1,0,0,0,484,5689,1,0,0,0,486,5695,
		1,0,0,0,488,5751,1,0,0,0,490,5906,1,0,0,0,492,5918,1,0,0,0,494,5933,1,
		0,0,0,496,5939,1,0,0,0,498,5958,1,0,0,0,500,5968,1,0,0,0,502,5982,1,0,
		0,0,504,5984,1,0,0,0,506,5987,1,0,0,0,508,6009,1,0,0,0,510,6021,1,0,0,
		0,512,6027,1,0,0,0,514,6039,1,0,0,0,516,6043,1,0,0,0,518,6045,1,0,0,0,
		520,6087,1,0,0,0,522,6094,1,0,0,0,524,6096,1,0,0,0,526,6119,1,0,0,0,528,
		6125,1,0,0,0,530,6133,1,0,0,0,532,6136,1,0,0,0,534,6139,1,0,0,0,536,6160,
		1,0,0,0,538,6181,1,0,0,0,540,6189,1,0,0,0,542,6201,1,0,0,0,544,6209,1,
		0,0,0,546,6247,1,0,0,0,548,6259,1,0,0,0,550,6261,1,0,0,0,552,6267,1,0,
		0,0,554,6271,1,0,0,0,556,6287,1,0,0,0,558,6300,1,0,0,0,560,6309,1,0,0,
		0,562,6311,1,0,0,0,564,6318,1,0,0,0,566,6320,1,0,0,0,568,6326,1,0,0,0,
		570,6330,1,0,0,0,572,6335,1,0,0,0,574,6337,1,0,0,0,576,6339,1,0,0,0,578,
		6357,1,0,0,0,580,6373,1,0,0,0,582,6377,1,0,0,0,584,6382,1,0,0,0,586,6393,
		1,0,0,0,588,6398,1,0,0,0,590,6400,1,0,0,0,592,6404,1,0,0,0,594,6429,1,
		0,0,0,596,6431,1,0,0,0,598,6434,1,0,0,0,600,6439,1,0,0,0,602,6455,1,0,
		0,0,604,6583,1,0,0,0,606,6585,1,0,0,0,608,6618,1,0,0,0,610,6623,1,0,0,
		0,612,6627,1,0,0,0,614,6633,1,0,0,0,616,6641,1,0,0,0,618,6649,1,0,0,0,
		620,6657,1,0,0,0,622,6665,1,0,0,0,624,6676,1,0,0,0,626,6684,1,0,0,0,628,
		6692,1,0,0,0,630,6700,1,0,0,0,632,6708,1,0,0,0,634,6742,1,0,0,0,636,6758,
		1,0,0,0,638,6762,1,0,0,0,640,6764,1,0,0,0,642,6767,1,0,0,0,644,6771,1,
		0,0,0,646,6777,1,0,0,0,648,6797,1,0,0,0,650,6978,1,0,0,0,652,6980,1,0,
		0,0,654,6999,1,0,0,0,656,7001,1,0,0,0,658,7064,1,0,0,0,660,7104,1,0,0,
		0,662,7106,1,0,0,0,664,7115,1,0,0,0,666,7126,1,0,0,0,668,7128,1,0,0,0,
		670,7131,1,0,0,0,672,7135,1,0,0,0,674,7137,1,0,0,0,676,7149,1,0,0,0,678,
		7151,1,0,0,0,680,7185,1,0,0,0,682,7187,1,0,0,0,684,7196,1,0,0,0,686,7214,
		1,0,0,0,688,7227,1,0,0,0,690,7238,1,0,0,0,692,7356,1,0,0,0,694,7382,1,
		0,0,0,696,7398,1,0,0,0,698,7407,1,0,0,0,700,7416,1,0,0,0,702,7418,1,0,
		0,0,704,7420,1,0,0,0,706,7427,1,0,0,0,708,7429,1,0,0,0,710,7431,1,0,0,
		0,712,7433,1,0,0,0,714,7435,1,0,0,0,716,7437,1,0,0,0,718,7439,1,0,0,0,
		720,7441,1,0,0,0,722,724,3,2,1,0,723,722,1,0,0,0,723,724,1,0,0,0,724,727,
		1,0,0,0,725,726,5,1121,0,0,726,728,5,1121,0,0,727,725,1,0,0,0,727,728,
		1,0,0,0,728,729,1,0,0,0,729,730,5,0,0,1,730,1,1,0,0,0,731,734,3,4,2,0,
		732,733,5,1121,0,0,733,735,5,1121,0,0,734,732,1,0,0,0,734,735,1,0,0,0,
		735,737,1,0,0,0,736,738,5,1136,0,0,737,736,1,0,0,0,737,738,1,0,0,0,738,
		741,1,0,0,0,739,741,3,6,3,0,740,731,1,0,0,0,740,739,1,0,0,0,741,744,1,
		0,0,0,742,740,1,0,0,0,742,743,1,0,0,0,743,754,1,0,0,0,744,742,1,0,0,0,
		745,751,3,4,2,0,746,747,5,1121,0,0,747,749,5,1121,0,0,748,746,1,0,0,0,
		748,749,1,0,0,0,749,750,1,0,0,0,750,752,5,1136,0,0,751,748,1,0,0,0,751,
		752,1,0,0,0,752,755,1,0,0,0,753,755,3,6,3,0,754,745,1,0,0,0,754,753,1,
		0,0,0,755,3,1,0,0,0,756,764,3,8,4,0,757,764,3,10,5,0,758,764,3,12,6,0,
		759,764,3,14,7,0,760,764,3,16,8,0,761,764,3,20,10,0,762,764,3,22,11,0,
		763,756,1,0,0,0,763,757,1,0,0,0,763,758,1,0,0,0,763,759,1,0,0,0,763,760,
		1,0,0,0,763,761,1,0,0,0,763,762,1,0,0,0,764,5,1,0,0,0,765,766,5,1136,0,
		0,766,7,1,0,0,0,767,806,3,24,12,0,768,806,3,26,13,0,769,806,3,28,14,0,
		770,806,3,30,15,0,771,806,3,32,16,0,772,806,3,34,17,0,773,806,3,38,19,
		0,774,806,3,40,20,0,775,806,3,42,21,0,776,806,3,44,22,0,777,806,3,46,23,
		0,778,806,3,56,28,0,779,806,3,36,18,0,780,806,3,128,64,0,781,806,3,130,
		65,0,782,806,3,132,66,0,783,806,3,134,67,0,784,806,3,136,68,0,785,806,
		3,138,69,0,786,806,3,140,70,0,787,806,3,142,71,0,788,806,3,144,72,0,789,
		806,3,146,73,0,790,806,3,152,76,0,791,806,3,154,77,0,792,806,3,156,78,
		0,793,806,3,158,79,0,794,806,3,160,80,0,795,806,3,162,81,0,796,806,3,164,
		82,0,797,806,3,166,83,0,798,806,3,168,84,0,799,806,3,170,85,0,800,806,
		3,172,86,0,801,806,3,174,87,0,802,806,3,176,88,0,803,806,3,178,89,0,804,
		806,3,182,91,0,805,767,1,0,0,0,805,768,1,0,0,0,805,769,1,0,0,0,805,770,
		1,0,0,0,805,771,1,0,0,0,805,772,1,0,0,0,805,773,1,0,0,0,805,774,1,0,0,
		0,805,775,1,0,0,0,805,776,1,0,0,0,805,777,1,0,0,0,805,778,1,0,0,0,805,
		779,1,0,0,0,805,780,1,0,0,0,805,781,1,0,0,0,805,782,1,0,0,0,805,783,1,
		0,0,0,805,784,1,0,0,0,805,785,1,0,0,0,805,786,1,0,0,0,805,787,1,0,0,0,
		805,788,1,0,0,0,805,789,1,0,0,0,805,790,1,0,0,0,805,791,1,0,0,0,805,792,
		1,0,0,0,805,793,1,0,0,0,805,794,1,0,0,0,805,795,1,0,0,0,805,796,1,0,0,
		0,805,797,1,0,0,0,805,798,1,0,0,0,805,799,1,0,0,0,805,800,1,0,0,0,805,
		801,1,0,0,0,805,802,1,0,0,0,805,803,1,0,0,0,805,804,1,0,0,0,806,9,1,0,
		0,0,807,821,3,200,100,0,808,821,3,192,96,0,809,821,3,202,101,0,810,821,
		3,186,93,0,811,821,3,198,99,0,812,821,3,184,92,0,813,821,3,194,97,0,814,
		821,3,196,98,0,815,821,3,188,94,0,816,821,3,190,95,0,817,821,3,204,102,
		0,818,821,3,540,270,0,819,821,3,542,271,0,820,807,1,0,0,0,820,808,1,0,
		0,0,820,809,1,0,0,0,820,810,1,0,0,0,820,811,1,0,0,0,820,812,1,0,0,0,820,
		813,1,0,0,0,820,814,1,0,0,0,820,815,1,0,0,0,820,816,1,0,0,0,820,817,1,
		0,0,0,820,818,1,0,0,0,820,819,1,0,0,0,821,11,1,0,0,0,822,832,3,298,149,
		0,823,832,3,300,150,0,824,832,3,302,151,0,825,832,3,304,152,0,826,832,
		3,306,153,0,827,832,3,308,154,0,828,832,3,310,155,0,829,832,3,312,156,
		0,830,832,3,314,157,0,831,822,1,0,0,0,831,823,1,0,0,0,831,824,1,0,0,0,
		831,825,1,0,0,0,831,826,1,0,0,0,831,827,1,0,0,0,831,828,1,0,0,0,831,829,
		1,0,0,0,831,830,1,0,0,0,832,13,1,0,0,0,833,849,3,330,165,0,834,849,3,332,
		166,0,835,849,3,334,167,0,836,849,3,336,168,0,837,849,3,338,169,0,838,
		849,3,340,170,0,839,849,3,342,171,0,840,849,3,344,172,0,841,849,3,346,
		173,0,842,849,3,370,185,0,843,849,3,372,186,0,844,849,3,374,187,0,845,
		849,3,376,188,0,846,849,3,378,189,0,847,849,3,380,190,0,848,833,1,0,0,
		0,848,834,1,0,0,0,848,835,1,0,0,0,848,836,1,0,0,0,848,837,1,0,0,0,848,
		838,1,0,0,0,848,839,1,0,0,0,848,840,1,0,0,0,848,841,1,0,0,0,848,842,1,
		0,0,0,848,843,1,0,0,0,848,844,1,0,0,0,848,845,1,0,0,0,848,846,1,0,0,0,
		848,847,1,0,0,0,849,15,1,0,0,0,850,854,3,382,191,0,851,854,3,384,192,0,
		852,854,3,386,193,0,853,850,1,0,0,0,853,851,1,0,0,0,853,852,1,0,0,0,854,
		17,1,0,0,0,855,866,3,390,195,0,856,866,3,392,196,0,857,866,3,394,197,0,
		858,866,3,398,199,0,859,866,3,400,200,0,860,866,3,402,201,0,861,866,3,
		406,203,0,862,866,3,396,198,0,863,866,3,404,202,0,864,866,3,408,204,0,
		865,855,1,0,0,0,865,856,1,0,0,0,865,857,1,0,0,0,865,858,1,0,0,0,865,859,
		1,0,0,0,865,860,1,0,0,0,865,861,1,0,0,0,865,862,1,0,0,0,865,863,1,0,0,
		0,865,864,1,0,0,0,866,19,1,0,0,0,867,893,3,426,213,0,868,893,3,428,214,
		0,869,893,3,430,215,0,870,893,3,432,216,0,871,893,3,436,218,0,872,893,
		3,438,219,0,873,893,3,440,220,0,874,893,3,442,221,0,875,893,3,470,235,
		0,876,893,3,472,236,0,877,893,3,474,237,0,878,893,3,476,238,0,879,893,
		3,478,239,0,880,893,3,482,241,0,881,893,3,484,242,0,882,893,3,486,243,
		0,883,893,3,488,244,0,884,893,3,490,245,0,885,893,3,504,252,0,886,893,
		3,506,253,0,887,893,3,508,254,0,888,893,3,510,255,0,889,893,3,512,256,
		0,890,893,3,514,257,0,891,893,3,516,258,0,892,867,1,0,0,0,892,868,1,0,
		0,0,892,869,1,0,0,0,892,870,1,0,0,0,892,871,1,0,0,0,892,872,1,0,0,0,892,
		873,1,0,0,0,892,874,1,0,0,0,892,875,1,0,0,0,892,876,1,0,0,0,892,877,1,
		0,0,0,892,878,1,0,0,0,892,879,1,0,0,0,892,880,1,0,0,0,892,881,1,0,0,0,
		892,882,1,0,0,0,892,883,1,0,0,0,892,884,1,0,0,0,892,885,1,0,0,0,892,886,
		1,0,0,0,892,887,1,0,0,0,892,888,1,0,0,0,892,889,1,0,0,0,892,890,1,0,0,
		0,892,891,1,0,0,0,893,21,1,0,0,0,894,902,3,526,263,0,895,902,3,528,264,
		0,896,902,3,530,265,0,897,902,3,532,266,0,898,902,3,534,267,0,899,902,
		3,536,268,0,900,902,3,544,272,0,901,894,1,0,0,0,901,895,1,0,0,0,901,896,
		1,0,0,0,901,897,1,0,0,0,901,898,1,0,0,0,901,899,1,0,0,0,901,900,1,0,0,
		0,902,23,1,0,0,0,903,904,5,33,0,0,904,906,7,0,0,0,905,907,3,642,321,0,
		906,905,1,0,0,0,906,907,1,0,0,0,907,908,1,0,0,0,908,912,3,584,292,0,909,
		911,3,58,29,0,910,909,1,0,0,0,911,914,1,0,0,0,912,910,1,0,0,0,912,913,
		1,0,0,0,913,25,1,0,0,0,914,912,1,0,0,0,915,917,5,33,0,0,916,918,3,64,32,
		0,917,916,1,0,0,0,917,918,1,0,0,0,918,919,1,0,0,0,919,921,5,415,0,0,920,
		922,3,642,321,0,921,920,1,0,0,0,921,922,1,0,0,0,922,923,1,0,0,0,923,924,
		3,550,275,0,924,925,5,118,0,0,925,926,5,605,0,0,926,933,3,66,33,0,927,
		928,5,118,0,0,928,930,5,371,0,0,929,931,5,114,0,0,930,929,1,0,0,0,930,
		931,1,0,0,0,931,932,1,0,0,0,932,934,5,561,0,0,933,927,1,0,0,0,933,934,
		1,0,0,0,934,936,1,0,0,0,935,937,3,74,37,0,936,935,1,0,0,0,936,937,1,0,
		0,0,937,940,1,0,0,0,938,939,5,368,0,0,939,941,5,1148,0,0,940,938,1,0,0,
		0,940,941,1,0,0,0,941,942,1,0,0,0,942,943,5,399,0,0,943,944,3,388,194,
		0,944,27,1,0,0,0,945,947,5,33,0,0,946,948,7,1,0,0,947,946,1,0,0,0,947,
		948,1,0,0,0,948,950,1,0,0,0,949,951,7,2,0,0,950,949,1,0,0,0,950,951,1,
		0,0,0,951,952,1,0,0,0,952,953,5,81,0,0,953,955,3,584,292,0,954,956,3,76,
		38,0,955,954,1,0,0,0,955,956,1,0,0,0,956,957,1,0,0,0,957,958,5,118,0,0,
		958,959,3,552,276,0,959,963,3,622,311,0,960,962,3,78,39,0,961,960,1,0,
		0,0,962,965,1,0,0,0,963,961,1,0,0,0,963,964,1,0,0,0,964,978,1,0,0,0,965,
		963,1,0,0,0,966,968,5,336,0,0,967,969,5,1124,0,0,968,967,1,0,0,0,968,969,
		1,0,0,0,969,970,1,0,0,0,970,977,7,3,0,0,971,973,5,103,0,0,972,974,5,1124,
		0,0,973,972,1,0,0,0,973,974,1,0,0,0,974,975,1,0,0,0,975,977,7,4,0,0,976,
		966,1,0,0,0,976,971,1,0,0,0,977,980,1,0,0,0,978,976,1,0,0,0,978,979,1,
		0,0,0,979,29,1,0,0,0,980,978,1,0,0,0,981,982,5,33,0,0,982,983,5,475,0,
		0,983,984,5,73,0,0,984,985,3,584,292,0,985,986,5,5,0,0,986,987,5,659,0,
		0,987,993,5,1148,0,0,988,990,5,453,0,0,989,991,5,1124,0,0,990,989,1,0,
		0,0,990,991,1,0,0,0,991,992,1,0,0,0,992,994,3,592,296,0,993,988,1,0,0,
		0,993,994,1,0,0,0,994,1000,1,0,0,0,995,997,5,660,0,0,996,998,5,1124,0,
		0,997,996,1,0,0,0,997,998,1,0,0,0,998,999,1,0,0,0,999,1001,3,592,296,0,
		1000,995,1,0,0,0,1000,1001,1,0,0,0,1001,1007,1,0,0,0,1002,1004,5,572,0,
		0,1003,1005,5,1124,0,0,1004,1003,1,0,0,0,1004,1005,1,0,0,0,1005,1006,1,
		0,0,0,1006,1008,3,592,296,0,1007,1002,1,0,0,0,1007,1008,1,0,0,0,1008,1014,
		1,0,0,0,1009,1011,5,528,0,0,1010,1012,5,1124,0,0,1011,1010,1,0,0,0,1011,
		1012,1,0,0,0,1012,1013,1,0,0,0,1013,1015,3,584,292,0,1014,1009,1,0,0,0,
		1014,1015,1,0,0,0,1015,1017,1,0,0,0,1016,1018,5,674,0,0,1017,1016,1,0,
		0,0,1017,1018,1,0,0,0,1018,1024,1,0,0,0,1019,1021,5,368,0,0,1020,1022,
		5,1124,0,0,1021,1020,1,0,0,0,1021,1022,1,0,0,0,1022,1023,1,0,0,0,1023,
		1025,5,1148,0,0,1024,1019,1,0,0,0,1024,1025,1,0,0,0,1025,1026,1,0,0,0,
		1026,1028,5,409,0,0,1027,1029,5,1124,0,0,1028,1027,1,0,0,0,1028,1029,1,
		0,0,0,1029,1030,1,0,0,0,1030,1031,3,572,286,0,1031,31,1,0,0,0,1032,1034,
		5,33,0,0,1033,1035,3,64,32,0,1034,1033,1,0,0,0,1034,1035,1,0,0,0,1035,
		1036,1,0,0,0,1036,1037,5,131,0,0,1037,1038,3,550,275,0,1038,1040,5,1133,
		0,0,1039,1041,3,80,40,0,1040,1039,1,0,0,0,1040,1041,1,0,0,0,1041,1046,
		1,0,0,0,1042,1043,5,1135,0,0,1043,1045,3,80,40,0,1044,1042,1,0,0,0,1045,
		1048,1,0,0,0,1046,1044,1,0,0,0,1046,1047,1,0,0,0,1047,1049,1,0,0,0,1048,
		1046,1,0,0,0,1049,1053,5,1134,0,0,1050,1052,3,84,42,0,1051,1050,1,0,0,
		0,1052,1055,1,0,0,0,1053,1051,1,0,0,0,1053,1054,1,0,0,0,1054,1056,1,0,
		0,0,1055,1053,1,0,0,0,1056,1057,3,388,194,0,1057,33,1,0,0,0,1058,1060,
		5,33,0,0,1059,1061,3,64,32,0,1060,1059,1,0,0,0,1060,1061,1,0,0,0,1061,
		1063,1,0,0,0,1062,1064,5,335,0,0,1063,1062,1,0,0,0,1063,1064,1,0,0,0,1064,
		1065,1,0,0,0,1065,1067,5,437,0,0,1066,1068,3,642,321,0,1067,1066,1,0,0,
		0,1067,1068,1,0,0,0,1068,1069,1,0,0,0,1069,1070,3,550,275,0,1070,1072,
		5,1133,0,0,1071,1073,3,82,41,0,1072,1071,1,0,0,0,1072,1073,1,0,0,0,1073,
		1078,1,0,0,0,1074,1075,5,1135,0,0,1075,1077,3,82,41,0,1076,1074,1,0,0,
		0,1077,1080,1,0,0,0,1078,1076,1,0,0,0,1078,1079,1,0,0,0,1079,1081,1,0,
		0,0,1080,1078,1,0,0,0,1081,1082,5,1134,0,0,1082,1083,5,594,0,0,1083,1087,
		3,604,302,0,1084,1086,3,84,42,0,1085,1084,1,0,0,0,1086,1089,1,0,0,0,1087,
		1085,1,0,0,0,1087,1088,1,0,0,0,1088,1092,1,0,0,0,1089,1087,1,0,0,0,1090,
		1093,3,388,194,0,1091,1093,3,404,202,0,1092,1090,1,0,0,0,1092,1091,1,0,
		0,0,1093,35,1,0,0,0,1094,1095,5,33,0,0,1095,1097,5,596,0,0,1096,1098,3,
		642,321,0,1097,1096,1,0,0,0,1097,1098,1,0,0,0,1098,1099,1,0,0,0,1099,1104,
		3,554,277,0,1100,1101,5,1135,0,0,1101,1103,3,554,277,0,1102,1100,1,0,0,
		0,1103,1106,1,0,0,0,1104,1102,1,0,0,0,1104,1105,1,0,0,0,1105,37,1,0,0,
		0,1106,1104,1,0,0,0,1107,1108,5,33,0,0,1108,1109,5,608,0,0,1109,1110,3,
		584,292,0,1110,1111,5,67,0,0,1111,1112,5,388,0,0,1112,1113,5,679,0,0,1113,
		1114,7,5,0,0,1114,1115,5,541,0,0,1115,1116,5,1133,0,0,1116,1121,3,86,43,
		0,1117,1118,5,1135,0,0,1118,1120,3,86,43,0,1119,1117,1,0,0,0,1120,1123,
		1,0,0,0,1121,1119,1,0,0,0,1121,1122,1,0,0,0,1122,1124,1,0,0,0,1123,1121,
		1,0,0,0,1124,1125,5,1134,0,0,1125,39,1,0,0,0,1126,1128,5,33,0,0,1127,1129,
		5,649,0,0,1128,1127,1,0,0,0,1128,1129,1,0,0,0,1129,1130,1,0,0,0,1130,1132,
		5,172,0,0,1131,1133,3,642,321,0,1132,1131,1,0,0,0,1132,1133,1,0,0,0,1133,
		1134,1,0,0,0,1134,1142,3,552,276,0,1135,1136,5,98,0,0,1136,1143,3,552,
		276,0,1137,1138,5,1133,0,0,1138,1139,5,98,0,0,1139,1140,3,552,276,0,1140,
		1141,5,1134,0,0,1141,1143,1,0,0,0,1142,1135,1,0,0,0,1142,1137,1,0,0,0,
		1143,1205,1,0,0,0,1144,1146,5,33,0,0,1145,1147,5,649,0,0,1146,1145,1,0,
		0,0,1146,1147,1,0,0,0,1147,1148,1,0,0,0,1148,1150,5,172,0,0,1149,1151,
		3,642,321,0,1150,1149,1,0,0,0,1150,1151,1,0,0,0,1151,1152,1,0,0,0,1152,
		1154,3,552,276,0,1153,1155,3,88,44,0,1154,1153,1,0,0,0,1154,1155,1,0,0,
		0,1155,1166,1,0,0,0,1156,1163,3,106,53,0,1157,1159,5,1135,0,0,1158,1157,
		1,0,0,0,1158,1159,1,0,0,0,1159,1160,1,0,0,0,1160,1162,3,106,53,0,1161,
		1158,1,0,0,0,1162,1165,1,0,0,0,1163,1161,1,0,0,0,1163,1164,1,0,0,0,1164,
		1167,1,0,0,0,1165,1163,1,0,0,0,1166,1156,1,0,0,0,1166,1167,1,0,0,0,1167,
		1169,1,0,0,0,1168,1170,3,112,56,0,1169,1168,1,0,0,0,1169,1170,1,0,0,0,
		1170,1172,1,0,0,0,1171,1173,7,6,0,0,1172,1171,1,0,0,0,1172,1173,1,0,0,
		0,1173,1175,1,0,0,0,1174,1176,5,12,0,0,1175,1174,1,0,0,0,1175,1176,1,0,
		0,0,1176,1177,1,0,0,0,1177,1178,3,200,100,0,1178,1205,1,0,0,0,1179,1181,
		5,33,0,0,1180,1182,5,649,0,0,1181,1180,1,0,0,0,1181,1182,1,0,0,0,1182,
		1183,1,0,0,0,1183,1185,5,172,0,0,1184,1186,3,642,321,0,1185,1184,1,0,0,
		0,1185,1186,1,0,0,0,1186,1187,1,0,0,0,1187,1188,3,552,276,0,1188,1199,
		3,88,44,0,1189,1196,3,106,53,0,1190,1192,5,1135,0,0,1191,1190,1,0,0,0,
		1191,1192,1,0,0,0,1192,1193,1,0,0,0,1193,1195,3,106,53,0,1194,1191,1,0,
		0,0,1195,1198,1,0,0,0,1196,1194,1,0,0,0,1196,1197,1,0,0,0,1197,1200,1,
		0,0,0,1198,1196,1,0,0,0,1199,1189,1,0,0,0,1199,1200,1,0,0,0,1200,1202,
		1,0,0,0,1201,1203,3,112,56,0,1202,1201,1,0,0,0,1202,1203,1,0,0,0,1203,
		1205,1,0,0,0,1204,1126,1,0,0,0,1204,1144,1,0,0,0,1204,1179,1,0,0,0,1205,
		41,1,0,0,0,1206,1207,5,33,0,0,1207,1208,5,647,0,0,1208,1209,3,584,292,
		0,1209,1210,5,5,0,0,1210,1211,5,389,0,0,1211,1215,5,1148,0,0,1212,1213,
		5,428,0,0,1213,1214,5,1124,0,0,1214,1216,3,592,296,0,1215,1212,1,0,0,0,
		1215,1216,1,0,0,0,1216,1222,1,0,0,0,1217,1219,5,409,0,0,1218,1220,5,1124,
		0,0,1219,1218,1,0,0,0,1219,1220,1,0,0,0,1220,1221,1,0,0,0,1221,1223,3,
		572,286,0,1222,1217,1,0,0,0,1222,1223,1,0,0,0,1223,43,1,0,0,0,1224,1225,
		5,33,0,0,1225,1226,5,647,0,0,1226,1227,3,584,292,0,1227,1228,5,5,0,0,1228,
		1229,5,389,0,0,1229,1230,5,1148,0,0,1230,1231,5,186,0,0,1231,1232,5,475,
		0,0,1232,1233,5,73,0,0,1233,1239,3,584,292,0,1234,1236,5,423,0,0,1235,
		1237,5,1124,0,0,1236,1235,1,0,0,0,1236,1237,1,0,0,0,1237,1238,1,0,0,0,
		1238,1240,3,592,296,0,1239,1234,1,0,0,0,1239,1240,1,0,0,0,1240,1246,1,
		0,0,0,1241,1243,5,453,0,0,1242,1244,5,1124,0,0,1243,1242,1,0,0,0,1243,
		1244,1,0,0,0,1244,1245,1,0,0,0,1245,1247,3,592,296,0,1246,1241,1,0,0,0,
		1246,1247,1,0,0,0,1247,1253,1,0,0,0,1248,1250,5,341,0,0,1249,1251,5,1124,
		0,0,1250,1249,1,0,0,0,1250,1251,1,0,0,0,1251,1252,1,0,0,0,1252,1254,3,
		592,296,0,1253,1248,1,0,0,0,1253,1254,1,0,0,0,1254,1260,1,0,0,0,1255,1257,
		5,501,0,0,1256,1258,5,1124,0,0,1257,1256,1,0,0,0,1257,1258,1,0,0,0,1258,
		1259,1,0,0,0,1259,1261,3,592,296,0,1260,1255,1,0,0,0,1260,1261,1,0,0,0,
		1261,1267,1,0,0,0,1262,1264,5,528,0,0,1263,1265,5,1124,0,0,1264,1263,1,
		0,0,0,1264,1265,1,0,0,0,1265,1266,1,0,0,0,1266,1268,3,584,292,0,1267,1262,
		1,0,0,0,1267,1268,1,0,0,0,1268,1270,1,0,0,0,1269,1271,5,674,0,0,1270,1269,
		1,0,0,0,1270,1271,1,0,0,0,1271,1277,1,0,0,0,1272,1274,5,368,0,0,1273,1275,
		5,1124,0,0,1274,1273,1,0,0,0,1274,1275,1,0,0,0,1275,1276,1,0,0,0,1276,
		1278,5,1148,0,0,1277,1272,1,0,0,0,1277,1278,1,0,0,0,1278,1279,1,0,0,0,
		1279,1281,5,409,0,0,1280,1282,5,1124,0,0,1281,1280,1,0,0,0,1281,1282,1,
		0,0,0,1282,1283,1,0,0,0,1283,1284,3,572,286,0,1284,45,1,0,0,0,1285,1287,
		5,33,0,0,1286,1288,3,64,32,0,1287,1286,1,0,0,0,1287,1288,1,0,0,0,1288,
		1289,1,0,0,0,1289,1290,5,177,0,0,1290,1291,3,550,275,0,1291,1292,7,7,0,
		0,1292,1293,7,8,0,0,1293,1294,5,118,0,0,1294,1295,3,552,276,0,1295,1296,
		5,65,0,0,1296,1297,5,52,0,0,1297,1300,5,600,0,0,1298,1299,7,9,0,0,1299,
		1301,3,550,275,0,1300,1298,1,0,0,0,1300,1301,1,0,0,0,1301,1302,1,0,0,0,
		1302,1303,3,388,194,0,1303,47,1,0,0,0,1304,1306,5,192,0,0,1305,1307,5,
		571,0,0,1306,1305,1,0,0,0,1306,1307,1,0,0,0,1307,1308,1,0,0,0,1308,1309,
		3,50,25,0,1309,49,1,0,0,0,1310,1322,3,52,26,0,1311,1312,5,1133,0,0,1312,
		1317,3,54,27,0,1313,1314,5,1135,0,0,1314,1316,3,54,27,0,1315,1313,1,0,
		0,0,1316,1319,1,0,0,0,1317,1315,1,0,0,0,1317,1318,1,0,0,0,1318,1320,1,
		0,0,0,1319,1317,1,0,0,0,1320,1321,5,1134,0,0,1321,1323,1,0,0,0,1322,1311,
		1,0,0,0,1322,1323,1,0,0,0,1323,1324,1,0,0,0,1324,1325,5,12,0,0,1325,1326,
		5,1133,0,0,1326,1327,3,10,5,0,1327,1330,5,1134,0,0,1328,1329,5,1135,0,
		0,1329,1331,3,50,25,0,1330,1328,1,0,0,0,1330,1331,1,0,0,0,1331,51,1,0,
		0,0,1332,1333,3,584,292,0,1333,53,1,0,0,0,1334,1335,3,584,292,0,1335,55,
		1,0,0,0,1336,1338,5,33,0,0,1337,1339,3,644,322,0,1338,1337,1,0,0,0,1338,
		1339,1,0,0,0,1339,1343,1,0,0,0,1340,1341,5,336,0,0,1341,1342,5,1124,0,
		0,1342,1344,7,10,0,0,1343,1340,1,0,0,0,1343,1344,1,0,0,0,1344,1346,1,0,
		0,0,1345,1347,3,64,32,0,1346,1345,1,0,0,0,1346,1347,1,0,0,0,1347,1351,
		1,0,0,0,1348,1349,5,160,0,0,1349,1350,5,606,0,0,1350,1352,7,11,0,0,1351,
		1348,1,0,0,0,1351,1352,1,0,0,0,1352,1353,1,0,0,0,1353,1354,5,671,0,0,1354,
		1359,3,550,275,0,1355,1356,5,1133,0,0,1356,1357,3,616,308,0,1357,1358,
		5,1134,0,0,1358,1360,1,0,0,0,1359,1355,1,0,0,0,1359,1360,1,0,0,0,1360,
		1361,1,0,0,0,1361,1381,5,12,0,0,1362,1364,5,1133,0,0,1363,1365,3,48,24,
		0,1364,1363,1,0,0,0,1364,1365,1,0,0,0,1365,1366,1,0,0,0,1366,1367,3,200,
		100,0,1367,1368,5,1134,0,0,1368,1382,1,0,0,0,1369,1371,3,48,24,0,1370,
		1369,1,0,0,0,1370,1371,1,0,0,0,1371,1372,1,0,0,0,1372,1379,3,200,100,0,
		1373,1375,5,192,0,0,1374,1376,7,12,0,0,1375,1374,1,0,0,0,1375,1376,1,0,
		0,0,1376,1377,1,0,0,0,1377,1378,5,26,0,0,1378,1380,5,120,0,0,1379,1373,
		1,0,0,0,1379,1380,1,0,0,0,1380,1382,1,0,0,0,1381,1362,1,0,0,0,1381,1370,
		1,0,0,0,1382,57,1,0,0,0,1383,1385,5,42,0,0,1384,1383,1,0,0,0,1384,1385,
		1,0,0,0,1385,1386,1,0,0,0,1386,1388,3,60,30,0,1387,1389,5,1124,0,0,1388,
		1387,1,0,0,0,1388,1389,1,0,0,0,1389,1392,1,0,0,0,1390,1393,3,568,284,0,
		1391,1393,5,42,0,0,1392,1390,1,0,0,0,1392,1391,1,0,0,0,1393,1417,1,0,0,
		0,1394,1396,5,42,0,0,1395,1394,1,0,0,0,1395,1396,1,0,0,0,1396,1397,1,0,
		0,0,1397,1399,5,27,0,0,1398,1400,5,1124,0,0,1399,1398,1,0,0,0,1399,1400,
		1,0,0,0,1400,1401,1,0,0,0,1401,1417,3,570,285,0,1402,1404,5,42,0,0,1403,
		1402,1,0,0,0,1403,1404,1,0,0,0,1404,1405,1,0,0,0,1405,1407,5,405,0,0,1406,
		1408,5,1124,0,0,1407,1406,1,0,0,0,1407,1408,1,0,0,0,1408,1409,1,0,0,0,
		1409,1417,5,1148,0,0,1410,1411,5,134,0,0,1411,1413,5,538,0,0,1412,1414,
		5,1124,0,0,1413,1412,1,0,0,0,1413,1414,1,0,0,0,1414,1415,1,0,0,0,1415,
		1417,7,13,0,0,1416,1384,1,0,0,0,1416,1395,1,0,0,0,1416,1403,1,0,0,0,1416,
		1410,1,0,0,0,1417,59,1,0,0,0,1418,1419,5,25,0,0,1419,1424,5,153,0,0,1420,
		1424,5,841,0,0,1421,1422,5,222,0,0,1422,1424,5,153,0,0,1423,1418,1,0,0,
		0,1423,1420,1,0,0,0,1423,1421,1,0,0,0,1424,61,1,0,0,0,1425,1428,5,37,0,
		0,1426,1427,5,1133,0,0,1427,1429,5,1134,0,0,1428,1426,1,0,0,0,1428,1429,
		1,0,0,0,1429,63,1,0,0,0,1430,1431,5,392,0,0,1431,1434,5,1124,0,0,1432,
		1435,3,564,282,0,1433,1435,3,62,31,0,1434,1432,1,0,0,0,1434,1433,1,0,0,
		0,1435,65,1,0,0,0,1436,1437,5,338,0,0,1437,1441,3,68,34,0,1438,1440,3,
		70,35,0,1439,1438,1,0,0,0,1440,1443,1,0,0,0,1441,1439,1,0,0,0,1441,1442,
		1,0,0,0,1442,1471,1,0,0,0,1443,1441,1,0,0,0,1444,1447,5,417,0,0,1445,1448,
		3,590,295,0,1446,1448,3,688,344,0,1447,1445,1,0,0,0,1447,1446,1,0,0,0,
		1448,1449,1,0,0,0,1449,1458,3,72,36,0,1450,1451,5,630,0,0,1451,1455,3,
		68,34,0,1452,1454,3,70,35,0,1453,1452,1,0,0,0,1454,1457,1,0,0,0,1455,1453,
		1,0,0,0,1455,1456,1,0,0,0,1456,1459,1,0,0,0,1457,1455,1,0,0,0,1458,1450,
		1,0,0,0,1458,1459,1,0,0,0,1459,1468,1,0,0,0,1460,1461,5,408,0,0,1461,1465,
		3,68,34,0,1462,1464,3,70,35,0,1463,1462,1,0,0,0,1464,1467,1,0,0,0,1465,
		1463,1,0,0,0,1465,1466,1,0,0,0,1466,1469,1,0,0,0,1467,1465,1,0,0,0,1468,
		1460,1,0,0,0,1468,1469,1,0,0,0,1469,1471,1,0,0,0,1470,1436,1,0,0,0,1470,
		1444,1,0,0,0,1471,67,1,0,0,0,1472,1477,5,315,0,0,1473,1477,3,594,297,0,
		1474,1477,3,590,295,0,1475,1477,3,688,344,0,1476,1472,1,0,0,0,1476,1473,
		1,0,0,0,1476,1474,1,0,0,0,1476,1475,1,0,0,0,1477,69,1,0,0,0,1478,1479,
		5,1120,0,0,1479,1482,5,86,0,0,1480,1483,3,590,295,0,1481,1483,3,688,344,
		0,1482,1480,1,0,0,0,1482,1481,1,0,0,0,1483,1484,1,0,0,0,1484,1485,3,72,
		36,0,1485,71,1,0,0,0,1486,1500,3,714,357,0,1487,1500,5,221,0,0,1488,1500,
		5,240,0,0,1489,1500,5,241,0,0,1490,1500,5,242,0,0,1491,1500,5,243,0,0,
		1492,1500,5,244,0,0,1493,1500,5,245,0,0,1494,1500,5,246,0,0,1495,1500,
		5,247,0,0,1496,1500,5,248,0,0,1497,1500,5,249,0,0,1498,1500,5,250,0,0,
		1499,1486,1,0,0,0,1499,1487,1,0,0,0,1499,1488,1,0,0,0,1499,1489,1,0,0,
		0,1499,1490,1,0,0,0,1499,1491,1,0,0,0,1499,1492,1,0,0,0,1499,1493,1,0,
		0,0,1499,1494,1,0,0,0,1499,1495,1,0,0,0,1499,1496,1,0,0,0,1499,1497,1,
		0,0,0,1499,1498,1,0,0,0,1500,73,1,0,0,0,1501,1507,5,403,0,0,1502,1507,
		5,396,0,0,1503,1504,5,396,0,0,1504,1505,5,118,0,0,1505,1507,5,614,0,0,
		1506,1501,1,0,0,0,1506,1502,1,0,0,0,1506,1503,1,0,0,0,1507,75,1,0,0,0,
		1508,1509,5,187,0,0,1509,1510,7,14,0,0,1510,77,1,0,0,0,1511,1513,5,467,
		0,0,1512,1514,5,1124,0,0,1513,1512,1,0,0,0,1513,1514,1,0,0,0,1514,1515,
		1,0,0,0,1515,1534,3,592,296,0,1516,1534,3,76,38,0,1517,1518,5,192,0,0,
		1518,1519,5,547,0,0,1519,1534,3,584,292,0,1520,1521,5,368,0,0,1521,1534,
		5,1148,0,0,1522,1534,7,15,0,0,1523,1525,5,875,0,0,1524,1526,5,1124,0,0,
		1525,1524,1,0,0,0,1525,1526,1,0,0,0,1526,1527,1,0,0,0,1527,1534,5,1148,
		0,0,1528,1530,5,1000,0,0,1529,1531,5,1124,0,0,1530,1529,1,0,0,0,1530,1531,
		1,0,0,0,1531,1532,1,0,0,0,1532,1534,5,1148,0,0,1533,1511,1,0,0,0,1533,
		1516,1,0,0,0,1533,1517,1,0,0,0,1533,1520,1,0,0,0,1533,1522,1,0,0,0,1533,
		1523,1,0,0,0,1533,1528,1,0,0,0,1534,79,1,0,0,0,1535,1537,7,16,0,0,1536,
		1535,1,0,0,0,1536,1537,1,0,0,0,1537,1538,1,0,0,0,1538,1539,3,584,292,0,
		1539,1540,3,604,302,0,1540,81,1,0,0,0,1541,1542,3,584,292,0,1542,1543,
		3,604,302,0,1543,83,1,0,0,0,1544,1545,5,368,0,0,1545,1568,5,1148,0,0,1546,
		1547,5,468,0,0,1547,1568,5,160,0,0,1548,1550,5,114,0,0,1549,1548,1,0,0,
		0,1549,1550,1,0,0,0,1550,1551,1,0,0,0,1551,1568,5,47,0,0,1552,1553,5,381,
		0,0,1553,1563,5,160,0,0,1554,1555,5,521,0,0,1555,1563,5,160,0,0,1556,1557,
		5,135,0,0,1557,1558,5,160,0,0,1558,1563,5,388,0,0,1559,1560,5,112,0,0,
		1560,1561,5,160,0,0,1561,1563,5,388,0,0,1562,1552,1,0,0,0,1562,1554,1,
		0,0,0,1562,1556,1,0,0,0,1562,1559,1,0,0,0,1563,1568,1,0,0,0,1564,1565,
		5,160,0,0,1565,1566,5,606,0,0,1566,1568,7,11,0,0,1567,1544,1,0,0,0,1567,
		1546,1,0,0,0,1567,1549,1,0,0,0,1567,1562,1,0,0,0,1567,1564,1,0,0,0,1568,
		85,1,0,0,0,1569,1570,5,446,0,0,1570,1584,5,1148,0,0,1571,1572,5,39,0,0,
		1572,1584,5,1148,0,0,1573,1574,5,665,0,0,1574,1584,5,1148,0,0,1575,1576,
		5,551,0,0,1576,1584,5,1148,0,0,1577,1578,5,617,0,0,1578,1584,5,1148,0,
		0,1579,1580,5,542,0,0,1580,1584,5,1148,0,0,1581,1582,5,557,0,0,1582,1584,
		3,590,295,0,1583,1569,1,0,0,0,1583,1571,1,0,0,0,1583,1573,1,0,0,0,1583,
		1575,1,0,0,0,1583,1577,1,0,0,0,1583,1579,1,0,0,0,1583,1581,1,0,0,0,1584,
		87,1,0,0,0,1585,1586,5,1133,0,0,1586,1591,3,90,45,0,1587,1588,5,1135,0,
		0,1588,1590,3,90,45,0,1589,1587,1,0,0,0,1590,1593,1,0,0,0,1591,1589,1,
		0,0,0,1591,1592,1,0,0,0,1592,1594,1,0,0,0,1593,1591,1,0,0,0,1594,1595,
		5,1134,0,0,1595,89,1,0,0,0,1596,1597,3,556,278,0,1597,1598,3,92,46,0,1598,
		1608,1,0,0,0,1599,1601,3,96,48,0,1600,1602,5,114,0,0,1601,1600,1,0,0,0,
		1601,1602,1,0,0,0,1602,1604,1,0,0,0,1603,1605,5,57,0,0,1604,1603,1,0,0,
		0,1604,1605,1,0,0,0,1605,1608,1,0,0,0,1606,1608,3,104,52,0,1607,1596,1,
		0,0,0,1607,1599,1,0,0,0,1607,1606,1,0,0,0,1608,91,1,0,0,0,1609,1613,3,
		604,302,0,1610,1612,3,94,47,0,1611,1610,1,0,0,0,1612,1615,1,0,0,0,1613,
		1611,1,0,0,0,1613,1614,1,0,0,0,1614,1617,1,0,0,0,1615,1613,1,0,0,0,1616,
		1618,5,114,0,0,1617,1616,1,0,0,0,1617,1618,1,0,0,0,1618,1620,1,0,0,0,1619,
		1621,5,57,0,0,1620,1619,1,0,0,0,1620,1621,1,0,0,0,1621,93,1,0,0,0,1622,
		1676,3,600,300,0,1623,1624,5,42,0,0,1624,1676,3,634,317,0,1625,1676,5,
		673,0,0,1626,1676,5,459,0,0,1627,1632,5,342,0,0,1628,1629,5,118,0,0,1629,
		1630,5,184,0,0,1630,1632,3,636,318,0,1631,1627,1,0,0,0,1631,1628,1,0,0,
		0,1632,1676,1,0,0,0,1633,1635,5,130,0,0,1634,1633,1,0,0,0,1634,1635,1,
		0,0,0,1635,1636,1,0,0,0,1636,1676,5,91,0,0,1637,1639,5,181,0,0,1638,1640,
		5,91,0,0,1639,1638,1,0,0,0,1639,1640,1,0,0,0,1640,1676,1,0,0,0,1641,1642,
		5,368,0,0,1642,1676,5,1148,0,0,1643,1644,5,366,0,0,1644,1676,7,17,0,0,
		1645,1646,5,636,0,0,1646,1676,7,18,0,0,1647,1676,3,98,49,0,1648,1649,5,
		27,0,0,1649,1676,3,570,285,0,1650,1651,5,70,0,0,1651,1653,5,8,0,0,1652,
		1650,1,0,0,0,1652,1653,1,0,0,0,1653,1654,1,0,0,0,1654,1655,5,12,0,0,1655,
		1656,5,1133,0,0,1656,1657,3,688,344,0,1657,1659,5,1134,0,0,1658,1660,7,
		19,0,0,1659,1658,1,0,0,0,1659,1660,1,0,0,0,1660,1676,1,0,0,0,1661,1662,
		5,239,0,0,1662,1663,5,42,0,0,1663,1676,5,669,0,0,1664,1666,5,30,0,0,1665,
		1667,3,584,292,0,1666,1665,1,0,0,0,1666,1667,1,0,0,0,1667,1669,1,0,0,0,
		1668,1664,1,0,0,0,1668,1669,1,0,0,0,1669,1670,1,0,0,0,1670,1671,5,26,0,
		0,1671,1672,5,1133,0,0,1672,1673,3,688,344,0,1673,1674,5,1134,0,0,1674,
		1676,1,0,0,0,1675,1622,1,0,0,0,1675,1623,1,0,0,0,1675,1625,1,0,0,0,1675,
		1626,1,0,0,0,1675,1631,1,0,0,0,1675,1634,1,0,0,0,1675,1637,1,0,0,0,1675,
		1641,1,0,0,0,1675,1643,1,0,0,0,1675,1645,1,0,0,0,1675,1647,1,0,0,0,1675,
		1648,1,0,0,0,1675,1652,1,0,0,0,1675,1661,1,0,0,0,1675,1668,1,0,0,0,1676,
		95,1,0,0,0,1677,1679,5,30,0,0,1678,1680,3,584,292,0,1679,1678,1,0,0,0,
		1679,1680,1,0,0,0,1680,1682,1,0,0,0,1681,1677,1,0,0,0,1681,1682,1,0,0,
		0,1682,1683,1,0,0,0,1683,1684,5,130,0,0,1684,1686,5,91,0,0,1685,1687,3,
		584,292,0,1686,1685,1,0,0,0,1686,1687,1,0,0,0,1687,1689,1,0,0,0,1688,1690,
		3,76,38,0,1689,1688,1,0,0,0,1689,1690,1,0,0,0,1690,1691,1,0,0,0,1691,1695,
		3,622,311,0,1692,1694,3,78,39,0,1693,1692,1,0,0,0,1694,1697,1,0,0,0,1695,
		1693,1,0,0,0,1695,1696,1,0,0,0,1696,1747,1,0,0,0,1697,1695,1,0,0,0,1698,
		1700,5,30,0,0,1699,1701,3,584,292,0,1700,1699,1,0,0,0,1700,1701,1,0,0,
		0,1701,1703,1,0,0,0,1702,1698,1,0,0,0,1702,1703,1,0,0,0,1703,1704,1,0,
		0,0,1704,1706,5,181,0,0,1705,1707,7,20,0,0,1706,1705,1,0,0,0,1706,1707,
		1,0,0,0,1707,1709,1,0,0,0,1708,1710,3,584,292,0,1709,1708,1,0,0,0,1709,
		1710,1,0,0,0,1710,1712,1,0,0,0,1711,1713,3,76,38,0,1712,1711,1,0,0,0,1712,
		1713,1,0,0,0,1713,1714,1,0,0,0,1714,1718,3,622,311,0,1715,1717,3,78,39,
		0,1716,1715,1,0,0,0,1717,1720,1,0,0,0,1718,1716,1,0,0,0,1718,1719,1,0,
		0,0,1719,1747,1,0,0,0,1720,1718,1,0,0,0,1721,1723,5,30,0,0,1722,1724,3,
		584,292,0,1723,1722,1,0,0,0,1723,1724,1,0,0,0,1724,1726,1,0,0,0,1725,1721,
		1,0,0,0,1725,1726,1,0,0,0,1726,1727,1,0,0,0,1727,1728,5,67,0,0,1728,1730,
		5,91,0,0,1729,1731,3,584,292,0,1730,1729,1,0,0,0,1730,1731,1,0,0,0,1731,
		1732,1,0,0,0,1732,1733,3,622,311,0,1733,1734,3,98,49,0,1734,1747,1,0,0,
		0,1735,1737,5,30,0,0,1736,1738,3,584,292,0,1737,1736,1,0,0,0,1737,1738,
		1,0,0,0,1738,1740,1,0,0,0,1739,1735,1,0,0,0,1739,1740,1,0,0,0,1740,1741,
		1,0,0,0,1741,1742,5,26,0,0,1742,1743,5,1133,0,0,1743,1744,3,688,344,0,
		1744,1745,5,1134,0,0,1745,1747,1,0,0,0,1746,1681,1,0,0,0,1746,1702,1,0,
		0,0,1746,1725,1,0,0,0,1746,1739,1,0,0,0,1747,97,1,0,0,0,1748,1749,5,136,
		0,0,1749,1751,3,552,276,0,1750,1752,3,622,311,0,1751,1750,1,0,0,0,1751,
		1752,1,0,0,0,1752,1755,1,0,0,0,1753,1754,5,109,0,0,1754,1756,7,21,0,0,
		1755,1753,1,0,0,0,1755,1756,1,0,0,0,1756,1758,1,0,0,0,1757,1759,3,100,
		50,0,1758,1757,1,0,0,0,1758,1759,1,0,0,0,1759,99,1,0,0,0,1760,1761,5,118,
		0,0,1761,1762,5,44,0,0,1762,1766,3,102,51,0,1763,1764,5,118,0,0,1764,1765,
		5,184,0,0,1765,1767,3,102,51,0,1766,1763,1,0,0,0,1766,1767,1,0,0,0,1767,
		1777,1,0,0,0,1768,1769,5,118,0,0,1769,1770,5,184,0,0,1770,1774,3,102,51,
		0,1771,1772,5,118,0,0,1772,1773,5,44,0,0,1773,1775,3,102,51,0,1774,1771,
		1,0,0,0,1774,1775,1,0,0,0,1775,1777,1,0,0,0,1776,1760,1,0,0,0,1776,1768,
		1,0,0,0,1777,101,1,0,0,0,1778,1787,5,144,0,0,1779,1787,5,21,0,0,1780,1781,
		5,153,0,0,1781,1787,5,116,0,0,1782,1783,5,521,0,0,1783,1787,5,333,0,0,
		1784,1785,5,153,0,0,1785,1787,5,42,0,0,1786,1778,1,0,0,0,1786,1779,1,0,
		0,0,1786,1780,1,0,0,0,1786,1782,1,0,0,0,1786,1784,1,0,0,0,1787,103,1,0,
		0,0,1788,1790,7,20,0,0,1789,1791,3,584,292,0,1790,1789,1,0,0,0,1790,1791,
		1,0,0,0,1791,1793,1,0,0,0,1792,1794,3,76,38,0,1793,1792,1,0,0,0,1793,1794,
		1,0,0,0,1794,1795,1,0,0,0,1795,1799,3,622,311,0,1796,1798,3,78,39,0,1797,
		1796,1,0,0,0,1798,1801,1,0,0,0,1799,1797,1,0,0,0,1799,1800,1,0,0,0,1800,
		1817,1,0,0,0,1801,1799,1,0,0,0,1802,1804,7,22,0,0,1803,1805,7,20,0,0,1804,
		1803,1,0,0,0,1804,1805,1,0,0,0,1805,1807,1,0,0,0,1806,1808,3,584,292,0,
		1807,1806,1,0,0,0,1807,1808,1,0,0,0,1808,1809,1,0,0,0,1809,1813,3,622,
		311,0,1810,1812,3,78,39,0,1811,1810,1,0,0,0,1812,1815,1,0,0,0,1813,1811,
		1,0,0,0,1813,1814,1,0,0,0,1814,1817,1,0,0,0,1815,1813,1,0,0,0,1816,1788,
		1,0,0,0,1816,1802,1,0,0,0,1817,105,1,0,0,0,1818,1820,5,409,0,0,1819,1821,
		5,1124,0,0,1820,1819,1,0,0,0,1820,1821,1,0,0,0,1821,1823,1,0,0,0,1822,
		1824,3,572,286,0,1823,1822,1,0,0,0,1823,1824,1,0,0,0,1824,2004,1,0,0,0,
		1825,1827,5,875,0,0,1826,1828,5,1124,0,0,1827,1826,1,0,0,0,1827,1828,1,
		0,0,0,1828,1829,1,0,0,0,1829,2004,5,1148,0,0,1830,1832,5,341,0,0,1831,
		1833,5,1124,0,0,1832,1831,1,0,0,0,1832,1833,1,0,0,0,1833,1834,1,0,0,0,
		1834,2004,3,590,295,0,1835,1837,5,342,0,0,1836,1838,5,1124,0,0,1837,1836,
		1,0,0,0,1837,1838,1,0,0,0,1838,1839,1,0,0,0,1839,2004,3,590,295,0,1840,
		1842,5,343,0,0,1841,1843,5,1124,0,0,1842,1841,1,0,0,0,1842,1843,1,0,0,
		0,1843,1844,1,0,0,0,1844,2004,3,590,295,0,1845,1847,5,42,0,0,1846,1845,
		1,0,0,0,1846,1847,1,0,0,0,1847,1848,1,0,0,0,1848,1850,3,60,30,0,1849,1851,
		5,1124,0,0,1850,1849,1,0,0,0,1850,1851,1,0,0,0,1851,1854,1,0,0,0,1852,
		1855,3,568,284,0,1853,1855,5,42,0,0,1854,1852,1,0,0,0,1854,1853,1,0,0,
		0,1855,2004,1,0,0,0,1856,1858,7,23,0,0,1857,1859,5,1124,0,0,1858,1857,
		1,0,0,0,1858,1859,1,0,0,0,1859,1860,1,0,0,0,1860,2004,7,24,0,0,1861,1863,
		5,42,0,0,1862,1861,1,0,0,0,1862,1863,1,0,0,0,1863,1864,1,0,0,0,1864,1866,
		5,27,0,0,1865,1867,5,1124,0,0,1866,1865,1,0,0,0,1866,1867,1,0,0,0,1867,
		1868,1,0,0,0,1868,2004,3,570,285,0,1869,1871,5,368,0,0,1870,1872,5,1124,
		0,0,1871,1870,1,0,0,0,1871,1872,1,0,0,0,1872,1873,1,0,0,0,1873,2004,5,
		1148,0,0,1874,1876,5,373,0,0,1875,1877,5,1124,0,0,1876,1875,1,0,0,0,1876,
		1877,1,0,0,0,1877,1878,1,0,0,0,1878,2004,7,25,0,0,1879,1881,5,376,0,0,
		1880,1882,5,1124,0,0,1881,1880,1,0,0,0,1881,1882,1,0,0,0,1882,1883,1,0,
		0,0,1883,2004,5,1148,0,0,1884,1885,7,26,0,0,1885,1887,5,395,0,0,1886,1888,
		5,1124,0,0,1887,1886,1,0,0,0,1887,1888,1,0,0,0,1888,1889,1,0,0,0,1889,
		2004,5,1148,0,0,1890,1892,5,393,0,0,1891,1893,5,1124,0,0,1892,1891,1,0,
		0,0,1892,1893,1,0,0,0,1893,1894,1,0,0,0,1894,2004,7,24,0,0,1895,1897,5,
		405,0,0,1896,1898,5,1124,0,0,1897,1896,1,0,0,0,1897,1898,1,0,0,0,1898,
		1899,1,0,0,0,1899,2004,5,1148,0,0,1900,1902,7,27,0,0,1901,1903,5,1124,
		0,0,1902,1901,1,0,0,0,1902,1903,1,0,0,0,1903,1904,1,0,0,0,1904,2004,7,
		24,0,0,1905,1907,7,28,0,0,1906,1908,5,1124,0,0,1907,1906,1,0,0,0,1907,
		1908,1,0,0,0,1908,1909,1,0,0,0,1909,2004,3,590,295,0,1910,1912,5,406,0,
		0,1911,1913,5,1124,0,0,1912,1911,1,0,0,0,1912,1913,1,0,0,0,1913,1914,1,
		0,0,0,1914,2004,3,590,295,0,1915,1916,5,81,0,0,1916,1918,5,395,0,0,1917,
		1919,5,1124,0,0,1918,1917,1,0,0,0,1918,1919,1,0,0,0,1919,1920,1,0,0,0,
		1920,2004,5,1148,0,0,1921,1923,5,455,0,0,1922,1924,5,1124,0,0,1923,1922,
		1,0,0,0,1923,1924,1,0,0,0,1924,1925,1,0,0,0,1925,2004,7,29,0,0,1926,1928,
		5,467,0,0,1927,1929,5,1124,0,0,1928,1927,1,0,0,0,1928,1929,1,0,0,0,1929,
		1930,1,0,0,0,1930,2004,3,592,296,0,1931,1933,5,500,0,0,1932,1934,5,1124,
		0,0,1933,1932,1,0,0,0,1933,1934,1,0,0,0,1934,1935,1,0,0,0,1935,2004,3,
		590,295,0,1936,1938,5,510,0,0,1937,1939,5,1124,0,0,1938,1937,1,0,0,0,1938,
		1939,1,0,0,0,1939,1940,1,0,0,0,1940,2004,3,590,295,0,1941,1943,5,543,0,
		0,1942,1944,5,1124,0,0,1943,1942,1,0,0,0,1943,1944,1,0,0,0,1944,1945,1,
		0,0,0,1945,2004,7,13,0,0,1946,1948,5,551,0,0,1947,1949,5,1124,0,0,1948,
		1947,1,0,0,0,1948,1949,1,0,0,0,1949,1950,1,0,0,0,1950,2004,5,1148,0,0,
		1951,1953,5,602,0,0,1952,1954,5,1124,0,0,1953,1952,1,0,0,0,1953,1954,1,
		0,0,0,1954,1955,1,0,0,0,1955,2004,7,30,0,0,1956,1957,5,629,0,0,1957,2004,
		5,653,0,0,1958,1960,5,1000,0,0,1959,1961,5,1124,0,0,1960,1959,1,0,0,0,
		1960,1961,1,0,0,0,1961,1962,1,0,0,0,1962,2004,5,1148,0,0,1963,1965,5,631,
		0,0,1964,1966,5,1124,0,0,1965,1964,1,0,0,0,1965,1966,1,0,0,0,1966,1967,
		1,0,0,0,1967,2004,7,13,0,0,1968,1970,5,632,0,0,1969,1971,5,1124,0,0,1970,
		1969,1,0,0,0,1970,1971,1,0,0,0,1971,1972,1,0,0,0,1972,2004,7,13,0,0,1973,
		1975,5,633,0,0,1974,1976,5,1124,0,0,1975,1974,1,0,0,0,1975,1976,1,0,0,
		0,1976,1979,1,0,0,0,1977,1980,5,42,0,0,1978,1980,3,590,295,0,1979,1977,
		1,0,0,0,1979,1978,1,0,0,0,1980,2004,1,0,0,0,1981,1982,5,647,0,0,1982,1984,
		3,584,292,0,1983,1985,3,110,55,0,1984,1983,1,0,0,0,1984,1985,1,0,0,0,1985,
		2004,1,0,0,0,1986,1987,5,648,0,0,1987,1988,5,1124,0,0,1988,2004,3,108,
		54,0,1989,2004,3,110,55,0,1990,1992,5,654,0,0,1991,1993,5,1124,0,0,1992,
		1991,1,0,0,0,1992,1993,1,0,0,0,1993,1994,1,0,0,0,1994,2004,7,24,0,0,1995,
		1997,5,180,0,0,1996,1998,5,1124,0,0,1997,1996,1,0,0,0,1997,1998,1,0,0,
		0,1998,1999,1,0,0,0,1999,2000,5,1133,0,0,2000,2001,3,620,310,0,2001,2002,
		5,1134,0,0,2002,2004,1,0,0,0,2003,1818,1,0,0,0,2003,1825,1,0,0,0,2003,
		1830,1,0,0,0,2003,1835,1,0,0,0,2003,1840,1,0,0,0,2003,1846,1,0,0,0,2003,
		1856,1,0,0,0,2003,1862,1,0,0,0,2003,1869,1,0,0,0,2003,1874,1,0,0,0,2003,
		1879,1,0,0,0,2003,1884,1,0,0,0,2003,1890,1,0,0,0,2003,1895,1,0,0,0,2003,
		1900,1,0,0,0,2003,1905,1,0,0,0,2003,1910,1,0,0,0,2003,1915,1,0,0,0,2003,
		1921,1,0,0,0,2003,1926,1,0,0,0,2003,1931,1,0,0,0,2003,1936,1,0,0,0,2003,
		1941,1,0,0,0,2003,1946,1,0,0,0,2003,1951,1,0,0,0,2003,1956,1,0,0,0,2003,
		1958,1,0,0,0,2003,1963,1,0,0,0,2003,1968,1,0,0,0,2003,1973,1,0,0,0,2003,
		1981,1,0,0,0,2003,1986,1,0,0,0,2003,1989,1,0,0,0,2003,1990,1,0,0,0,2003,
		1995,1,0,0,0,2004,107,1,0,0,0,2005,2006,7,31,0,0,2006,109,1,0,0,0,2007,
		2008,5,636,0,0,2008,2009,7,18,0,0,2009,111,1,0,0,0,2010,2011,5,129,0,0,
		2011,2012,5,19,0,0,2012,2015,3,114,57,0,2013,2014,5,550,0,0,2014,2016,
		3,590,295,0,2015,2013,1,0,0,0,2015,2016,1,0,0,0,2016,2024,1,0,0,0,2017,
		2018,5,641,0,0,2018,2019,5,19,0,0,2019,2022,3,116,58,0,2020,2021,5,642,
		0,0,2021,2023,3,590,295,0,2022,2020,1,0,0,0,2022,2023,1,0,0,0,2023,2025,
		1,0,0,0,2024,2017,1,0,0,0,2024,2025,1,0,0,0,2025,2037,1,0,0,0,2026,2027,
		5,1133,0,0,2027,2032,3,118,59,0,2028,2029,5,1135,0,0,2029,2031,3,118,59,
		0,2030,2028,1,0,0,0,2031,2034,1,0,0,0,2032,2030,1,0,0,0,2032,2033,1,0,
		0,0,2033,2035,1,0,0,0,2034,2032,1,0,0,0,2035,2036,5,1134,0,0,2036,2038,
		1,0,0,0,2037,2026,1,0,0,0,2037,2038,1,0,0,0,2038,113,1,0,0,0,2039,2041,
		5,100,0,0,2040,2039,1,0,0,0,2040,2041,1,0,0,0,2041,2042,1,0,0,0,2042,2043,
		5,443,0,0,2043,2044,5,1133,0,0,2044,2045,3,688,344,0,2045,2046,5,1134,
		0,0,2046,2086,1,0,0,0,2047,2049,5,100,0,0,2048,2047,1,0,0,0,2048,2049,
		1,0,0,0,2049,2050,1,0,0,0,2050,2054,5,91,0,0,2051,2052,5,336,0,0,2052,
		2053,5,1124,0,0,2053,2055,7,32,0,0,2054,2051,1,0,0,0,2054,2055,1,0,0,0,
		2055,2056,1,0,0,0,2056,2058,5,1133,0,0,2057,2059,3,616,308,0,2058,2057,
		1,0,0,0,2058,2059,1,0,0,0,2059,2060,1,0,0,0,2060,2086,5,1134,0,0,2061,
		2071,5,133,0,0,2062,2063,5,1133,0,0,2063,2064,3,688,344,0,2064,2065,5,
		1134,0,0,2065,2072,1,0,0,0,2066,2067,5,365,0,0,2067,2068,5,1133,0,0,2068,
		2069,3,616,308,0,2069,2070,5,1134,0,0,2070,2072,1,0,0,0,2071,2062,1,0,
		0,0,2071,2066,1,0,0,0,2072,2086,1,0,0,0,2073,2083,5,473,0,0,2074,2075,
		5,1133,0,0,2075,2076,3,688,344,0,2076,2077,5,1134,0,0,2077,2084,1,0,0,
		0,2078,2079,5,365,0,0,2079,2080,5,1133,0,0,2080,2081,3,616,308,0,2081,
		2082,5,1134,0,0,2082,2084,1,0,0,0,2083,2074,1,0,0,0,2083,2078,1,0,0,0,
		2084,2086,1,0,0,0,2085,2040,1,0,0,0,2085,2048,1,0,0,0,2085,2061,1,0,0,
		0,2085,2073,1,0,0,0,2086,115,1,0,0,0,2087,2089,5,100,0,0,2088,2087,1,0,
		0,0,2088,2089,1,0,0,0,2089,2090,1,0,0,0,2090,2091,5,443,0,0,2091,2092,
		5,1133,0,0,2092,2093,3,688,344,0,2093,2094,5,1134,0,0,2094,2109,1,0,0,
		0,2095,2097,5,100,0,0,2096,2095,1,0,0,0,2096,2097,1,0,0,0,2097,2098,1,
		0,0,0,2098,2102,5,91,0,0,2099,2100,5,336,0,0,2100,2101,5,1124,0,0,2101,
		2103,7,32,0,0,2102,2099,1,0,0,0,2102,2103,1,0,0,0,2103,2104,1,0,0,0,2104,
		2105,5,1133,0,0,2105,2106,3,616,308,0,2106,2107,5,1134,0,0,2107,2109,1,
		0,0,0,2108,2088,1,0,0,0,2108,2096,1,0,0,0,2109,117,1,0,0,0,2110,2111,5,
		129,0,0,2111,2112,3,584,292,0,2112,2113,5,188,0,0,2113,2114,5,471,0,0,
		2114,2115,5,651,0,0,2115,2116,5,1133,0,0,2116,2121,3,120,60,0,2117,2118,
		5,1135,0,0,2118,2120,3,120,60,0,2119,2117,1,0,0,0,2120,2123,1,0,0,0,2121,
		2119,1,0,0,0,2121,2122,1,0,0,0,2122,2124,1,0,0,0,2123,2121,1,0,0,0,2124,
		2128,5,1134,0,0,2125,2127,3,126,63,0,2126,2125,1,0,0,0,2127,2130,1,0,0,
		0,2128,2126,1,0,0,0,2128,2129,1,0,0,0,2129,2142,1,0,0,0,2130,2128,1,0,
		0,0,2131,2132,5,1133,0,0,2132,2137,3,124,62,0,2133,2134,5,1135,0,0,2134,
		2136,3,124,62,0,2135,2133,1,0,0,0,2136,2139,1,0,0,0,2137,2135,1,0,0,0,
		2137,2138,1,0,0,0,2138,2140,1,0,0,0,2139,2137,1,0,0,0,2140,2141,5,1134,
		0,0,2141,2143,1,0,0,0,2142,2131,1,0,0,0,2142,2143,1,0,0,0,2143,2257,1,
		0,0,0,2144,2145,5,129,0,0,2145,2146,3,584,292,0,2146,2147,5,188,0,0,2147,
		2148,5,471,0,0,2148,2149,5,651,0,0,2149,2153,3,120,60,0,2150,2152,3,126,
		63,0,2151,2150,1,0,0,0,2152,2155,1,0,0,0,2153,2151,1,0,0,0,2153,2154,1,
		0,0,0,2154,2167,1,0,0,0,2155,2153,1,0,0,0,2156,2157,5,1133,0,0,2157,2162,
		3,124,62,0,2158,2159,5,1135,0,0,2159,2161,3,124,62,0,2160,2158,1,0,0,0,
		2161,2164,1,0,0,0,2162,2160,1,0,0,0,2162,2163,1,0,0,0,2163,2165,1,0,0,
		0,2164,2162,1,0,0,0,2165,2166,5,1134,0,0,2166,2168,1,0,0,0,2167,2156,1,
		0,0,0,2167,2168,1,0,0,0,2168,2257,1,0,0,0,2169,2170,5,129,0,0,2170,2171,
		3,584,292,0,2171,2172,5,188,0,0,2172,2173,5,80,0,0,2173,2174,5,1133,0,
		0,2174,2179,3,120,60,0,2175,2176,5,1135,0,0,2176,2178,3,120,60,0,2177,
		2175,1,0,0,0,2178,2181,1,0,0,0,2179,2177,1,0,0,0,2179,2180,1,0,0,0,2180,
		2182,1,0,0,0,2181,2179,1,0,0,0,2182,2186,5,1134,0,0,2183,2185,3,126,63,
		0,2184,2183,1,0,0,0,2185,2188,1,0,0,0,2186,2184,1,0,0,0,2186,2187,1,0,
		0,0,2187,2200,1,0,0,0,2188,2186,1,0,0,0,2189,2190,5,1133,0,0,2190,2195,
		3,124,62,0,2191,2192,5,1135,0,0,2192,2194,3,124,62,0,2193,2191,1,0,0,0,
		2194,2197,1,0,0,0,2195,2193,1,0,0,0,2195,2196,1,0,0,0,2196,2198,1,0,0,
		0,2197,2195,1,0,0,0,2198,2199,5,1134,0,0,2199,2201,1,0,0,0,2200,2189,1,
		0,0,0,2200,2201,1,0,0,0,2201,2257,1,0,0,0,2202,2203,5,129,0,0,2203,2204,
		3,584,292,0,2204,2205,5,188,0,0,2205,2206,5,80,0,0,2206,2207,5,1133,0,
		0,2207,2212,3,122,61,0,2208,2209,5,1135,0,0,2209,2211,3,122,61,0,2210,
		2208,1,0,0,0,2211,2214,1,0,0,0,2212,2210,1,0,0,0,2212,2213,1,0,0,0,2213,
		2215,1,0,0,0,2214,2212,1,0,0,0,2215,2219,5,1134,0,0,2216,2218,3,126,63,
		0,2217,2216,1,0,0,0,2218,2221,1,0,0,0,2219,2217,1,0,0,0,2219,2220,1,0,
		0,0,2220,2233,1,0,0,0,2221,2219,1,0,0,0,2222,2223,5,1133,0,0,2223,2228,
		3,124,62,0,2224,2225,5,1135,0,0,2225,2227,3,124,62,0,2226,2224,1,0,0,0,
		2227,2230,1,0,0,0,2228,2226,1,0,0,0,2228,2229,1,0,0,0,2229,2231,1,0,0,
		0,2230,2228,1,0,0,0,2231,2232,5,1134,0,0,2232,2234,1,0,0,0,2233,2222,1,
		0,0,0,2233,2234,1,0,0,0,2234,2257,1,0,0,0,2235,2236,5,129,0,0,2236,2240,
		3,584,292,0,2237,2239,3,126,63,0,2238,2237,1,0,0,0,2239,2242,1,0,0,0,2240,
		2238,1,0,0,0,2240,2241,1,0,0,0,2241,2254,1,0,0,0,2242,2240,1,0,0,0,2243,
		2244,5,1133,0,0,2244,2249,3,124,62,0,2245,2246,5,1135,0,0,2246,2248,3,
		124,62,0,2247,2245,1,0,0,0,2248,2251,1,0,0,0,2249,2247,1,0,0,0,2249,2250,
		1,0,0,0,2250,2252,1,0,0,0,2251,2249,1,0,0,0,2252,2253,5,1134,0,0,2253,
		2255,1,0,0,0,2254,2243,1,0,0,0,2254,2255,1,0,0,0,2255,2257,1,0,0,0,2256,
		2110,1,0,0,0,2256,2144,1,0,0,0,2256,2169,1,0,0,0,2256,2202,1,0,0,0,2256,
		2235,1,0,0,0,2257,119,1,0,0,0,2258,2262,3,602,301,0,2259,2262,3,688,344,
		0,2260,2262,5,110,0,0,2261,2258,1,0,0,0,2261,2259,1,0,0,0,2261,2260,1,
		0,0,0,2262,121,1,0,0,0,2263,2264,5,1133,0,0,2264,2267,3,120,60,0,2265,
		2266,5,1135,0,0,2266,2268,3,120,60,0,2267,2265,1,0,0,0,2268,2269,1,0,0,
		0,2269,2267,1,0,0,0,2269,2270,1,0,0,0,2270,2271,1,0,0,0,2271,2272,5,1134,
		0,0,2272,123,1,0,0,0,2273,2274,5,641,0,0,2274,2278,3,584,292,0,2275,2277,
		3,126,63,0,2276,2275,1,0,0,0,2277,2280,1,0,0,0,2278,2276,1,0,0,0,2278,
		2279,1,0,0,0,2279,125,1,0,0,0,2280,2278,1,0,0,0,2281,2283,5,42,0,0,2282,
		2281,1,0,0,0,2282,2283,1,0,0,0,2283,2285,1,0,0,0,2284,2286,5,636,0,0,2285,
		2284,1,0,0,0,2285,2286,1,0,0,0,2286,2287,1,0,0,0,2287,2289,5,409,0,0,2288,
		2290,5,1124,0,0,2289,2288,1,0,0,0,2289,2290,1,0,0,0,2290,2291,1,0,0,0,
		2291,2330,3,572,286,0,2292,2294,5,368,0,0,2293,2295,5,1124,0,0,2294,2293,
		1,0,0,0,2294,2295,1,0,0,0,2295,2296,1,0,0,0,2296,2330,5,1148,0,0,2297,
		2298,5,388,0,0,2298,2300,5,395,0,0,2299,2301,5,1124,0,0,2300,2299,1,0,
		0,0,2300,2301,1,0,0,0,2301,2302,1,0,0,0,2302,2330,5,1148,0,0,2303,2304,
		5,81,0,0,2304,2306,5,395,0,0,2305,2307,5,1124,0,0,2306,2305,1,0,0,0,2306,
		2307,1,0,0,0,2307,2308,1,0,0,0,2308,2330,5,1148,0,0,2309,2311,5,500,0,
		0,2310,2312,5,1124,0,0,2311,2310,1,0,0,0,2311,2312,1,0,0,0,2312,2313,1,
		0,0,0,2313,2330,3,590,295,0,2314,2316,5,510,0,0,2315,2317,5,1124,0,0,2316,
		2315,1,0,0,0,2316,2317,1,0,0,0,2317,2318,1,0,0,0,2318,2330,3,590,295,0,
		2319,2321,5,647,0,0,2320,2322,5,1124,0,0,2321,2320,1,0,0,0,2321,2322,1,
		0,0,0,2322,2323,1,0,0,0,2323,2330,3,584,292,0,2324,2326,5,528,0,0,2325,
		2327,5,1124,0,0,2326,2325,1,0,0,0,2326,2327,1,0,0,0,2327,2328,1,0,0,0,
		2328,2330,3,584,292,0,2329,2282,1,0,0,0,2329,2292,1,0,0,0,2329,2297,1,
		0,0,0,2329,2303,1,0,0,0,2329,2309,1,0,0,0,2329,2314,1,0,0,0,2329,2319,
		1,0,0,0,2329,2324,1,0,0,0,2330,127,1,0,0,0,2331,2332,5,7,0,0,2332,2334,
		7,0,0,0,2333,2335,3,584,292,0,2334,2333,1,0,0,0,2334,2335,1,0,0,0,2335,
		2337,1,0,0,0,2336,2338,3,58,29,0,2337,2336,1,0,0,0,2338,2339,1,0,0,0,2339,
		2337,1,0,0,0,2339,2340,1,0,0,0,2340,2350,1,0,0,0,2341,2342,5,7,0,0,2342,
		2343,7,0,0,0,2343,2344,3,584,292,0,2344,2345,5,664,0,0,2345,2346,5,388,
		0,0,2346,2347,5,395,0,0,2347,2348,5,516,0,0,2348,2350,1,0,0,0,2349,2331,
		1,0,0,0,2349,2341,1,0,0,0,2350,129,1,0,0,0,2351,2353,5,7,0,0,2352,2354,
		3,64,32,0,2353,2352,1,0,0,0,2353,2354,1,0,0,0,2354,2355,1,0,0,0,2355,2356,
		5,415,0,0,2356,2360,3,550,275,0,2357,2358,5,118,0,0,2358,2359,5,605,0,
		0,2359,2361,3,66,33,0,2360,2357,1,0,0,0,2360,2361,1,0,0,0,2361,2368,1,
		0,0,0,2362,2363,5,118,0,0,2363,2365,5,371,0,0,2364,2366,5,114,0,0,2365,
		2364,1,0,0,0,2365,2366,1,0,0,0,2366,2367,1,0,0,0,2367,2369,5,561,0,0,2368,
		2362,1,0,0,0,2368,2369,1,0,0,0,2369,2373,1,0,0,0,2370,2371,5,139,0,0,2371,
		2372,5,175,0,0,2372,2374,3,550,275,0,2373,2370,1,0,0,0,2373,2374,1,0,0,
		0,2374,2376,1,0,0,0,2375,2377,3,74,37,0,2376,2375,1,0,0,0,2376,2377,1,
		0,0,0,2377,2380,1,0,0,0,2378,2379,5,368,0,0,2379,2381,5,1148,0,0,2380,
		2378,1,0,0,0,2380,2381,1,0,0,0,2381,2384,1,0,0,0,2382,2383,5,399,0,0,2383,
		2385,3,388,194,0,2384,2382,1,0,0,0,2384,2385,1,0,0,0,2385,131,1,0,0,0,
		2386,2387,5,7,0,0,2387,2388,5,437,0,0,2388,2392,3,550,275,0,2389,2391,
		3,84,42,0,2390,2389,1,0,0,0,2391,2394,1,0,0,0,2392,2390,1,0,0,0,2392,2393,
		1,0,0,0,2393,133,1,0,0,0,2394,2392,1,0,0,0,2395,2396,5,7,0,0,2396,2397,
		5,457,0,0,2397,2398,5,599,0,0,2398,2399,5,791,0,0,2399,2400,5,477,0,0,
		2400,2401,5,91,0,0,2401,135,1,0,0,0,2402,2403,5,7,0,0,2403,2404,5,475,
		0,0,2404,2405,5,73,0,0,2405,2406,3,584,292,0,2406,2407,5,5,0,0,2407,2408,
		5,659,0,0,2408,2414,5,1148,0,0,2409,2411,5,453,0,0,2410,2412,5,1124,0,
		0,2411,2410,1,0,0,0,2411,2412,1,0,0,0,2412,2413,1,0,0,0,2413,2415,3,592,
		296,0,2414,2409,1,0,0,0,2414,2415,1,0,0,0,2415,2417,1,0,0,0,2416,2418,
		5,674,0,0,2417,2416,1,0,0,0,2417,2418,1,0,0,0,2418,2419,1,0,0,0,2419,2421,
		5,409,0,0,2420,2422,5,1124,0,0,2421,2420,1,0,0,0,2421,2422,1,0,0,0,2422,
		2423,1,0,0,0,2423,2424,3,572,286,0,2424,137,1,0,0,0,2425,2426,5,7,0,0,
		2426,2427,5,131,0,0,2427,2431,3,550,275,0,2428,2430,3,84,42,0,2429,2428,
		1,0,0,0,2430,2433,1,0,0,0,2431,2429,1,0,0,0,2431,2432,1,0,0,0,2432,139,
		1,0,0,0,2433,2431,1,0,0,0,2434,2435,5,7,0,0,2435,2436,5,608,0,0,2436,2437,
		3,584,292,0,2437,2438,5,541,0,0,2438,2439,5,1133,0,0,2439,2444,3,86,43,
		0,2440,2441,5,1135,0,0,2441,2443,3,86,43,0,2442,2440,1,0,0,0,2443,2446,
		1,0,0,0,2444,2442,1,0,0,0,2444,2445,1,0,0,0,2445,2447,1,0,0,0,2446,2444,
		1,0,0,0,2447,2448,5,1134,0,0,2448,141,1,0,0,0,2449,2451,5,7,0,0,2450,2452,
		7,1,0,0,2451,2450,1,0,0,0,2451,2452,1,0,0,0,2452,2454,1,0,0,0,2453,2455,
		5,78,0,0,2454,2453,1,0,0,0,2454,2455,1,0,0,0,2455,2456,1,0,0,0,2456,2457,
		5,172,0,0,2457,2459,3,552,276,0,2458,2460,3,646,323,0,2459,2458,1,0,0,
		0,2459,2460,1,0,0,0,2460,2469,1,0,0,0,2461,2466,3,148,74,0,2462,2463,5,
		1135,0,0,2463,2465,3,148,74,0,2464,2462,1,0,0,0,2465,2468,1,0,0,0,2466,
		2464,1,0,0,0,2466,2467,1,0,0,0,2467,2470,1,0,0,0,2468,2466,1,0,0,0,2469,
		2461,1,0,0,0,2469,2470,1,0,0,0,2470,2472,1,0,0,0,2471,2473,3,112,56,0,
		2472,2471,1,0,0,0,2472,2473,1,0,0,0,2473,143,1,0,0,0,2474,2475,5,7,0,0,
		2475,2476,5,647,0,0,2476,2477,3,584,292,0,2477,2478,7,33,0,0,2478,2479,
		5,389,0,0,2479,2483,5,1148,0,0,2480,2481,5,453,0,0,2481,2482,5,1124,0,
		0,2482,2484,3,592,296,0,2483,2480,1,0,0,0,2483,2484,1,0,0,0,2484,2486,
		1,0,0,0,2485,2487,5,674,0,0,2486,2485,1,0,0,0,2486,2487,1,0,0,0,2487,2488,
		1,0,0,0,2488,2490,5,409,0,0,2489,2491,5,1124,0,0,2490,2489,1,0,0,0,2490,
		2491,1,0,0,0,2491,2492,1,0,0,0,2492,2493,3,572,286,0,2493,145,1,0,0,0,
		2494,2498,5,7,0,0,2495,2496,5,336,0,0,2496,2497,5,1124,0,0,2497,2499,7,
		10,0,0,2498,2495,1,0,0,0,2498,2499,1,0,0,0,2499,2501,1,0,0,0,2500,2502,
		3,64,32,0,2501,2500,1,0,0,0,2501,2502,1,0,0,0,2502,2506,1,0,0,0,2503,2504,
		5,160,0,0,2504,2505,5,606,0,0,2505,2507,7,11,0,0,2506,2503,1,0,0,0,2506,
		2507,1,0,0,0,2507,2508,1,0,0,0,2508,2509,5,671,0,0,2509,2514,3,550,275,
		0,2510,2511,5,1133,0,0,2511,2512,3,616,308,0,2512,2513,5,1134,0,0,2513,
		2515,1,0,0,0,2514,2510,1,0,0,0,2514,2515,1,0,0,0,2515,2516,1,0,0,0,2516,
		2517,5,12,0,0,2517,2524,3,200,100,0,2518,2520,5,192,0,0,2519,2521,7,12,
		0,0,2520,2519,1,0,0,0,2520,2521,1,0,0,0,2521,2522,1,0,0,0,2522,2523,5,
		26,0,0,2523,2525,5,120,0,0,2524,2518,1,0,0,0,2524,2525,1,0,0,0,2525,147,
		1,0,0,0,2526,2533,3,106,53,0,2527,2529,5,1135,0,0,2528,2527,1,0,0,0,2528,
		2529,1,0,0,0,2529,2530,1,0,0,0,2530,2532,3,106,53,0,2531,2528,1,0,0,0,
		2532,2535,1,0,0,0,2533,2531,1,0,0,0,2533,2534,1,0,0,0,2534,2878,1,0,0,
		0,2535,2533,1,0,0,0,2536,2538,5,5,0,0,2537,2539,5,28,0,0,2538,2537,1,0,
		0,0,2538,2539,1,0,0,0,2539,2540,1,0,0,0,2540,2541,3,584,292,0,2541,2545,
		3,92,46,0,2542,2546,5,430,0,0,2543,2544,5,334,0,0,2544,2546,3,584,292,
		0,2545,2542,1,0,0,0,2545,2543,1,0,0,0,2545,2546,1,0,0,0,2546,2878,1,0,
		0,0,2547,2549,5,5,0,0,2548,2550,5,28,0,0,2549,2548,1,0,0,0,2549,2550,1,
		0,0,0,2550,2551,1,0,0,0,2551,2552,5,1133,0,0,2552,2553,3,584,292,0,2553,
		2560,3,92,46,0,2554,2555,5,1135,0,0,2555,2556,3,584,292,0,2556,2557,3,
		92,46,0,2557,2559,1,0,0,0,2558,2554,1,0,0,0,2559,2562,1,0,0,0,2560,2558,
		1,0,0,0,2560,2561,1,0,0,0,2561,2563,1,0,0,0,2562,2560,1,0,0,0,2563,2564,
		5,1134,0,0,2564,2878,1,0,0,0,2565,2566,5,5,0,0,2566,2568,7,20,0,0,2567,
		2569,3,584,292,0,2568,2567,1,0,0,0,2568,2569,1,0,0,0,2569,2571,1,0,0,0,
		2570,2572,3,76,38,0,2571,2570,1,0,0,0,2571,2572,1,0,0,0,2572,2573,1,0,
		0,0,2573,2577,3,622,311,0,2574,2576,3,78,39,0,2575,2574,1,0,0,0,2576,2579,
		1,0,0,0,2577,2575,1,0,0,0,2577,2578,1,0,0,0,2578,2878,1,0,0,0,2579,2577,
		1,0,0,0,2580,2585,5,5,0,0,2581,2583,5,30,0,0,2582,2584,3,584,292,0,2583,
		2582,1,0,0,0,2583,2584,1,0,0,0,2584,2586,1,0,0,0,2585,2581,1,0,0,0,2585,
		2586,1,0,0,0,2586,2587,1,0,0,0,2587,2588,5,130,0,0,2588,2590,5,91,0,0,
		2589,2591,3,584,292,0,2590,2589,1,0,0,0,2590,2591,1,0,0,0,2591,2593,1,
		0,0,0,2592,2594,3,76,38,0,2593,2592,1,0,0,0,2593,2594,1,0,0,0,2594,2595,
		1,0,0,0,2595,2599,3,622,311,0,2596,2598,3,78,39,0,2597,2596,1,0,0,0,2598,
		2601,1,0,0,0,2599,2597,1,0,0,0,2599,2600,1,0,0,0,2600,2878,1,0,0,0,2601,
		2599,1,0,0,0,2602,2607,5,5,0,0,2603,2605,5,30,0,0,2604,2606,3,584,292,
		0,2605,2604,1,0,0,0,2605,2606,1,0,0,0,2606,2608,1,0,0,0,2607,2603,1,0,
		0,0,2607,2608,1,0,0,0,2608,2609,1,0,0,0,2609,2611,5,181,0,0,2610,2612,
		7,20,0,0,2611,2610,1,0,0,0,2611,2612,1,0,0,0,2612,2614,1,0,0,0,2613,2615,
		3,584,292,0,2614,2613,1,0,0,0,2614,2615,1,0,0,0,2615,2617,1,0,0,0,2616,
		2618,3,76,38,0,2617,2616,1,0,0,0,2617,2618,1,0,0,0,2618,2619,1,0,0,0,2619,
		2623,3,622,311,0,2620,2622,3,78,39,0,2621,2620,1,0,0,0,2622,2625,1,0,0,
		0,2623,2621,1,0,0,0,2623,2624,1,0,0,0,2624,2878,1,0,0,0,2625,2623,1,0,
		0,0,2626,2627,5,5,0,0,2627,2629,7,22,0,0,2628,2630,7,20,0,0,2629,2628,
		1,0,0,0,2629,2630,1,0,0,0,2630,2632,1,0,0,0,2631,2633,3,584,292,0,2632,
		2631,1,0,0,0,2632,2633,1,0,0,0,2633,2634,1,0,0,0,2634,2638,3,622,311,0,
		2635,2637,3,78,39,0,2636,2635,1,0,0,0,2637,2640,1,0,0,0,2638,2636,1,0,
		0,0,2638,2639,1,0,0,0,2639,2878,1,0,0,0,2640,2638,1,0,0,0,2641,2646,5,
		5,0,0,2642,2644,5,30,0,0,2643,2645,3,584,292,0,2644,2643,1,0,0,0,2644,
		2645,1,0,0,0,2645,2647,1,0,0,0,2646,2642,1,0,0,0,2646,2647,1,0,0,0,2647,
		2648,1,0,0,0,2648,2649,5,67,0,0,2649,2651,5,91,0,0,2650,2652,3,584,292,
		0,2651,2650,1,0,0,0,2651,2652,1,0,0,0,2652,2653,1,0,0,0,2653,2654,3,622,
		311,0,2654,2655,3,98,49,0,2655,2878,1,0,0,0,2656,2661,5,5,0,0,2657,2659,
		5,30,0,0,2658,2660,3,584,292,0,2659,2658,1,0,0,0,2659,2660,1,0,0,0,2660,
		2662,1,0,0,0,2661,2657,1,0,0,0,2661,2662,1,0,0,0,2662,2663,1,0,0,0,2663,
		2670,5,26,0,0,2664,2671,3,584,292,0,2665,2671,3,594,297,0,2666,2667,5,
		1133,0,0,2667,2668,3,688,344,0,2668,2669,5,1134,0,0,2669,2671,1,0,0,0,
		2670,2664,1,0,0,0,2670,2665,1,0,0,0,2670,2666,1,0,0,0,2671,2673,1,0,0,
		0,2672,2674,5,114,0,0,2673,2672,1,0,0,0,2673,2674,1,0,0,0,2674,2676,1,
		0,0,0,2675,2677,5,57,0,0,2676,2675,1,0,0,0,2676,2677,1,0,0,0,2677,2878,
		1,0,0,0,2678,2683,5,7,0,0,2679,2681,5,30,0,0,2680,2682,3,584,292,0,2681,
		2680,1,0,0,0,2681,2682,1,0,0,0,2682,2684,1,0,0,0,2683,2679,1,0,0,0,2683,
		2684,1,0,0,0,2684,2685,1,0,0,0,2685,2692,5,26,0,0,2686,2693,3,584,292,
		0,2687,2693,3,594,297,0,2688,2689,5,1133,0,0,2689,2690,3,688,344,0,2690,
		2691,5,1134,0,0,2691,2693,1,0,0,0,2692,2686,1,0,0,0,2692,2687,1,0,0,0,
		2692,2688,1,0,0,0,2693,2695,1,0,0,0,2694,2696,5,114,0,0,2695,2694,1,0,
		0,0,2695,2696,1,0,0,0,2696,2698,1,0,0,0,2697,2699,5,57,0,0,2698,2697,1,
		0,0,0,2698,2699,1,0,0,0,2699,2878,1,0,0,0,2700,2705,5,5,0,0,2701,2703,
		5,30,0,0,2702,2704,3,584,292,0,2703,2702,1,0,0,0,2703,2704,1,0,0,0,2704,
		2706,1,0,0,0,2705,2701,1,0,0,0,2705,2706,1,0,0,0,2706,2707,1,0,0,0,2707,
		2708,5,26,0,0,2708,2709,5,1133,0,0,2709,2710,3,688,344,0,2710,2711,5,1134,
		0,0,2711,2878,1,0,0,0,2712,2714,5,336,0,0,2713,2715,5,1124,0,0,2714,2713,
		1,0,0,0,2714,2715,1,0,0,0,2715,2716,1,0,0,0,2716,2878,7,34,0,0,2717,2719,
		5,7,0,0,2718,2720,5,28,0,0,2719,2718,1,0,0,0,2719,2720,1,0,0,0,2720,2721,
		1,0,0,0,2721,2727,3,584,292,0,2722,2723,5,153,0,0,2723,2724,5,42,0,0,2724,
		2728,3,634,317,0,2725,2726,5,51,0,0,2726,2728,5,42,0,0,2727,2722,1,0,0,
		0,2727,2725,1,0,0,0,2728,2878,1,0,0,0,2729,2731,5,24,0,0,2730,2732,5,28,
		0,0,2731,2730,1,0,0,0,2731,2732,1,0,0,0,2732,2733,1,0,0,0,2733,2734,3,
		584,292,0,2734,2735,3,584,292,0,2735,2739,3,92,46,0,2736,2740,5,430,0,
		0,2737,2738,5,334,0,0,2738,2740,3,584,292,0,2739,2736,1,0,0,0,2739,2737,
		1,0,0,0,2739,2740,1,0,0,0,2740,2878,1,0,0,0,2741,2742,5,139,0,0,2742,2743,
		5,28,0,0,2743,2744,3,584,292,0,2744,2745,5,175,0,0,2745,2746,3,584,292,
		0,2746,2878,1,0,0,0,2747,2749,5,103,0,0,2748,2750,5,1124,0,0,2749,2748,
		1,0,0,0,2749,2750,1,0,0,0,2750,2751,1,0,0,0,2751,2878,7,4,0,0,2752,2754,
		5,512,0,0,2753,2755,5,28,0,0,2754,2753,1,0,0,0,2754,2755,1,0,0,0,2755,
		2756,1,0,0,0,2756,2757,3,584,292,0,2757,2761,3,92,46,0,2758,2762,5,430,
		0,0,2759,2760,5,334,0,0,2760,2762,3,584,292,0,2761,2758,1,0,0,0,2761,2759,
		1,0,0,0,2761,2762,1,0,0,0,2762,2878,1,0,0,0,2763,2765,5,51,0,0,2764,2766,
		5,28,0,0,2765,2764,1,0,0,0,2765,2766,1,0,0,0,2766,2767,1,0,0,0,2767,2769,
		3,584,292,0,2768,2770,5,144,0,0,2769,2768,1,0,0,0,2769,2770,1,0,0,0,2770,
		2878,1,0,0,0,2771,2772,5,51,0,0,2772,2773,7,35,0,0,2773,2878,3,584,292,
		0,2774,2775,5,51,0,0,2775,2776,5,130,0,0,2776,2878,5,91,0,0,2777,2778,
		5,51,0,0,2778,2779,7,20,0,0,2779,2878,3,584,292,0,2780,2781,5,139,0,0,
		2781,2782,7,20,0,0,2782,2783,3,584,292,0,2783,2784,5,175,0,0,2784,2785,
		3,584,292,0,2785,2878,1,0,0,0,2786,2788,5,7,0,0,2787,2789,5,28,0,0,2788,
		2787,1,0,0,0,2788,2789,1,0,0,0,2789,2790,1,0,0,0,2790,2804,3,584,292,0,
		2791,2792,5,153,0,0,2792,2798,5,42,0,0,2793,2799,3,594,297,0,2794,2795,
		5,1133,0,0,2795,2796,3,688,344,0,2796,2797,5,1134,0,0,2797,2799,1,0,0,
		0,2798,2793,1,0,0,0,2798,2794,1,0,0,0,2799,2805,1,0,0,0,2800,2801,5,153,
		0,0,2801,2805,7,15,0,0,2802,2803,5,51,0,0,2803,2805,5,42,0,0,2804,2791,
		1,0,0,0,2804,2800,1,0,0,0,2804,2802,1,0,0,0,2805,2878,1,0,0,0,2806,2807,
		5,7,0,0,2807,2808,5,81,0,0,2808,2809,3,584,292,0,2809,2810,7,15,0,0,2810,
		2878,1,0,0,0,2811,2812,5,51,0,0,2812,2813,5,67,0,0,2813,2814,5,91,0,0,
		2814,2878,3,584,292,0,2815,2816,5,396,0,0,2816,2878,5,92,0,0,2817,2818,
		5,403,0,0,2818,2878,5,92,0,0,2819,2821,5,139,0,0,2820,2822,7,36,0,0,2821,
		2820,1,0,0,0,2821,2822,1,0,0,0,2822,2825,1,0,0,0,2823,2826,3,584,292,0,
		2824,2826,3,550,275,0,2825,2823,1,0,0,0,2825,2824,1,0,0,0,2826,2878,1,
		0,0,0,2827,2828,5,124,0,0,2828,2829,5,19,0,0,2829,2878,3,616,308,0,2830,
		2831,5,32,0,0,2831,2835,5,175,0,0,2832,2836,5,841,0,0,2833,2834,5,25,0,
		0,2834,2836,5,153,0,0,2835,2832,1,0,0,0,2835,2833,1,0,0,0,2836,2837,1,
		0,0,0,2837,2840,3,568,284,0,2838,2839,5,27,0,0,2839,2841,3,570,285,0,2840,
		2838,1,0,0,0,2840,2841,1,0,0,0,2841,2878,1,0,0,0,2842,2844,5,42,0,0,2843,
		2842,1,0,0,0,2843,2844,1,0,0,0,2844,2845,1,0,0,0,2845,2846,5,25,0,0,2846,
		2847,5,153,0,0,2847,2848,5,1124,0,0,2848,2852,3,568,284,0,2849,2850,5,
		27,0,0,2850,2851,5,1124,0,0,2851,2853,3,570,285,0,2852,2849,1,0,0,0,2852,
		2853,1,0,0,0,2853,2878,1,0,0,0,2854,2855,5,397,0,0,2855,2878,5,647,0,0,
		2856,2857,5,450,0,0,2857,2878,5,647,0,0,2858,2878,5,66,0,0,2859,2860,7,
		37,0,0,2860,2878,5,668,0,0,2861,2863,5,5,0,0,2862,2864,5,28,0,0,2863,2862,
		1,0,0,0,2863,2864,1,0,0,0,2864,2865,1,0,0,0,2865,2866,5,1133,0,0,2866,
		2871,3,90,45,0,2867,2868,5,1135,0,0,2868,2870,3,90,45,0,2869,2867,1,0,
		0,0,2870,2873,1,0,0,0,2871,2869,1,0,0,0,2871,2872,1,0,0,0,2872,2874,1,
		0,0,0,2873,2871,1,0,0,0,2874,2875,5,1134,0,0,2875,2878,1,0,0,0,2876,2878,
		3,150,75,0,2877,2526,1,0,0,0,2877,2536,1,0,0,0,2877,2547,1,0,0,0,2877,
		2565,1,0,0,0,2877,2580,1,0,0,0,2877,2602,1,0,0,0,2877,2626,1,0,0,0,2877,
		2641,1,0,0,0,2877,2656,1,0,0,0,2877,2678,1,0,0,0,2877,2700,1,0,0,0,2877,
		2712,1,0,0,0,2877,2717,1,0,0,0,2877,2729,1,0,0,0,2877,2741,1,0,0,0,2877,
		2747,1,0,0,0,2877,2752,1,0,0,0,2877,2763,1,0,0,0,2877,2771,1,0,0,0,2877,
		2774,1,0,0,0,2877,2777,1,0,0,0,2877,2780,1,0,0,0,2877,2786,1,0,0,0,2877,
		2806,1,0,0,0,2877,2811,1,0,0,0,2877,2815,1,0,0,0,2877,2817,1,0,0,0,2877,
		2819,1,0,0,0,2877,2827,1,0,0,0,2877,2830,1,0,0,0,2877,2843,1,0,0,0,2877,
		2854,1,0,0,0,2877,2856,1,0,0,0,2877,2858,1,0,0,0,2877,2859,1,0,0,0,2877,
		2861,1,0,0,0,2877,2876,1,0,0,0,2878,149,1,0,0,0,2879,2880,5,5,0,0,2880,
		2881,5,129,0,0,2881,2882,5,1133,0,0,2882,2887,3,118,59,0,2883,2884,5,1135,
		0,0,2884,2886,3,118,59,0,2885,2883,1,0,0,0,2886,2889,1,0,0,0,2887,2885,
		1,0,0,0,2887,2888,1,0,0,0,2888,2890,1,0,0,0,2889,2887,1,0,0,0,2890,2891,
		5,1134,0,0,2891,2978,1,0,0,0,2892,2893,5,51,0,0,2893,2894,5,129,0,0,2894,
		2978,3,616,308,0,2895,2896,5,397,0,0,2896,2899,5,129,0,0,2897,2900,3,616,
		308,0,2898,2900,5,6,0,0,2899,2897,1,0,0,0,2899,2898,1,0,0,0,2900,2901,
		1,0,0,0,2901,2978,5,647,0,0,2902,2903,5,450,0,0,2903,2906,5,129,0,0,2904,
		2907,3,616,308,0,2905,2907,5,6,0,0,2906,2904,1,0,0,0,2906,2905,1,0,0,0,
		2907,2908,1,0,0,0,2908,2978,5,647,0,0,2909,2910,5,656,0,0,2910,2913,5,
		129,0,0,2911,2914,3,616,308,0,2912,2914,5,6,0,0,2913,2911,1,0,0,0,2913,
		2912,1,0,0,0,2914,2978,1,0,0,0,2915,2916,5,363,0,0,2916,2917,5,129,0,0,
		2917,2978,3,590,295,0,2918,2919,5,579,0,0,2919,2920,5,129,0,0,2920,2921,
		3,616,308,0,2921,2922,5,87,0,0,2922,2923,5,1133,0,0,2923,2928,3,118,59,
		0,2924,2925,5,1135,0,0,2925,2927,3,118,59,0,2926,2924,1,0,0,0,2927,2930,
		1,0,0,0,2928,2926,1,0,0,0,2928,2929,1,0,0,0,2929,2931,1,0,0,0,2930,2928,
		1,0,0,0,2931,2932,5,1134,0,0,2932,2978,1,0,0,0,2933,2934,5,418,0,0,2934,
		2935,5,129,0,0,2935,2936,3,584,292,0,2936,2937,5,192,0,0,2937,2938,5,172,
		0,0,2938,2941,3,552,276,0,2939,2940,7,37,0,0,2940,2942,5,668,0,0,2941,
		2939,1,0,0,0,2941,2942,1,0,0,0,2942,2978,1,0,0,0,2943,2944,5,9,0,0,2944,
		2947,5,129,0,0,2945,2948,3,616,308,0,2946,2948,5,6,0,0,2947,2945,1,0,0,
		0,2947,2946,1,0,0,0,2948,2978,1,0,0,0,2949,2950,5,26,0,0,2950,2953,5,129,
		0,0,2951,2954,3,616,308,0,2952,2954,5,6,0,0,2953,2951,1,0,0,0,2953,2952,
		1,0,0,0,2954,2978,1,0,0,0,2955,2956,5,119,0,0,2956,2959,5,129,0,0,2957,
		2960,3,616,308,0,2958,2960,5,6,0,0,2959,2957,1,0,0,0,2959,2958,1,0,0,0,
		2960,2978,1,0,0,0,2961,2962,5,569,0,0,2962,2965,5,129,0,0,2963,2966,3,
		616,308,0,2964,2966,5,6,0,0,2965,2963,1,0,0,0,2965,2964,1,0,0,0,2966,2978,
		1,0,0,0,2967,2968,5,580,0,0,2968,2971,5,129,0,0,2969,2972,3,616,308,0,
		2970,2972,5,6,0,0,2971,2969,1,0,0,0,2971,2970,1,0,0,0,2972,2978,1,0,0,
		0,2973,2974,5,578,0,0,2974,2978,5,549,0,0,2975,2976,5,664,0,0,2976,2978,
		5,549,0,0,2977,2879,1,0,0,0,2977,2892,1,0,0,0,2977,2895,1,0,0,0,2977,2902,
		1,0,0,0,2977,2909,1,0,0,0,2977,2915,1,0,0,0,2977,2918,1,0,0,0,2977,2933,
		1,0,0,0,2977,2943,1,0,0,0,2977,2949,1,0,0,0,2977,2955,1,0,0,0,2977,2961,
		1,0,0,0,2977,2967,1,0,0,0,2977,2973,1,0,0,0,2977,2975,1,0,0,0,2978,151,
		1,0,0,0,2979,2980,5,51,0,0,2980,2982,7,0,0,0,2981,2983,3,640,320,0,2982,
		2981,1,0,0,0,2982,2983,1,0,0,0,2983,2984,1,0,0,0,2984,2985,3,584,292,0,
		2985,153,1,0,0,0,2986,2987,5,51,0,0,2987,2989,5,415,0,0,2988,2990,3,640,
		320,0,2989,2988,1,0,0,0,2989,2990,1,0,0,0,2990,2991,1,0,0,0,2991,2992,
		3,550,275,0,2992,155,1,0,0,0,2993,2994,5,51,0,0,2994,2996,5,81,0,0,2995,
		2997,7,1,0,0,2996,2995,1,0,0,0,2996,2997,1,0,0,0,2997,2998,1,0,0,0,2998,
		2999,3,584,292,0,2999,3000,5,118,0,0,3000,3013,3,552,276,0,3001,3003,5,
		336,0,0,3002,3004,5,1124,0,0,3003,3002,1,0,0,0,3003,3004,1,0,0,0,3004,
		3005,1,0,0,0,3005,3012,7,3,0,0,3006,3008,5,103,0,0,3007,3009,5,1124,0,
		0,3008,3007,1,0,0,0,3008,3009,1,0,0,0,3009,3010,1,0,0,0,3010,3012,7,4,
		0,0,3011,3001,1,0,0,0,3011,3006,1,0,0,0,3012,3015,1,0,0,0,3013,3011,1,
		0,0,0,3013,3014,1,0,0,0,3014,157,1,0,0,0,3015,3013,1,0,0,0,3016,3017,5,
		51,0,0,3017,3018,5,475,0,0,3018,3019,5,73,0,0,3019,3020,3,584,292,0,3020,
		3021,5,409,0,0,3021,3022,5,1124,0,0,3022,3023,3,572,286,0,3023,159,1,0,
		0,0,3024,3025,5,51,0,0,3025,3027,5,131,0,0,3026,3028,3,640,320,0,3027,
		3026,1,0,0,0,3027,3028,1,0,0,0,3028,3029,1,0,0,0,3029,3030,3,550,275,0,
		3030,161,1,0,0,0,3031,3032,5,51,0,0,3032,3034,5,437,0,0,3033,3035,3,640,
		320,0,3034,3033,1,0,0,0,3034,3035,1,0,0,0,3035,3036,1,0,0,0,3036,3037,
		3,550,275,0,3037,163,1,0,0,0,3038,3039,5,51,0,0,3039,3041,5,608,0,0,3040,
		3042,3,640,320,0,3041,3040,1,0,0,0,3041,3042,1,0,0,0,3042,3043,1,0,0,0,
		3043,3044,3,584,292,0,3044,165,1,0,0,0,3045,3047,5,51,0,0,3046,3048,5,
		649,0,0,3047,3046,1,0,0,0,3047,3048,1,0,0,0,3048,3049,1,0,0,0,3049,3051,
		5,172,0,0,3050,3052,3,640,320,0,3051,3050,1,0,0,0,3051,3052,1,0,0,0,3052,
		3053,1,0,0,0,3053,3055,3,620,310,0,3054,3056,7,38,0,0,3055,3054,1,0,0,
		0,3055,3056,1,0,0,0,3056,167,1,0,0,0,3057,3058,5,51,0,0,3058,3059,5,647,
		0,0,3059,3065,3,584,292,0,3060,3062,5,409,0,0,3061,3063,5,1124,0,0,3062,
		3061,1,0,0,0,3062,3063,1,0,0,0,3063,3064,1,0,0,0,3064,3066,3,572,286,0,
		3065,3060,1,0,0,0,3065,3066,1,0,0,0,3066,169,1,0,0,0,3067,3068,5,51,0,
		0,3068,3070,5,177,0,0,3069,3071,3,640,320,0,3070,3069,1,0,0,0,3070,3071,
		1,0,0,0,3071,3072,1,0,0,0,3072,3073,3,550,275,0,3073,171,1,0,0,0,3074,
		3075,5,51,0,0,3075,3077,5,671,0,0,3076,3078,3,640,320,0,3077,3076,1,0,
		0,0,3077,3078,1,0,0,0,3078,3079,1,0,0,0,3079,3084,3,550,275,0,3080,3081,
		5,1135,0,0,3081,3083,3,550,275,0,3082,3080,1,0,0,0,3083,3086,1,0,0,0,3084,
		3082,1,0,0,0,3084,3085,1,0,0,0,3085,3088,1,0,0,0,3086,3084,1,0,0,0,3087,
		3089,7,38,0,0,3088,3087,1,0,0,0,3088,3089,1,0,0,0,3089,173,1,0,0,0,3090,
		3091,5,51,0,0,3091,3093,5,596,0,0,3092,3094,3,640,320,0,3093,3092,1,0,
		0,0,3093,3094,1,0,0,0,3094,3095,1,0,0,0,3095,3100,3,554,277,0,3096,3097,
		5,1135,0,0,3097,3099,3,554,277,0,3098,3096,1,0,0,0,3099,3102,1,0,0,0,3100,
		3098,1,0,0,0,3100,3101,1,0,0,0,3101,175,1,0,0,0,3102,3100,1,0,0,0,3103,
		3104,5,153,0,0,3104,3105,5,42,0,0,3105,3116,5,596,0,0,3106,3117,5,529,
		0,0,3107,3117,5,6,0,0,3108,3113,3,554,277,0,3109,3110,5,1135,0,0,3110,
		3112,3,554,277,0,3111,3109,1,0,0,0,3112,3115,1,0,0,0,3113,3111,1,0,0,0,
		3113,3114,1,0,0,0,3114,3117,1,0,0,0,3115,3113,1,0,0,0,3116,3106,1,0,0,
		0,3116,3107,1,0,0,0,3116,3108,1,0,0,0,3117,3118,1,0,0,0,3118,3121,5,175,
		0,0,3119,3122,3,564,282,0,3120,3122,3,584,292,0,3121,3119,1,0,0,0,3121,
		3120,1,0,0,0,3122,3130,1,0,0,0,3123,3126,5,1135,0,0,3124,3127,3,564,282,
		0,3125,3127,3,584,292,0,3126,3124,1,0,0,0,3126,3125,1,0,0,0,3127,3129,
		1,0,0,0,3128,3123,1,0,0,0,3129,3132,1,0,0,0,3130,3128,1,0,0,0,3130,3131,
		1,0,0,0,3131,3137,1,0,0,0,3132,3130,1,0,0,0,3133,3134,5,153,0,0,3134,3135,
		5,596,0,0,3135,3137,3,434,217,0,3136,3103,1,0,0,0,3136,3133,1,0,0,0,3137,
		177,1,0,0,0,3138,3139,5,139,0,0,3139,3140,5,172,0,0,3140,3145,3,180,90,
		0,3141,3142,5,1135,0,0,3142,3144,3,180,90,0,3143,3141,1,0,0,0,3144,3147,
		1,0,0,0,3145,3143,1,0,0,0,3145,3146,1,0,0,0,3146,179,1,0,0,0,3147,3145,
		1,0,0,0,3148,3149,3,552,276,0,3149,3150,5,175,0,0,3150,3151,3,552,276,
		0,3151,181,1,0,0,0,3152,3154,5,656,0,0,3153,3155,5,172,0,0,3154,3153,1,
		0,0,0,3154,3155,1,0,0,0,3155,3156,1,0,0,0,3156,3157,3,552,276,0,3157,183,
		1,0,0,0,3158,3159,5,20,0,0,3159,3166,3,550,275,0,3160,3163,5,1133,0,0,
		3161,3164,3,628,314,0,3162,3164,3,624,312,0,3163,3161,1,0,0,0,3163,3162,
		1,0,0,0,3163,3164,1,0,0,0,3164,3165,1,0,0,0,3165,3167,5,1134,0,0,3166,
		3160,1,0,0,0,3166,3167,1,0,0,0,3167,185,1,0,0,0,3168,3171,3,214,107,0,
		3169,3171,3,216,108,0,3170,3168,1,0,0,0,3170,3169,1,0,0,0,3171,187,1,0,
		0,0,3172,3173,5,399,0,0,3173,3174,3,624,312,0,3174,189,1,0,0,0,3175,3180,
		3,218,109,0,3176,3180,3,220,110,0,3177,3180,3,222,111,0,3178,3180,3,224,
		112,0,3179,3175,1,0,0,0,3179,3176,1,0,0,0,3179,3177,1,0,0,0,3179,3178,
		1,0,0,0,3180,191,1,0,0,0,3181,3183,5,85,0,0,3182,3184,7,39,0,0,3183,3182,
		1,0,0,0,3183,3184,1,0,0,0,3184,3186,1,0,0,0,3185,3187,5,78,0,0,3186,3185,
		1,0,0,0,3186,3187,1,0,0,0,3187,3189,1,0,0,0,3188,3190,5,87,0,0,3189,3188,
		1,0,0,0,3189,3190,1,0,0,0,3190,3191,1,0,0,0,3191,3198,3,552,276,0,3192,
		3193,5,129,0,0,3193,3195,5,1133,0,0,3194,3196,3,616,308,0,3195,3194,1,
		0,0,0,3195,3196,1,0,0,0,3196,3197,1,0,0,0,3197,3199,5,1134,0,0,3198,3192,
		1,0,0,0,3198,3199,1,0,0,0,3199,3223,1,0,0,0,3200,3202,5,1133,0,0,3201,
		3203,3,618,309,0,3202,3201,1,0,0,0,3202,3203,1,0,0,0,3203,3204,1,0,0,0,
		3204,3206,5,1134,0,0,3205,3200,1,0,0,0,3205,3206,1,0,0,0,3206,3207,1,0,
		0,0,3207,3212,3,206,103,0,3208,3210,5,12,0,0,3209,3208,1,0,0,0,3209,3210,
		1,0,0,0,3210,3211,1,0,0,0,3211,3213,3,584,292,0,3212,3209,1,0,0,0,3212,
		3213,1,0,0,0,3213,3224,1,0,0,0,3214,3215,5,153,0,0,3215,3220,3,208,104,
		0,3216,3217,5,1135,0,0,3217,3219,3,208,104,0,3218,3216,1,0,0,0,3219,3222,
		1,0,0,0,3220,3218,1,0,0,0,3220,3221,1,0,0,0,3221,3224,1,0,0,0,3222,3220,
		1,0,0,0,3223,3205,1,0,0,0,3223,3214,1,0,0,0,3224,3237,1,0,0,0,3225,3226,
		5,118,0,0,3226,3227,5,401,0,0,3227,3228,5,91,0,0,3228,3229,5,184,0,0,3229,
		3234,3,208,104,0,3230,3231,5,1135,0,0,3231,3233,3,208,104,0,3232,3230,
		1,0,0,0,3233,3236,1,0,0,0,3234,3232,1,0,0,0,3234,3235,1,0,0,0,3235,3238,
		1,0,0,0,3236,3234,1,0,0,0,3237,3225,1,0,0,0,3237,3238,1,0,0,0,3238,193,
		1,0,0,0,3239,3240,5,102,0,0,3240,3242,5,388,0,0,3241,3243,7,40,0,0,3242,
		3241,1,0,0,0,3242,3243,1,0,0,0,3243,3245,1,0,0,0,3244,3246,5,474,0,0,3245,
		3244,1,0,0,0,3245,3246,1,0,0,0,3246,3247,1,0,0,0,3247,3248,5,82,0,0,3248,
		3250,5,1148,0,0,3249,3251,7,6,0,0,3250,3249,1,0,0,0,3250,3251,1,0,0,0,
		3251,3252,1,0,0,0,3252,3253,5,87,0,0,3253,3254,5,172,0,0,3254,3260,3,552,
		276,0,3255,3256,5,129,0,0,3256,3257,5,1133,0,0,3257,3258,3,616,308,0,3258,
		3259,5,1134,0,0,3259,3261,1,0,0,0,3260,3255,1,0,0,0,3260,3261,1,0,0,0,
		3261,3265,1,0,0,0,3262,3263,5,25,0,0,3263,3264,5,153,0,0,3264,3266,3,568,
		284,0,3265,3262,1,0,0,0,3265,3266,1,0,0,0,3266,3273,1,0,0,0,3267,3269,
		7,41,0,0,3268,3270,3,280,140,0,3269,3268,1,0,0,0,3270,3271,1,0,0,0,3271,
		3269,1,0,0,0,3271,3272,1,0,0,0,3272,3274,1,0,0,0,3273,3267,1,0,0,0,3273,
		3274,1,0,0,0,3274,3281,1,0,0,0,3275,3277,5,101,0,0,3276,3278,3,282,141,
		0,3277,3276,1,0,0,0,3278,3279,1,0,0,0,3279,3277,1,0,0,0,3279,3280,1,0,
		0,0,3280,3282,1,0,0,0,3281,3275,1,0,0,0,3281,3282,1,0,0,0,3282,3287,1,
		0,0,0,3283,3284,5,78,0,0,3284,3285,3,590,295,0,3285,3286,7,42,0,0,3286,
		3288,1,0,0,0,3287,3283,1,0,0,0,3287,3288,1,0,0,0,3288,3300,1,0,0,0,3289,
		3290,5,1133,0,0,3290,3295,3,210,105,0,3291,3292,5,1135,0,0,3292,3294,3,
		210,105,0,3293,3291,1,0,0,0,3294,3297,1,0,0,0,3295,3293,1,0,0,0,3295,3296,
		1,0,0,0,3296,3298,1,0,0,0,3297,3295,1,0,0,0,3298,3299,5,1134,0,0,3299,
		3301,1,0,0,0,3300,3289,1,0,0,0,3300,3301,1,0,0,0,3301,3311,1,0,0,0,3302,
		3303,5,153,0,0,3303,3308,3,208,104,0,3304,3305,5,1135,0,0,3305,3307,3,
		208,104,0,3306,3304,1,0,0,0,3307,3310,1,0,0,0,3308,3306,1,0,0,0,3308,3309,
		1,0,0,0,3309,3312,1,0,0,0,3310,3308,1,0,0,0,3311,3302,1,0,0,0,3311,3312,
		1,0,0,0,3312,195,1,0,0,0,3313,3314,5,102,0,0,3314,3316,5,682,0,0,3315,
		3317,7,40,0,0,3316,3315,1,0,0,0,3316,3317,1,0,0,0,3317,3319,1,0,0,0,3318,
		3320,5,474,0,0,3319,3318,1,0,0,0,3319,3320,1,0,0,0,3320,3321,1,0,0,0,3321,
		3322,5,82,0,0,3322,3324,5,1148,0,0,3323,3325,7,6,0,0,3324,3323,1,0,0,0,
		3324,3325,1,0,0,0,3325,3326,1,0,0,0,3326,3327,5,87,0,0,3327,3328,5,172,
		0,0,3328,3332,3,552,276,0,3329,3330,5,25,0,0,3330,3331,5,153,0,0,3331,
		3333,3,568,284,0,3332,3329,1,0,0,0,3332,3333,1,0,0,0,3333,3340,1,0,0,0,
		3334,3335,5,601,0,0,3335,3336,5,448,0,0,3336,3337,5,19,0,0,3337,3338,5,
		1126,0,0,3338,3339,5,1148,0,0,3339,3341,5,1125,0,0,3340,3334,1,0,0,0,3340,
		3341,1,0,0,0,3341,3346,1,0,0,0,3342,3343,5,78,0,0,3343,3344,3,590,295,
		0,3344,3345,7,42,0,0,3345,3347,1,0,0,0,3346,3342,1,0,0,0,3346,3347,1,0,
		0,0,3347,3359,1,0,0,0,3348,3349,5,1133,0,0,3349,3354,3,210,105,0,3350,
		3351,5,1135,0,0,3351,3353,3,210,105,0,3352,3350,1,0,0,0,3353,3356,1,0,
		0,0,3354,3352,1,0,0,0,3354,3355,1,0,0,0,3355,3357,1,0,0,0,3356,3354,1,
		0,0,0,3357,3358,5,1134,0,0,3358,3360,1,0,0,0,3359,3348,1,0,0,0,3359,3360,
		1,0,0,0,3360,3370,1,0,0,0,3361,3362,5,153,0,0,3362,3367,3,208,104,0,3363,
		3364,5,1135,0,0,3364,3366,3,208,104,0,3365,3363,1,0,0,0,3366,3369,1,0,
		0,0,3367,3365,1,0,0,0,3367,3368,1,0,0,0,3368,3371,1,0,0,0,3369,3367,1,
		0,0,0,3370,3361,1,0,0,0,3370,3371,1,0,0,0,3371,197,1,0,0,0,3372,3374,5,
		141,0,0,3373,3375,7,43,0,0,3374,3373,1,0,0,0,3374,3375,1,0,0,0,3375,3377,
		1,0,0,0,3376,3378,5,87,0,0,3377,3376,1,0,0,0,3377,3378,1,0,0,0,3378,3379,
		1,0,0,0,3379,3385,3,552,276,0,3380,3381,5,129,0,0,3381,3382,5,1133,0,0,
		3382,3383,3,616,308,0,3383,3384,5,1134,0,0,3384,3386,1,0,0,0,3385,3380,
		1,0,0,0,3385,3386,1,0,0,0,3386,3403,1,0,0,0,3387,3388,5,1133,0,0,3388,
		3389,3,616,308,0,3389,3390,5,1134,0,0,3390,3392,1,0,0,0,3391,3387,1,0,
		0,0,3391,3392,1,0,0,0,3392,3393,1,0,0,0,3393,3404,3,206,103,0,3394,3395,
		5,153,0,0,3395,3400,3,208,104,0,3396,3397,5,1135,0,0,3397,3399,3,208,104,
		0,3398,3396,1,0,0,0,3399,3402,1,0,0,0,3400,3398,1,0,0,0,3400,3401,1,0,
		0,0,3401,3404,1,0,0,0,3402,3400,1,0,0,0,3403,3391,1,0,0,0,3403,3394,1,
		0,0,0,3404,199,1,0,0,0,3405,3407,3,252,126,0,3406,3408,3,212,106,0,3407,
		3406,1,0,0,0,3407,3408,1,0,0,0,3408,3471,1,0,0,0,3409,3411,3,248,124,0,
		3410,3412,3,212,106,0,3411,3410,1,0,0,0,3411,3412,1,0,0,0,3412,3471,1,
		0,0,0,3413,3416,3,254,127,0,3414,3416,3,250,125,0,3415,3413,1,0,0,0,3415,
		3414,1,0,0,0,3416,3418,1,0,0,0,3417,3419,3,258,129,0,3418,3417,1,0,0,0,
		3419,3420,1,0,0,0,3420,3418,1,0,0,0,3420,3421,1,0,0,0,3421,3430,1,0,0,
		0,3422,3424,5,180,0,0,3423,3425,7,44,0,0,3424,3423,1,0,0,0,3424,3425,1,
		0,0,0,3425,3428,1,0,0,0,3426,3429,3,252,126,0,3427,3429,3,248,124,0,3428,
		3426,1,0,0,0,3428,3427,1,0,0,0,3429,3431,1,0,0,0,3430,3422,1,0,0,0,3430,
		3431,1,0,0,0,3431,3433,1,0,0,0,3432,3434,3,230,115,0,3433,3432,1,0,0,0,
		3433,3434,1,0,0,0,3434,3436,1,0,0,0,3435,3437,3,294,147,0,3436,3435,1,
		0,0,0,3436,3437,1,0,0,0,3437,3439,1,0,0,0,3438,3440,3,212,106,0,3439,3438,
		1,0,0,0,3439,3440,1,0,0,0,3440,3471,1,0,0,0,3441,3443,3,250,125,0,3442,
		3444,3,256,128,0,3443,3442,1,0,0,0,3444,3445,1,0,0,0,3445,3443,1,0,0,0,
		3445,3446,1,0,0,0,3446,3452,1,0,0,0,3447,3449,5,180,0,0,3448,3450,7,44,
		0,0,3449,3448,1,0,0,0,3449,3450,1,0,0,0,3450,3451,1,0,0,0,3451,3453,3,
		248,124,0,3452,3447,1,0,0,0,3452,3453,1,0,0,0,3453,3455,1,0,0,0,3454,3456,
		3,230,115,0,3455,3454,1,0,0,0,3455,3456,1,0,0,0,3456,3458,1,0,0,0,3457,
		3459,3,294,147,0,3458,3457,1,0,0,0,3458,3459,1,0,0,0,3459,3461,1,0,0,0,
		3460,3462,3,212,106,0,3461,3460,1,0,0,0,3461,3462,1,0,0,0,3462,3471,1,
		0,0,0,3463,3466,3,254,127,0,3464,3465,5,1135,0,0,3465,3467,3,260,130,0,
		3466,3464,1,0,0,0,3467,3468,1,0,0,0,3468,3466,1,0,0,0,3468,3469,1,0,0,
		0,3469,3471,1,0,0,0,3470,3405,1,0,0,0,3470,3409,1,0,0,0,3470,3415,1,0,
		0,0,3470,3441,1,0,0,0,3470,3463,1,0,0,0,3471,201,1,0,0,0,3472,3475,3,226,
		113,0,3473,3475,3,228,114,0,3474,3472,1,0,0,0,3474,3473,1,0,0,0,3475,203,
		1,0,0,0,3476,3477,5,188,0,0,3477,3479,5,1133,0,0,3478,3480,3,626,313,0,
		3479,3478,1,0,0,0,3479,3480,1,0,0,0,3480,3481,1,0,0,0,3481,3490,5,1134,
		0,0,3482,3483,5,1135,0,0,3483,3485,5,1133,0,0,3484,3486,3,626,313,0,3485,
		3484,1,0,0,0,3485,3486,1,0,0,0,3486,3487,1,0,0,0,3487,3489,5,1134,0,0,
		3488,3482,1,0,0,0,3489,3492,1,0,0,0,3490,3488,1,0,0,0,3490,3491,1,0,0,
		0,3491,205,1,0,0,0,3492,3490,1,0,0,0,3493,3512,3,200,100,0,3494,3495,7,
		45,0,0,3495,3497,5,1133,0,0,3496,3498,3,626,313,0,3497,3496,1,0,0,0,3497,
		3498,1,0,0,0,3498,3499,1,0,0,0,3499,3508,5,1134,0,0,3500,3501,5,1135,0,
		0,3501,3503,5,1133,0,0,3502,3504,3,626,313,0,3503,3502,1,0,0,0,3503,3504,
		1,0,0,0,3504,3505,1,0,0,0,3505,3507,5,1134,0,0,3506,3500,1,0,0,0,3507,
		3510,1,0,0,0,3508,3506,1,0,0,0,3508,3509,1,0,0,0,3509,3512,1,0,0,0,3510,
		3508,1,0,0,0,3511,3493,1,0,0,0,3511,3494,1,0,0,0,3512,207,1,0,0,0,3513,
		3514,3,556,278,0,3514,3517,5,1124,0,0,3515,3518,3,688,344,0,3516,3518,
		5,42,0,0,3517,3515,1,0,0,0,3517,3516,1,0,0,0,3518,209,1,0,0,0,3519,3522,
		3,584,292,0,3520,3522,5,1159,0,0,3521,3519,1,0,0,0,3521,3520,1,0,0,0,3522,
		211,1,0,0,0,3523,3524,5,65,0,0,3524,3530,5,184,0,0,3525,3526,5,103,0,0,
		3526,3527,5,80,0,0,3527,3528,5,610,0,0,3528,3530,5,511,0,0,3529,3523,1,
		0,0,0,3529,3525,1,0,0,0,3530,213,1,0,0,0,3531,3533,5,44,0,0,3532,3534,
		5,106,0,0,3533,3532,1,0,0,0,3533,3534,1,0,0,0,3534,3536,1,0,0,0,3535,3537,
		5,568,0,0,3536,3535,1,0,0,0,3536,3537,1,0,0,0,3537,3539,1,0,0,0,3538,3540,
		5,78,0,0,3539,3538,1,0,0,0,3539,3540,1,0,0,0,3540,3541,1,0,0,0,3541,3542,
		5,68,0,0,3542,3547,3,552,276,0,3543,3545,5,12,0,0,3544,3543,1,0,0,0,3544,
		3545,1,0,0,0,3545,3546,1,0,0,0,3546,3548,3,584,292,0,3547,3544,1,0,0,0,
		3547,3548,1,0,0,0,3548,3554,1,0,0,0,3549,3550,5,129,0,0,3550,3551,5,1133,
		0,0,3551,3552,3,616,308,0,3552,3553,5,1134,0,0,3553,3555,1,0,0,0,3554,
		3549,1,0,0,0,3554,3555,1,0,0,0,3555,3558,1,0,0,0,3556,3557,5,190,0,0,3557,
		3559,3,688,344,0,3558,3556,1,0,0,0,3558,3559,1,0,0,0,3559,3561,1,0,0,0,
		3560,3562,3,230,115,0,3561,3560,1,0,0,0,3561,3562,1,0,0,0,3562,3565,1,
		0,0,0,3563,3564,5,99,0,0,3564,3566,3,296,148,0,3565,3563,1,0,0,0,3565,
		3566,1,0,0,0,3566,215,1,0,0,0,3567,3569,5,44,0,0,3568,3570,5,106,0,0,3569,
		3568,1,0,0,0,3569,3570,1,0,0,0,3570,3572,1,0,0,0,3571,3573,5,568,0,0,3572,
		3571,1,0,0,0,3572,3573,1,0,0,0,3573,3575,1,0,0,0,3574,3576,5,78,0,0,3575,
		3574,1,0,0,0,3575,3576,1,0,0,0,3576,3616,1,0,0,0,3577,3580,3,552,276,0,
		3578,3579,5,1132,0,0,3579,3581,5,1117,0,0,3580,3578,1,0,0,0,3580,3581,
		1,0,0,0,3581,3590,1,0,0,0,3582,3583,5,1135,0,0,3583,3586,3,552,276,0,3584,
		3585,5,1132,0,0,3585,3587,5,1117,0,0,3586,3584,1,0,0,0,3586,3587,1,0,0,
		0,3587,3589,1,0,0,0,3588,3582,1,0,0,0,3589,3592,1,0,0,0,3590,3588,1,0,
		0,0,3590,3591,1,0,0,0,3591,3593,1,0,0,0,3592,3590,1,0,0,0,3593,3594,5,
		68,0,0,3594,3595,3,234,117,0,3595,3617,1,0,0,0,3596,3597,5,68,0,0,3597,
		3600,3,552,276,0,3598,3599,5,1132,0,0,3599,3601,5,1117,0,0,3600,3598,1,
		0,0,0,3600,3601,1,0,0,0,3601,3610,1,0,0,0,3602,3603,5,1135,0,0,3603,3606,
		3,552,276,0,3604,3605,5,1132,0,0,3605,3607,5,1117,0,0,3606,3604,1,0,0,
		0,3606,3607,1,0,0,0,3607,3609,1,0,0,0,3608,3602,1,0,0,0,3609,3612,1,0,
		0,0,3610,3608,1,0,0,0,3610,3611,1,0,0,0,3611,3613,1,0,0,0,3612,3610,1,
		0,0,0,3613,3614,5,187,0,0,3614,3615,3,234,117,0,3615,3617,1,0,0,0,3616,
		3577,1,0,0,0,3616,3596,1,0,0,0,3617,3620,1,0,0,0,3618,3619,5,190,0,0,3619,
		3621,3,688,344,0,3620,3618,1,0,0,0,3620,3621,1,0,0,0,3621,217,1,0,0,0,
		3622,3623,5,442,0,0,3623,3624,3,552,276,0,3624,3629,5,539,0,0,3625,3627,
		5,12,0,0,3626,3625,1,0,0,0,3626,3627,1,0,0,0,3627,3628,1,0,0,0,3628,3630,
		3,584,292,0,3629,3626,1,0,0,0,3629,3630,1,0,0,0,3630,219,1,0,0,0,3631,
		3632,5,442,0,0,3632,3633,3,552,276,0,3633,3634,5,134,0,0,3634,3641,3,584,
		292,0,3635,3636,3,696,348,0,3636,3637,5,1133,0,0,3637,3638,3,628,314,0,
		3638,3639,5,1134,0,0,3639,3642,1,0,0,0,3640,3642,7,46,0,0,3641,3635,1,
		0,0,0,3641,3640,1,0,0,0,3642,3645,1,0,0,0,3643,3644,5,190,0,0,3644,3646,
		3,688,344,0,3645,3643,1,0,0,0,3645,3646,1,0,0,0,3646,3649,1,0,0,0,3647,
		3648,5,99,0,0,3648,3650,3,296,148,0,3649,3647,1,0,0,0,3649,3650,1,0,0,
		0,3650,221,1,0,0,0,3651,3652,5,442,0,0,3652,3653,3,552,276,0,3653,3654,
		5,134,0,0,3654,3657,7,47,0,0,3655,3656,5,190,0,0,3656,3658,3,688,344,0,
		3657,3655,1,0,0,0,3657,3658,1,0,0,0,3658,3661,1,0,0,0,3659,3660,5,99,0,
		0,3660,3662,3,296,148,0,3661,3659,1,0,0,0,3661,3662,1,0,0,0,3662,223,1,
		0,0,0,3663,3664,5,442,0,0,3664,3665,3,552,276,0,3665,3666,5,361,0,0,3666,
		225,1,0,0,0,3667,3669,5,184,0,0,3668,3670,5,106,0,0,3669,3668,1,0,0,0,
		3669,3670,1,0,0,0,3670,3672,1,0,0,0,3671,3673,5,78,0,0,3672,3671,1,0,0,
		0,3672,3673,1,0,0,0,3673,3674,1,0,0,0,3674,3679,3,552,276,0,3675,3677,
		5,12,0,0,3676,3675,1,0,0,0,3676,3677,1,0,0,0,3677,3678,1,0,0,0,3678,3680,
		3,584,292,0,3679,3676,1,0,0,0,3679,3680,1,0,0,0,3680,3681,1,0,0,0,3681,
		3682,5,153,0,0,3682,3687,3,208,104,0,3683,3684,5,1135,0,0,3684,3686,3,
		208,104,0,3685,3683,1,0,0,0,3686,3689,1,0,0,0,3687,3685,1,0,0,0,3687,3688,
		1,0,0,0,3688,3692,1,0,0,0,3689,3687,1,0,0,0,3690,3691,5,190,0,0,3691,3693,
		3,688,344,0,3692,3690,1,0,0,0,3692,3693,1,0,0,0,3693,3695,1,0,0,0,3694,
		3696,3,230,115,0,3695,3694,1,0,0,0,3695,3696,1,0,0,0,3696,3698,1,0,0,0,
		3697,3699,3,294,147,0,3698,3697,1,0,0,0,3698,3699,1,0,0,0,3699,227,1,0,
		0,0,3700,3702,5,184,0,0,3701,3703,5,106,0,0,3702,3701,1,0,0,0,3702,3703,
		1,0,0,0,3703,3705,1,0,0,0,3704,3706,5,78,0,0,3705,3704,1,0,0,0,3705,3706,
		1,0,0,0,3706,3707,1,0,0,0,3707,3708,3,234,117,0,3708,3709,5,153,0,0,3709,
		3714,3,208,104,0,3710,3711,5,1135,0,0,3711,3713,3,208,104,0,3712,3710,
		1,0,0,0,3713,3716,1,0,0,0,3714,3712,1,0,0,0,3714,3715,1,0,0,0,3715,3719,
		1,0,0,0,3716,3714,1,0,0,0,3717,3718,5,190,0,0,3718,3720,3,688,344,0,3719,
		3717,1,0,0,0,3719,3720,1,0,0,0,3720,229,1,0,0,0,3721,3722,5,124,0,0,3722,
		3723,5,19,0,0,3723,3728,3,232,116,0,3724,3725,5,1135,0,0,3725,3727,3,232,
		116,0,3726,3724,1,0,0,0,3727,3730,1,0,0,0,3728,3726,1,0,0,0,3728,3729,
		1,0,0,0,3729,231,1,0,0,0,3730,3728,1,0,0,0,3731,3733,3,688,344,0,3732,
		3734,7,48,0,0,3733,3732,1,0,0,0,3733,3734,1,0,0,0,3734,233,1,0,0,0,3735,
		3740,3,236,118,0,3736,3737,5,1135,0,0,3737,3739,3,236,118,0,3738,3736,
		1,0,0,0,3739,3742,1,0,0,0,3740,3738,1,0,0,0,3740,3741,1,0,0,0,3741,235,
		1,0,0,0,3742,3740,1,0,0,0,3743,3747,3,238,119,0,3744,3746,3,244,122,0,
		3745,3744,1,0,0,0,3746,3749,1,0,0,0,3747,3745,1,0,0,0,3747,3748,1,0,0,
		0,3748,3762,1,0,0,0,3749,3747,1,0,0,0,3750,3751,5,1133,0,0,3751,3755,3,
		238,119,0,3752,3754,3,244,122,0,3753,3752,1,0,0,0,3754,3757,1,0,0,0,3755,
		3753,1,0,0,0,3755,3756,1,0,0,0,3756,3758,1,0,0,0,3757,3755,1,0,0,0,3758,
		3759,5,1134,0,0,3759,3762,1,0,0,0,3760,3762,3,262,131,0,3761,3743,1,0,
		0,0,3761,3750,1,0,0,0,3761,3760,1,0,0,0,3762,237,1,0,0,0,3763,3769,3,552,
		276,0,3764,3765,5,129,0,0,3765,3766,5,1133,0,0,3766,3767,3,616,308,0,3767,
		3768,5,1134,0,0,3768,3770,1,0,0,0,3769,3764,1,0,0,0,3769,3770,1,0,0,0,
		3770,3775,1,0,0,0,3771,3773,5,12,0,0,3772,3771,1,0,0,0,3772,3773,1,0,0,
		0,3773,3774,1,0,0,0,3774,3776,3,584,292,0,3775,3772,1,0,0,0,3775,3776,
		1,0,0,0,3776,3785,1,0,0,0,3777,3782,3,240,120,0,3778,3779,5,1135,0,0,3779,
		3781,3,240,120,0,3780,3778,1,0,0,0,3781,3784,1,0,0,0,3782,3780,1,0,0,0,
		3782,3783,1,0,0,0,3783,3786,1,0,0,0,3784,3782,1,0,0,0,3785,3777,1,0,0,
		0,3785,3786,1,0,0,0,3786,3804,1,0,0,0,3787,3793,3,200,100,0,3788,3789,
		5,1133,0,0,3789,3790,3,200,100,0,3790,3791,5,1134,0,0,3791,3793,1,0,0,
		0,3792,3787,1,0,0,0,3792,3788,1,0,0,0,3793,3795,1,0,0,0,3794,3796,5,12,
		0,0,3795,3794,1,0,0,0,3795,3796,1,0,0,0,3796,3797,1,0,0,0,3797,3798,3,
		584,292,0,3798,3804,1,0,0,0,3799,3800,5,1133,0,0,3800,3801,3,234,117,0,
		3801,3802,5,1134,0,0,3802,3804,1,0,0,0,3803,3763,1,0,0,0,3803,3792,1,0,
		0,0,3803,3799,1,0,0,0,3804,239,1,0,0,0,3805,3806,7,49,0,0,3806,3809,7,
		20,0,0,3807,3808,5,65,0,0,3808,3810,3,242,121,0,3809,3807,1,0,0,0,3809,
		3810,1,0,0,0,3810,3811,1,0,0,0,3811,3812,5,1133,0,0,3812,3813,3,616,308,
		0,3813,3814,5,1134,0,0,3814,241,1,0,0,0,3815,3821,5,90,0,0,3816,3817,5,
		124,0,0,3817,3821,5,19,0,0,3818,3819,5,73,0,0,3819,3821,5,19,0,0,3820,
		3815,1,0,0,0,3820,3816,1,0,0,0,3820,3818,1,0,0,0,3821,243,1,0,0,0,3822,
		3824,7,50,0,0,3823,3822,1,0,0,0,3823,3824,1,0,0,0,3824,3825,1,0,0,0,3825,
		3827,5,90,0,0,3826,3828,5,94,0,0,3827,3826,1,0,0,0,3827,3828,1,0,0,0,3828,
		3829,1,0,0,0,3829,3833,3,238,119,0,3830,3832,3,246,123,0,3831,3830,1,0,
		0,0,3832,3835,1,0,0,0,3833,3831,1,0,0,0,3833,3834,1,0,0,0,3834,3870,1,
		0,0,0,3835,3833,1,0,0,0,3836,3837,5,171,0,0,3837,3842,3,238,119,0,3838,
		3839,5,118,0,0,3839,3841,3,688,344,0,3840,3838,1,0,0,0,3841,3844,1,0,0,
		0,3842,3840,1,0,0,0,3842,3843,1,0,0,0,3843,3870,1,0,0,0,3844,3842,1,0,
		0,0,3845,3847,7,51,0,0,3846,3848,5,126,0,0,3847,3846,1,0,0,0,3847,3848,
		1,0,0,0,3848,3849,1,0,0,0,3849,3851,5,90,0,0,3850,3852,5,94,0,0,3851,3850,
		1,0,0,0,3851,3852,1,0,0,0,3852,3853,1,0,0,0,3853,3857,3,238,119,0,3854,
		3856,3,246,123,0,3855,3854,1,0,0,0,3856,3859,1,0,0,0,3857,3855,1,0,0,0,
		3857,3858,1,0,0,0,3858,3870,1,0,0,0,3859,3857,1,0,0,0,3860,3865,5,113,
		0,0,3861,3863,7,51,0,0,3862,3864,5,126,0,0,3863,3862,1,0,0,0,3863,3864,
		1,0,0,0,3864,3866,1,0,0,0,3865,3861,1,0,0,0,3865,3866,1,0,0,0,3866,3867,
		1,0,0,0,3867,3868,5,90,0,0,3868,3870,3,238,119,0,3869,3823,1,0,0,0,3869,
		3836,1,0,0,0,3869,3845,1,0,0,0,3869,3860,1,0,0,0,3870,245,1,0,0,0,3871,
		3872,5,118,0,0,3872,3879,3,688,344,0,3873,3874,5,187,0,0,3874,3875,5,1133,
		0,0,3875,3876,3,616,308,0,3876,3877,5,1134,0,0,3877,3879,1,0,0,0,3878,
		3871,1,0,0,0,3878,3873,1,0,0,0,3879,247,1,0,0,0,3880,3881,5,1133,0,0,3881,
		3882,3,252,126,0,3882,3883,5,1134,0,0,3883,3889,1,0,0,0,3884,3885,5,1133,
		0,0,3885,3886,3,248,124,0,3886,3887,5,1134,0,0,3887,3889,1,0,0,0,3888,
		3880,1,0,0,0,3888,3884,1,0,0,0,3889,249,1,0,0,0,3890,3891,5,1133,0,0,3891,
		3892,3,254,127,0,3892,3893,5,1134,0,0,3893,3899,1,0,0,0,3894,3895,5,1133,
		0,0,3895,3896,3,250,125,0,3896,3897,5,1134,0,0,3897,3899,1,0,0,0,3898,
		3890,1,0,0,0,3898,3894,1,0,0,0,3899,251,1,0,0,0,3900,3904,5,152,0,0,3901,
		3903,3,272,136,0,3902,3901,1,0,0,0,3903,3906,1,0,0,0,3904,3902,1,0,0,0,
		3904,3905,1,0,0,0,3905,3907,1,0,0,0,3906,3904,1,0,0,0,3907,3909,3,274,
		137,0,3908,3910,3,278,139,0,3909,3908,1,0,0,0,3909,3910,1,0,0,0,3910,3911,
		1,0,0,0,3911,3913,3,284,142,0,3912,3914,3,286,143,0,3913,3912,1,0,0,0,
		3913,3914,1,0,0,0,3914,3916,1,0,0,0,3915,3917,3,288,144,0,3916,3915,1,
		0,0,0,3916,3917,1,0,0,0,3917,3919,1,0,0,0,3918,3920,3,290,145,0,3919,3918,
		1,0,0,0,3919,3920,1,0,0,0,3920,3922,1,0,0,0,3921,3923,3,230,115,0,3922,
		3921,1,0,0,0,3922,3923,1,0,0,0,3923,3925,1,0,0,0,3924,3926,3,294,147,0,
		3925,3924,1,0,0,0,3925,3926,1,0,0,0,3926,3955,1,0,0,0,3927,3931,5,152,
		0,0,3928,3930,3,272,136,0,3929,3928,1,0,0,0,3930,3933,1,0,0,0,3931,3929,
		1,0,0,0,3931,3932,1,0,0,0,3932,3934,1,0,0,0,3933,3931,1,0,0,0,3934,3935,
		3,274,137,0,3935,3937,3,284,142,0,3936,3938,3,286,143,0,3937,3936,1,0,
		0,0,3937,3938,1,0,0,0,3938,3940,1,0,0,0,3939,3941,3,288,144,0,3940,3939,
		1,0,0,0,3940,3941,1,0,0,0,3941,3943,1,0,0,0,3942,3944,3,290,145,0,3943,
		3942,1,0,0,0,3943,3944,1,0,0,0,3944,3946,1,0,0,0,3945,3947,3,230,115,0,
		3946,3945,1,0,0,0,3946,3947,1,0,0,0,3947,3949,1,0,0,0,3948,3950,3,294,
		147,0,3949,3948,1,0,0,0,3949,3950,1,0,0,0,3950,3952,1,0,0,0,3951,3953,
		3,278,139,0,3952,3951,1,0,0,0,3952,3953,1,0,0,0,3953,3955,1,0,0,0,3954,
		3900,1,0,0,0,3954,3927,1,0,0,0,3955,253,1,0,0,0,3956,3960,5,152,0,0,3957,
		3959,3,272,136,0,3958,3957,1,0,0,0,3959,3962,1,0,0,0,3960,3958,1,0,0,0,
		3960,3961,1,0,0,0,3961,3963,1,0,0,0,3962,3960,1,0,0,0,3963,3964,3,274,
		137,0,3964,3966,3,284,142,0,3965,3967,3,286,143,0,3966,3965,1,0,0,0,3966,
		3967,1,0,0,0,3967,3969,1,0,0,0,3968,3970,3,288,144,0,3969,3968,1,0,0,0,
		3969,3970,1,0,0,0,3970,3972,1,0,0,0,3971,3973,3,290,145,0,3972,3971,1,
		0,0,0,3972,3973,1,0,0,0,3973,3975,1,0,0,0,3974,3976,3,230,115,0,3975,3974,
		1,0,0,0,3975,3976,1,0,0,0,3976,3978,1,0,0,0,3977,3979,3,294,147,0,3978,
		3977,1,0,0,0,3978,3979,1,0,0,0,3979,3981,1,0,0,0,3980,3982,3,258,129,0,
		3981,3980,1,0,0,0,3981,3982,1,0,0,0,3982,255,1,0,0,0,3983,3985,5,180,0,
		0,3984,3986,7,44,0,0,3985,3984,1,0,0,0,3985,3986,1,0,0,0,3986,3987,1,0,
		0,0,3987,3988,3,250,125,0,3988,257,1,0,0,0,3989,3991,5,180,0,0,3990,3992,
		7,44,0,0,3991,3990,1,0,0,0,3991,3992,1,0,0,0,3992,3995,1,0,0,0,3993,3996,
		3,254,127,0,3994,3996,3,250,125,0,3995,3993,1,0,0,0,3995,3994,1,0,0,0,
		3996,259,1,0,0,0,3997,4012,5,94,0,0,3998,4013,3,254,127,0,3999,4013,3,
		250,125,0,4000,4003,5,1133,0,0,4001,4004,3,254,127,0,4002,4004,3,250,125,
		0,4003,4001,1,0,0,0,4003,4002,1,0,0,0,4004,4005,1,0,0,0,4005,4010,5,1134,
		0,0,4006,4008,5,12,0,0,4007,4006,1,0,0,0,4007,4008,1,0,0,0,4008,4009,1,
		0,0,0,4009,4011,3,584,292,0,4010,4007,1,0,0,0,4010,4011,1,0,0,0,4011,4013,
		1,0,0,0,4012,3998,1,0,0,0,4012,3999,1,0,0,0,4012,4000,1,0,0,0,4013,261,
		1,0,0,0,4014,4015,5,278,0,0,4015,4016,5,1133,0,0,4016,4017,5,1148,0,0,
		4017,4018,5,1135,0,0,4018,4019,5,1148,0,0,4019,4020,5,365,0,0,4020,4021,
		5,1133,0,0,4021,4022,3,264,132,0,4022,4023,5,1134,0,0,4023,4028,5,1134,
		0,0,4024,4026,5,12,0,0,4025,4024,1,0,0,0,4025,4026,1,0,0,0,4026,4027,1,
		0,0,0,4027,4029,3,584,292,0,4028,4025,1,0,0,0,4028,4029,1,0,0,0,4029,263,
		1,0,0,0,4030,4035,3,266,133,0,4031,4032,5,1135,0,0,4032,4034,3,266,133,
		0,4033,4031,1,0,0,0,4034,4037,1,0,0,0,4035,4033,1,0,0,0,4035,4036,1,0,
		0,0,4036,265,1,0,0,0,4037,4035,1,0,0,0,4038,4055,3,556,278,0,4039,4040,
		5,65,0,0,4040,4056,5,284,0,0,4041,4053,3,604,302,0,4042,4043,5,285,0,0,
		4043,4045,5,1148,0,0,4044,4046,3,268,134,0,4045,4044,1,0,0,0,4045,4046,
		1,0,0,0,4046,4048,1,0,0,0,4047,4049,3,270,135,0,4048,4047,1,0,0,0,4048,
		4049,1,0,0,0,4049,4054,1,0,0,0,4050,4051,5,60,0,0,4051,4052,5,285,0,0,
		4052,4054,5,1148,0,0,4053,4042,1,0,0,0,4053,4050,1,0,0,0,4054,4056,1,0,
		0,0,4055,4039,1,0,0,0,4055,4041,1,0,0,0,4056,4068,1,0,0,0,4057,4059,5,
		283,0,0,4058,4060,5,285,0,0,4059,4058,1,0,0,0,4059,4060,1,0,0,0,4060,4061,
		1,0,0,0,4061,4062,5,1148,0,0,4062,4063,5,365,0,0,4063,4064,5,1133,0,0,
		4064,4065,3,264,132,0,4065,4066,5,1134,0,0,4066,4068,1,0,0,0,4067,4038,
		1,0,0,0,4067,4057,1,0,0,0,4068,267,1,0,0,0,4069,4074,5,116,0,0,4070,4074,
		5,411,0,0,4071,4072,5,42,0,0,4072,4074,3,634,317,0,4073,4069,1,0,0,0,4073,
		4070,1,0,0,0,4073,4071,1,0,0,0,4074,4075,1,0,0,0,4075,4076,5,118,0,0,4076,
		4077,5,55,0,0,4077,269,1,0,0,0,4078,4083,5,116,0,0,4079,4083,5,411,0,0,
		4080,4081,5,42,0,0,4081,4083,3,634,317,0,4082,4078,1,0,0,0,4082,4079,1,
		0,0,0,4082,4080,1,0,0,0,4083,4084,1,0,0,0,4084,4085,5,118,0,0,4085,4086,
		5,411,0,0,4086,271,1,0,0,0,4087,4096,7,52,0,0,4088,4096,5,75,0,0,4089,
		4096,5,171,0,0,4090,4096,5,166,0,0,4091,4096,5,164,0,0,4092,4096,5,625,
		0,0,4093,4096,7,53,0,0,4094,4096,5,165,0,0,4095,4087,1,0,0,0,4095,4088,
		1,0,0,0,4095,4089,1,0,0,0,4095,4090,1,0,0,0,4095,4091,1,0,0,0,4095,4092,
		1,0,0,0,4095,4093,1,0,0,0,4095,4094,1,0,0,0,4096,273,1,0,0,0,4097,4100,
		5,1117,0,0,4098,4100,3,276,138,0,4099,4097,1,0,0,0,4099,4098,1,0,0,0,4100,
		4105,1,0,0,0,4101,4102,5,1135,0,0,4102,4104,3,276,138,0,4103,4101,1,0,
		0,0,4104,4107,1,0,0,0,4105,4103,1,0,0,0,4105,4106,1,0,0,0,4106,275,1,0,
		0,0,4107,4105,1,0,0,0,4108,4109,3,550,275,0,4109,4110,5,1132,0,0,4110,
		4111,5,1117,0,0,4111,4138,1,0,0,0,4112,4117,3,556,278,0,4113,4115,5,12,
		0,0,4114,4113,1,0,0,0,4114,4115,1,0,0,0,4115,4116,1,0,0,0,4116,4118,3,
		584,292,0,4117,4114,1,0,0,0,4117,4118,1,0,0,0,4118,4138,1,0,0,0,4119,4124,
		3,648,324,0,4120,4122,5,12,0,0,4121,4120,1,0,0,0,4121,4122,1,0,0,0,4122,
		4123,1,0,0,0,4123,4125,3,584,292,0,4124,4121,1,0,0,0,4124,4125,1,0,0,0,
		4125,4138,1,0,0,0,4126,4127,5,1159,0,0,4127,4129,5,1108,0,0,4128,4126,
		1,0,0,0,4128,4129,1,0,0,0,4129,4130,1,0,0,0,4130,4135,3,688,344,0,4131,
		4133,5,12,0,0,4132,4131,1,0,0,0,4132,4133,1,0,0,0,4133,4134,1,0,0,0,4134,
		4136,3,584,292,0,4135,4132,1,0,0,0,4135,4136,1,0,0,0,4136,4138,1,0,0,0,
		4137,4108,1,0,0,0,4137,4112,1,0,0,0,4137,4119,1,0,0,0,4137,4128,1,0,0,
		0,4138,277,1,0,0,0,4139,4140,5,87,0,0,4140,4145,3,210,105,0,4141,4142,
		5,1135,0,0,4142,4144,3,210,105,0,4143,4141,1,0,0,0,4144,4147,1,0,0,0,4145,
		4143,1,0,0,0,4145,4146,1,0,0,0,4146,4176,1,0,0,0,4147,4145,1,0,0,0,4148,
		4149,5,87,0,0,4149,4150,5,400,0,0,4150,4176,5,1148,0,0,4151,4152,5,87,
		0,0,4152,4153,5,127,0,0,4153,4157,5,1148,0,0,4154,4155,5,25,0,0,4155,4156,
		5,153,0,0,4156,4158,3,568,284,0,4157,4154,1,0,0,0,4157,4158,1,0,0,0,4158,
		4165,1,0,0,0,4159,4161,7,41,0,0,4160,4162,3,280,140,0,4161,4160,1,0,0,
		0,4162,4163,1,0,0,0,4163,4161,1,0,0,0,4163,4164,1,0,0,0,4164,4166,1,0,
		0,0,4165,4159,1,0,0,0,4165,4166,1,0,0,0,4166,4173,1,0,0,0,4167,4169,5,
		101,0,0,4168,4170,3,282,141,0,4169,4168,1,0,0,0,4170,4171,1,0,0,0,4171,
		4169,1,0,0,0,4171,4172,1,0,0,0,4172,4174,1,0,0,0,4173,4167,1,0,0,0,4173,
		4174,1,0,0,0,4174,4176,1,0,0,0,4175,4139,1,0,0,0,4175,4148,1,0,0,0,4175,
		4151,1,0,0,0,4176,279,1,0,0,0,4177,4178,5,173,0,0,4178,4179,5,19,0,0,4179,
		4190,5,1148,0,0,4180,4182,5,122,0,0,4181,4180,1,0,0,0,4181,4182,1,0,0,
		0,4182,4183,1,0,0,0,4183,4184,5,56,0,0,4184,4185,5,19,0,0,4185,4190,5,
		1148,0,0,4186,4187,5,58,0,0,4187,4188,5,19,0,0,4188,4190,5,1148,0,0,4189,
		4177,1,0,0,0,4189,4181,1,0,0,0,4189,4186,1,0,0,0,4190,281,1,0,0,0,4191,
		4192,5,169,0,0,4192,4193,5,19,0,0,4193,4198,5,1148,0,0,4194,4195,5,173,
		0,0,4195,4196,5,19,0,0,4196,4198,5,1148,0,0,4197,4191,1,0,0,0,4197,4194,
		1,0,0,0,4198,283,1,0,0,0,4199,4200,5,68,0,0,4200,4202,3,234,117,0,4201,
		4199,1,0,0,0,4201,4202,1,0,0,0,4202,4205,1,0,0,0,4203,4204,5,190,0,0,4204,
		4206,3,688,344,0,4205,4203,1,0,0,0,4205,4206,1,0,0,0,4206,285,1,0,0,0,
		4207,4208,5,73,0,0,4208,4209,5,19,0,0,4209,4214,3,292,146,0,4210,4211,
		5,1135,0,0,4211,4213,3,292,146,0,4212,4210,1,0,0,0,4213,4216,1,0,0,0,4214,
		4212,1,0,0,0,4214,4215,1,0,0,0,4215,4219,1,0,0,0,4216,4214,1,0,0,0,4217,
		4218,5,192,0,0,4218,4220,5,598,0,0,4219,4217,1,0,0,0,4219,4220,1,0,0,0,
		4220,287,1,0,0,0,4221,4222,5,74,0,0,4222,4223,3,688,344,0,4223,289,1,0,
		0,0,4224,4225,5,676,0,0,4225,4226,3,666,333,0,4226,4227,5,12,0,0,4227,
		4228,5,1133,0,0,4228,4229,3,664,332,0,4229,4239,5,1134,0,0,4230,4231,5,
		1135,0,0,4231,4232,3,666,333,0,4232,4233,5,12,0,0,4233,4234,5,1133,0,0,
		4234,4235,3,664,332,0,4235,4236,5,1134,0,0,4236,4238,1,0,0,0,4237,4230,
		1,0,0,0,4238,4241,1,0,0,0,4239,4237,1,0,0,0,4239,4240,1,0,0,0,4240,291,
		1,0,0,0,4241,4239,1,0,0,0,4242,4244,3,688,344,0,4243,4245,7,48,0,0,4244,
		4243,1,0,0,0,4244,4245,1,0,0,0,4245,293,1,0,0,0,4246,4257,5,99,0,0,4247,
		4248,3,296,148,0,4248,4249,5,1135,0,0,4249,4251,1,0,0,0,4250,4247,1,0,
		0,0,4250,4251,1,0,0,0,4251,4252,1,0,0,0,4252,4258,3,296,148,0,4253,4254,
		3,296,148,0,4254,4255,5,532,0,0,4255,4256,3,296,148,0,4256,4258,1,0,0,
		0,4257,4250,1,0,0,0,4257,4253,1,0,0,0,4258,295,1,0,0,0,4259,4263,3,590,
		295,0,4260,4263,3,566,283,0,4261,4263,3,586,293,0,4262,4259,1,0,0,0,4262,
		4260,1,0,0,0,4262,4261,1,0,0,0,4263,297,1,0,0,0,4264,4265,5,629,0,0,4265,
		4274,5,653,0,0,4266,4271,3,320,160,0,4267,4268,5,1135,0,0,4268,4270,3,
		320,160,0,4269,4267,1,0,0,0,4270,4273,1,0,0,0,4271,4269,1,0,0,0,4271,4272,
		1,0,0,0,4272,4275,1,0,0,0,4273,4271,1,0,0,0,4274,4266,1,0,0,0,4274,4275,
		1,0,0,0,4275,299,1,0,0,0,4276,4278,5,344,0,0,4277,4279,5,678,0,0,4278,
		4277,1,0,0,0,4278,4279,1,0,0,0,4279,301,1,0,0,0,4280,4282,5,369,0,0,4281,
		4283,5,678,0,0,4282,4281,1,0,0,0,4282,4283,1,0,0,0,4283,4289,1,0,0,0,4284,
		4286,5,10,0,0,4285,4287,5,521,0,0,4286,4285,1,0,0,0,4286,4287,1,0,0,0,
		4287,4288,1,0,0,0,4288,4290,5,353,0,0,4289,4284,1,0,0,0,4289,4290,1,0,
		0,0,4290,4295,1,0,0,0,4291,4293,5,521,0,0,4292,4291,1,0,0,0,4292,4293,
		1,0,0,0,4293,4294,1,0,0,0,4294,4296,5,138,0,0,4295,4292,1,0,0,0,4295,4296,
		1,0,0,0,4296,303,1,0,0,0,4297,4299,5,597,0,0,4298,4300,5,678,0,0,4299,
		4298,1,0,0,0,4299,4300,1,0,0,0,4300,4306,1,0,0,0,4301,4303,5,10,0,0,4302,
		4304,5,521,0,0,4303,4302,1,0,0,0,4303,4304,1,0,0,0,4304,4305,1,0,0,0,4305,
		4307,5,353,0,0,4306,4301,1,0,0,0,4306,4307,1,0,0,0,4307,4312,1,0,0,0,4308,
		4310,5,521,0,0,4309,4308,1,0,0,0,4309,4310,1,0,0,0,4310,4311,1,0,0,0,4311,
		4313,5,138,0,0,4312,4309,1,0,0,0,4312,4313,1,0,0,0,4313,305,1,0,0,0,4314,
		4315,5,604,0,0,4315,4316,3,584,292,0,4316,307,1,0,0,0,4317,4319,5,597,
		0,0,4318,4320,5,678,0,0,4319,4318,1,0,0,0,4319,4320,1,0,0,0,4320,4321,
		1,0,0,0,4321,4323,5,175,0,0,4322,4324,5,604,0,0,4323,4322,1,0,0,0,4323,
		4324,1,0,0,0,4324,4325,1,0,0,0,4325,4326,3,584,292,0,4326,309,1,0,0,0,
		4327,4328,5,138,0,0,4328,4329,5,604,0,0,4329,4330,3,584,292,0,4330,311,
		1,0,0,0,4331,4332,5,103,0,0,4332,4333,7,54,0,0,4333,4338,3,322,161,0,4334,
		4335,5,1135,0,0,4335,4337,3,322,161,0,4336,4334,1,0,0,0,4337,4340,1,0,
		0,0,4338,4336,1,0,0,0,4338,4339,1,0,0,0,4339,4342,1,0,0,0,4340,4338,1,
		0,0,0,4341,4343,3,646,323,0,4342,4341,1,0,0,0,4342,4343,1,0,0,0,4343,313,
		1,0,0,0,4344,4345,5,182,0,0,4345,4346,5,742,0,0,4346,315,1,0,0,0,4347,
		4348,5,153,0,0,4348,4349,5,340,0,0,4349,4350,5,1124,0,0,4350,4351,7,24,
		0,0,4351,317,1,0,0,0,4352,4354,5,153,0,0,4353,4355,7,55,0,0,4354,4353,
		1,0,0,0,4354,4355,1,0,0,0,4355,4356,1,0,0,0,4356,4357,5,653,0,0,4357,4362,
		3,326,163,0,4358,4359,5,1135,0,0,4359,4361,3,326,163,0,4360,4358,1,0,0,
		0,4361,4364,1,0,0,0,4362,4360,1,0,0,0,4362,4363,1,0,0,0,4363,319,1,0,0,
		0,4364,4362,1,0,0,0,4365,4366,5,192,0,0,4366,4367,5,377,0,0,4367,4373,
		5,616,0,0,4368,4369,5,134,0,0,4369,4373,5,193,0,0,4370,4371,5,134,0,0,
		4371,4373,5,538,0,0,4372,4365,1,0,0,0,4372,4368,1,0,0,0,4372,4370,1,0,
		0,0,4373,321,1,0,0,0,4374,4379,3,552,276,0,4375,4377,5,12,0,0,4376,4375,
		1,0,0,0,4376,4377,1,0,0,0,4377,4378,1,0,0,0,4378,4380,3,584,292,0,4379,
		4376,1,0,0,0,4379,4380,1,0,0,0,4380,4381,1,0,0,0,4381,4382,3,324,162,0,
		4382,323,1,0,0,0,4383,4385,5,134,0,0,4384,4386,5,474,0,0,4385,4384,1,0,
		0,0,4385,4386,1,0,0,0,4386,4392,1,0,0,0,4387,4389,5,106,0,0,4388,4387,
		1,0,0,0,4388,4389,1,0,0,0,4389,4390,1,0,0,0,4390,4392,5,193,0,0,4391,4383,
		1,0,0,0,4391,4388,1,0,0,0,4392,325,1,0,0,0,4393,4394,5,464,0,0,4394,4395,
		5,472,0,0,4395,4401,3,328,164,0,4396,4397,5,134,0,0,4397,4401,5,193,0,
		0,4398,4399,5,134,0,0,4399,4401,5,538,0,0,4400,4393,1,0,0,0,4400,4396,
		1,0,0,0,4400,4398,1,0,0,0,4401,327,1,0,0,0,4402,4403,5,799,0,0,4403,4410,
		5,134,0,0,4404,4405,5,134,0,0,4405,4410,5,800,0,0,4406,4407,5,134,0,0,
		4407,4410,5,801,0,0,4408,4410,5,802,0,0,4409,4402,1,0,0,0,4409,4404,1,
		0,0,0,4409,4406,1,0,0,0,4409,4408,1,0,0,0,4410,329,1,0,0,0,4411,4412,5,
		24,0,0,4412,4413,5,477,0,0,4413,4414,5,175,0,0,4414,4419,3,348,174,0,4415,
		4416,5,1135,0,0,4416,4418,3,348,174,0,4417,4415,1,0,0,0,4418,4421,1,0,
		0,0,4419,4417,1,0,0,0,4419,4420,1,0,0,0,4420,4423,1,0,0,0,4421,4419,1,
		0,0,0,4422,4424,3,356,178,0,4423,4422,1,0,0,0,4423,4424,1,0,0,0,4424,331,
		1,0,0,0,4425,4426,5,24,0,0,4426,4427,5,588,0,0,4427,4428,5,429,0,0,4428,
		4433,3,358,179,0,4429,4430,5,1135,0,0,4430,4432,3,358,179,0,4431,4429,
		1,0,0,0,4432,4435,1,0,0,0,4433,4431,1,0,0,0,4433,4434,1,0,0,0,4434,333,
		1,0,0,0,4435,4433,1,0,0,0,4436,4437,5,132,0,0,4437,4438,7,56,0,0,4438,
		4443,5,476,0,0,4439,4440,5,175,0,0,4440,4444,5,1148,0,0,4441,4442,5,15,
		0,0,4442,4444,5,1148,0,0,4443,4439,1,0,0,0,4443,4441,1,0,0,0,4444,335,
		1,0,0,0,4445,4446,5,589,0,0,4446,4447,5,477,0,0,4447,337,1,0,0,0,4448,
		4449,5,589,0,0,4449,4451,5,614,0,0,4450,4452,5,6,0,0,4451,4450,1,0,0,0,
		4451,4452,1,0,0,0,4452,4454,1,0,0,0,4453,4455,3,356,178,0,4454,4453,1,
		0,0,0,4454,4455,1,0,0,0,4455,339,1,0,0,0,4456,4457,5,629,0,0,4457,4466,
		5,614,0,0,4458,4463,3,362,181,0,4459,4460,5,1135,0,0,4460,4462,3,362,181,
		0,4461,4459,1,0,0,0,4462,4465,1,0,0,0,4463,4461,1,0,0,0,4463,4464,1,0,
		0,0,4464,4467,1,0,0,0,4465,4463,1,0,0,0,4466,4458,1,0,0,0,4466,4467,1,
		0,0,0,4467,4470,1,0,0,0,4468,4469,5,663,0,0,4469,4471,3,364,182,0,4470,
		4468,1,0,0,0,4470,4471,1,0,0,0,4471,4475,1,0,0,0,4472,4474,3,366,183,0,
		4473,4472,1,0,0,0,4474,4477,1,0,0,0,4475,4473,1,0,0,0,4475,4476,1,0,0,
		0,4476,4479,1,0,0,0,4477,4475,1,0,0,0,4478,4480,3,356,178,0,4479,4478,
		1,0,0,0,4479,4480,1,0,0,0,4480,341,1,0,0,0,4481,4482,5,635,0,0,4482,4491,
		5,614,0,0,4483,4488,3,362,181,0,4484,4485,5,1135,0,0,4485,4487,3,362,181,
		0,4486,4484,1,0,0,0,4487,4490,1,0,0,0,4488,4486,1,0,0,0,4488,4489,1,0,
		0,0,4489,4492,1,0,0,0,4490,4488,1,0,0,0,4491,4483,1,0,0,0,4491,4492,1,
		0,0,0,4492,343,1,0,0,0,4493,4494,5,629,0,0,4494,4495,5,441,0,0,4495,345,
		1,0,0,0,4496,4497,5,635,0,0,4497,4498,5,441,0,0,4498,347,1,0,0,0,4499,
		4500,3,350,175,0,4500,4501,5,1124,0,0,4501,4502,5,1148,0,0,4502,4529,1,
		0,0,0,4503,4504,3,352,176,0,4504,4505,5,1124,0,0,4505,4506,3,590,295,0,
		4506,4529,1,0,0,0,4507,4508,3,354,177,0,4508,4509,5,1124,0,0,4509,4510,
		7,24,0,0,4510,4529,1,0,0,0,4511,4512,5,481,0,0,4512,4513,5,1124,0,0,4513,
		4529,5,1151,0,0,4514,4515,5,449,0,0,4515,4516,5,1124,0,0,4516,4525,5,1133,
		0,0,4517,4522,3,584,292,0,4518,4519,5,1135,0,0,4519,4521,3,584,292,0,4520,
		4518,1,0,0,0,4521,4524,1,0,0,0,4522,4520,1,0,0,0,4522,4523,1,0,0,0,4523,
		4526,1,0,0,0,4524,4522,1,0,0,0,4525,4517,1,0,0,0,4525,4526,1,0,0,0,4526,
		4527,1,0,0,0,4527,4529,5,1134,0,0,4528,4499,1,0,0,0,4528,4503,1,0,0,0,
		4528,4507,1,0,0,0,4528,4511,1,0,0,0,4528,4514,1,0,0,0,4529,349,1,0,0,0,
		4530,4531,7,57,0,0,4531,351,1,0,0,0,4532,4533,7,58,0,0,4533,353,1,0,0,
		0,4534,4535,7,59,0,0,4535,355,1,0,0,0,4536,4537,5,65,0,0,4537,4538,5,355,
		0,0,4538,4539,5,1148,0,0,4539,357,1,0,0,0,4540,4541,5,581,0,0,4541,4542,
		5,1124,0,0,4542,4543,5,1133,0,0,4543,4544,3,616,308,0,4544,4545,5,1134,
		0,0,4545,4590,1,0,0,0,4546,4547,5,583,0,0,4547,4548,5,1124,0,0,4548,4549,
		5,1133,0,0,4549,4550,3,616,308,0,4550,4551,5,1134,0,0,4551,4590,1,0,0,
		0,4552,4553,5,582,0,0,4553,4554,5,1124,0,0,4554,4555,5,1133,0,0,4555,4556,
		3,620,310,0,4556,4557,5,1134,0,0,4557,4590,1,0,0,0,4558,4559,5,584,0,0,
		4559,4560,5,1124,0,0,4560,4561,5,1133,0,0,4561,4562,3,620,310,0,4562,4563,
		5,1134,0,0,4563,4590,1,0,0,0,4564,4565,5,586,0,0,4565,4566,5,1124,0,0,
		4566,4567,5,1133,0,0,4567,4568,3,630,315,0,4568,4569,5,1134,0,0,4569,4590,
		1,0,0,0,4570,4571,5,587,0,0,4571,4572,5,1124,0,0,4572,4573,5,1133,0,0,
		4573,4574,3,630,315,0,4574,4575,5,1134,0,0,4575,4590,1,0,0,0,4576,4577,
		5,585,0,0,4577,4578,5,1124,0,0,4578,4579,5,1133,0,0,4579,4584,3,360,180,
		0,4580,4581,5,1135,0,0,4581,4583,3,360,180,0,4582,4580,1,0,0,0,4583,4586,
		1,0,0,0,4584,4582,1,0,0,0,4584,4585,1,0,0,0,4585,4587,1,0,0,0,4586,4584,
		1,0,0,0,4587,4588,5,1134,0,0,4588,4590,1,0,0,0,4589,4540,1,0,0,0,4589,
		4546,1,0,0,0,4589,4552,1,0,0,0,4589,4558,1,0,0,0,4589,4564,1,0,0,0,4589,
		4570,1,0,0,0,4589,4576,1,0,0,0,4590,359,1,0,0,0,4591,4592,5,1133,0,0,4592,
		4593,3,552,276,0,4593,4594,5,1135,0,0,4594,4595,3,552,276,0,4595,4596,
		5,1134,0,0,4596,361,1,0,0,0,4597,4598,7,60,0,0,4598,363,1,0,0,0,4599,4600,
		7,61,0,0,4600,4601,5,1124,0,0,4601,4618,3,368,184,0,4602,4603,5,483,0,
		0,4603,4604,5,1124,0,0,4604,4605,5,1148,0,0,4605,4606,5,1135,0,0,4606,
		4607,5,484,0,0,4607,4608,5,1124,0,0,4608,4618,3,590,295,0,4609,4610,5,
		575,0,0,4610,4611,5,1124,0,0,4611,4612,5,1148,0,0,4612,4613,5,1135,0,0,
		4613,4614,5,576,0,0,4614,4615,5,1124,0,0,4615,4618,3,590,295,0,4616,4618,
		5,623,0,0,4617,4599,1,0,0,0,4617,4602,1,0,0,0,4617,4609,1,0,0,0,4617,4616,
		1,0,0,0,4618,365,1,0,0,0,4619,4620,5,665,0,0,4620,4621,5,1124,0,0,4621,
		4632,5,1148,0,0,4622,4623,5,551,0,0,4623,4624,5,1124,0,0,4624,4632,5,1148,
		0,0,4625,4626,5,391,0,0,4626,4627,5,1124,0,0,4627,4632,5,1148,0,0,4628,
		4629,5,555,0,0,4629,4630,5,1124,0,0,4630,4632,5,1148,0,0,4631,4619,1,0,
		0,0,4631,4622,1,0,0,0,4631,4625,1,0,0,0,4631,4628,1,0,0,0,4632,367,1,0,
		0,0,4633,4638,3,576,288,0,4634,4635,5,1135,0,0,4635,4637,3,576,288,0,4636,
		4634,1,0,0,0,4637,4640,1,0,0,0,4638,4636,1,0,0,0,4638,4639,1,0,0,0,4639,
		4643,1,0,0,0,4640,4638,1,0,0,0,4641,4643,5,1148,0,0,4642,4633,1,0,0,0,
		4642,4641,1,0,0,0,4643,369,1,0,0,0,4644,4645,5,681,0,0,4645,4646,7,62,
		0,0,4646,4648,3,578,289,0,4647,4649,7,63,0,0,4648,4647,1,0,0,0,4648,4649,
		1,0,0,0,4649,371,1,0,0,0,4650,4651,5,681,0,0,4651,4652,5,407,0,0,4652,
		4658,3,578,289,0,4653,4656,5,643,0,0,4654,4655,5,65,0,0,4655,4657,5,509,
		0,0,4656,4654,1,0,0,0,4656,4657,1,0,0,0,4657,4659,1,0,0,0,4658,4653,1,
		0,0,0,4658,4659,1,0,0,0,4659,373,1,0,0,0,4660,4661,5,681,0,0,4661,4662,
		5,560,0,0,4662,4663,3,578,289,0,4663,375,1,0,0,0,4664,4665,5,681,0,0,4665,
		4666,5,369,0,0,4666,4669,3,578,289,0,4667,4668,5,536,0,0,4668,4670,5,553,
		0,0,4669,4667,1,0,0,0,4669,4670,1,0,0,0,4670,377,1,0,0,0,4671,4672,5,681,
		0,0,4672,4673,5,597,0,0,4673,4674,3,578,289,0,4674,379,1,0,0,0,4675,4676,
		5,681,0,0,4676,4679,5,570,0,0,4677,4678,5,32,0,0,4678,4680,3,578,289,0,
		4679,4677,1,0,0,0,4679,4680,1,0,0,0,4680,381,1,0,0,0,4681,4682,5,560,0,
		0,4682,4683,3,584,292,0,4683,4686,5,68,0,0,4684,4687,5,1148,0,0,4685,4687,
		5,1159,0,0,4686,4684,1,0,0,0,4686,4685,1,0,0,0,4687,383,1,0,0,0,4688,4689,
		5,708,0,0,4689,4692,3,584,292,0,4690,4691,5,187,0,0,4691,4693,3,632,316,
		0,4692,4690,1,0,0,0,4692,4693,1,0,0,0,4693,385,1,0,0,0,4694,4695,7,64,
		0,0,4695,4696,5,560,0,0,4696,4697,3,584,292,0,4697,387,1,0,0,0,4698,4701,
		3,390,195,0,4699,4701,3,4,2,0,4700,4698,1,0,0,0,4700,4699,1,0,0,0,4701,
		389,1,0,0,0,4702,4703,3,584,292,0,4703,4704,5,1144,0,0,4704,4706,1,0,0,
		0,4705,4702,1,0,0,0,4705,4706,1,0,0,0,4706,4707,1,0,0,0,4707,4713,5,344,
		0,0,4708,4709,3,410,205,0,4709,4710,5,1136,0,0,4710,4712,1,0,0,0,4711,
		4708,1,0,0,0,4712,4715,1,0,0,0,4713,4711,1,0,0,0,4713,4714,1,0,0,0,4714,
		4721,1,0,0,0,4715,4713,1,0,0,0,4716,4717,3,412,206,0,4717,4718,5,1136,
		0,0,4718,4720,1,0,0,0,4719,4716,1,0,0,0,4720,4723,1,0,0,0,4721,4719,1,
		0,0,0,4721,4722,1,0,0,0,4722,4729,1,0,0,0,4723,4721,1,0,0,0,4724,4725,
		3,414,207,0,4725,4726,5,1136,0,0,4726,4728,1,0,0,0,4727,4724,1,0,0,0,4728,
		4731,1,0,0,0,4729,4727,1,0,0,0,4729,4730,1,0,0,0,4730,4737,1,0,0,0,4731,
		4729,1,0,0,0,4732,4733,3,416,208,0,4733,4734,5,1136,0,0,4734,4736,1,0,
		0,0,4735,4732,1,0,0,0,4736,4739,1,0,0,0,4737,4735,1,0,0,0,4737,4738,1,
		0,0,0,4738,4743,1,0,0,0,4739,4737,1,0,0,0,4740,4742,3,420,210,0,4741,4740,
		1,0,0,0,4742,4745,1,0,0,0,4743,4741,1,0,0,0,4743,4744,1,0,0,0,4744,4746,
		1,0,0,0,4745,4743,1,0,0,0,4746,4748,5,407,0,0,4747,4749,3,584,292,0,4748,
		4747,1,0,0,0,4748,4749,1,0,0,0,4749,391,1,0,0,0,4750,4753,5,22,0,0,4751,
		4754,3,584,292,0,4752,4754,3,688,344,0,4753,4751,1,0,0,0,4753,4752,1,0,
		0,0,4753,4754,1,0,0,0,4754,4756,1,0,0,0,4755,4757,3,422,211,0,4756,4755,
		1,0,0,0,4757,4758,1,0,0,0,4758,4756,1,0,0,0,4758,4759,1,0,0,0,4759,4766,
		1,0,0,0,4760,4762,5,53,0,0,4761,4763,3,420,210,0,4762,4761,1,0,0,0,4763,
		4764,1,0,0,0,4764,4762,1,0,0,0,4764,4765,1,0,0,0,4765,4767,1,0,0,0,4766,
		4760,1,0,0,0,4766,4767,1,0,0,0,4767,4768,1,0,0,0,4768,4769,5,407,0,0,4769,
		4770,5,22,0,0,4770,393,1,0,0,0,4771,4772,5,77,0,0,4772,4773,3,688,344,
		0,4773,4775,5,174,0,0,4774,4776,3,420,210,0,4775,4774,1,0,0,0,4776,4777,
		1,0,0,0,4777,4775,1,0,0,0,4777,4778,1,0,0,0,4778,4782,1,0,0,0,4779,4781,
		3,424,212,0,4780,4779,1,0,0,0,4781,4784,1,0,0,0,4782,4780,1,0,0,0,4782,
		4783,1,0,0,0,4783,4791,1,0,0,0,4784,4782,1,0,0,0,4785,4787,5,53,0,0,4786,
		4788,3,420,210,0,4787,4786,1,0,0,0,4788,4789,1,0,0,0,4789,4787,1,0,0,0,
		4789,4790,1,0,0,0,4790,4792,1,0,0,0,4791,4785,1,0,0,0,4791,4792,1,0,0,
		0,4792,4793,1,0,0,0,4793,4794,5,407,0,0,4794,4795,5,77,0,0,4795,395,1,
		0,0,0,4796,4797,5,89,0,0,4797,4798,3,584,292,0,4798,397,1,0,0,0,4799,4800,
		5,96,0,0,4800,4801,3,584,292,0,4801,399,1,0,0,0,4802,4803,3,584,292,0,
		4803,4804,5,1144,0,0,4804,4806,1,0,0,0,4805,4802,1,0,0,0,4805,4806,1,0,
		0,0,4806,4807,1,0,0,0,4807,4809,5,105,0,0,4808,4810,3,420,210,0,4809,4808,
		1,0,0,0,4810,4811,1,0,0,0,4811,4809,1,0,0,0,4811,4812,1,0,0,0,4812,4813,
		1,0,0,0,4813,4814,5,407,0,0,4814,4816,5,105,0,0,4815,4817,3,584,292,0,
		4816,4815,1,0,0,0,4816,4817,1,0,0,0,4817,401,1,0,0,0,4818,4819,3,584,292,
		0,4819,4820,5,1144,0,0,4820,4822,1,0,0,0,4821,4818,1,0,0,0,4821,4822,1,
		0,0,0,4822,4823,1,0,0,0,4823,4825,5,140,0,0,4824,4826,3,420,210,0,4825,
		4824,1,0,0,0,4826,4827,1,0,0,0,4827,4825,1,0,0,0,4827,4828,1,0,0,0,4828,
		4829,1,0,0,0,4829,4830,5,663,0,0,4830,4831,3,688,344,0,4831,4832,5,407,
		0,0,4832,4834,5,140,0,0,4833,4835,3,584,292,0,4834,4833,1,0,0,0,4834,4835,
		1,0,0,0,4835,403,1,0,0,0,4836,4837,5,146,0,0,4837,4838,3,688,344,0,4838,
		405,1,0,0,0,4839,4840,3,584,292,0,4840,4841,5,1144,0,0,4841,4843,1,0,0,
		0,4842,4839,1,0,0,0,4842,4843,1,0,0,0,4843,4844,1,0,0,0,4844,4845,5,191,
		0,0,4845,4846,3,688,344,0,4846,4848,5,399,0,0,4847,4849,3,420,210,0,4848,
		4847,1,0,0,0,4849,4850,1,0,0,0,4850,4848,1,0,0,0,4850,4851,1,0,0,0,4851,
		4852,1,0,0,0,4852,4853,5,407,0,0,4853,4855,5,191,0,0,4854,4856,3,584,292,
		0,4855,4854,1,0,0,0,4855,4856,1,0,0,0,4856,407,1,0,0,0,4857,4858,5,361,
		0,0,4858,4873,3,584,292,0,4859,4864,5,64,0,0,4860,4862,5,520,0,0,4861,
		4860,1,0,0,0,4861,4862,1,0,0,0,4862,4863,1,0,0,0,4863,4865,5,68,0,0,4864,
		4861,1,0,0,0,4864,4865,1,0,0,0,4865,4866,1,0,0,0,4866,4867,3,584,292,0,
		4867,4868,5,87,0,0,4868,4869,3,616,308,0,4869,4873,1,0,0,0,4870,4871,5,
		539,0,0,4871,4873,3,584,292,0,4872,4857,1,0,0,0,4872,4859,1,0,0,0,4872,
		4870,1,0,0,0,4873,409,1,0,0,0,4874,4875,5,41,0,0,4875,4876,3,616,308,0,
		4876,4879,3,604,302,0,4877,4878,5,42,0,0,4878,4880,3,688,344,0,4879,4877,
		1,0,0,0,4879,4880,1,0,0,0,4880,411,1,0,0,0,4881,4882,5,41,0,0,4882,4883,
		3,584,292,0,4883,4884,5,29,0,0,4884,4891,5,65,0,0,4885,4892,3,590,295,
		0,4886,4888,5,162,0,0,4887,4889,5,669,0,0,4888,4887,1,0,0,0,4888,4889,
		1,0,0,0,4889,4890,1,0,0,0,4890,4892,5,1148,0,0,4891,4885,1,0,0,0,4891,
		4886,1,0,0,0,4892,413,1,0,0,0,4893,4894,5,41,0,0,4894,4895,3,584,292,0,
		4895,4896,5,38,0,0,4896,4897,5,65,0,0,4897,4898,3,200,100,0,4898,415,1,
		0,0,0,4899,4900,5,41,0,0,4900,4901,7,65,0,0,4901,4902,5,442,0,0,4902,4903,
		5,65,0,0,4903,4908,3,418,209,0,4904,4905,5,1135,0,0,4905,4907,3,418,209,
		0,4906,4904,1,0,0,0,4907,4910,1,0,0,0,4908,4906,1,0,0,0,4908,4909,1,0,
		0,0,4909,4911,1,0,0,0,4910,4908,1,0,0,0,4911,4912,3,388,194,0,4912,417,
		1,0,0,0,4913,4925,3,590,295,0,4914,4916,5,162,0,0,4915,4917,5,669,0,0,
		4916,4915,1,0,0,0,4916,4917,1,0,0,0,4917,4918,1,0,0,0,4918,4925,5,1148,
		0,0,4919,4925,3,584,292,0,4920,4925,5,163,0,0,4921,4922,5,114,0,0,4922,
		4925,5,435,0,0,4923,4925,5,161,0,0,4924,4913,1,0,0,0,4924,4914,1,0,0,0,
		4924,4919,1,0,0,0,4924,4920,1,0,0,0,4924,4921,1,0,0,0,4924,4923,1,0,0,
		0,4925,419,1,0,0,0,4926,4929,3,18,9,0,4927,4929,3,4,2,0,4928,4926,1,0,
		0,0,4928,4927,1,0,0,0,4929,4930,1,0,0,0,4930,4931,5,1136,0,0,4931,421,
		1,0,0,0,4932,4935,5,189,0,0,4933,4936,3,602,301,0,4934,4936,3,688,344,
		0,4935,4933,1,0,0,0,4935,4934,1,0,0,0,4936,4937,1,0,0,0,4937,4939,5,174,
		0,0,4938,4940,3,420,210,0,4939,4938,1,0,0,0,4940,4941,1,0,0,0,4941,4939,
		1,0,0,0,4941,4942,1,0,0,0,4942,423,1,0,0,0,4943,4944,5,54,0,0,4944,4945,
		3,688,344,0,4945,4947,5,174,0,0,4946,4948,3,420,210,0,4947,4946,1,0,0,
		0,4948,4949,1,0,0,0,4949,4947,1,0,0,0,4949,4950,1,0,0,0,4950,425,1,0,0,
		0,4951,4952,5,7,0,0,4952,4953,5,665,0,0,4953,4958,3,446,223,0,4954,4955,
		5,1135,0,0,4955,4957,3,446,223,0,4956,4954,1,0,0,0,4957,4960,1,0,0,0,4958,
		4956,1,0,0,0,4958,4959,1,0,0,0,4959,5025,1,0,0,0,4960,4958,1,0,0,0,4961,
		4962,5,7,0,0,4962,4964,5,665,0,0,4963,4965,3,640,320,0,4964,4963,1,0,0,
		0,4964,4965,1,0,0,0,4965,4966,1,0,0,0,4966,4971,3,448,224,0,4967,4968,
		5,1135,0,0,4968,4970,3,448,224,0,4969,4967,1,0,0,0,4970,4973,1,0,0,0,4971,
		4969,1,0,0,0,4971,4972,1,0,0,0,4972,4988,1,0,0,0,4973,4971,1,0,0,0,4974,
		4986,5,142,0,0,4975,4987,5,529,0,0,4976,4983,3,454,227,0,4977,4979,5,10,
		0,0,4978,4977,1,0,0,0,4978,4979,1,0,0,0,4979,4980,1,0,0,0,4980,4982,3,
		454,227,0,4981,4978,1,0,0,0,4982,4985,1,0,0,0,4983,4981,1,0,0,0,4983,4984,
		1,0,0,0,4984,4987,1,0,0,0,4985,4983,1,0,0,0,4986,4975,1,0,0,0,4986,4976,
		1,0,0,0,4987,4989,1,0,0,0,4988,4974,1,0,0,0,4988,4989,1,0,0,0,4989,4996,
		1,0,0,0,4990,4992,5,192,0,0,4991,4993,3,456,228,0,4992,4991,1,0,0,0,4993,
		4994,1,0,0,0,4994,4992,1,0,0,0,4994,4995,1,0,0,0,4995,4997,1,0,0,0,4996,
		4990,1,0,0,0,4996,4997,1,0,0,0,4997,5002,1,0,0,0,4998,5001,3,458,229,0,
		4999,5001,3,460,230,0,5000,4998,1,0,0,0,5000,4999,1,0,0,0,5001,5004,1,
		0,0,0,5002,5000,1,0,0,0,5002,5003,1,0,0,0,5003,5009,1,0,0,0,5004,5002,
		1,0,0,0,5005,5006,5,368,0,0,5006,5010,5,1148,0,0,5007,5008,5,14,0,0,5008,
		5010,5,1148,0,0,5009,5005,1,0,0,0,5009,5007,1,0,0,0,5009,5010,1,0,0,0,
		5010,5025,1,0,0,0,5011,5012,5,7,0,0,5012,5014,5,665,0,0,5013,5015,3,640,
		320,0,5014,5013,1,0,0,0,5014,5015,1,0,0,0,5015,5018,1,0,0,0,5016,5019,
		3,564,282,0,5017,5019,3,584,292,0,5018,5016,1,0,0,0,5018,5017,1,0,0,0,
		5019,5020,1,0,0,0,5020,5021,5,42,0,0,5021,5022,5,596,0,0,5022,5023,3,434,
		217,0,5023,5025,1,0,0,0,5024,4951,1,0,0,0,5024,4961,1,0,0,0,5024,5011,
		1,0,0,0,5025,427,1,0,0,0,5026,5027,5,33,0,0,5027,5028,5,665,0,0,5028,5033,
		3,448,224,0,5029,5030,5,1135,0,0,5030,5032,3,448,224,0,5031,5029,1,0,0,
		0,5032,5035,1,0,0,0,5033,5031,1,0,0,0,5033,5034,1,0,0,0,5034,5092,1,0,
		0,0,5035,5033,1,0,0,0,5036,5037,5,33,0,0,5037,5039,5,665,0,0,5038,5040,
		3,642,321,0,5039,5038,1,0,0,0,5039,5040,1,0,0,0,5040,5041,1,0,0,0,5041,
		5046,3,448,224,0,5042,5043,5,1135,0,0,5043,5045,3,448,224,0,5044,5042,
		1,0,0,0,5045,5048,1,0,0,0,5046,5044,1,0,0,0,5046,5047,1,0,0,0,5047,5052,
		1,0,0,0,5048,5046,1,0,0,0,5049,5050,5,42,0,0,5050,5051,5,596,0,0,5051,
		5053,3,434,217,0,5052,5049,1,0,0,0,5052,5053,1,0,0,0,5053,5068,1,0,0,0,
		5054,5066,5,142,0,0,5055,5067,5,529,0,0,5056,5063,3,454,227,0,5057,5059,
		5,10,0,0,5058,5057,1,0,0,0,5058,5059,1,0,0,0,5059,5060,1,0,0,0,5060,5062,
		3,454,227,0,5061,5058,1,0,0,0,5062,5065,1,0,0,0,5063,5061,1,0,0,0,5063,
		5064,1,0,0,0,5064,5067,1,0,0,0,5065,5063,1,0,0,0,5066,5055,1,0,0,0,5066,
		5056,1,0,0,0,5067,5069,1,0,0,0,5068,5054,1,0,0,0,5068,5069,1,0,0,0,5069,
		5076,1,0,0,0,5070,5072,5,192,0,0,5071,5073,3,456,228,0,5072,5071,1,0,0,
		0,5073,5074,1,0,0,0,5074,5072,1,0,0,0,5074,5075,1,0,0,0,5075,5077,1,0,
		0,0,5076,5070,1,0,0,0,5076,5077,1,0,0,0,5077,5082,1,0,0,0,5078,5081,3,
		458,229,0,5079,5081,3,460,230,0,5080,5078,1,0,0,0,5080,5079,1,0,0,0,5081,
		5084,1,0,0,0,5082,5080,1,0,0,0,5082,5083,1,0,0,0,5083,5089,1,0,0,0,5084,
		5082,1,0,0,0,5085,5086,5,368,0,0,5086,5090,5,1148,0,0,5087,5088,5,14,0,
		0,5088,5090,5,1148,0,0,5089,5085,1,0,0,0,5089,5087,1,0,0,0,5089,5090,1,
		0,0,0,5090,5092,1,0,0,0,5091,5026,1,0,0,0,5091,5036,1,0,0,0,5092,429,1,
		0,0,0,5093,5094,5,51,0,0,5094,5096,5,665,0,0,5095,5097,3,640,320,0,5096,
		5095,1,0,0,0,5096,5097,1,0,0,0,5097,5098,1,0,0,0,5098,5103,3,564,282,0,
		5099,5100,5,1135,0,0,5100,5102,3,564,282,0,5101,5099,1,0,0,0,5102,5105,
		1,0,0,0,5103,5101,1,0,0,0,5103,5104,1,0,0,0,5104,431,1,0,0,0,5105,5103,
		1,0,0,0,5106,5107,5,72,0,0,5107,5112,3,462,231,0,5108,5109,5,1135,0,0,
		5109,5111,3,462,231,0,5110,5108,1,0,0,0,5111,5114,1,0,0,0,5112,5110,1,
		0,0,0,5112,5113,1,0,0,0,5113,5115,1,0,0,0,5114,5112,1,0,0,0,5115,5117,
		5,118,0,0,5116,5118,7,66,0,0,5117,5116,1,0,0,0,5117,5118,1,0,0,0,5118,
		5119,1,0,0,0,5119,5120,3,466,233,0,5120,5121,5,175,0,0,5121,5126,3,448,
		224,0,5122,5123,5,1135,0,0,5123,5125,3,448,224,0,5124,5122,1,0,0,0,5125,
		5128,1,0,0,0,5126,5124,1,0,0,0,5126,5127,1,0,0,0,5127,5143,1,0,0,0,5128,
		5126,1,0,0,0,5129,5141,5,142,0,0,5130,5142,5,529,0,0,5131,5138,3,454,227,
		0,5132,5134,5,10,0,0,5133,5132,1,0,0,0,5133,5134,1,0,0,0,5134,5135,1,0,
		0,0,5135,5137,3,454,227,0,5136,5133,1,0,0,0,5137,5140,1,0,0,0,5138,5136,
		1,0,0,0,5138,5139,1,0,0,0,5139,5142,1,0,0,0,5140,5138,1,0,0,0,5141,5130,
		1,0,0,0,5141,5131,1,0,0,0,5142,5144,1,0,0,0,5143,5129,1,0,0,0,5143,5144,
		1,0,0,0,5144,5154,1,0,0,0,5145,5151,5,192,0,0,5146,5147,5,72,0,0,5147,
		5150,5,120,0,0,5148,5150,3,456,228,0,5149,5146,1,0,0,0,5149,5148,1,0,0,
		0,5150,5153,1,0,0,0,5151,5149,1,0,0,0,5151,5152,1,0,0,0,5152,5155,1,0,
		0,0,5153,5151,1,0,0,0,5154,5145,1,0,0,0,5154,5155,1,0,0,0,5155,5162,1,
		0,0,0,5156,5157,5,12,0,0,5157,5158,3,564,282,0,5158,5159,5,192,0,0,5159,
		5160,5,596,0,0,5160,5161,3,434,217,0,5161,5163,1,0,0,0,5162,5156,1,0,0,
		0,5162,5163,1,0,0,0,5163,5200,1,0,0,0,5164,5167,5,72,0,0,5165,5168,3,564,
		282,0,5166,5168,3,584,292,0,5167,5165,1,0,0,0,5167,5166,1,0,0,0,5168,5176,
		1,0,0,0,5169,5172,5,1135,0,0,5170,5173,3,564,282,0,5171,5173,3,584,292,
		0,5172,5170,1,0,0,0,5172,5171,1,0,0,0,5173,5175,1,0,0,0,5174,5169,1,0,
		0,0,5175,5178,1,0,0,0,5176,5174,1,0,0,0,5176,5177,1,0,0,0,5177,5179,1,
		0,0,0,5178,5176,1,0,0,0,5179,5182,5,175,0,0,5180,5183,3,564,282,0,5181,
		5183,3,584,292,0,5182,5180,1,0,0,0,5182,5181,1,0,0,0,5183,5191,1,0,0,0,
		5184,5187,5,1135,0,0,5185,5188,3,564,282,0,5186,5188,3,584,292,0,5187,
		5185,1,0,0,0,5187,5186,1,0,0,0,5188,5190,1,0,0,0,5189,5184,1,0,0,0,5190,
		5193,1,0,0,0,5191,5189,1,0,0,0,5191,5192,1,0,0,0,5192,5197,1,0,0,0,5193,
		5191,1,0,0,0,5194,5195,5,192,0,0,5195,5196,5,697,0,0,5196,5198,5,120,0,
		0,5197,5194,1,0,0,0,5197,5198,1,0,0,0,5198,5200,1,0,0,0,5199,5106,1,0,
		0,0,5199,5164,1,0,0,0,5200,433,1,0,0,0,5201,5224,5,42,0,0,5202,5224,5,
		529,0,0,5203,5213,5,6,0,0,5204,5205,5,59,0,0,5205,5210,3,564,282,0,5206,
		5207,5,1135,0,0,5207,5209,3,564,282,0,5208,5206,1,0,0,0,5209,5212,1,0,
		0,0,5210,5208,1,0,0,0,5210,5211,1,0,0,0,5211,5214,1,0,0,0,5212,5210,1,
		0,0,0,5213,5204,1,0,0,0,5213,5214,1,0,0,0,5214,5224,1,0,0,0,5215,5220,
		3,564,282,0,5216,5217,5,1135,0,0,5217,5219,3,564,282,0,5218,5216,1,0,0,
		0,5219,5222,1,0,0,0,5220,5218,1,0,0,0,5220,5221,1,0,0,0,5221,5224,1,0,
		0,0,5222,5220,1,0,0,0,5223,5201,1,0,0,0,5223,5202,1,0,0,0,5223,5203,1,
		0,0,0,5223,5215,1,0,0,0,5224,435,1,0,0,0,5225,5226,5,72,0,0,5226,5227,
		5,566,0,0,5227,5228,5,118,0,0,5228,5229,3,564,282,0,5229,5230,5,175,0,
		0,5230,5235,3,564,282,0,5231,5232,5,1135,0,0,5232,5234,3,564,282,0,5233,
		5231,1,0,0,0,5234,5237,1,0,0,0,5235,5233,1,0,0,0,5235,5236,1,0,0,0,5236,
		5241,1,0,0,0,5237,5235,1,0,0,0,5238,5239,5,192,0,0,5239,5240,5,72,0,0,
		5240,5242,5,120,0,0,5241,5238,1,0,0,0,5241,5242,1,0,0,0,5242,437,1,0,0,
		0,5243,5244,5,139,0,0,5244,5245,5,665,0,0,5245,5250,3,468,234,0,5246,5247,
		5,1135,0,0,5247,5249,3,468,234,0,5248,5246,1,0,0,0,5249,5252,1,0,0,0,5250,
		5248,1,0,0,0,5250,5251,1,0,0,0,5251,439,1,0,0,0,5252,5250,1,0,0,0,5253,
		5254,5,147,0,0,5254,5259,3,462,231,0,5255,5256,5,1135,0,0,5256,5258,3,
		462,231,0,5257,5255,1,0,0,0,5258,5261,1,0,0,0,5259,5257,1,0,0,0,5259,5260,
		1,0,0,0,5260,5262,1,0,0,0,5261,5259,1,0,0,0,5262,5264,5,118,0,0,5263,5265,
		7,66,0,0,5264,5263,1,0,0,0,5264,5265,1,0,0,0,5265,5266,1,0,0,0,5266,5267,
		3,466,233,0,5267,5268,5,68,0,0,5268,5273,3,564,282,0,5269,5270,5,1135,
		0,0,5270,5272,3,564,282,0,5271,5269,1,0,0,0,5272,5275,1,0,0,0,5273,5271,
		1,0,0,0,5273,5274,1,0,0,0,5274,5324,1,0,0,0,5275,5273,1,0,0,0,5276,5277,
		5,147,0,0,5277,5279,5,6,0,0,5278,5280,5,725,0,0,5279,5278,1,0,0,0,5279,
		5280,1,0,0,0,5280,5281,1,0,0,0,5281,5282,5,1135,0,0,5282,5283,5,72,0,0,
		5283,5284,5,120,0,0,5284,5285,5,68,0,0,5285,5290,3,564,282,0,5286,5287,
		5,1135,0,0,5287,5289,3,564,282,0,5288,5286,1,0,0,0,5289,5292,1,0,0,0,5290,
		5288,1,0,0,0,5290,5291,1,0,0,0,5291,5324,1,0,0,0,5292,5290,1,0,0,0,5293,
		5296,5,147,0,0,5294,5297,3,564,282,0,5295,5297,3,584,292,0,5296,5294,1,
		0,0,0,5296,5295,1,0,0,0,5297,5305,1,0,0,0,5298,5301,5,1135,0,0,5299,5302,
		3,564,282,0,5300,5302,3,584,292,0,5301,5299,1,0,0,0,5301,5300,1,0,0,0,
		5302,5304,1,0,0,0,5303,5298,1,0,0,0,5304,5307,1,0,0,0,5305,5303,1,0,0,
		0,5305,5306,1,0,0,0,5306,5308,1,0,0,0,5307,5305,1,0,0,0,5308,5311,5,68,
		0,0,5309,5312,3,564,282,0,5310,5312,3,584,292,0,5311,5309,1,0,0,0,5311,
		5310,1,0,0,0,5312,5320,1,0,0,0,5313,5316,5,1135,0,0,5314,5317,3,564,282,
		0,5315,5317,3,584,292,0,5316,5314,1,0,0,0,5316,5315,1,0,0,0,5317,5319,
		1,0,0,0,5318,5313,1,0,0,0,5319,5322,1,0,0,0,5320,5318,1,0,0,0,5320,5321,
		1,0,0,0,5321,5324,1,0,0,0,5322,5320,1,0,0,0,5323,5253,1,0,0,0,5323,5276,
		1,0,0,0,5323,5293,1,0,0,0,5324,441,1,0,0,0,5325,5326,5,147,0,0,5326,5327,
		5,566,0,0,5327,5328,5,118,0,0,5328,5329,3,564,282,0,5329,5330,5,68,0,0,
		5330,5335,3,564,282,0,5331,5332,5,1135,0,0,5332,5334,3,564,282,0,5333,
		5331,1,0,0,0,5334,5337,1,0,0,0,5335,5333,1,0,0,0,5335,5336,1,0,0,0,5336,
		443,1,0,0,0,5337,5335,1,0,0,0,5338,5339,5,153,0,0,5339,5342,5,551,0,0,
		5340,5341,5,65,0,0,5341,5343,3,564,282,0,5342,5340,1,0,0,0,5342,5343,1,
		0,0,0,5343,5344,1,0,0,0,5344,5347,5,1124,0,0,5345,5348,3,682,341,0,5346,
		5348,5,1148,0,0,5347,5345,1,0,0,0,5347,5346,1,0,0,0,5348,445,1,0,0,0,5349,
		5350,3,564,282,0,5350,5351,3,458,229,0,5351,447,1,0,0,0,5352,5353,3,564,
		282,0,5353,5354,5,448,0,0,5354,5355,5,19,0,0,5355,5356,5,551,0,0,5356,
		5357,5,1148,0,0,5357,5378,1,0,0,0,5358,5359,3,564,282,0,5359,5360,5,448,
		0,0,5360,5361,5,19,0,0,5361,5362,5,991,0,0,5362,5363,5,551,0,0,5363,5364,
		3,450,225,0,5364,5378,1,0,0,0,5365,5366,3,564,282,0,5366,5367,5,448,0,
		0,5367,5368,5,19,0,0,5368,5369,5,1148,0,0,5369,5370,3,450,225,0,5370,5378,
		1,0,0,0,5371,5372,3,564,282,0,5372,5373,5,448,0,0,5373,5374,5,192,0,0,
		5374,5375,3,452,226,0,5375,5378,1,0,0,0,5376,5378,3,564,282,0,5377,5352,
		1,0,0,0,5377,5358,1,0,0,0,5377,5365,1,0,0,0,5377,5371,1,0,0,0,5377,5376,
		1,0,0,0,5378,449,1,0,0,0,5379,5380,5,141,0,0,5380,5382,5,1148,0,0,5381,
		5379,1,0,0,0,5381,5382,1,0,0,0,5382,5386,1,0,0,0,5383,5384,5,145,0,0,5384,
		5385,5,35,0,0,5385,5387,5,551,0,0,5386,5383,1,0,0,0,5386,5387,1,0,0,0,
		5387,451,1,0,0,0,5388,5396,3,582,291,0,5389,5393,7,67,0,0,5390,5394,5,
		1148,0,0,5391,5392,5,991,0,0,5392,5394,5,551,0,0,5393,5390,1,0,0,0,5393,
		5391,1,0,0,0,5394,5395,1,0,0,0,5395,5397,3,450,225,0,5396,5389,1,0,0,0,
		5396,5397,1,0,0,0,5397,5403,1,0,0,0,5398,5399,3,582,291,0,5399,5400,5,
		187,0,0,5400,5401,3,682,341,0,5401,5403,1,0,0,0,5402,5388,1,0,0,0,5402,
		5398,1,0,0,0,5403,453,1,0,0,0,5404,5413,5,167,0,0,5405,5413,5,680,0,0,
		5406,5407,5,358,0,0,5407,5413,5,1148,0,0,5408,5409,5,465,0,0,5409,5413,
		5,1148,0,0,5410,5411,5,640,0,0,5411,5413,5,1148,0,0,5412,5404,1,0,0,0,
		5412,5405,1,0,0,0,5412,5406,1,0,0,0,5412,5408,1,0,0,0,5412,5410,1,0,0,
		0,5413,455,1,0,0,0,5414,5415,5,499,0,0,5415,5423,3,590,295,0,5416,5417,
		5,502,0,0,5417,5423,3,590,295,0,5418,5419,5,498,0,0,5419,5423,3,590,295,
		0,5420,5421,5,503,0,0,5421,5423,3,590,295,0,5422,5414,1,0,0,0,5422,5416,
		1,0,0,0,5422,5418,1,0,0,0,5422,5420,1,0,0,0,5423,457,1,0,0,0,5424,5425,
		5,551,0,0,5425,5432,5,420,0,0,5426,5433,5,42,0,0,5427,5433,5,519,0,0,5428,
		5429,5,86,0,0,5429,5430,3,590,295,0,5430,5431,5,691,0,0,5431,5433,1,0,
		0,0,5432,5426,1,0,0,0,5432,5427,1,0,0,0,5432,5428,1,0,0,0,5432,5433,1,
		0,0,0,5433,5463,1,0,0,0,5434,5435,5,551,0,0,5435,5438,5,445,0,0,5436,5439,
		5,42,0,0,5437,5439,3,590,295,0,5438,5436,1,0,0,0,5438,5437,1,0,0,0,5439,
		5463,1,0,0,0,5440,5441,5,551,0,0,5441,5442,5,595,0,0,5442,5447,5,86,0,
		0,5443,5448,5,42,0,0,5444,5445,3,590,295,0,5445,5446,5,691,0,0,5446,5448,
		1,0,0,0,5447,5443,1,0,0,0,5447,5444,1,0,0,0,5448,5463,1,0,0,0,5449,5450,
		5,551,0,0,5450,5451,5,142,0,0,5451,5453,5,35,0,0,5452,5454,7,68,0,0,5453,
		5452,1,0,0,0,5453,5454,1,0,0,0,5454,5463,1,0,0,0,5455,5456,5,424,0,0,5456,
		5463,3,590,295,0,5457,5460,5,552,0,0,5458,5461,3,590,295,0,5459,5461,5,
		657,0,0,5460,5458,1,0,0,0,5460,5459,1,0,0,0,5461,5463,1,0,0,0,5462,5424,
		1,0,0,0,5462,5434,1,0,0,0,5462,5440,1,0,0,0,5462,5449,1,0,0,0,5462,5455,
		1,0,0,0,5462,5457,1,0,0,0,5463,459,1,0,0,0,5464,5465,5,332,0,0,5465,5466,
		7,69,0,0,5466,461,1,0,0,0,5467,5472,3,464,232,0,5468,5469,5,1133,0,0,5469,
		5470,3,616,308,0,5470,5471,5,1134,0,0,5471,5473,1,0,0,0,5472,5468,1,0,
		0,0,5472,5473,1,0,0,0,5473,463,1,0,0,0,5474,5476,5,6,0,0,5475,5477,5,725,
		0,0,5476,5475,1,0,0,0,5476,5477,1,0,0,0,5477,5568,1,0,0,0,5478,5480,5,
		7,0,0,5479,5481,5,733,0,0,5480,5479,1,0,0,0,5480,5481,1,0,0,0,5481,5568,
		1,0,0,0,5482,5490,5,33,0,0,5483,5484,5,649,0,0,5484,5491,5,742,0,0,5485,
		5491,5,733,0,0,5486,5491,5,671,0,0,5487,5491,5,665,0,0,5488,5491,5,647,
		0,0,5489,5491,5,596,0,0,5490,5483,1,0,0,0,5490,5485,1,0,0,0,5490,5486,
		1,0,0,0,5490,5487,1,0,0,0,5490,5488,1,0,0,0,5490,5489,1,0,0,0,5490,5491,
		1,0,0,0,5491,5568,1,0,0,0,5492,5568,5,44,0,0,5493,5495,5,51,0,0,5494,5496,
		5,596,0,0,5495,5494,1,0,0,0,5495,5496,1,0,0,0,5496,5568,1,0,0,0,5497,5568,
		5,415,0,0,5498,5568,5,708,0,0,5499,5568,5,709,0,0,5500,5501,5,72,0,0,5501,
		5568,5,120,0,0,5502,5568,5,81,0,0,5503,5568,5,85,0,0,5504,5505,5,103,0,
		0,5505,5568,5,742,0,0,5506,5568,5,726,0,0,5507,5568,5,566,0,0,5508,5568,
		5,136,0,0,5509,5568,5,727,0,0,5510,5511,5,588,0,0,5511,5568,7,70,0,0,5512,
		5568,5,152,0,0,5513,5514,5,155,0,0,5514,5568,7,71,0,0,5515,5568,5,739,
		0,0,5516,5568,5,740,0,0,5517,5568,5,177,0,0,5518,5568,5,184,0,0,5519,5568,
		5,185,0,0,5520,5568,5,698,0,0,5521,5568,5,699,0,0,5522,5568,5,700,0,0,
		5523,5568,5,701,0,0,5524,5568,5,702,0,0,5525,5568,5,703,0,0,5526,5568,
		5,704,0,0,5527,5568,5,705,0,0,5528,5568,5,706,0,0,5529,5568,5,707,0,0,
		5530,5568,5,710,0,0,5531,5568,5,711,0,0,5532,5568,5,712,0,0,5533,5568,
		5,713,0,0,5534,5568,5,714,0,0,5535,5568,5,715,0,0,5536,5568,5,716,0,0,
		5537,5568,5,717,0,0,5538,5568,5,718,0,0,5539,5568,5,719,0,0,5540,5568,
		5,722,0,0,5541,5568,5,723,0,0,5542,5568,5,724,0,0,5543,5568,5,728,0,0,
		5544,5568,5,729,0,0,5545,5568,5,730,0,0,5546,5568,5,731,0,0,5547,5568,
		5,732,0,0,5548,5568,5,735,0,0,5549,5568,5,736,0,0,5550,5568,5,737,0,0,
		5551,5568,5,158,0,0,5552,5568,5,738,0,0,5553,5568,5,1077,0,0,5554,5568,
		5,741,0,0,5555,5568,5,743,0,0,5556,5568,5,1088,0,0,5557,5568,5,744,0,0,
		5558,5568,5,745,0,0,5559,5560,5,102,0,0,5560,5561,5,68,0,0,5561,5568,5,
		734,0,0,5562,5563,5,152,0,0,5563,5564,5,87,0,0,5564,5568,5,734,0,0,5565,
		5566,5,720,0,0,5566,5568,5,721,0,0,5567,5474,1,0,0,0,5567,5478,1,0,0,0,
		5567,5482,1,0,0,0,5567,5492,1,0,0,0,5567,5493,1,0,0,0,5567,5497,1,0,0,
		0,5567,5498,1,0,0,0,5567,5499,1,0,0,0,5567,5500,1,0,0,0,5567,5502,1,0,
		0,0,5567,5503,1,0,0,0,5567,5504,1,0,0,0,5567,5506,1,0,0,0,5567,5507,1,
		0,0,0,5567,5508,1,0,0,0,5567,5509,1,0,0,0,5567,5510,1,0,0,0,5567,5512,
		1,0,0,0,5567,5513,1,0,0,0,5567,5515,1,0,0,0,5567,5516,1,0,0,0,5567,5517,
		1,0,0,0,5567,5518,1,0,0,0,5567,5519,1,0,0,0,5567,5520,1,0,0,0,5567,5521,
		1,0,0,0,5567,5522,1,0,0,0,5567,5523,1,0,0,0,5567,5524,1,0,0,0,5567,5525,
		1,0,0,0,5567,5526,1,0,0,0,5567,5527,1,0,0,0,5567,5528,1,0,0,0,5567,5529,
		1,0,0,0,5567,5530,1,0,0,0,5567,5531,1,0,0,0,5567,5532,1,0,0,0,5567,5533,
		1,0,0,0,5567,5534,1,0,0,0,5567,5535,1,0,0,0,5567,5536,1,0,0,0,5567,5537,
		1,0,0,0,5567,5538,1,0,0,0,5567,5539,1,0,0,0,5567,5540,1,0,0,0,5567,5541,
		1,0,0,0,5567,5542,1,0,0,0,5567,5543,1,0,0,0,5567,5544,1,0,0,0,5567,5545,
		1,0,0,0,5567,5546,1,0,0,0,5567,5547,1,0,0,0,5567,5548,1,0,0,0,5567,5549,
		1,0,0,0,5567,5550,1,0,0,0,5567,5551,1,0,0,0,5567,5552,1,0,0,0,5567,5553,
		1,0,0,0,5567,5554,1,0,0,0,5567,5555,1,0,0,0,5567,5556,1,0,0,0,5567,5557,
		1,0,0,0,5567,5558,1,0,0,0,5567,5559,1,0,0,0,5567,5562,1,0,0,0,5567,5565,
		1,0,0,0,5568,465,1,0,0,0,5569,5586,5,1117,0,0,5570,5571,5,1117,0,0,5571,
		5572,5,1132,0,0,5572,5586,5,1117,0,0,5573,5574,3,584,292,0,5574,5575,5,
		1132,0,0,5575,5576,5,1117,0,0,5576,5586,1,0,0,0,5577,5578,3,584,292,0,
		5578,5579,5,1132,0,0,5579,5580,3,584,292,0,5580,5586,1,0,0,0,5581,5582,
		3,584,292,0,5582,5583,3,588,294,0,5583,5586,1,0,0,0,5584,5586,3,584,292,
		0,5585,5569,1,0,0,0,5585,5570,1,0,0,0,5585,5573,1,0,0,0,5585,5577,1,0,
		0,0,5585,5581,1,0,0,0,5585,5584,1,0,0,0,5586,467,1,0,0,0,5587,5588,3,564,
		282,0,5588,5589,5,175,0,0,5589,5590,3,564,282,0,5590,469,1,0,0,0,5591,
		5593,5,9,0,0,5592,5594,7,72,0,0,5593,5592,1,0,0,0,5593,5594,1,0,0,0,5594,
		5595,1,0,0,0,5595,5596,7,54,0,0,5596,5614,3,620,310,0,5597,5598,5,184,
		0,0,5598,5599,5,76,0,0,5599,5600,5,118,0,0,5600,5605,3,556,278,0,5601,
		5602,5,1135,0,0,5602,5604,3,556,278,0,5603,5601,1,0,0,0,5604,5607,1,0,
		0,0,5605,5603,1,0,0,0,5605,5606,1,0,0,0,5606,5612,1,0,0,0,5607,5605,1,
		0,0,0,5608,5609,5,192,0,0,5609,5610,3,590,295,0,5610,5611,5,18,0,0,5611,
		5613,1,0,0,0,5612,5608,1,0,0,0,5612,5613,1,0,0,0,5613,5615,1,0,0,0,5614,
		5597,1,0,0,0,5614,5615,1,0,0,0,5615,5627,1,0,0,0,5616,5617,5,51,0,0,5617,
		5618,5,76,0,0,5618,5619,5,118,0,0,5619,5624,3,556,278,0,5620,5621,5,1135,
		0,0,5621,5623,3,556,278,0,5622,5620,1,0,0,0,5623,5626,1,0,0,0,5624,5622,
		1,0,0,0,5624,5625,1,0,0,0,5625,5628,1,0,0,0,5626,5624,1,0,0,0,5627,5616,
		1,0,0,0,5627,5628,1,0,0,0,5628,471,1,0,0,0,5629,5630,5,26,0,0,5630,5631,
		5,172,0,0,5631,5635,3,620,310,0,5632,5634,3,480,240,0,5633,5632,1,0,0,
		0,5634,5637,1,0,0,0,5635,5633,1,0,0,0,5635,5636,1,0,0,0,5636,473,1,0,0,
		0,5637,5635,1,0,0,0,5638,5639,5,356,0,0,5639,5640,5,172,0,0,5640,5642,
		3,620,310,0,5641,5643,7,73,0,0,5642,5641,1,0,0,0,5642,5643,1,0,0,0,5643,
		475,1,0,0,0,5644,5646,5,119,0,0,5645,5647,7,72,0,0,5646,5645,1,0,0,0,5646,
		5647,1,0,0,0,5647,5648,1,0,0,0,5648,5649,7,54,0,0,5649,5650,3,620,310,
		0,5650,477,1,0,0,0,5651,5653,5,580,0,0,5652,5654,7,72,0,0,5653,5652,1,
		0,0,0,5653,5654,1,0,0,0,5654,5655,1,0,0,0,5655,5656,5,172,0,0,5656,5658,
		3,620,310,0,5657,5659,5,568,0,0,5658,5657,1,0,0,0,5658,5659,1,0,0,0,5659,
		5661,1,0,0,0,5660,5662,5,422,0,0,5661,5660,1,0,0,0,5661,5662,1,0,0,0,5662,
		5664,1,0,0,0,5663,5665,5,666,0,0,5664,5663,1,0,0,0,5664,5665,1,0,0,0,5665,
		479,1,0,0,0,5666,5667,5,65,0,0,5667,5674,5,664,0,0,5668,5674,5,568,0,0,
		5669,5674,5,425,0,0,5670,5674,5,504,0,0,5671,5674,5,422,0,0,5672,5674,
		5,354,0,0,5673,5666,1,0,0,0,5673,5668,1,0,0,0,5673,5669,1,0,0,0,5673,5670,
		1,0,0,0,5673,5671,1,0,0,0,5673,5672,1,0,0,0,5674,481,1,0,0,0,5675,5677,
		5,33,0,0,5676,5678,5,335,0,0,5677,5676,1,0,0,0,5677,5678,1,0,0,0,5678,
		5679,1,0,0,0,5679,5681,5,437,0,0,5680,5682,3,642,321,0,5681,5680,1,0,0,
		0,5681,5682,1,0,0,0,5682,5683,1,0,0,0,5683,5684,3,584,292,0,5684,5685,
		5,594,0,0,5685,5686,7,74,0,0,5686,5687,5,619,0,0,5687,5688,5,1148,0,0,
		5688,483,1,0,0,0,5689,5690,5,456,0,0,5690,5691,5,554,0,0,5691,5692,3,584,
		292,0,5692,5693,5,619,0,0,5693,5694,5,1148,0,0,5694,485,1,0,0,0,5695,5696,
		5,661,0,0,5696,5697,5,554,0,0,5697,5698,3,584,292,0,5698,487,1,0,0,0,5699,
		5700,5,153,0,0,5700,5701,3,492,246,0,5701,5704,7,75,0,0,5702,5705,3,688,
		344,0,5703,5705,5,118,0,0,5704,5702,1,0,0,0,5704,5703,1,0,0,0,5705,5715,
		1,0,0,0,5706,5707,5,1135,0,0,5707,5708,3,492,246,0,5708,5711,7,75,0,0,
		5709,5712,3,688,344,0,5710,5712,5,118,0,0,5711,5709,1,0,0,0,5711,5710,
		1,0,0,0,5712,5714,1,0,0,0,5713,5706,1,0,0,0,5714,5717,1,0,0,0,5715,5713,
		1,0,0,0,5715,5716,1,0,0,0,5716,5752,1,0,0,0,5717,5715,1,0,0,0,5718,5719,
		5,153,0,0,5719,5722,3,60,30,0,5720,5723,3,568,284,0,5721,5723,5,42,0,0,
		5722,5720,1,0,0,0,5722,5721,1,0,0,0,5723,5752,1,0,0,0,5724,5725,5,153,
		0,0,5725,5732,5,517,0,0,5726,5729,3,568,284,0,5727,5728,5,27,0,0,5728,
		5730,3,570,285,0,5729,5727,1,0,0,0,5729,5730,1,0,0,0,5730,5733,1,0,0,0,
		5731,5733,5,42,0,0,5732,5726,1,0,0,0,5732,5731,1,0,0,0,5733,5752,1,0,0,
		0,5734,5752,3,444,222,0,5735,5752,3,318,159,0,5736,5752,3,316,158,0,5737,
		5738,5,153,0,0,5738,5739,3,550,275,0,5739,5740,7,75,0,0,5740,5748,3,688,
		344,0,5741,5742,5,1135,0,0,5742,5743,3,550,275,0,5743,5744,7,75,0,0,5744,
		5745,3,688,344,0,5745,5747,1,0,0,0,5746,5741,1,0,0,0,5747,5750,1,0,0,0,
		5748,5746,1,0,0,0,5748,5749,1,0,0,0,5749,5752,1,0,0,0,5750,5748,1,0,0,
		0,5751,5699,1,0,0,0,5751,5718,1,0,0,0,5751,5724,1,0,0,0,5751,5734,1,0,
		0,0,5751,5735,1,0,0,0,5751,5736,1,0,0,0,5751,5737,1,0,0,0,5752,489,1,0,
		0,0,5753,5754,5,155,0,0,5754,5755,7,56,0,0,5755,5907,5,476,0,0,5756,5757,
		5,155,0,0,5757,5758,7,76,0,0,5758,5761,5,416,0,0,5759,5760,5,80,0,0,5760,
		5762,5,1148,0,0,5761,5759,1,0,0,0,5761,5762,1,0,0,0,5762,5765,1,0,0,0,
		5763,5764,5,68,0,0,5764,5766,3,590,295,0,5765,5763,1,0,0,0,5765,5766,1,
		0,0,0,5766,5774,1,0,0,0,5767,5771,5,99,0,0,5768,5769,3,590,295,0,5769,
		5770,5,1135,0,0,5770,5772,1,0,0,0,5771,5768,1,0,0,0,5771,5772,1,0,0,0,
		5772,5773,1,0,0,0,5773,5775,3,590,295,0,5774,5767,1,0,0,0,5774,5775,1,
		0,0,0,5775,5907,1,0,0,0,5776,5777,5,155,0,0,5777,5779,3,494,247,0,5778,
		5780,3,496,248,0,5779,5778,1,0,0,0,5779,5780,1,0,0,0,5780,5907,1,0,0,0,
		5781,5783,5,155,0,0,5782,5784,5,436,0,0,5783,5782,1,0,0,0,5783,5784,1,
		0,0,0,5784,5785,1,0,0,0,5785,5786,7,41,0,0,5786,5787,7,77,0,0,5787,5790,
		3,552,276,0,5788,5789,7,77,0,0,5789,5791,3,584,292,0,5790,5788,1,0,0,0,
		5790,5791,1,0,0,0,5791,5793,1,0,0,0,5792,5794,3,496,248,0,5793,5792,1,
		0,0,0,5793,5794,1,0,0,0,5794,5907,1,0,0,0,5795,5796,5,155,0,0,5796,5797,
		5,33,0,0,5797,5799,7,0,0,0,5798,5800,3,642,321,0,5799,5798,1,0,0,0,5799,
		5800,1,0,0,0,5800,5801,1,0,0,0,5801,5907,3,584,292,0,5802,5803,5,155,0,
		0,5803,5804,5,33,0,0,5804,5805,7,78,0,0,5805,5907,3,550,275,0,5806,5807,
		5,155,0,0,5807,5808,5,33,0,0,5808,5809,5,665,0,0,5809,5907,3,564,282,0,
		5810,5811,5,155,0,0,5811,5812,5,409,0,0,5812,5813,3,572,286,0,5813,5814,
		7,79,0,0,5814,5907,1,0,0,0,5815,5816,5,155,0,0,5816,5907,3,498,249,0,5817,
		5818,5,155,0,0,5818,5826,7,80,0,0,5819,5823,5,99,0,0,5820,5821,3,590,295,
		0,5821,5822,5,1135,0,0,5822,5824,1,0,0,0,5823,5820,1,0,0,0,5823,5824,1,
		0,0,0,5824,5825,1,0,0,0,5825,5827,3,590,295,0,5826,5819,1,0,0,0,5826,5827,
		1,0,0,0,5827,5907,1,0,0,0,5828,5829,5,155,0,0,5829,5830,5,290,0,0,5830,
		5831,5,1133,0,0,5831,5832,5,1117,0,0,5832,5833,5,1134,0,0,5833,5907,7,
		80,0,0,5834,5835,5,155,0,0,5835,5838,3,500,250,0,5836,5837,7,77,0,0,5837,
		5839,3,584,292,0,5838,5836,1,0,0,0,5838,5839,1,0,0,0,5839,5841,1,0,0,0,
		5840,5842,3,496,248,0,5841,5840,1,0,0,0,5841,5842,1,0,0,0,5842,5907,1,
		0,0,0,5843,5844,5,155,0,0,5844,5845,7,81,0,0,5845,5846,5,364,0,0,5846,
		5907,3,550,275,0,5847,5848,5,155,0,0,5848,5851,5,440,0,0,5849,5850,5,65,
		0,0,5850,5852,3,564,282,0,5851,5849,1,0,0,0,5851,5852,1,0,0,0,5852,5907,
		1,0,0,0,5853,5854,5,155,0,0,5854,5855,7,82,0,0,5855,5856,7,77,0,0,5856,
		5859,3,552,276,0,5857,5858,7,77,0,0,5858,5860,3,584,292,0,5859,5857,1,
		0,0,0,5859,5860,1,0,0,0,5860,5863,1,0,0,0,5861,5862,5,190,0,0,5862,5864,
		3,688,344,0,5863,5861,1,0,0,0,5863,5864,1,0,0,0,5864,5907,1,0,0,0,5865,
		5866,5,155,0,0,5866,5867,5,539,0,0,5867,5870,5,742,0,0,5868,5869,7,77,
		0,0,5869,5871,3,584,292,0,5870,5868,1,0,0,0,5870,5871,1,0,0,0,5871,5873,
		1,0,0,0,5872,5874,3,496,248,0,5873,5872,1,0,0,0,5873,5874,1,0,0,0,5874,
		5907,1,0,0,0,5875,5876,5,155,0,0,5876,5877,5,564,0,0,5877,5882,3,502,251,
		0,5878,5879,5,1135,0,0,5879,5881,3,502,251,0,5880,5878,1,0,0,0,5881,5884,
		1,0,0,0,5882,5880,1,0,0,0,5882,5883,1,0,0,0,5883,5888,1,0,0,0,5884,5882,
		1,0,0,0,5885,5886,5,65,0,0,5886,5887,5,567,0,0,5887,5889,3,590,295,0,5888,
		5885,1,0,0,0,5888,5889,1,0,0,0,5889,5890,1,0,0,0,5890,5894,5,99,0,0,5891,
		5892,3,590,295,0,5892,5893,5,1135,0,0,5893,5895,1,0,0,0,5894,5891,1,0,
		0,0,5894,5895,1,0,0,0,5895,5896,1,0,0,0,5896,5897,3,590,295,0,5897,5907,
		1,0,0,0,5898,5899,5,155,0,0,5899,5900,5,614,0,0,5900,5904,5,634,0,0,5901,
		5902,5,65,0,0,5902,5903,5,355,0,0,5903,5905,5,1148,0,0,5904,5901,1,0,0,
		0,5904,5905,1,0,0,0,5905,5907,1,0,0,0,5906,5753,1,0,0,0,5906,5756,1,0,
		0,0,5906,5776,1,0,0,0,5906,5781,1,0,0,0,5906,5795,1,0,0,0,5906,5802,1,
		0,0,0,5906,5806,1,0,0,0,5906,5810,1,0,0,0,5906,5815,1,0,0,0,5906,5817,
		1,0,0,0,5906,5828,1,0,0,0,5906,5834,1,0,0,0,5906,5843,1,0,0,0,5906,5847,
		1,0,0,0,5906,5853,1,0,0,0,5906,5865,1,0,0,0,5906,5875,1,0,0,0,5906,5898,
		1,0,0,0,5907,491,1,0,0,0,5908,5919,5,1159,0,0,5909,5919,5,1160,0,0,5910,
		5911,5,1137,0,0,5911,5913,5,1137,0,0,5912,5910,1,0,0,0,5912,5913,1,0,0,
		0,5913,5914,1,0,0,0,5914,5916,7,83,0,0,5915,5912,1,0,0,0,5915,5916,1,0,
		0,0,5916,5917,1,0,0,0,5917,5919,3,584,292,0,5918,5908,1,0,0,0,5918,5909,
		1,0,0,0,5918,5915,1,0,0,0,5919,493,1,0,0,0,5920,5921,5,25,0,0,5921,5934,
		5,153,0,0,5922,5934,5,844,0,0,5923,5934,5,40,0,0,5924,5934,5,151,0,0,5925,
		5926,5,437,0,0,5926,5934,5,634,0,0,5927,5928,5,131,0,0,5928,5934,5,634,
		0,0,5929,5931,7,55,0,0,5930,5929,1,0,0,0,5930,5931,1,0,0,0,5931,5932,1,
		0,0,0,5932,5934,7,84,0,0,5933,5920,1,0,0,0,5933,5922,1,0,0,0,5933,5923,
		1,0,0,0,5933,5924,1,0,0,0,5933,5925,1,0,0,0,5933,5927,1,0,0,0,5933,5930,
		1,0,0,0,5934,495,1,0,0,0,5935,5936,5,98,0,0,5936,5940,5,1148,0,0,5937,
		5938,5,190,0,0,5938,5940,3,688,344,0,5939,5935,1,0,0,0,5939,5937,1,0,0,
		0,5940,497,1,0,0,0,5941,5943,5,636,0,0,5942,5941,1,0,0,0,5942,5943,1,0,
		0,0,5943,5944,1,0,0,0,5944,5959,5,410,0,0,5945,5946,5,477,0,0,5946,5959,
		5,634,0,0,5947,5959,5,556,0,0,5948,5959,5,725,0,0,5949,5951,5,436,0,0,
		5950,5949,1,0,0,0,5950,5951,1,0,0,0,5951,5952,1,0,0,0,5952,5959,5,563,
		0,0,5953,5959,5,565,0,0,5954,5955,5,614,0,0,5955,5959,5,447,0,0,5956,5959,
		5,339,0,0,5957,5959,5,383,0,0,5958,5942,1,0,0,0,5958,5945,1,0,0,0,5958,
		5947,1,0,0,0,5958,5948,1,0,0,0,5958,5950,1,0,0,0,5958,5953,1,0,0,0,5958,
		5954,1,0,0,0,5958,5956,1,0,0,0,5958,5957,1,0,0,0,5959,499,1,0,0,0,5960,
		5969,5,416,0,0,5961,5962,5,172,0,0,5962,5969,5,634,0,0,5963,5965,5,436,
		0,0,5964,5963,1,0,0,0,5964,5965,1,0,0,0,5965,5966,1,0,0,0,5966,5969,5,
		742,0,0,5967,5969,5,655,0,0,5968,5960,1,0,0,0,5968,5961,1,0,0,0,5968,5964,
		1,0,0,0,5968,5967,1,0,0,0,5969,501,1,0,0,0,5970,5983,5,6,0,0,5971,5972,
		5,347,0,0,5972,5983,5,461,0,0,5973,5974,5,382,0,0,5974,5983,5,645,0,0,
		5975,5983,5,385,0,0,5976,5983,5,463,0,0,5977,5983,5,792,0,0,5978,5979,
		5,544,0,0,5979,5983,5,426,0,0,5980,5983,5,621,0,0,5981,5983,5,644,0,0,
		5982,5970,1,0,0,0,5982,5971,1,0,0,0,5982,5973,1,0,0,0,5982,5975,1,0,0,
		0,5982,5976,1,0,0,0,5982,5977,1,0,0,0,5982,5978,1,0,0,0,5982,5980,1,0,
		0,0,5982,5981,1,0,0,0,5983,503,1,0,0,0,5984,5985,5,345,0,0,5985,5986,5,
		1148,0,0,5986,505,1,0,0,0,5987,5988,5,351,0,0,5988,5989,5,81,0,0,5989,
		5994,3,518,259,0,5990,5991,5,1135,0,0,5991,5993,3,518,259,0,5992,5990,
		1,0,0,0,5993,5996,1,0,0,0,5994,5992,1,0,0,0,5994,5995,1,0,0,0,5995,6004,
		1,0,0,0,5996,5994,1,0,0,0,5997,5998,5,129,0,0,5998,6001,5,1133,0,0,5999,
		6002,3,616,308,0,6000,6002,5,6,0,0,6001,5999,1,0,0,0,6001,6000,1,0,0,0,
		6002,6003,1,0,0,0,6003,6005,5,1134,0,0,6004,5997,1,0,0,0,6004,6005,1,0,
		0,0,6005,6006,1,0,0,0,6006,6007,5,80,0,0,6007,6008,3,584,292,0,6008,507,
		1,0,0,0,6009,6011,5,432,0,0,6010,6012,7,72,0,0,6011,6010,1,0,0,0,6011,
		6012,1,0,0,0,6012,6013,1,0,0,0,6013,6018,3,520,260,0,6014,6015,5,1135,
		0,0,6015,6017,3,520,260,0,6016,6014,1,0,0,0,6017,6020,1,0,0,0,6018,6016,
		1,0,0,0,6018,6019,1,0,0,0,6019,509,1,0,0,0,6020,6018,1,0,0,0,6021,6023,
		5,93,0,0,6022,6024,7,85,0,0,6023,6022,1,0,0,0,6023,6024,1,0,0,0,6024,6025,
		1,0,0,0,6025,6026,3,688,344,0,6026,511,1,0,0,0,6027,6028,5,102,0,0,6028,
		6029,5,81,0,0,6029,6030,5,87,0,0,6030,6031,5,351,0,0,6031,6036,3,524,262,
		0,6032,6033,5,1135,0,0,6033,6035,3,524,262,0,6034,6032,1,0,0,0,6035,6038,
		1,0,0,0,6036,6034,1,0,0,0,6036,6037,1,0,0,0,6037,513,1,0,0,0,6038,6036,
		1,0,0,0,6039,6040,5,589,0,0,6040,6041,5,567,0,0,6041,6042,5,351,0,0,6042,
		515,1,0,0,0,6043,6044,5,739,0,0,6044,517,1,0,0,0,6045,6053,3,552,276,0,
		6046,6048,7,20,0,0,6047,6046,1,0,0,0,6047,6048,1,0,0,0,6048,6049,1,0,0,
		0,6049,6050,5,1133,0,0,6050,6051,3,616,308,0,6051,6052,5,1134,0,0,6052,
		6054,1,0,0,0,6053,6047,1,0,0,0,6053,6054,1,0,0,0,6054,519,1,0,0,0,6055,
		6074,5,394,0,0,6056,6074,5,447,0,0,6057,6059,7,86,0,0,6058,6057,1,0,0,
		0,6058,6059,1,0,0,0,6059,6060,1,0,0,0,6060,6074,5,476,0,0,6061,6074,5,
		540,0,0,6062,6074,5,725,0,0,6063,6064,5,567,0,0,6064,6074,5,351,0,0,6065,
		6074,5,634,0,0,6066,6074,5,667,0,0,6067,6071,5,742,0,0,6068,6069,5,192,
		0,0,6069,6070,5,134,0,0,6070,6072,5,103,0,0,6071,6068,1,0,0,0,6071,6072,
		1,0,0,0,6072,6074,1,0,0,0,6073,6055,1,0,0,0,6073,6056,1,0,0,0,6073,6058,
		1,0,0,0,6073,6061,1,0,0,0,6073,6062,1,0,0,0,6073,6063,1,0,0,0,6073,6065,
		1,0,0,0,6073,6066,1,0,0,0,6073,6067,1,0,0,0,6074,6088,1,0,0,0,6075,6076,
		5,574,0,0,6076,6078,5,476,0,0,6077,6079,3,356,178,0,6078,6077,1,0,0,0,
		6078,6079,1,0,0,0,6079,6088,1,0,0,0,6080,6082,7,54,0,0,6081,6083,3,620,
		310,0,6082,6081,1,0,0,0,6082,6083,1,0,0,0,6083,6085,1,0,0,0,6084,6086,
		3,522,261,0,6085,6084,1,0,0,0,6085,6086,1,0,0,0,6086,6088,1,0,0,0,6087,
		6073,1,0,0,0,6087,6075,1,0,0,0,6087,6080,1,0,0,0,6088,521,1,0,0,0,6089,
		6090,5,192,0,0,6090,6091,5,134,0,0,6091,6095,5,103,0,0,6092,6093,5,65,
		0,0,6093,6095,5,421,0,0,6094,6089,1,0,0,0,6094,6092,1,0,0,0,6095,523,1,
		0,0,0,6096,6104,3,552,276,0,6097,6098,5,129,0,0,6098,6101,5,1133,0,0,6099,
		6102,3,616,308,0,6100,6102,5,6,0,0,6101,6099,1,0,0,0,6101,6100,1,0,0,0,
		6102,6103,1,0,0,0,6103,6105,5,1134,0,0,6104,6097,1,0,0,0,6104,6105,1,0,
		0,0,6105,6113,1,0,0,0,6106,6108,7,20,0,0,6107,6106,1,0,0,0,6107,6108,1,
		0,0,0,6108,6109,1,0,0,0,6109,6110,5,1133,0,0,6110,6111,3,616,308,0,6111,
		6112,5,1134,0,0,6112,6114,1,0,0,0,6113,6107,1,0,0,0,6113,6114,1,0,0,0,
		6114,6117,1,0,0,0,6115,6116,5,78,0,0,6116,6118,5,470,0,0,6117,6115,1,0,
		0,0,6117,6118,1,0,0,0,6118,525,1,0,0,0,6119,6120,7,87,0,0,6120,6123,3,
		552,276,0,6121,6124,3,584,292,0,6122,6124,5,1148,0,0,6123,6121,1,0,0,0,
		6123,6122,1,0,0,0,6123,6124,1,0,0,0,6124,527,1,0,0,0,6125,6129,7,87,0,
		0,6126,6127,7,88,0,0,6127,6128,5,1124,0,0,6128,6130,7,89,0,0,6129,6126,
		1,0,0,0,6129,6130,1,0,0,0,6130,6131,1,0,0,0,6131,6132,3,548,274,0,6132,
		529,1,0,0,0,6133,6134,5,444,0,0,6134,6135,5,1148,0,0,6135,531,1,0,0,0,
		6136,6137,5,186,0,0,6137,6138,3,584,292,0,6138,533,1,0,0,0,6139,6147,5,
		156,0,0,6140,6142,5,162,0,0,6141,6143,5,669,0,0,6142,6141,1,0,0,0,6142,
		6143,1,0,0,0,6143,6144,1,0,0,0,6144,6148,3,594,297,0,6145,6148,5,1156,
		0,0,6146,6148,5,1157,0,0,6147,6140,1,0,0,0,6147,6145,1,0,0,0,6147,6146,
		1,0,0,0,6148,6158,1,0,0,0,6149,6150,5,153,0,0,6150,6155,3,538,269,0,6151,
		6152,5,1135,0,0,6152,6154,3,538,269,0,6153,6151,1,0,0,0,6154,6157,1,0,
		0,0,6155,6153,1,0,0,0,6155,6156,1,0,0,0,6156,6159,1,0,0,0,6157,6155,1,
		0,0,0,6158,6149,1,0,0,0,6158,6159,1,0,0,0,6159,535,1,0,0,0,6160,6168,5,
		143,0,0,6161,6163,5,162,0,0,6162,6164,5,669,0,0,6163,6162,1,0,0,0,6163,
		6164,1,0,0,0,6164,6165,1,0,0,0,6165,6169,3,594,297,0,6166,6169,5,1156,
		0,0,6167,6169,5,1157,0,0,6168,6161,1,0,0,0,6168,6166,1,0,0,0,6168,6167,
		1,0,0,0,6168,6169,1,0,0,0,6169,6179,1,0,0,0,6170,6171,5,153,0,0,6171,6176,
		3,538,269,0,6172,6173,5,1135,0,0,6173,6175,3,538,269,0,6174,6172,1,0,0,
		0,6175,6178,1,0,0,0,6176,6174,1,0,0,0,6176,6177,1,0,0,0,6177,6180,1,0,
		0,0,6178,6176,1,0,0,0,6179,6170,1,0,0,0,6179,6180,1,0,0,0,6180,537,1,0,
		0,0,6181,6182,7,90,0,0,6182,6187,5,1124,0,0,6183,6188,3,594,297,0,6184,
		6188,5,1149,0,0,6185,6188,3,566,283,0,6186,6188,3,586,293,0,6187,6183,
		1,0,0,0,6187,6184,1,0,0,0,6187,6185,1,0,0,0,6187,6186,1,0,0,0,6188,539,
		1,0,0,0,6189,6191,5,192,0,0,6190,6192,5,571,0,0,6191,6190,1,0,0,0,6191,
		6192,1,0,0,0,6192,6193,1,0,0,0,6193,6198,3,50,25,0,6194,6195,5,1135,0,
		0,6195,6197,3,50,25,0,6196,6194,1,0,0,0,6197,6200,1,0,0,0,6198,6196,1,
		0,0,0,6198,6199,1,0,0,0,6199,541,1,0,0,0,6200,6198,1,0,0,0,6201,6202,5,
		172,0,0,6202,6204,3,552,276,0,6203,6205,3,230,115,0,6204,6203,1,0,0,0,
		6204,6205,1,0,0,0,6205,6207,1,0,0,0,6206,6208,3,294,147,0,6207,6206,1,
		0,0,0,6207,6208,1,0,0,0,6208,543,1,0,0,0,6209,6211,5,71,0,0,6210,6212,
		7,91,0,0,6211,6210,1,0,0,0,6211,6212,1,0,0,0,6212,6213,1,0,0,0,6213,6245,
		5,48,0,0,6214,6215,3,492,246,0,6215,6216,5,1124,0,0,6216,6224,7,92,0,0,
		6217,6218,5,1135,0,0,6218,6219,3,492,246,0,6219,6220,5,1124,0,0,6220,6221,
		7,92,0,0,6221,6223,1,0,0,0,6222,6217,1,0,0,0,6223,6226,1,0,0,0,6224,6222,
		1,0,0,0,6224,6225,1,0,0,0,6225,6246,1,0,0,0,6226,6224,1,0,0,0,6227,6230,
		5,29,0,0,6228,6231,3,590,295,0,6229,6231,3,492,246,0,6230,6228,1,0,0,0,
		6230,6229,1,0,0,0,6231,6232,1,0,0,0,6232,6233,3,492,246,0,6233,6234,5,
		1124,0,0,6234,6242,3,546,273,0,6235,6236,5,1135,0,0,6236,6237,3,492,246,
		0,6237,6238,5,1124,0,0,6238,6239,3,546,273,0,6239,6241,1,0,0,0,6240,6235,
		1,0,0,0,6241,6244,1,0,0,0,6242,6240,1,0,0,0,6242,6243,1,0,0,0,6243,6246,
		1,0,0,0,6244,6242,1,0,0,0,6245,6214,1,0,0,0,6245,6227,1,0,0,0,6246,545,
		1,0,0,0,6247,6248,7,93,0,0,6248,547,1,0,0,0,6249,6255,3,200,100,0,6250,
		6255,3,186,93,0,6251,6255,3,192,96,0,6252,6255,3,198,99,0,6253,6255,3,
		202,101,0,6254,6249,1,0,0,0,6254,6250,1,0,0,0,6254,6251,1,0,0,0,6254,6252,
		1,0,0,0,6254,6253,1,0,0,0,6255,6260,1,0,0,0,6256,6257,5,65,0,0,6257,6258,
		5,376,0,0,6258,6260,3,584,292,0,6259,6254,1,0,0,0,6259,6256,1,0,0,0,6260,
		549,1,0,0,0,6261,6265,3,584,292,0,6262,6266,5,1155,0,0,6263,6264,5,1132,
		0,0,6264,6266,3,584,292,0,6265,6262,1,0,0,0,6265,6263,1,0,0,0,6265,6266,
		1,0,0,0,6266,551,1,0,0,0,6267,6268,3,550,275,0,6268,553,1,0,0,0,6269,6272,
		3,564,282,0,6270,6272,3,584,292,0,6271,6269,1,0,0,0,6271,6270,1,0,0,0,
		6272,555,1,0,0,0,6273,6278,3,584,292,0,6274,6276,3,588,294,0,6275,6277,
		3,588,294,0,6276,6275,1,0,0,0,6276,6277,1,0,0,0,6277,6279,1,0,0,0,6278,
		6274,1,0,0,0,6278,6279,1,0,0,0,6279,6288,1,0,0,0,6280,6282,9,0,0,0,6281,
		6280,1,0,0,0,6281,6282,1,0,0,0,6282,6283,1,0,0,0,6283,6285,3,588,294,0,
		6284,6286,3,588,294,0,6285,6284,1,0,0,0,6285,6286,1,0,0,0,6286,6288,1,
		0,0,0,6287,6273,1,0,0,0,6287,6281,1,0,0,0,6288,557,1,0,0,0,6289,6292,3,
		584,292,0,6290,6292,5,1148,0,0,6291,6289,1,0,0,0,6291,6290,1,0,0,0,6292,
		6297,1,0,0,0,6293,6294,5,1133,0,0,6294,6295,3,590,295,0,6295,6296,5,1134,
		0,0,6296,6298,1,0,0,0,6297,6293,1,0,0,0,6297,6298,1,0,0,0,6298,6301,1,
		0,0,0,6299,6301,3,688,344,0,6300,6291,1,0,0,0,6300,6299,1,0,0,0,6301,6303,
		1,0,0,0,6302,6304,7,48,0,0,6303,6302,1,0,0,0,6303,6304,1,0,0,0,6304,559,
		1,0,0,0,6305,6310,5,1148,0,0,6306,6310,5,1156,0,0,6307,6310,5,697,0,0,
		6308,6310,3,718,359,0,6309,6305,1,0,0,0,6309,6306,1,0,0,0,6309,6307,1,
		0,0,0,6309,6308,1,0,0,0,6310,561,1,0,0,0,6311,6312,7,94,0,0,6312,563,1,
		0,0,0,6313,6319,3,560,280,0,6314,6315,3,560,280,0,6315,6316,3,562,281,
		0,6316,6319,1,0,0,0,6317,6319,3,62,31,0,6318,6313,1,0,0,0,6318,6314,1,
		0,0,0,6318,6317,1,0,0,0,6319,565,1,0,0,0,6320,6321,7,95,0,0,6321,567,1,
		0,0,0,6322,6327,5,226,0,0,6323,6327,3,708,354,0,6324,6327,5,1148,0,0,6325,
		6327,5,1145,0,0,6326,6322,1,0,0,0,6326,6323,1,0,0,0,6326,6324,1,0,0,0,
		6326,6325,1,0,0,0,6327,569,1,0,0,0,6328,6331,3,584,292,0,6329,6331,5,1148,
		0,0,6330,6328,1,0,0,0,6330,6329,1,0,0,0,6331,571,1,0,0,0,6332,6336,3,574,
		287,0,6333,6336,5,1156,0,0,6334,6336,5,1148,0,0,6335,6332,1,0,0,0,6335,
		6333,1,0,0,0,6335,6334,1,0,0,0,6336,573,1,0,0,0,6337,6338,7,96,0,0,6338,
		575,1,0,0,0,6339,6340,3,590,295,0,6340,6341,5,1121,0,0,6341,6342,3,590,
		295,0,6342,6343,5,1121,0,0,6343,6344,3,590,295,0,6344,6345,5,1121,0,0,
		6345,6346,3,590,295,0,6346,6347,5,1121,0,0,6347,6353,3,590,295,0,6348,
		6349,5,1144,0,0,6349,6350,3,590,295,0,6350,6351,5,1121,0,0,6351,6352,3,
		590,295,0,6352,6354,1,0,0,0,6353,6348,1,0,0,0,6354,6355,1,0,0,0,6355,6353,
		1,0,0,0,6355,6356,1,0,0,0,6356,577,1,0,0,0,6357,6364,3,580,290,0,6358,
		6359,5,1135,0,0,6359,6362,3,580,290,0,6360,6361,5,1135,0,0,6361,6363,3,
		590,295,0,6362,6360,1,0,0,0,6362,6363,1,0,0,0,6363,6365,1,0,0,0,6364,6358,
		1,0,0,0,6364,6365,1,0,0,0,6365,579,1,0,0,0,6366,6374,5,1148,0,0,6367,6374,
		5,1153,0,0,6368,6370,5,1150,0,0,6369,6368,1,0,0,0,6370,6371,1,0,0,0,6371,
		6369,1,0,0,0,6371,6372,1,0,0,0,6372,6374,1,0,0,0,6373,6366,1,0,0,0,6373,
		6367,1,0,0,0,6373,6369,1,0,0,0,6374,581,1,0,0,0,6375,6378,3,584,292,0,
		6376,6378,5,1148,0,0,6377,6375,1,0,0,0,6377,6376,1,0,0,0,6378,583,1,0,
		0,0,6379,6383,3,586,293,0,6380,6383,5,1145,0,0,6381,6383,5,1148,0,0,6382,
		6379,1,0,0,0,6382,6380,1,0,0,0,6382,6381,1,0,0,0,6383,585,1,0,0,0,6384,
		6394,5,1156,0,0,6385,6394,3,708,354,0,6386,6394,3,710,355,0,6387,6394,
		3,574,287,0,6388,6394,3,712,356,0,6389,6394,3,714,357,0,6390,6394,3,716,
		358,0,6391,6394,3,718,359,0,6392,6394,3,680,340,0,6393,6384,1,0,0,0,6393,
		6385,1,0,0,0,6393,6386,1,0,0,0,6393,6387,1,0,0,0,6393,6388,1,0,0,0,6393,
		6389,1,0,0,0,6393,6390,1,0,0,0,6393,6391,1,0,0,0,6393,6392,1,0,0,0,6394,
		587,1,0,0,0,6395,6399,5,1155,0,0,6396,6397,5,1132,0,0,6397,6399,3,584,
		292,0,6398,6395,1,0,0,0,6398,6396,1,0,0,0,6399,589,1,0,0,0,6400,6401,7,
		97,0,0,6401,591,1,0,0,0,6402,6405,5,1146,0,0,6403,6405,3,590,295,0,6404,
		6402,1,0,0,0,6404,6403,1,0,0,0,6405,593,1,0,0,0,6406,6408,5,1154,0,0,6407,
		6406,1,0,0,0,6407,6408,1,0,0,0,6408,6409,1,0,0,0,6409,6412,5,1148,0,0,
		6410,6412,5,1147,0,0,6411,6407,1,0,0,0,6411,6410,1,0,0,0,6412,6414,1,0,
		0,0,6413,6415,5,1148,0,0,6414,6413,1,0,0,0,6415,6416,1,0,0,0,6416,6414,
		1,0,0,0,6416,6417,1,0,0,0,6417,6430,1,0,0,0,6418,6420,5,1154,0,0,6419,
		6418,1,0,0,0,6419,6420,1,0,0,0,6420,6421,1,0,0,0,6421,6424,5,1148,0,0,
		6422,6424,5,1147,0,0,6423,6419,1,0,0,0,6423,6422,1,0,0,0,6424,6427,1,0,
		0,0,6425,6426,5,27,0,0,6426,6428,3,570,285,0,6427,6425,1,0,0,0,6427,6428,
		1,0,0,0,6428,6430,1,0,0,0,6429,6411,1,0,0,0,6429,6423,1,0,0,0,6430,595,
		1,0,0,0,6431,6432,7,98,0,0,6432,597,1,0,0,0,6433,6435,5,1154,0,0,6434,
		6433,1,0,0,0,6434,6435,1,0,0,0,6435,6436,1,0,0,0,6436,6437,5,1150,0,0,
		6437,599,1,0,0,0,6438,6440,5,114,0,0,6439,6438,1,0,0,0,6439,6440,1,0,0,
		0,6440,6441,1,0,0,0,6441,6442,7,99,0,0,6442,601,1,0,0,0,6443,6456,3,594,
		297,0,6444,6456,3,590,295,0,6445,6446,5,1121,0,0,6446,6456,3,590,295,0,
		6447,6456,3,598,299,0,6448,6456,3,596,298,0,6449,6456,5,1151,0,0,6450,
		6456,5,1153,0,0,6451,6453,5,114,0,0,6452,6451,1,0,0,0,6452,6453,1,0,0,
		0,6453,6454,1,0,0,0,6454,6456,7,99,0,0,6455,6443,1,0,0,0,6455,6444,1,0,
		0,0,6455,6445,1,0,0,0,6455,6447,1,0,0,0,6455,6448,1,0,0,0,6455,6449,1,
		0,0,0,6455,6450,1,0,0,0,6455,6452,1,0,0,0,6456,603,1,0,0,0,6457,6459,7,
		100,0,0,6458,6460,5,238,0,0,6459,6458,1,0,0,0,6459,6460,1,0,0,0,6460,6462,
		1,0,0,0,6461,6463,3,610,305,0,6462,6461,1,0,0,0,6462,6463,1,0,0,0,6463,
		6465,1,0,0,0,6464,6466,5,226,0,0,6465,6464,1,0,0,0,6465,6466,1,0,0,0,6466,
		6470,1,0,0,0,6467,6468,3,60,30,0,6468,6469,3,568,284,0,6469,6471,1,0,0,
		0,6470,6467,1,0,0,0,6470,6471,1,0,0,0,6471,6475,1,0,0,0,6472,6473,5,27,
		0,0,6473,6476,3,570,285,0,6474,6476,5,226,0,0,6475,6472,1,0,0,0,6475,6474,
		1,0,0,0,6475,6476,1,0,0,0,6476,6584,1,0,0,0,6477,6478,5,225,0,0,6478,6479,
		7,101,0,0,6479,6481,5,238,0,0,6480,6482,3,610,305,0,6481,6480,1,0,0,0,
		6481,6482,1,0,0,0,6482,6484,1,0,0,0,6483,6485,5,226,0,0,6484,6483,1,0,
		0,0,6484,6485,1,0,0,0,6485,6584,1,0,0,0,6486,6487,5,225,0,0,6487,6489,
		7,102,0,0,6488,6490,3,610,305,0,6489,6488,1,0,0,0,6489,6490,1,0,0,0,6490,
		6492,1,0,0,0,6491,6493,5,226,0,0,6492,6491,1,0,0,0,6492,6493,1,0,0,0,6493,
		6584,1,0,0,0,6494,6495,5,518,0,0,6495,6497,5,223,0,0,6496,6498,3,610,305,
		0,6497,6496,1,0,0,0,6497,6498,1,0,0,0,6498,6500,1,0,0,0,6499,6501,5,226,
		0,0,6500,6499,1,0,0,0,6500,6501,1,0,0,0,6501,6584,1,0,0,0,6502,6504,7,
		103,0,0,6503,6505,3,610,305,0,6504,6503,1,0,0,0,6504,6505,1,0,0,0,6505,
		6509,1,0,0,0,6506,6508,7,104,0,0,6507,6506,1,0,0,0,6508,6511,1,0,0,0,6509,
		6507,1,0,0,0,6509,6510,1,0,0,0,6510,6584,1,0,0,0,6511,6509,1,0,0,0,6512,
		6514,5,208,0,0,6513,6515,3,612,306,0,6514,6513,1,0,0,0,6514,6515,1,0,0,
		0,6515,6519,1,0,0,0,6516,6518,7,104,0,0,6517,6516,1,0,0,0,6518,6521,1,
		0,0,0,6519,6517,1,0,0,0,6519,6520,1,0,0,0,6520,6584,1,0,0,0,6521,6519,
		1,0,0,0,6522,6524,5,209,0,0,6523,6525,5,210,0,0,6524,6523,1,0,0,0,6524,
		6525,1,0,0,0,6525,6527,1,0,0,0,6526,6528,3,612,306,0,6527,6526,1,0,0,0,
		6527,6528,1,0,0,0,6528,6532,1,0,0,0,6529,6531,7,104,0,0,6530,6529,1,0,
		0,0,6531,6534,1,0,0,0,6532,6530,1,0,0,0,6532,6533,1,0,0,0,6533,6584,1,
		0,0,0,6534,6532,1,0,0,0,6535,6537,7,105,0,0,6536,6538,3,614,307,0,6537,
		6536,1,0,0,0,6537,6538,1,0,0,0,6538,6542,1,0,0,0,6539,6541,7,104,0,0,6540,
		6539,1,0,0,0,6541,6544,1,0,0,0,6542,6540,1,0,0,0,6542,6543,1,0,0,0,6543,
		6584,1,0,0,0,6544,6542,1,0,0,0,6545,6584,7,106,0,0,6546,6548,7,107,0,0,
		6547,6549,3,610,305,0,6548,6547,1,0,0,0,6548,6549,1,0,0,0,6549,6584,1,
		0,0,0,6550,6551,7,108,0,0,6551,6553,3,606,303,0,6552,6554,5,226,0,0,6553,
		6552,1,0,0,0,6553,6554,1,0,0,0,6554,6558,1,0,0,0,6555,6556,3,60,30,0,6556,
		6557,3,568,284,0,6557,6559,1,0,0,0,6558,6555,1,0,0,0,6558,6559,1,0,0,0,
		6559,6584,1,0,0,0,6560,6563,7,109,0,0,6561,6562,5,1012,0,0,6562,6564,3,
		590,295,0,6563,6561,1,0,0,0,6563,6564,1,0,0,0,6564,6584,1,0,0,0,6565,6567,
		5,231,0,0,6566,6568,5,223,0,0,6567,6566,1,0,0,0,6567,6568,1,0,0,0,6568,
		6570,1,0,0,0,6569,6571,5,226,0,0,6570,6569,1,0,0,0,6570,6571,1,0,0,0,6571,
		6575,1,0,0,0,6572,6573,3,60,30,0,6573,6574,3,568,284,0,6574,6576,1,0,0,
		0,6575,6572,1,0,0,0,6575,6576,1,0,0,0,6576,6579,1,0,0,0,6577,6578,5,27,
		0,0,6578,6580,3,570,285,0,6579,6577,1,0,0,0,6579,6580,1,0,0,0,6580,6584,
		1,0,0,0,6581,6582,5,231,0,0,6582,6584,5,227,0,0,6583,6457,1,0,0,0,6583,
		6477,1,0,0,0,6583,6486,1,0,0,0,6583,6494,1,0,0,0,6583,6502,1,0,0,0,6583,
		6512,1,0,0,0,6583,6522,1,0,0,0,6583,6535,1,0,0,0,6583,6545,1,0,0,0,6583,
		6546,1,0,0,0,6583,6550,1,0,0,0,6583,6560,1,0,0,0,6583,6565,1,0,0,0,6583,
		6581,1,0,0,0,6584,605,1,0,0,0,6585,6586,5,1133,0,0,6586,6591,5,1148,0,
		0,6587,6588,5,1135,0,0,6588,6590,5,1148,0,0,6589,6587,1,0,0,0,6590,6593,
		1,0,0,0,6591,6589,1,0,0,0,6591,6592,1,0,0,0,6592,6594,1,0,0,0,6593,6591,
		1,0,0,0,6594,6595,5,1134,0,0,6595,607,1,0,0,0,6596,6598,7,110,0,0,6597,
		6599,3,610,305,0,6598,6597,1,0,0,0,6598,6599,1,0,0,0,6599,6619,1,0,0,0,
		6600,6602,5,222,0,0,6601,6603,3,610,305,0,6602,6601,1,0,0,0,6602,6603,
		1,0,0,0,6603,6607,1,0,0,0,6604,6605,3,60,30,0,6605,6606,3,568,284,0,6606,
		6608,1,0,0,0,6607,6604,1,0,0,0,6607,6608,1,0,0,0,6608,6619,1,0,0,0,6609,
		6619,7,111,0,0,6610,6612,7,112,0,0,6611,6613,3,614,307,0,6612,6611,1,0,
		0,0,6612,6613,1,0,0,0,6613,6619,1,0,0,0,6614,6616,7,113,0,0,6615,6617,
		7,114,0,0,6616,6615,1,0,0,0,6616,6617,1,0,0,0,6617,6619,1,0,0,0,6618,6596,
		1,0,0,0,6618,6600,1,0,0,0,6618,6609,1,0,0,0,6618,6610,1,0,0,0,6618,6614,
		1,0,0,0,6619,6621,1,0,0,0,6620,6622,5,11,0,0,6621,6620,1,0,0,0,6621,6622,
		1,0,0,0,6622,609,1,0,0,0,6623,6624,5,1133,0,0,6624,6625,3,590,295,0,6625,
		6626,5,1134,0,0,6626,611,1,0,0,0,6627,6628,5,1133,0,0,6628,6629,3,590,
		295,0,6629,6630,5,1135,0,0,6630,6631,3,590,295,0,6631,6632,5,1134,0,0,
		6632,613,1,0,0,0,6633,6634,5,1133,0,0,6634,6637,3,590,295,0,6635,6636,
		5,1135,0,0,6636,6638,3,590,295,0,6637,6635,1,0,0,0,6637,6638,1,0,0,0,6638,
		6639,1,0,0,0,6639,6640,5,1134,0,0,6640,615,1,0,0,0,6641,6646,3,584,292,
		0,6642,6643,5,1135,0,0,6643,6645,3,584,292,0,6644,6642,1,0,0,0,6645,6648,
		1,0,0,0,6646,6644,1,0,0,0,6646,6647,1,0,0,0,6647,617,1,0,0,0,6648,6646,
		1,0,0,0,6649,6654,3,556,278,0,6650,6651,5,1135,0,0,6651,6653,3,556,278,
		0,6652,6650,1,0,0,0,6653,6656,1,0,0,0,6654,6652,1,0,0,0,6654,6655,1,0,
		0,0,6655,619,1,0,0,0,6656,6654,1,0,0,0,6657,6662,3,552,276,0,6658,6659,
		5,1135,0,0,6659,6661,3,552,276,0,6660,6658,1,0,0,0,6661,6664,1,0,0,0,6662,
		6660,1,0,0,0,6662,6663,1,0,0,0,6663,621,1,0,0,0,6664,6662,1,0,0,0,6665,
		6666,5,1133,0,0,6666,6671,3,558,279,0,6667,6668,5,1135,0,0,6668,6670,3,
		558,279,0,6669,6667,1,0,0,0,6670,6673,1,0,0,0,6671,6669,1,0,0,0,6671,6672,
		1,0,0,0,6672,6674,1,0,0,0,6673,6671,1,0,0,0,6674,6675,5,1134,0,0,6675,
		623,1,0,0,0,6676,6681,3,688,344,0,6677,6678,5,1135,0,0,6678,6680,3,688,
		344,0,6679,6677,1,0,0,0,6680,6683,1,0,0,0,6681,6679,1,0,0,0,6681,6682,
		1,0,0,0,6682,625,1,0,0,0,6683,6681,1,0,0,0,6684,6689,3,638,319,0,6685,
		6686,5,1135,0,0,6686,6688,3,638,319,0,6687,6685,1,0,0,0,6688,6691,1,0,
		0,0,6689,6687,1,0,0,0,6689,6690,1,0,0,0,6690,627,1,0,0,0,6691,6689,1,0,
		0,0,6692,6697,3,602,301,0,6693,6694,5,1135,0,0,6694,6696,3,602,301,0,6695,
		6693,1,0,0,0,6696,6699,1,0,0,0,6697,6695,1,0,0,0,6697,6698,1,0,0,0,6698,
		629,1,0,0,0,6699,6697,1,0,0,0,6700,6705,5,1148,0,0,6701,6702,5,1135,0,
		0,6702,6704,5,1148,0,0,6703,6701,1,0,0,0,6704,6707,1,0,0,0,6705,6703,1,
		0,0,0,6705,6706,1,0,0,0,6706,631,1,0,0,0,6707,6705,1,0,0,0,6708,6713,5,
		1159,0,0,6709,6710,5,1135,0,0,6710,6712,5,1159,0,0,6711,6709,1,0,0,0,6712,
		6715,1,0,0,0,6713,6711,1,0,0,0,6713,6714,1,0,0,0,6714,633,1,0,0,0,6715,
		6713,1,0,0,0,6716,6743,5,116,0,0,6717,6718,5,23,0,0,6718,6719,5,1133,0,
		0,6719,6720,3,688,344,0,6720,6721,5,12,0,0,6721,6722,3,608,304,0,6722,
		6723,5,1134,0,0,6723,6743,1,0,0,0,6724,6726,3,694,347,0,6725,6724,1,0,
		0,0,6725,6726,1,0,0,0,6726,6727,1,0,0,0,6727,6743,3,602,301,0,6728,6732,
		3,636,318,0,6729,6730,5,118,0,0,6730,6731,5,184,0,0,6731,6733,3,636,318,
		0,6732,6729,1,0,0,0,6732,6733,1,0,0,0,6733,6743,1,0,0,0,6734,6735,5,1133,
		0,0,6735,6736,3,688,344,0,6736,6737,5,1134,0,0,6737,6743,1,0,0,0,6738,
		6739,5,1133,0,0,6739,6740,3,550,275,0,6740,6741,5,1134,0,0,6741,6743,1,
		0,0,0,6742,6716,1,0,0,0,6742,6717,1,0,0,0,6742,6725,1,0,0,0,6742,6728,
		1,0,0,0,6742,6734,1,0,0,0,6742,6738,1,0,0,0,6743,635,1,0,0,0,6744,6750,
		7,115,0,0,6745,6747,5,1133,0,0,6746,6748,3,590,295,0,6747,6746,1,0,0,0,
		6747,6748,1,0,0,0,6748,6749,1,0,0,0,6749,6751,5,1134,0,0,6750,6745,1,0,
		0,0,6750,6751,1,0,0,0,6751,6759,1,0,0,0,6752,6753,5,323,0,0,6753,6755,
		5,1133,0,0,6754,6756,3,590,295,0,6755,6754,1,0,0,0,6755,6756,1,0,0,0,6756,
		6757,1,0,0,0,6757,6759,5,1134,0,0,6758,6744,1,0,0,0,6758,6752,1,0,0,0,
		6759,637,1,0,0,0,6760,6763,3,688,344,0,6761,6763,5,42,0,0,6762,6760,1,
		0,0,0,6762,6761,1,0,0,0,6763,639,1,0,0,0,6764,6765,5,77,0,0,6765,6766,
		5,60,0,0,6766,641,1,0,0,0,6767,6768,5,77,0,0,6768,6769,5,114,0,0,6769,
		6770,5,60,0,0,6770,643,1,0,0,0,6771,6772,5,123,0,0,6772,6773,5,141,0,0,
		6773,645,1,0,0,0,6774,6775,5,674,0,0,6775,6778,3,590,295,0,6776,6778,5,
		527,0,0,6777,6774,1,0,0,0,6777,6776,1,0,0,0,6778,647,1,0,0,0,6779,6798,
		3,650,325,0,6780,6798,3,658,329,0,6781,6798,3,660,330,0,6782,6783,3,680,
		340,0,6783,6785,5,1133,0,0,6784,6786,3,684,342,0,6785,6784,1,0,0,0,6785,
		6786,1,0,0,0,6786,6787,1,0,0,0,6787,6788,5,1134,0,0,6788,6798,1,0,0,0,
		6789,6790,3,550,275,0,6790,6792,5,1133,0,0,6791,6793,3,684,342,0,6792,
		6791,1,0,0,0,6792,6793,1,0,0,0,6793,6794,1,0,0,0,6794,6795,5,1134,0,0,
		6795,6798,1,0,0,0,6796,6798,3,682,341,0,6797,6779,1,0,0,0,6797,6780,1,
		0,0,0,6797,6781,1,0,0,0,6797,6782,1,0,0,0,6797,6789,1,0,0,0,6797,6796,
		1,0,0,0,6798,649,1,0,0,0,6799,6802,7,116,0,0,6800,6801,5,1133,0,0,6801,
		6803,5,1134,0,0,6802,6800,1,0,0,0,6802,6803,1,0,0,0,6803,6979,1,0,0,0,
		6804,6979,3,62,31,0,6805,6806,5,32,0,0,6806,6807,5,1133,0,0,6807,6808,
		3,688,344,0,6808,6809,5,1135,0,0,6809,6810,3,608,304,0,6810,6811,5,1134,
		0,0,6811,6979,1,0,0,0,6812,6813,5,32,0,0,6813,6814,5,1133,0,0,6814,6815,
		3,688,344,0,6815,6816,5,187,0,0,6816,6817,3,568,284,0,6817,6818,5,1134,
		0,0,6818,6979,1,0,0,0,6819,6820,5,23,0,0,6820,6821,5,1133,0,0,6821,6822,
		3,688,344,0,6822,6823,5,12,0,0,6823,6824,3,608,304,0,6824,6825,5,1134,
		0,0,6825,6979,1,0,0,0,6826,6827,5,188,0,0,6827,6828,5,1133,0,0,6828,6829,
		3,556,278,0,6829,6830,5,1134,0,0,6830,6979,1,0,0,0,6831,6832,5,22,0,0,
		6832,6834,3,688,344,0,6833,6835,3,652,326,0,6834,6833,1,0,0,0,6835,6836,
		1,0,0,0,6836,6834,1,0,0,0,6836,6837,1,0,0,0,6837,6840,1,0,0,0,6838,6839,
		5,53,0,0,6839,6841,3,686,343,0,6840,6838,1,0,0,0,6840,6841,1,0,0,0,6841,
		6842,1,0,0,0,6842,6843,5,407,0,0,6843,6979,1,0,0,0,6844,6846,5,22,0,0,
		6845,6847,3,652,326,0,6846,6845,1,0,0,0,6847,6848,1,0,0,0,6848,6846,1,
		0,0,0,6848,6849,1,0,0,0,6849,6852,1,0,0,0,6850,6851,5,53,0,0,6851,6853,
		3,686,343,0,6852,6850,1,0,0,0,6852,6853,1,0,0,0,6853,6854,1,0,0,0,6854,
		6855,5,407,0,0,6855,6979,1,0,0,0,6856,6857,5,222,0,0,6857,6858,5,1133,
		0,0,6858,6861,3,684,342,0,6859,6860,5,187,0,0,6860,6862,3,568,284,0,6861,
		6859,1,0,0,0,6861,6862,1,0,0,0,6862,6863,1,0,0,0,6863,6864,5,1134,0,0,
		6864,6979,1,0,0,0,6865,6866,5,324,0,0,6866,6869,5,1133,0,0,6867,6870,3,
		594,297,0,6868,6870,3,688,344,0,6869,6867,1,0,0,0,6869,6868,1,0,0,0,6870,
		6871,1,0,0,0,6871,6874,5,80,0,0,6872,6875,3,594,297,0,6873,6875,3,688,
		344,0,6874,6872,1,0,0,0,6874,6873,1,0,0,0,6875,6876,1,0,0,0,6876,6877,
		5,1134,0,0,6877,6979,1,0,0,0,6878,6879,7,117,0,0,6879,6882,5,1133,0,0,
		6880,6883,3,594,297,0,6881,6883,3,688,344,0,6882,6880,1,0,0,0,6882,6881,
		1,0,0,0,6883,6884,1,0,0,0,6884,6887,5,68,0,0,6885,6888,3,590,295,0,6886,
		6888,3,688,344,0,6887,6885,1,0,0,0,6887,6886,1,0,0,0,6888,6894,1,0,0,0,
		6889,6892,5,65,0,0,6890,6893,3,590,295,0,6891,6893,3,688,344,0,6892,6890,
		1,0,0,0,6892,6891,1,0,0,0,6893,6895,1,0,0,0,6894,6889,1,0,0,0,6894,6895,
		1,0,0,0,6895,6896,1,0,0,0,6896,6897,5,1134,0,0,6897,6979,1,0,0,0,6898,
		6899,5,328,0,0,6899,6900,5,1133,0,0,6900,6903,7,118,0,0,6901,6904,3,594,
		297,0,6902,6904,3,688,344,0,6903,6901,1,0,0,0,6903,6902,1,0,0,0,6903,6904,
		1,0,0,0,6904,6905,1,0,0,0,6905,6908,5,68,0,0,6906,6909,3,594,297,0,6907,
		6909,3,688,344,0,6908,6906,1,0,0,0,6908,6907,1,0,0,0,6909,6910,1,0,0,0,
		6910,6911,5,1134,0,0,6911,6979,1,0,0,0,6912,6913,5,328,0,0,6913,6916,5,
		1133,0,0,6914,6917,3,594,297,0,6915,6917,3,688,344,0,6916,6914,1,0,0,0,
		6916,6915,1,0,0,0,6917,6918,1,0,0,0,6918,6921,5,68,0,0,6919,6922,3,594,
		297,0,6920,6922,3,688,344,0,6921,6919,1,0,0,0,6921,6920,1,0,0,0,6922,6923,
		1,0,0,0,6923,6924,5,1134,0,0,6924,6979,1,0,0,0,6925,6926,5,1103,0,0,6926,
		6929,5,1133,0,0,6927,6930,3,594,297,0,6928,6930,3,688,344,0,6929,6927,
		1,0,0,0,6929,6928,1,0,0,0,6930,6937,1,0,0,0,6931,6932,5,12,0,0,6932,6933,
		7,119,0,0,6933,6934,5,1133,0,0,6934,6935,3,590,295,0,6935,6936,5,1134,
		0,0,6936,6938,1,0,0,0,6937,6931,1,0,0,0,6937,6938,1,0,0,0,6938,6940,1,
		0,0,0,6939,6941,3,654,327,0,6940,6939,1,0,0,0,6940,6941,1,0,0,0,6941,6942,
		1,0,0,0,6942,6943,5,1134,0,0,6943,6979,1,0,0,0,6944,6945,5,321,0,0,6945,
		6946,5,1133,0,0,6946,6947,3,72,36,0,6947,6950,5,68,0,0,6948,6951,3,594,
		297,0,6949,6951,3,688,344,0,6950,6948,1,0,0,0,6950,6949,1,0,0,0,6951,6952,
		1,0,0,0,6952,6953,5,1134,0,0,6953,6979,1,0,0,0,6954,6955,5,900,0,0,6955,
		6956,5,1133,0,0,6956,6957,7,120,0,0,6957,6958,5,1135,0,0,6958,6959,3,594,
		297,0,6959,6960,5,1134,0,0,6960,6979,1,0,0,0,6961,6962,5,282,0,0,6962,
		6963,5,1133,0,0,6963,6964,3,688,344,0,6964,6965,5,1135,0,0,6965,6968,3,
		688,344,0,6966,6967,5,593,0,0,6967,6969,3,608,304,0,6968,6966,1,0,0,0,
		6968,6969,1,0,0,0,6969,6971,1,0,0,0,6970,6972,3,268,134,0,6971,6970,1,
		0,0,0,6971,6972,1,0,0,0,6972,6974,1,0,0,0,6973,6975,3,270,135,0,6974,6973,
		1,0,0,0,6974,6975,1,0,0,0,6975,6976,1,0,0,0,6976,6977,5,1134,0,0,6977,
		6979,1,0,0,0,6978,6799,1,0,0,0,6978,6804,1,0,0,0,6978,6805,1,0,0,0,6978,
		6812,1,0,0,0,6978,6819,1,0,0,0,6978,6826,1,0,0,0,6978,6831,1,0,0,0,6978,
		6844,1,0,0,0,6978,6856,1,0,0,0,6978,6865,1,0,0,0,6978,6878,1,0,0,0,6978,
		6898,1,0,0,0,6978,6912,1,0,0,0,6978,6925,1,0,0,0,6978,6944,1,0,0,0,6978,
		6954,1,0,0,0,6978,6961,1,0,0,0,6979,651,1,0,0,0,6980,6981,5,189,0,0,6981,
		6982,3,686,343,0,6982,6983,5,174,0,0,6983,6984,3,686,343,0,6984,653,1,
		0,0,0,6985,6986,5,472,0,0,6986,6991,3,656,328,0,6987,6988,5,1135,0,0,6988,
		6990,3,656,328,0,6989,6987,1,0,0,0,6990,6993,1,0,0,0,6991,6989,1,0,0,0,
		6991,6992,1,0,0,0,6992,7000,1,0,0,0,6993,6991,1,0,0,0,6994,6995,5,472,
		0,0,6995,6996,3,590,295,0,6996,6997,5,1121,0,0,6997,6998,3,590,295,0,6998,
		7000,1,0,0,0,6999,6985,1,0,0,0,6999,6994,1,0,0,0,7000,655,1,0,0,0,7001,
		7003,3,590,295,0,7002,7004,7,121,0,0,7003,7002,1,0,0,0,7003,7004,1,0,0,
		0,7004,657,1,0,0,0,7005,7006,7,122,0,0,7006,7008,5,1133,0,0,7007,7009,
		7,44,0,0,7008,7007,1,0,0,0,7008,7009,1,0,0,0,7009,7010,1,0,0,0,7010,7011,
		3,686,343,0,7011,7013,5,1134,0,0,7012,7014,3,662,331,0,7013,7012,1,0,0,
		0,7013,7014,1,0,0,0,7014,7065,1,0,0,0,7015,7016,5,290,0,0,7016,7024,5,
		1133,0,0,7017,7025,5,1117,0,0,7018,7020,5,6,0,0,7019,7018,1,0,0,0,7019,
		7020,1,0,0,0,7020,7021,1,0,0,0,7021,7025,3,686,343,0,7022,7023,5,49,0,
		0,7023,7025,3,684,342,0,7024,7017,1,0,0,0,7024,7019,1,0,0,0,7024,7022,
		1,0,0,0,7025,7026,1,0,0,0,7026,7028,5,1134,0,0,7027,7029,3,662,331,0,7028,
		7027,1,0,0,0,7028,7029,1,0,0,0,7029,7065,1,0,0,0,7030,7031,7,123,0,0,7031,
		7033,5,1133,0,0,7032,7034,5,6,0,0,7033,7032,1,0,0,0,7033,7034,1,0,0,0,
		7034,7035,1,0,0,0,7035,7036,3,686,343,0,7036,7038,5,1134,0,0,7037,7039,
		3,662,331,0,7038,7037,1,0,0,0,7038,7039,1,0,0,0,7039,7065,1,0,0,0,7040,
		7041,5,294,0,0,7041,7043,5,1133,0,0,7042,7044,5,49,0,0,7043,7042,1,0,0,
		0,7043,7044,1,0,0,0,7044,7045,1,0,0,0,7045,7056,3,684,342,0,7046,7047,
		5,124,0,0,7047,7048,5,19,0,0,7048,7053,3,232,116,0,7049,7050,5,1135,0,
		0,7050,7052,3,232,116,0,7051,7049,1,0,0,0,7052,7055,1,0,0,0,7053,7051,
		1,0,0,0,7053,7054,1,0,0,0,7054,7057,1,0,0,0,7055,7053,1,0,0,0,7056,7046,
		1,0,0,0,7056,7057,1,0,0,0,7057,7060,1,0,0,0,7058,7059,5,154,0,0,7059,7061,
		5,1148,0,0,7060,7058,1,0,0,0,7060,7061,1,0,0,0,7061,7062,1,0,0,0,7062,
		7063,5,1134,0,0,7063,7065,1,0,0,0,7064,7005,1,0,0,0,7064,7015,1,0,0,0,
		7064,7030,1,0,0,0,7064,7040,1,0,0,0,7065,659,1,0,0,0,7066,7067,7,124,0,
		0,7067,7068,5,1133,0,0,7068,7071,3,688,344,0,7069,7070,5,1135,0,0,7070,
		7072,3,590,295,0,7071,7069,1,0,0,0,7071,7072,1,0,0,0,7072,7075,1,0,0,0,
		7073,7074,5,1135,0,0,7074,7076,3,590,295,0,7075,7073,1,0,0,0,7075,7076,
		1,0,0,0,7076,7077,1,0,0,0,7077,7078,5,1134,0,0,7078,7079,3,662,331,0,7079,
		7105,1,0,0,0,7080,7081,7,125,0,0,7081,7082,5,1133,0,0,7082,7083,3,688,
		344,0,7083,7084,5,1134,0,0,7084,7085,3,662,331,0,7085,7105,1,0,0,0,7086,
		7087,7,126,0,0,7087,7088,5,1133,0,0,7088,7089,5,1134,0,0,7089,7105,3,662,
		331,0,7090,7091,5,301,0,0,7091,7092,5,1133,0,0,7092,7093,3,688,344,0,7093,
		7094,5,1135,0,0,7094,7095,3,590,295,0,7095,7096,5,1134,0,0,7096,7097,3,
		662,331,0,7097,7105,1,0,0,0,7098,7099,5,300,0,0,7099,7100,5,1133,0,0,7100,
		7101,3,590,295,0,7101,7102,5,1134,0,0,7102,7103,3,662,331,0,7103,7105,
		1,0,0,0,7104,7066,1,0,0,0,7104,7080,1,0,0,0,7104,7086,1,0,0,0,7104,7090,
		1,0,0,0,7104,7098,1,0,0,0,7105,661,1,0,0,0,7106,7112,5,128,0,0,7107,7108,
		5,1133,0,0,7108,7109,3,664,332,0,7109,7110,5,1134,0,0,7110,7113,1,0,0,
		0,7111,7113,3,666,333,0,7112,7107,1,0,0,0,7112,7111,1,0,0,0,7113,663,1,
		0,0,0,7114,7116,3,666,333,0,7115,7114,1,0,0,0,7115,7116,1,0,0,0,7116,7118,
		1,0,0,0,7117,7119,3,678,339,0,7118,7117,1,0,0,0,7118,7119,1,0,0,0,7119,
		7121,1,0,0,0,7120,7122,3,230,115,0,7121,7120,1,0,0,0,7121,7122,1,0,0,0,
		7122,7124,1,0,0,0,7123,7125,3,668,334,0,7124,7123,1,0,0,0,7124,7125,1,
		0,0,0,7125,665,1,0,0,0,7126,7127,3,584,292,0,7127,667,1,0,0,0,7128,7129,
		3,670,335,0,7129,7130,3,672,336,0,7130,669,1,0,0,0,7131,7132,7,127,0,0,
		7132,671,1,0,0,0,7133,7136,3,676,338,0,7134,7136,3,674,337,0,7135,7133,
		1,0,0,0,7135,7134,1,0,0,0,7136,673,1,0,0,0,7137,7138,5,16,0,0,7138,7139,
		3,676,338,0,7139,7140,5,10,0,0,7140,7141,3,676,338,0,7141,675,1,0,0,0,
		7142,7143,5,35,0,0,7143,7150,5,600,0,0,7144,7145,5,657,0,0,7145,7150,7,
		128,0,0,7146,7147,3,688,344,0,7147,7148,7,128,0,0,7148,7150,1,0,0,0,7149,
		7142,1,0,0,0,7149,7144,1,0,0,0,7149,7146,1,0,0,0,7150,677,1,0,0,0,7151,
		7152,5,129,0,0,7152,7153,5,19,0,0,7153,7158,3,688,344,0,7154,7155,5,1135,
		0,0,7155,7157,3,688,344,0,7156,7154,1,0,0,0,7157,7160,1,0,0,0,7158,7156,
		1,0,0,0,7158,7159,1,0,0,0,7159,679,1,0,0,0,7160,7158,1,0,0,0,7161,7186,
		3,720,360,0,7162,7186,5,747,0,0,7163,7186,5,317,0,0,7164,7186,5,313,0,
		0,7165,7186,5,314,0,0,7166,7186,5,315,0,0,7167,7186,5,318,0,0,7168,7186,
		5,319,0,0,7169,7186,5,320,0,0,7170,7186,5,77,0,0,7171,7186,5,85,0,0,7172,
		7186,5,316,0,0,7173,7186,5,322,0,0,7174,7186,5,508,0,0,7175,7186,5,323,
		0,0,7176,7186,5,140,0,0,7177,7186,5,141,0,0,7178,7186,5,325,0,0,7179,7186,
		5,326,0,0,7180,7186,5,327,0,0,7181,7186,5,328,0,0,7182,7186,5,329,0,0,
		7183,7186,5,330,0,0,7184,7186,5,331,0,0,7185,7161,1,0,0,0,7185,7162,1,
		0,0,0,7185,7163,1,0,0,0,7185,7164,1,0,0,0,7185,7165,1,0,0,0,7185,7166,
		1,0,0,0,7185,7167,1,0,0,0,7185,7168,1,0,0,0,7185,7169,1,0,0,0,7185,7170,
		1,0,0,0,7185,7171,1,0,0,0,7185,7172,1,0,0,0,7185,7173,1,0,0,0,7185,7174,
		1,0,0,0,7185,7175,1,0,0,0,7185,7176,1,0,0,0,7185,7177,1,0,0,0,7185,7178,
		1,0,0,0,7185,7179,1,0,0,0,7185,7180,1,0,0,0,7185,7181,1,0,0,0,7185,7182,
		1,0,0,0,7185,7183,1,0,0,0,7185,7184,1,0,0,0,7186,681,1,0,0,0,7187,7188,
		7,129,0,0,7188,7189,5,1133,0,0,7189,7190,3,686,343,0,7190,7191,5,1134,
		0,0,7191,683,1,0,0,0,7192,7197,3,602,301,0,7193,7197,3,556,278,0,7194,
		7197,3,648,324,0,7195,7197,3,688,344,0,7196,7192,1,0,0,0,7196,7193,1,0,
		0,0,7196,7194,1,0,0,0,7196,7195,1,0,0,0,7197,7207,1,0,0,0,7198,7203,5,
		1135,0,0,7199,7204,3,602,301,0,7200,7204,3,556,278,0,7201,7204,3,648,324,
		0,7202,7204,3,688,344,0,7203,7199,1,0,0,0,7203,7200,1,0,0,0,7203,7201,
		1,0,0,0,7203,7202,1,0,0,0,7204,7206,1,0,0,0,7205,7198,1,0,0,0,7206,7209,
		1,0,0,0,7207,7205,1,0,0,0,7207,7208,1,0,0,0,7208,685,1,0,0,0,7209,7207,
		1,0,0,0,7210,7215,3,602,301,0,7211,7215,3,556,278,0,7212,7215,3,648,324,
		0,7213,7215,3,688,344,0,7214,7210,1,0,0,0,7214,7211,1,0,0,0,7214,7212,
		1,0,0,0,7214,7213,1,0,0,0,7215,687,1,0,0,0,7216,7217,6,344,-1,0,7217,7218,
		7,130,0,0,7218,7228,3,688,344,4,7219,7220,3,690,345,0,7220,7222,5,88,0,
		0,7221,7223,5,114,0,0,7222,7221,1,0,0,0,7222,7223,1,0,0,0,7223,7224,1,
		0,0,0,7224,7225,7,131,0,0,7225,7228,1,0,0,0,7226,7228,3,690,345,0,7227,
		7216,1,0,0,0,7227,7219,1,0,0,0,7227,7226,1,0,0,0,7228,7235,1,0,0,0,7229,
		7230,10,3,0,0,7230,7231,3,698,349,0,7231,7232,3,688,344,4,7232,7234,1,
		0,0,0,7233,7229,1,0,0,0,7234,7237,1,0,0,0,7235,7233,1,0,0,0,7235,7236,
		1,0,0,0,7236,689,1,0,0,0,7237,7235,1,0,0,0,7238,7239,6,345,-1,0,7239,7240,
		3,692,346,0,7240,7305,1,0,0,0,7241,7242,10,8,0,0,7242,7243,3,696,348,0,
		7243,7244,3,690,345,9,7244,7304,1,0,0,0,7245,7247,10,6,0,0,7246,7248,5,
		114,0,0,7247,7246,1,0,0,0,7247,7248,1,0,0,0,7248,7249,1,0,0,0,7249,7250,
		5,16,0,0,7250,7251,3,690,345,0,7251,7252,5,10,0,0,7252,7253,3,690,345,
		7,7253,7304,1,0,0,0,7254,7255,10,5,0,0,7255,7256,5,620,0,0,7256,7257,5,
		98,0,0,7257,7304,3,690,345,6,7258,7260,10,3,0,0,7259,7261,5,114,0,0,7260,
		7259,1,0,0,0,7260,7261,1,0,0,0,7261,7262,1,0,0,0,7262,7263,7,132,0,0,7263,
		7304,3,690,345,4,7264,7266,10,10,0,0,7265,7267,5,114,0,0,7266,7265,1,0,
		0,0,7266,7267,1,0,0,0,7267,7268,1,0,0,0,7268,7269,5,80,0,0,7269,7272,5,
		1133,0,0,7270,7273,3,200,100,0,7271,7273,3,624,312,0,7272,7270,1,0,0,0,
		7272,7271,1,0,0,0,7273,7274,1,0,0,0,7274,7275,5,1134,0,0,7275,7304,1,0,
		0,0,7276,7277,10,9,0,0,7277,7278,5,88,0,0,7278,7304,3,600,300,0,7279,7280,
		10,7,0,0,7280,7281,3,696,348,0,7281,7282,7,133,0,0,7282,7283,5,1133,0,
		0,7283,7284,3,200,100,0,7284,7285,5,1134,0,0,7285,7304,1,0,0,0,7286,7288,
		10,4,0,0,7287,7289,5,114,0,0,7288,7287,1,0,0,0,7288,7289,1,0,0,0,7289,
		7290,1,0,0,0,7290,7291,5,98,0,0,7291,7294,3,690,345,0,7292,7293,5,413,
		0,0,7293,7295,5,1148,0,0,7294,7292,1,0,0,0,7294,7295,1,0,0,0,7295,7304,
		1,0,0,0,7296,7297,10,2,0,0,7297,7298,5,505,0,0,7298,7299,5,533,0,0,7299,
		7300,5,1133,0,0,7300,7301,3,690,345,0,7301,7302,5,1134,0,0,7302,7304,1,
		0,0,0,7303,7241,1,0,0,0,7303,7245,1,0,0,0,7303,7254,1,0,0,0,7303,7258,
		1,0,0,0,7303,7264,1,0,0,0,7303,7276,1,0,0,0,7303,7279,1,0,0,0,7303,7286,
		1,0,0,0,7303,7296,1,0,0,0,7304,7307,1,0,0,0,7305,7303,1,0,0,0,7305,7306,
		1,0,0,0,7306,691,1,0,0,0,7307,7305,1,0,0,0,7308,7309,6,346,-1,0,7309,7357,
		3,602,301,0,7310,7357,3,556,278,0,7311,7357,3,648,324,0,7312,7357,3,566,
		283,0,7313,7314,3,694,347,0,7314,7315,3,692,346,12,7315,7357,1,0,0,0,7316,
		7317,5,226,0,0,7317,7357,3,692,346,11,7318,7319,5,1159,0,0,7319,7320,5,
		1108,0,0,7320,7357,3,692,346,10,7321,7322,5,1133,0,0,7322,7327,3,688,344,
		0,7323,7324,5,1135,0,0,7324,7326,3,688,344,0,7325,7323,1,0,0,0,7326,7329,
		1,0,0,0,7327,7325,1,0,0,0,7327,7328,1,0,0,0,7328,7330,1,0,0,0,7329,7327,
		1,0,0,0,7330,7331,5,1134,0,0,7331,7357,1,0,0,0,7332,7333,5,600,0,0,7333,
		7334,5,1133,0,0,7334,7337,3,688,344,0,7335,7336,5,1135,0,0,7336,7338,3,
		688,344,0,7337,7335,1,0,0,0,7338,7339,1,0,0,0,7339,7337,1,0,0,0,7339,7340,
		1,0,0,0,7340,7341,1,0,0,0,7341,7342,5,1134,0,0,7342,7357,1,0,0,0,7343,
		7344,5,60,0,0,7344,7345,5,1133,0,0,7345,7346,3,200,100,0,7346,7347,5,1134,
		0,0,7347,7357,1,0,0,0,7348,7349,5,1133,0,0,7349,7350,3,200,100,0,7350,
		7351,5,1134,0,0,7351,7357,1,0,0,0,7352,7353,5,86,0,0,7353,7354,3,688,344,
		0,7354,7355,3,72,36,0,7355,7357,1,0,0,0,7356,7308,1,0,0,0,7356,7310,1,
		0,0,0,7356,7311,1,0,0,0,7356,7312,1,0,0,0,7356,7313,1,0,0,0,7356,7316,
		1,0,0,0,7356,7318,1,0,0,0,7356,7321,1,0,0,0,7356,7332,1,0,0,0,7356,7343,
		1,0,0,0,7356,7348,1,0,0,0,7356,7352,1,0,0,0,7357,7379,1,0,0,0,7358,7359,
		10,4,0,0,7359,7360,3,700,350,0,7360,7361,3,692,346,5,7361,7378,1,0,0,0,
		7362,7363,10,3,0,0,7363,7364,3,702,351,0,7364,7365,3,692,346,4,7365,7378,
		1,0,0,0,7366,7367,10,2,0,0,7367,7368,3,704,352,0,7368,7369,3,692,346,3,
		7369,7378,1,0,0,0,7370,7371,10,1,0,0,7371,7372,3,706,353,0,7372,7373,3,
		692,346,2,7373,7378,1,0,0,0,7374,7375,10,14,0,0,7375,7376,5,27,0,0,7376,
		7378,3,570,285,0,7377,7358,1,0,0,0,7377,7362,1,0,0,0,7377,7366,1,0,0,0,
		7377,7370,1,0,0,0,7377,7374,1,0,0,0,7378,7381,1,0,0,0,7379,7377,1,0,0,
		0,7379,7380,1,0,0,0,7380,693,1,0,0,0,7381,7379,1,0,0,0,7382,7383,7,134,
		0,0,7383,695,1,0,0,0,7384,7399,5,1124,0,0,7385,7399,5,1125,0,0,7386,7399,
		5,1126,0,0,7387,7388,5,1126,0,0,7388,7399,5,1124,0,0,7389,7390,5,1125,
		0,0,7390,7399,5,1124,0,0,7391,7392,5,1126,0,0,7392,7399,5,1125,0,0,7393,
		7394,5,1127,0,0,7394,7399,5,1124,0,0,7395,7396,5,1126,0,0,7396,7397,5,
		1124,0,0,7397,7399,5,1125,0,0,7398,7384,1,0,0,0,7398,7385,1,0,0,0,7398,
		7386,1,0,0,0,7398,7387,1,0,0,0,7398,7389,1,0,0,0,7398,7391,1,0,0,0,7398,
		7393,1,0,0,0,7398,7395,1,0,0,0,7399,697,1,0,0,0,7400,7408,5,10,0,0,7401,
		7402,5,1130,0,0,7402,7408,5,1130,0,0,7403,7408,5,194,0,0,7404,7408,5,123,
		0,0,7405,7406,5,1129,0,0,7406,7408,5,1129,0,0,7407,7400,1,0,0,0,7407,7401,
		1,0,0,0,7407,7403,1,0,0,0,7407,7404,1,0,0,0,7407,7405,1,0,0,0,7408,699,
		1,0,0,0,7409,7410,5,1126,0,0,7410,7417,5,1126,0,0,7411,7412,5,1125,0,0,
		7412,7417,5,1125,0,0,7413,7417,5,1130,0,0,7414,7417,5,1131,0,0,7415,7417,
		5,1129,0,0,7416,7409,1,0,0,0,7416,7411,1,0,0,0,7416,7413,1,0,0,0,7416,
		7414,1,0,0,0,7416,7415,1,0,0,0,7417,701,1,0,0,0,7418,7419,7,135,0,0,7419,
		703,1,0,0,0,7420,7421,7,136,0,0,7421,705,1,0,0,0,7422,7423,5,1121,0,0,
		7423,7428,5,1125,0,0,7424,7425,5,1121,0,0,7425,7426,5,1125,0,0,7426,7428,
		5,1125,0,0,7427,7422,1,0,0,0,7427,7424,1,0,0,0,7428,707,1,0,0,0,7429,7430,
		7,137,0,0,7430,709,1,0,0,0,7431,7432,7,138,0,0,7432,711,1,0,0,0,7433,7434,
		7,139,0,0,7434,713,1,0,0,0,7435,7436,7,140,0,0,7436,715,1,0,0,0,7437,7438,
		7,141,0,0,7438,717,1,0,0,0,7439,7440,7,142,0,0,7440,719,1,0,0,0,7441,7442,
		7,143,0,0,7442,721,1,0,0,0,1086,723,727,734,737,740,742,748,751,754,763,
		805,820,831,848,853,865,892,901,906,912,917,921,930,933,936,940,947,950,
		955,963,968,973,976,978,990,993,997,1000,1004,1007,1011,1014,1017,1021,
		1024,1028,1034,1040,1046,1053,1060,1063,1067,1072,1078,1087,1092,1097,
		1104,1121,1128,1132,1142,1146,1150,1154,1158,1163,1166,1169,1172,1175,
		1181,1185,1191,1196,1199,1202,1204,1215,1219,1222,1236,1239,1243,1246,
		1250,1253,1257,1260,1264,1267,1270,1274,1277,1281,1287,1300,1306,1317,
		1322,1330,1338,1343,1346,1351,1359,1364,1370,1375,1379,1381,1384,1388,
		1392,1395,1399,1403,1407,1413,1416,1423,1428,1434,1441,1447,1455,1458,
		1465,1468,1470,1476,1482,1499,1506,1513,1525,1530,1533,1536,1549,1562,
		1567,1583,1591,1601,1604,1607,1613,1617,1620,1631,1634,1639,1652,1659,
		1666,1668,1675,1679,1681,1686,1689,1695,1700,1702,1706,1709,1712,1718,
		1723,1725,1730,1737,1739,1746,1751,1755,1758,1766,1774,1776,1786,1790,
		1793,1799,1804,1807,1813,1816,1820,1823,1827,1832,1837,1842,1846,1850,
		1854,1858,1862,1866,1871,1876,1881,1887,1892,1897,1902,1907,1912,1918,
		1923,1928,1933,1938,1943,1948,1953,1960,1965,1970,1975,1979,1984,1992,
		1997,2003,2015,2022,2024,2032,2037,2040,2048,2054,2058,2071,2083,2085,
		2088,2096,2102,2108,2121,2128,2137,2142,2153,2162,2167,2179,2186,2195,
		2200,2212,2219,2228,2233,2240,2249,2254,2256,2261,2269,2278,2282,2285,
		2289,2294,2300,2306,2311,2316,2321,2326,2329,2334,2339,2349,2353,2360,
		2365,2368,2373,2376,2380,2384,2392,2411,2414,2417,2421,2431,2444,2451,
		2454,2459,2466,2469,2472,2483,2486,2490,2498,2501,2506,2514,2520,2524,
		2528,2533,2538,2545,2549,2560,2568,2571,2577,2583,2585,2590,2593,2599,
		2605,2607,2611,2614,2617,2623,2629,2632,2638,2644,2646,2651,2659,2661,
		2670,2673,2676,2681,2683,2692,2695,2698,2703,2705,2714,2719,2727,2731,
		2739,2749,2754,2761,2765,2769,2788,2798,2804,2821,2825,2835,2840,2843,
		2852,2863,2871,2877,2887,2899,2906,2913,2928,2941,2947,2953,2959,2965,
		2971,2977,2982,2989,2996,3003,3008,3011,3013,3027,3034,3041,3047,3051,
		3055,3062,3065,3070,3077,3084,3088,3093,3100,3113,3116,3121,3126,3130,
		3136,3145,3154,3163,3166,3170,3179,3183,3186,3189,3195,3198,3202,3205,
		3209,3212,3220,3223,3234,3237,3242,3245,3250,3260,3265,3271,3273,3279,
		3281,3287,3295,3300,3308,3311,3316,3319,3324,3332,3340,3346,3354,3359,
		3367,3370,3374,3377,3385,3391,3400,3403,3407,3411,3415,3420,3424,3428,
		3430,3433,3436,3439,3445,3449,3452,3455,3458,3461,3468,3470,3474,3479,
		3485,3490,3497,3503,3508,3511,3517,3521,3529,3533,3536,3539,3544,3547,
		3554,3558,3561,3565,3569,3572,3575,3580,3586,3590,3600,3606,3610,3616,
		3620,3626,3629,3641,3645,3649,3657,3661,3669,3672,3676,3679,3687,3692,
		3695,3698,3702,3705,3714,3719,3728,3733,3740,3747,3755,3761,3769,3772,
		3775,3782,3785,3792,3795,3803,3809,3820,3823,3827,3833,3842,3847,3851,
		3857,3863,3865,3869,3878,3888,3898,3904,3909,3913,3916,3919,3922,3925,
		3931,3937,3940,3943,3946,3949,3952,3954,3960,3966,3969,3972,3975,3978,
		3981,3985,3991,3995,4003,4007,4010,4012,4025,4028,4035,4045,4048,4053,
		4055,4059,4067,4073,4082,4095,4099,4105,4114,4117,4121,4124,4128,4132,
		4135,4137,4145,4157,4163,4165,4171,4173,4175,4181,4189,4197,4201,4205,
		4214,4219,4239,4244,4250,4257,4262,4271,4274,4278,4282,4286,4289,4292,
		4295,4299,4303,4306,4309,4312,4319,4323,4338,4342,4354,4362,4372,4376,
		4379,4385,4388,4391,4400,4409,4419,4423,4433,4443,4451,4454,4463,4466,
		4470,4475,4479,4488,4491,4522,4525,4528,4584,4589,4617,4631,4638,4642,
		4648,4656,4658,4669,4679,4686,4692,4700,4705,4713,4721,4729,4737,4743,
		4748,4753,4758,4764,4766,4777,4782,4789,4791,4805,4811,4816,4821,4827,
		4834,4842,4850,4855,4861,4864,4872,4879,4888,4891,4908,4916,4924,4928,
		4935,4941,4949,4958,4964,4971,4978,4983,4986,4988,4994,4996,5000,5002,
		5009,5014,5018,5024,5033,5039,5046,5052,5058,5063,5066,5068,5074,5076,
		5080,5082,5089,5091,5096,5103,5112,5117,5126,5133,5138,5141,5143,5149,
		5151,5154,5162,5167,5172,5176,5182,5187,5191,5197,5199,5210,5213,5220,
		5223,5235,5241,5250,5259,5264,5273,5279,5290,5296,5301,5305,5311,5316,
		5320,5323,5335,5342,5347,5377,5381,5386,5393,5396,5402,5412,5422,5432,
		5438,5447,5453,5460,5462,5472,5476,5480,5490,5495,5567,5585,5593,5605,
		5612,5614,5624,5627,5635,5642,5646,5653,5658,5661,5664,5673,5677,5681,
		5704,5711,5715,5722,5729,5732,5748,5751,5761,5765,5771,5774,5779,5783,
		5790,5793,5799,5823,5826,5838,5841,5851,5859,5863,5870,5873,5882,5888,
		5894,5904,5906,5912,5915,5918,5930,5933,5939,5942,5950,5958,5964,5968,
		5982,5994,6001,6004,6011,6018,6023,6036,6047,6053,6058,6071,6073,6078,
		6082,6085,6087,6094,6101,6104,6107,6113,6117,6123,6129,6142,6147,6155,
		6158,6163,6168,6176,6179,6187,6191,6198,6204,6207,6211,6224,6230,6242,
		6245,6254,6259,6265,6271,6276,6278,6281,6285,6287,6291,6297,6300,6303,
		6309,6318,6326,6330,6335,6355,6362,6364,6371,6373,6377,6382,6393,6398,
		6404,6407,6411,6416,6419,6423,6427,6429,6434,6439,6452,6455,6459,6462,
		6465,6470,6475,6481,6484,6489,6492,6497,6500,6504,6509,6514,6519,6524,
		6527,6532,6537,6542,6548,6553,6558,6563,6567,6570,6575,6579,6583,6591,
		6598,6602,6607,6612,6616,6618,6621,6637,6646,6654,6662,6671,6681,6689,
		6697,6705,6713,6725,6732,6742,6747,6750,6755,6758,6762,6777,6785,6792,
		6797,6802,6836,6840,6848,6852,6861,6869,6874,6882,6887,6892,6894,6903,
		6908,6916,6921,6929,6937,6940,6950,6968,6971,6974,6978,6991,6999,7003,
		7008,7013,7019,7024,7028,7033,7038,7043,7053,7056,7060,7064,7071,7075,
		7104,7112,7115,7118,7121,7124,7135,7149,7158,7185,7196,7203,7207,7214,
		7222,7227,7235,7247,7260,7266,7272,7288,7294,7303,7305,7327,7339,7356,
		7377,7379,7398,7407,7416,7427
	]

	public
	static let _ATN = try! ATNDeserializer().deserialize(_serializedATN)
}
